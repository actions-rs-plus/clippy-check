import yr from "path";
import cn from "os";
import su from "crypto";
import Zr from "fs";
import Ds from "http";
import Ef from "https";
import iu from "net";
import Cf from "tls";
import Ts, { EventEmitter as TQ } from "events";
import bt from "assert";
import Qr from "util";
import ln from "stream";
import Dn from "buffer";
import kQ from "querystring";
import xn from "stream/web";
import ra from "node:stream";
import ks from "node:util";
import Bf from "node:events";
import If from "worker_threads";
import FQ from "perf_hooks";
import yf from "util/types";
import Vi from "async_hooks";
import PQ from "console";
import Qf from "url";
import UQ from "zlib";
import bf from "string_decoder";
import wf from "diagnostics_channel";
import Nf from "child_process";
import LQ from "timers";
import Is from "node:path";
import * as _Q from "node:os";
import MQ from "node:os";
import "node:fs";
var Ui = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function OQ(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function rs(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      var s = !1;
      try {
        s = this instanceof n;
      } catch {
      }
      return s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var bd = {}, wi = { exports: {} }, gi = {}, xa = {}, Bo = {}, Io = {}, wd;
function GQ() {
  if (wd) return Io;
  wd = 1;
  var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  return Io.encode = function(e) {
    if (0 <= e && e < t.length)
      return t[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  }, Io.decode = function(e) {
    var r = 65, n = 90, s = 97, i = 122, o = 48, c = 57, l = 43, A = 47, a = 26, u = 52;
    return r <= e && e <= n ? e - r : s <= e && e <= i ? e - s + a : o <= e && e <= c ? e - o + u : e == l ? 62 : e == A ? 63 : -1;
  }, Io;
}
var Nd;
function Rf() {
  if (Nd) return Bo;
  Nd = 1;
  var t = GQ(), e = 5, r = 1 << e, n = r - 1, s = r;
  function i(c) {
    return c < 0 ? (-c << 1) + 1 : (c << 1) + 0;
  }
  function o(c) {
    var l = (c & 1) === 1, A = c >> 1;
    return l ? -A : A;
  }
  return Bo.encode = function(l) {
    var A = "", a, u = i(l);
    do
      a = u & n, u >>>= e, u > 0 && (a |= s), A += t.encode(a);
    while (u > 0);
    return A;
  }, Bo.decode = function(l, A, a) {
    var u = l.length, g = 0, h = 0, m, d;
    do {
      if (A >= u)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (d = t.decode(l.charCodeAt(A++)), d === -1)
        throw new Error("Invalid base64 digit: " + l.charAt(A - 1));
      m = !!(d & s), d &= n, g = g + (d << h), h += e;
    } while (m);
    a.value = o(g), a.rest = A;
  }, Bo;
}
var Da = {}, Rd;
function Wi() {
  return Rd || (Rd = 1, function(t) {
    function e(Q, I, w) {
      if (I in Q)
        return Q[I];
      if (arguments.length === 3)
        return w;
      throw new Error('"' + I + '" is a required argument.');
    }
    t.getArg = e;
    var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, n = /^data:.+\,.+$/;
    function s(Q) {
      var I = Q.match(r);
      return I ? {
        scheme: I[1],
        auth: I[2],
        host: I[3],
        port: I[4],
        path: I[5]
      } : null;
    }
    t.urlParse = s;
    function i(Q) {
      var I = "";
      return Q.scheme && (I += Q.scheme + ":"), I += "//", Q.auth && (I += Q.auth + "@"), Q.host && (I += Q.host), Q.port && (I += ":" + Q.port), Q.path && (I += Q.path), I;
    }
    t.urlGenerate = i;
    function o(Q) {
      var I = Q, w = s(Q);
      if (w) {
        if (!w.path)
          return Q;
        I = w.path;
      }
      for (var f = t.isAbsolute(I), C = I.split(/\/+/), b, N = 0, v = C.length - 1; v >= 0; v--)
        b = C[v], b === "." ? C.splice(v, 1) : b === ".." ? N++ : N > 0 && (b === "" ? (C.splice(v + 1, N), N = 0) : (C.splice(v, 2), N--));
      return I = C.join("/"), I === "" && (I = f ? "/" : "."), w ? (w.path = I, i(w)) : I;
    }
    t.normalize = o;
    function c(Q, I) {
      Q === "" && (Q = "."), I === "" && (I = ".");
      var w = s(I), f = s(Q);
      if (f && (Q = f.path || "/"), w && !w.scheme)
        return f && (w.scheme = f.scheme), i(w);
      if (w || I.match(n))
        return I;
      if (f && !f.host && !f.path)
        return f.host = I, i(f);
      var C = I.charAt(0) === "/" ? I : o(Q.replace(/\/+$/, "") + "/" + I);
      return f ? (f.path = C, i(f)) : C;
    }
    t.join = c, t.isAbsolute = function(Q) {
      return Q.charAt(0) === "/" || r.test(Q);
    };
    function l(Q, I) {
      Q === "" && (Q = "."), Q = Q.replace(/\/$/, "");
      for (var w = 0; I.indexOf(Q + "/") !== 0; ) {
        var f = Q.lastIndexOf("/");
        if (f < 0 || (Q = Q.slice(0, f), Q.match(/^([^\/]+:\/)?\/*$/)))
          return I;
        ++w;
      }
      return Array(w + 1).join("../") + I.substr(Q.length + 1);
    }
    t.relative = l;
    var A = function() {
      var Q = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in Q);
    }();
    function a(Q) {
      return Q;
    }
    function u(Q) {
      return h(Q) ? "$" + Q : Q;
    }
    t.toSetString = A ? a : u;
    function g(Q) {
      return h(Q) ? Q.slice(1) : Q;
    }
    t.fromSetString = A ? a : g;
    function h(Q) {
      if (!Q)
        return !1;
      var I = Q.length;
      if (I < 9 || Q.charCodeAt(I - 1) !== 95 || Q.charCodeAt(I - 2) !== 95 || Q.charCodeAt(I - 3) !== 111 || Q.charCodeAt(I - 4) !== 116 || Q.charCodeAt(I - 5) !== 111 || Q.charCodeAt(I - 6) !== 114 || Q.charCodeAt(I - 7) !== 112 || Q.charCodeAt(I - 8) !== 95 || Q.charCodeAt(I - 9) !== 95)
        return !1;
      for (var w = I - 10; w >= 0; w--)
        if (Q.charCodeAt(w) !== 36)
          return !1;
      return !0;
    }
    function m(Q, I, w) {
      var f = p(Q.source, I.source);
      return f !== 0 || (f = Q.originalLine - I.originalLine, f !== 0) || (f = Q.originalColumn - I.originalColumn, f !== 0 || w) || (f = Q.generatedColumn - I.generatedColumn, f !== 0) || (f = Q.generatedLine - I.generatedLine, f !== 0) ? f : p(Q.name, I.name);
    }
    t.compareByOriginalPositions = m;
    function d(Q, I, w) {
      var f = Q.generatedLine - I.generatedLine;
      return f !== 0 || (f = Q.generatedColumn - I.generatedColumn, f !== 0 || w) || (f = p(Q.source, I.source), f !== 0) || (f = Q.originalLine - I.originalLine, f !== 0) || (f = Q.originalColumn - I.originalColumn, f !== 0) ? f : p(Q.name, I.name);
    }
    t.compareByGeneratedPositionsDeflated = d;
    function p(Q, I) {
      return Q === I ? 0 : Q === null ? 1 : I === null ? -1 : Q > I ? 1 : -1;
    }
    function E(Q, I) {
      var w = Q.generatedLine - I.generatedLine;
      return w !== 0 || (w = Q.generatedColumn - I.generatedColumn, w !== 0) || (w = p(Q.source, I.source), w !== 0) || (w = Q.originalLine - I.originalLine, w !== 0) || (w = Q.originalColumn - I.originalColumn, w !== 0) ? w : p(Q.name, I.name);
    }
    t.compareByGeneratedPositionsInflated = E;
    function B(Q) {
      return JSON.parse(Q.replace(/^\)]}'[^\n]*\n/, ""));
    }
    t.parseSourceMapInput = B;
    function y(Q, I, w) {
      if (I = I || "", Q && (Q[Q.length - 1] !== "/" && I[0] !== "/" && (Q += "/"), I = Q + I), w) {
        var f = s(w);
        if (!f)
          throw new Error("sourceMapURL could not be parsed");
        if (f.path) {
          var C = f.path.lastIndexOf("/");
          C >= 0 && (f.path = f.path.substring(0, C + 1));
        }
        I = c(i(f), I);
      }
      return o(I);
    }
    t.computeSourceURL = y;
  }(Da)), Da;
}
var Ta = {}, Sd;
function Sf() {
  if (Sd) return Ta;
  Sd = 1;
  var t = Wi(), e = Object.prototype.hasOwnProperty, r = typeof Map < "u";
  function n() {
    this._array = [], this._set = r ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  return n.fromArray = function(i, o) {
    for (var c = new n(), l = 0, A = i.length; l < A; l++)
      c.add(i[l], o);
    return c;
  }, n.prototype.size = function() {
    return r ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, n.prototype.add = function(i, o) {
    var c = r ? i : t.toSetString(i), l = r ? this.has(i) : e.call(this._set, c), A = this._array.length;
    (!l || o) && this._array.push(i), l || (r ? this._set.set(i, A) : this._set[c] = A);
  }, n.prototype.has = function(i) {
    if (r)
      return this._set.has(i);
    var o = t.toSetString(i);
    return e.call(this._set, o);
  }, n.prototype.indexOf = function(i) {
    if (r) {
      var o = this._set.get(i);
      if (o >= 0)
        return o;
    } else {
      var c = t.toSetString(i);
      if (e.call(this._set, c))
        return this._set[c];
    }
    throw new Error('"' + i + '" is not in the set.');
  }, n.prototype.at = function(i) {
    if (i >= 0 && i < this._array.length)
      return this._array[i];
    throw new Error("No element indexed by " + i);
  }, n.prototype.toArray = function() {
    return this._array.slice();
  }, Ta.ArraySet = n, Ta;
}
var ka = {}, vd;
function qQ() {
  if (vd) return ka;
  vd = 1;
  var t = Wi();
  function e(n, s) {
    var i = n.generatedLine, o = s.generatedLine, c = n.generatedColumn, l = s.generatedColumn;
    return o > i || o == i && l >= c || t.compareByGeneratedPositionsInflated(n, s) <= 0;
  }
  function r() {
    this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  return r.prototype.unsortedForEach = function(s, i) {
    this._array.forEach(s, i);
  }, r.prototype.add = function(s) {
    e(this._last, s) ? (this._last = s, this._array.push(s)) : (this._sorted = !1, this._array.push(s));
  }, r.prototype.toArray = function() {
    return this._sorted || (this._array.sort(t.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, ka.MappingList = r, ka;
}
var xd;
function vf() {
  if (xd) return xa;
  xd = 1;
  var t = Rf(), e = Wi(), r = Sf().ArraySet, n = qQ().MappingList;
  function s(i) {
    i || (i = {}), this._file = e.getArg(i, "file", null), this._sourceRoot = e.getArg(i, "sourceRoot", null), this._skipValidation = e.getArg(i, "skipValidation", !1), this._sources = new r(), this._names = new r(), this._mappings = new n(), this._sourcesContents = null;
  }
  return s.prototype._version = 3, s.fromSourceMap = function(o) {
    var c = o.sourceRoot, l = new s({
      file: o.file,
      sourceRoot: c
    });
    return o.eachMapping(function(A) {
      var a = {
        generated: {
          line: A.generatedLine,
          column: A.generatedColumn
        }
      };
      A.source != null && (a.source = A.source, c != null && (a.source = e.relative(c, a.source)), a.original = {
        line: A.originalLine,
        column: A.originalColumn
      }, A.name != null && (a.name = A.name)), l.addMapping(a);
    }), o.sources.forEach(function(A) {
      var a = A;
      c !== null && (a = e.relative(c, A)), l._sources.has(a) || l._sources.add(a);
      var u = o.sourceContentFor(A);
      u != null && l.setSourceContent(A, u);
    }), l;
  }, s.prototype.addMapping = function(o) {
    var c = e.getArg(o, "generated"), l = e.getArg(o, "original", null), A = e.getArg(o, "source", null), a = e.getArg(o, "name", null);
    this._skipValidation || this._validateMapping(c, l, A, a), A != null && (A = String(A), this._sources.has(A) || this._sources.add(A)), a != null && (a = String(a), this._names.has(a) || this._names.add(a)), this._mappings.add({
      generatedLine: c.line,
      generatedColumn: c.column,
      originalLine: l != null && l.line,
      originalColumn: l != null && l.column,
      source: A,
      name: a
    });
  }, s.prototype.setSourceContent = function(o, c) {
    var l = o;
    this._sourceRoot != null && (l = e.relative(this._sourceRoot, l)), c != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[e.toSetString(l)] = c) : this._sourcesContents && (delete this._sourcesContents[e.toSetString(l)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, s.prototype.applySourceMap = function(o, c, l) {
    var A = c;
    if (c == null) {
      if (o.file == null)
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      A = o.file;
    }
    var a = this._sourceRoot;
    a != null && (A = e.relative(a, A));
    var u = new r(), g = new r();
    this._mappings.unsortedForEach(function(h) {
      if (h.source === A && h.originalLine != null) {
        var m = o.originalPositionFor({
          line: h.originalLine,
          column: h.originalColumn
        });
        m.source != null && (h.source = m.source, l != null && (h.source = e.join(l, h.source)), a != null && (h.source = e.relative(a, h.source)), h.originalLine = m.line, h.originalColumn = m.column, m.name != null && (h.name = m.name));
      }
      var d = h.source;
      d != null && !u.has(d) && u.add(d);
      var p = h.name;
      p != null && !g.has(p) && g.add(p);
    }, this), this._sources = u, this._names = g, o.sources.forEach(function(h) {
      var m = o.sourceContentFor(h);
      m != null && (l != null && (h = e.join(l, h)), a != null && (h = e.relative(a, h)), this.setSourceContent(h, m));
    }, this);
  }, s.prototype._validateMapping = function(o, c, l, A) {
    if (c && typeof c.line != "number" && typeof c.column != "number")
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    if (!(o && "line" in o && "column" in o && o.line > 0 && o.column >= 0 && !c && !l && !A)) {
      if (o && "line" in o && "column" in o && c && "line" in c && "column" in c && o.line > 0 && o.column >= 0 && c.line > 0 && c.column >= 0 && l)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: o,
        source: l,
        original: c,
        name: A
      }));
    }
  }, s.prototype._serializeMappings = function() {
    for (var o = 0, c = 1, l = 0, A = 0, a = 0, u = 0, g = "", h, m, d, p, E = this._mappings.toArray(), B = 0, y = E.length; B < y; B++) {
      if (m = E[B], h = "", m.generatedLine !== c)
        for (o = 0; m.generatedLine !== c; )
          h += ";", c++;
      else if (B > 0) {
        if (!e.compareByGeneratedPositionsInflated(m, E[B - 1]))
          continue;
        h += ",";
      }
      h += t.encode(m.generatedColumn - o), o = m.generatedColumn, m.source != null && (p = this._sources.indexOf(m.source), h += t.encode(p - u), u = p, h += t.encode(m.originalLine - 1 - A), A = m.originalLine - 1, h += t.encode(m.originalColumn - l), l = m.originalColumn, m.name != null && (d = this._names.indexOf(m.name), h += t.encode(d - a), a = d)), g += h;
    }
    return g;
  }, s.prototype._generateSourcesContent = function(o, c) {
    return o.map(function(l) {
      if (!this._sourcesContents)
        return null;
      c != null && (l = e.relative(c, l));
      var A = e.toSetString(l);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, A) ? this._sourcesContents[A] : null;
    }, this);
  }, s.prototype.toJSON = function() {
    var o = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (o.file = this._file), this._sourceRoot != null && (o.sourceRoot = this._sourceRoot), this._sourcesContents && (o.sourcesContent = this._generateSourcesContent(o.sources, o.sourceRoot)), o;
  }, s.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, xa.SourceMapGenerator = s, xa;
}
var mi = {}, Fa = {}, Dd;
function HQ() {
  return Dd || (Dd = 1, function(t) {
    t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2;
    function e(r, n, s, i, o, c) {
      var l = Math.floor((n - r) / 2) + r, A = o(s, i[l], !0);
      return A === 0 ? l : A > 0 ? n - l > 1 ? e(l, n, s, i, o, c) : c == t.LEAST_UPPER_BOUND ? n < i.length ? n : -1 : l : l - r > 1 ? e(r, l, s, i, o, c) : c == t.LEAST_UPPER_BOUND ? l : r < 0 ? -1 : r;
    }
    t.search = function(n, s, i, o) {
      if (s.length === 0)
        return -1;
      var c = e(
        -1,
        s.length,
        n,
        s,
        i,
        o || t.GREATEST_LOWER_BOUND
      );
      if (c < 0)
        return -1;
      for (; c - 1 >= 0 && i(s[c], s[c - 1], !0) === 0; )
        --c;
      return c;
    };
  }(Fa)), Fa;
}
var Pa = {}, Td;
function zQ() {
  if (Td) return Pa;
  Td = 1;
  function t(n, s, i) {
    var o = n[s];
    n[s] = n[i], n[i] = o;
  }
  function e(n, s) {
    return Math.round(n + Math.random() * (s - n));
  }
  function r(n, s, i, o) {
    if (i < o) {
      var c = e(i, o), l = i - 1;
      t(n, c, o);
      for (var A = n[o], a = i; a < o; a++)
        s(n[a], A) <= 0 && (l += 1, t(n, l, a));
      t(n, l + 1, a);
      var u = l + 1;
      r(n, s, i, u - 1), r(n, s, u + 1, o);
    }
  }
  return Pa.quickSort = function(n, s) {
    r(n, s, 0, n.length - 1);
  }, Pa;
}
var kd;
function YQ() {
  if (kd) return mi;
  kd = 1;
  var t = Wi(), e = HQ(), r = Sf().ArraySet, n = Rf(), s = zQ().quickSort;
  function i(A, a) {
    var u = A;
    return typeof A == "string" && (u = t.parseSourceMapInput(A)), u.sections != null ? new l(u, a) : new o(u, a);
  }
  i.fromSourceMap = function(A, a) {
    return o.fromSourceMap(A, a);
  }, i.prototype._version = 3, i.prototype.__generatedMappings = null, Object.defineProperty(i.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  }), i.prototype.__originalMappings = null, Object.defineProperty(i.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  }), i.prototype._charIsMappingSeparator = function(a, u) {
    var g = a.charAt(u);
    return g === ";" || g === ",";
  }, i.prototype._parseMappings = function(a, u) {
    throw new Error("Subclasses must implement _parseMappings");
  }, i.GENERATED_ORDER = 1, i.ORIGINAL_ORDER = 2, i.GREATEST_LOWER_BOUND = 1, i.LEAST_UPPER_BOUND = 2, i.prototype.eachMapping = function(a, u, g) {
    var h = u || null, m = g || i.GENERATED_ORDER, d;
    switch (m) {
      case i.GENERATED_ORDER:
        d = this._generatedMappings;
        break;
      case i.ORIGINAL_ORDER:
        d = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var p = this.sourceRoot;
    d.map(function(E) {
      var B = E.source === null ? null : this._sources.at(E.source);
      return B = t.computeSourceURL(p, B, this._sourceMapURL), {
        source: B,
        generatedLine: E.generatedLine,
        generatedColumn: E.generatedColumn,
        originalLine: E.originalLine,
        originalColumn: E.originalColumn,
        name: E.name === null ? null : this._names.at(E.name)
      };
    }, this).forEach(a, h);
  }, i.prototype.allGeneratedPositionsFor = function(a) {
    var u = t.getArg(a, "line"), g = {
      source: t.getArg(a, "source"),
      originalLine: u,
      originalColumn: t.getArg(a, "column", 0)
    };
    if (g.source = this._findSourceIndex(g.source), g.source < 0)
      return [];
    var h = [], m = this._findMapping(
      g,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      e.LEAST_UPPER_BOUND
    );
    if (m >= 0) {
      var d = this._originalMappings[m];
      if (a.column === void 0)
        for (var p = d.originalLine; d && d.originalLine === p; )
          h.push({
            line: t.getArg(d, "generatedLine", null),
            column: t.getArg(d, "generatedColumn", null),
            lastColumn: t.getArg(d, "lastGeneratedColumn", null)
          }), d = this._originalMappings[++m];
      else
        for (var E = d.originalColumn; d && d.originalLine === u && d.originalColumn == E; )
          h.push({
            line: t.getArg(d, "generatedLine", null),
            column: t.getArg(d, "generatedColumn", null),
            lastColumn: t.getArg(d, "lastGeneratedColumn", null)
          }), d = this._originalMappings[++m];
    }
    return h;
  }, mi.SourceMapConsumer = i;
  function o(A, a) {
    var u = A;
    typeof A == "string" && (u = t.parseSourceMapInput(A));
    var g = t.getArg(u, "version"), h = t.getArg(u, "sources"), m = t.getArg(u, "names", []), d = t.getArg(u, "sourceRoot", null), p = t.getArg(u, "sourcesContent", null), E = t.getArg(u, "mappings"), B = t.getArg(u, "file", null);
    if (g != this._version)
      throw new Error("Unsupported version: " + g);
    d && (d = t.normalize(d)), h = h.map(String).map(t.normalize).map(function(y) {
      return d && t.isAbsolute(d) && t.isAbsolute(y) ? t.relative(d, y) : y;
    }), this._names = r.fromArray(m.map(String), !0), this._sources = r.fromArray(h, !0), this._absoluteSources = this._sources.toArray().map(function(y) {
      return t.computeSourceURL(d, y, a);
    }), this.sourceRoot = d, this.sourcesContent = p, this._mappings = E, this._sourceMapURL = a, this.file = B;
  }
  o.prototype = Object.create(i.prototype), o.prototype.consumer = i, o.prototype._findSourceIndex = function(A) {
    var a = A;
    if (this.sourceRoot != null && (a = t.relative(this.sourceRoot, a)), this._sources.has(a))
      return this._sources.indexOf(a);
    var u;
    for (u = 0; u < this._absoluteSources.length; ++u)
      if (this._absoluteSources[u] == A)
        return u;
    return -1;
  }, o.fromSourceMap = function(a, u) {
    var g = Object.create(o.prototype), h = g._names = r.fromArray(a._names.toArray(), !0), m = g._sources = r.fromArray(a._sources.toArray(), !0);
    g.sourceRoot = a._sourceRoot, g.sourcesContent = a._generateSourcesContent(
      g._sources.toArray(),
      g.sourceRoot
    ), g.file = a._file, g._sourceMapURL = u, g._absoluteSources = g._sources.toArray().map(function(w) {
      return t.computeSourceURL(g.sourceRoot, w, u);
    });
    for (var d = a._mappings.toArray().slice(), p = g.__generatedMappings = [], E = g.__originalMappings = [], B = 0, y = d.length; B < y; B++) {
      var Q = d[B], I = new c();
      I.generatedLine = Q.generatedLine, I.generatedColumn = Q.generatedColumn, Q.source && (I.source = m.indexOf(Q.source), I.originalLine = Q.originalLine, I.originalColumn = Q.originalColumn, Q.name && (I.name = h.indexOf(Q.name)), E.push(I)), p.push(I);
    }
    return s(g.__originalMappings, t.compareByOriginalPositions), g;
  }, o.prototype._version = 3, Object.defineProperty(o.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function c() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  o.prototype._parseMappings = function(a, u) {
    for (var g = 1, h = 0, m = 0, d = 0, p = 0, E = 0, B = a.length, y = 0, Q = {}, I = {}, w = [], f = [], C, b, N, v, R; y < B; )
      if (a.charAt(y) === ";")
        g++, y++, h = 0;
      else if (a.charAt(y) === ",")
        y++;
      else {
        for (C = new c(), C.generatedLine = g, v = y; v < B && !this._charIsMappingSeparator(a, v); v++)
          ;
        if (b = a.slice(y, v), N = Q[b], N)
          y += b.length;
        else {
          for (N = []; y < v; )
            n.decode(a, y, I), R = I.value, y = I.rest, N.push(R);
          if (N.length === 2)
            throw new Error("Found a source, but no line and column");
          if (N.length === 3)
            throw new Error("Found a source and line, but no column");
          Q[b] = N;
        }
        C.generatedColumn = h + N[0], h = C.generatedColumn, N.length > 1 && (C.source = p + N[1], p += N[1], C.originalLine = m + N[2], m = C.originalLine, C.originalLine += 1, C.originalColumn = d + N[3], d = C.originalColumn, N.length > 4 && (C.name = E + N[4], E += N[4])), f.push(C), typeof C.originalLine == "number" && w.push(C);
      }
    s(f, t.compareByGeneratedPositionsDeflated), this.__generatedMappings = f, s(w, t.compareByOriginalPositions), this.__originalMappings = w;
  }, o.prototype._findMapping = function(a, u, g, h, m, d) {
    if (a[g] <= 0)
      throw new TypeError("Line must be greater than or equal to 1, got " + a[g]);
    if (a[h] < 0)
      throw new TypeError("Column must be greater than or equal to 0, got " + a[h]);
    return e.search(a, u, m, d);
  }, o.prototype.computeColumnSpans = function() {
    for (var a = 0; a < this._generatedMappings.length; ++a) {
      var u = this._generatedMappings[a];
      if (a + 1 < this._generatedMappings.length) {
        var g = this._generatedMappings[a + 1];
        if (u.generatedLine === g.generatedLine) {
          u.lastGeneratedColumn = g.generatedColumn - 1;
          continue;
        }
      }
      u.lastGeneratedColumn = 1 / 0;
    }
  }, o.prototype.originalPositionFor = function(a) {
    var u = {
      generatedLine: t.getArg(a, "line"),
      generatedColumn: t.getArg(a, "column")
    }, g = this._findMapping(
      u,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      t.compareByGeneratedPositionsDeflated,
      t.getArg(a, "bias", i.GREATEST_LOWER_BOUND)
    );
    if (g >= 0) {
      var h = this._generatedMappings[g];
      if (h.generatedLine === u.generatedLine) {
        var m = t.getArg(h, "source", null);
        m !== null && (m = this._sources.at(m), m = t.computeSourceURL(this.sourceRoot, m, this._sourceMapURL));
        var d = t.getArg(h, "name", null);
        return d !== null && (d = this._names.at(d)), {
          source: m,
          line: t.getArg(h, "originalLine", null),
          column: t.getArg(h, "originalColumn", null),
          name: d
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, o.prototype.hasContentsOfAllSources = function() {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(a) {
      return a == null;
    }) : !1;
  }, o.prototype.sourceContentFor = function(a, u) {
    if (!this.sourcesContent)
      return null;
    var g = this._findSourceIndex(a);
    if (g >= 0)
      return this.sourcesContent[g];
    var h = a;
    this.sourceRoot != null && (h = t.relative(this.sourceRoot, h));
    var m;
    if (this.sourceRoot != null && (m = t.urlParse(this.sourceRoot))) {
      var d = h.replace(/^file:\/\//, "");
      if (m.scheme == "file" && this._sources.has(d))
        return this.sourcesContent[this._sources.indexOf(d)];
      if ((!m.path || m.path == "/") && this._sources.has("/" + h))
        return this.sourcesContent[this._sources.indexOf("/" + h)];
    }
    if (u)
      return null;
    throw new Error('"' + h + '" is not in the SourceMap.');
  }, o.prototype.generatedPositionFor = function(a) {
    var u = t.getArg(a, "source");
    if (u = this._findSourceIndex(u), u < 0)
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    var g = {
      source: u,
      originalLine: t.getArg(a, "line"),
      originalColumn: t.getArg(a, "column")
    }, h = this._findMapping(
      g,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      t.compareByOriginalPositions,
      t.getArg(a, "bias", i.GREATEST_LOWER_BOUND)
    );
    if (h >= 0) {
      var m = this._originalMappings[h];
      if (m.source === g.source)
        return {
          line: t.getArg(m, "generatedLine", null),
          column: t.getArg(m, "generatedColumn", null),
          lastColumn: t.getArg(m, "lastGeneratedColumn", null)
        };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, mi.BasicSourceMapConsumer = o;
  function l(A, a) {
    var u = A;
    typeof A == "string" && (u = t.parseSourceMapInput(A));
    var g = t.getArg(u, "version"), h = t.getArg(u, "sections");
    if (g != this._version)
      throw new Error("Unsupported version: " + g);
    this._sources = new r(), this._names = new r();
    var m = {
      line: -1,
      column: 0
    };
    this._sections = h.map(function(d) {
      if (d.url)
        throw new Error("Support for url field in sections not implemented.");
      var p = t.getArg(d, "offset"), E = t.getArg(p, "line"), B = t.getArg(p, "column");
      if (E < m.line || E === m.line && B < m.column)
        throw new Error("Section offsets must be ordered and non-overlapping.");
      return m = p, {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: E + 1,
          generatedColumn: B + 1
        },
        consumer: new i(t.getArg(d, "map"), a)
      };
    });
  }
  return l.prototype = Object.create(i.prototype), l.prototype.constructor = i, l.prototype._version = 3, Object.defineProperty(l.prototype, "sources", {
    get: function() {
      for (var A = [], a = 0; a < this._sections.length; a++)
        for (var u = 0; u < this._sections[a].consumer.sources.length; u++)
          A.push(this._sections[a].consumer.sources[u]);
      return A;
    }
  }), l.prototype.originalPositionFor = function(a) {
    var u = {
      generatedLine: t.getArg(a, "line"),
      generatedColumn: t.getArg(a, "column")
    }, g = e.search(
      u,
      this._sections,
      function(m, d) {
        var p = m.generatedLine - d.generatedOffset.generatedLine;
        return p || m.generatedColumn - d.generatedOffset.generatedColumn;
      }
    ), h = this._sections[g];
    return h ? h.consumer.originalPositionFor({
      line: u.generatedLine - (h.generatedOffset.generatedLine - 1),
      column: u.generatedColumn - (h.generatedOffset.generatedLine === u.generatedLine ? h.generatedOffset.generatedColumn - 1 : 0),
      bias: a.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, l.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(a) {
      return a.consumer.hasContentsOfAllSources();
    });
  }, l.prototype.sourceContentFor = function(a, u) {
    for (var g = 0; g < this._sections.length; g++) {
      var h = this._sections[g], m = h.consumer.sourceContentFor(a, !0);
      if (m)
        return m;
    }
    if (u)
      return null;
    throw new Error('"' + a + '" is not in the SourceMap.');
  }, l.prototype.generatedPositionFor = function(a) {
    for (var u = 0; u < this._sections.length; u++) {
      var g = this._sections[u];
      if (g.consumer._findSourceIndex(t.getArg(a, "source")) !== -1) {
        var h = g.consumer.generatedPositionFor(a);
        if (h) {
          var m = {
            line: h.line + (g.generatedOffset.generatedLine - 1),
            column: h.column + (g.generatedOffset.generatedLine === h.line ? g.generatedOffset.generatedColumn - 1 : 0)
          };
          return m;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, l.prototype._parseMappings = function(a, u) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var g = 0; g < this._sections.length; g++)
      for (var h = this._sections[g], m = h.consumer._generatedMappings, d = 0; d < m.length; d++) {
        var p = m[d], E = h.consumer._sources.at(p.source);
        E = t.computeSourceURL(h.consumer.sourceRoot, E, this._sourceMapURL), this._sources.add(E), E = this._sources.indexOf(E);
        var B = null;
        p.name && (B = h.consumer._names.at(p.name), this._names.add(B), B = this._names.indexOf(B));
        var y = {
          source: E,
          generatedLine: p.generatedLine + (h.generatedOffset.generatedLine - 1),
          generatedColumn: p.generatedColumn + (h.generatedOffset.generatedLine === p.generatedLine ? h.generatedOffset.generatedColumn - 1 : 0),
          originalLine: p.originalLine,
          originalColumn: p.originalColumn,
          name: B
        };
        this.__generatedMappings.push(y), typeof y.originalLine == "number" && this.__originalMappings.push(y);
      }
    s(this.__generatedMappings, t.compareByGeneratedPositionsDeflated), s(this.__originalMappings, t.compareByOriginalPositions);
  }, mi.IndexedSourceMapConsumer = l, mi;
}
var Ua = {}, Fd;
function JQ() {
  if (Fd) return Ua;
  Fd = 1;
  var t = vf().SourceMapGenerator, e = Wi(), r = /(\r?\n)/, n = 10, s = "$$$isSourceNode$$$";
  function i(o, c, l, A, a) {
    this.children = [], this.sourceContents = {}, this.line = o ?? null, this.column = c ?? null, this.source = l ?? null, this.name = a ?? null, this[s] = !0, A != null && this.add(A);
  }
  return i.fromStringWithSourceMap = function(c, l, A) {
    var a = new i(), u = c.split(r), g = 0, h = function() {
      var B = Q(), y = Q() || "";
      return B + y;
      function Q() {
        return g < u.length ? u[g++] : void 0;
      }
    }, m = 1, d = 0, p = null;
    return l.eachMapping(function(B) {
      if (p !== null)
        if (m < B.generatedLine)
          E(p, h()), m++, d = 0;
        else {
          var y = u[g] || "", Q = y.substr(0, B.generatedColumn - d);
          u[g] = y.substr(B.generatedColumn - d), d = B.generatedColumn, E(p, Q), p = B;
          return;
        }
      for (; m < B.generatedLine; )
        a.add(h()), m++;
      if (d < B.generatedColumn) {
        var y = u[g] || "";
        a.add(y.substr(0, B.generatedColumn)), u[g] = y.substr(B.generatedColumn), d = B.generatedColumn;
      }
      p = B;
    }, this), g < u.length && (p && E(p, h()), a.add(u.splice(g).join(""))), l.sources.forEach(function(B) {
      var y = l.sourceContentFor(B);
      y != null && (A != null && (B = e.join(A, B)), a.setSourceContent(B, y));
    }), a;
    function E(B, y) {
      if (B === null || B.source === void 0)
        a.add(y);
      else {
        var Q = A ? e.join(A, B.source) : B.source;
        a.add(new i(
          B.originalLine,
          B.originalColumn,
          Q,
          y,
          B.name
        ));
      }
    }
  }, i.prototype.add = function(c) {
    if (Array.isArray(c))
      c.forEach(function(l) {
        this.add(l);
      }, this);
    else if (c[s] || typeof c == "string")
      c && this.children.push(c);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + c
      );
    return this;
  }, i.prototype.prepend = function(c) {
    if (Array.isArray(c))
      for (var l = c.length - 1; l >= 0; l--)
        this.prepend(c[l]);
    else if (c[s] || typeof c == "string")
      this.children.unshift(c);
    else
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + c
      );
    return this;
  }, i.prototype.walk = function(c) {
    for (var l, A = 0, a = this.children.length; A < a; A++)
      l = this.children[A], l[s] ? l.walk(c) : l !== "" && c(l, {
        source: this.source,
        line: this.line,
        column: this.column,
        name: this.name
      });
  }, i.prototype.join = function(c) {
    var l, A, a = this.children.length;
    if (a > 0) {
      for (l = [], A = 0; A < a - 1; A++)
        l.push(this.children[A]), l.push(c);
      l.push(this.children[A]), this.children = l;
    }
    return this;
  }, i.prototype.replaceRight = function(c, l) {
    var A = this.children[this.children.length - 1];
    return A[s] ? A.replaceRight(c, l) : typeof A == "string" ? this.children[this.children.length - 1] = A.replace(c, l) : this.children.push("".replace(c, l)), this;
  }, i.prototype.setSourceContent = function(c, l) {
    this.sourceContents[e.toSetString(c)] = l;
  }, i.prototype.walkSourceContents = function(c) {
    for (var l = 0, A = this.children.length; l < A; l++)
      this.children[l][s] && this.children[l].walkSourceContents(c);
    for (var a = Object.keys(this.sourceContents), l = 0, A = a.length; l < A; l++)
      c(e.fromSetString(a[l]), this.sourceContents[a[l]]);
  }, i.prototype.toString = function() {
    var c = "";
    return this.walk(function(l) {
      c += l;
    }), c;
  }, i.prototype.toStringWithSourceMap = function(c) {
    var l = {
      code: "",
      line: 1,
      column: 0
    }, A = new t(c), a = !1, u = null, g = null, h = null, m = null;
    return this.walk(function(d, p) {
      l.code += d, p.source !== null && p.line !== null && p.column !== null ? ((u !== p.source || g !== p.line || h !== p.column || m !== p.name) && A.addMapping({
        source: p.source,
        original: {
          line: p.line,
          column: p.column
        },
        generated: {
          line: l.line,
          column: l.column
        },
        name: p.name
      }), u = p.source, g = p.line, h = p.column, m = p.name, a = !0) : a && (A.addMapping({
        generated: {
          line: l.line,
          column: l.column
        }
      }), u = null, a = !1);
      for (var E = 0, B = d.length; E < B; E++)
        d.charCodeAt(E) === n ? (l.line++, l.column = 0, E + 1 === B ? (u = null, a = !1) : a && A.addMapping({
          source: p.source,
          original: {
            line: p.line,
            column: p.column
          },
          generated: {
            line: l.line,
            column: l.column
          },
          name: p.name
        })) : l.column++;
    }), this.walkSourceContents(function(d, p) {
      A.setSourceContent(d, p);
    }), { code: l.code, map: A };
  }, Ua.SourceNode = i, Ua;
}
var Pd;
function VQ() {
  return Pd || (Pd = 1, gi.SourceMapGenerator = vf().SourceMapGenerator, gi.SourceMapConsumer = YQ().SourceMapConsumer, gi.SourceNode = JQ().SourceNode), gi;
}
var La, Ud;
function WQ() {
  if (Ud) return La;
  Ud = 1;
  var t = Object.prototype.toString, e = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
  function r(o) {
    return t.call(o).slice(8, -1) === "ArrayBuffer";
  }
  function n(o, c, l) {
    c >>>= 0;
    var A = o.byteLength - c;
    if (A < 0)
      throw new RangeError("'offset' is out of bounds");
    if (l === void 0)
      l = A;
    else if (l >>>= 0, l > A)
      throw new RangeError("'length' is out of bounds");
    return e ? Buffer.from(o.slice(c, c + l)) : new Buffer(new Uint8Array(o.slice(c, c + l)));
  }
  function s(o, c) {
    if ((typeof c != "string" || c === "") && (c = "utf8"), !Buffer.isEncoding(c))
      throw new TypeError('"encoding" must be a valid string encoding');
    return e ? Buffer.from(o, c) : new Buffer(o, c);
  }
  function i(o, c, l) {
    if (typeof o == "number")
      throw new TypeError('"value" argument must not be a number');
    return r(o) ? n(o, c, l) : typeof o == "string" ? s(o, c) : e ? Buffer.from(o) : new Buffer(o);
  }
  return La = i, La;
}
wi.exports;
var Ld;
function jQ() {
  return Ld || (Ld = 1, function(t, e) {
    var r = VQ().SourceMapConsumer, n = yr, s;
    try {
      s = require("fs"), (!s.existsSync || !s.readFileSync) && (s = null);
    } catch {
    }
    var i = WQ();
    function o(_, M) {
      return _.require(M);
    }
    var c = !1, l = !1, A = !1, a = "auto", u = {}, g = {}, h = /^data:application\/json[^,]+base64,/, m = [], d = [];
    function p() {
      return a === "browser" ? !0 : a === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function E() {
      return typeof process == "object" && process !== null && typeof process.on == "function";
    }
    function B() {
      return typeof process == "object" && process !== null ? process.version : "";
    }
    function y() {
      if (typeof process == "object" && process !== null)
        return process.stderr;
    }
    function Q(_) {
      if (typeof process == "object" && process !== null && typeof process.exit == "function")
        return process.exit(_);
    }
    function I(_) {
      return function(M) {
        for (var $ = 0; $ < _.length; $++) {
          var U = _[$](M);
          if (U)
            return U;
        }
        return null;
      };
    }
    var w = I(m);
    m.push(function(_) {
      if (_ = _.trim(), /^file:/.test(_) && (_ = _.replace(/file:\/\/\/(\w:)?/, function(U, J) {
        return J ? "" : (
          // file:///C:/dir/file -> C:/dir/file
          "/"
        );
      })), _ in u)
        return u[_];
      var M = "";
      try {
        if (s)
          s.existsSync(_) && (M = s.readFileSync(_, "utf8"));
        else {
          var $ = new XMLHttpRequest();
          $.open(
            "GET",
            _,
            /** async */
            !1
          ), $.send(null), $.readyState === 4 && $.status === 200 && (M = $.responseText);
        }
      } catch {
      }
      return u[_] = M;
    });
    function f(_, M) {
      if (!_) return M;
      var $ = n.dirname(_), U = /^\w+:\/\/[^\/]*/.exec($), J = U ? U[0] : "", j = $.slice(J.length);
      return J && /^\/\w\:/.test(j) ? (J += "/", J + n.resolve($.slice(J.length), M).replace(/\\/g, "/")) : J + n.resolve($.slice(J.length), M);
    }
    function C(_) {
      var M;
      if (p())
        try {
          var $ = new XMLHttpRequest();
          $.open("GET", _, !1), $.send(null), M = $.readyState === 4 ? $.responseText : null;
          var U = $.getResponseHeader("SourceMap") || $.getResponseHeader("X-SourceMap");
          if (U)
            return U;
        } catch {
        }
      M = w(_);
      for (var J = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, j, te; te = J.exec(M); ) j = te;
      return j ? j[1] : null;
    }
    var b = I(d);
    d.push(function(_) {
      var M = C(_);
      if (!M) return null;
      var $;
      if (h.test(M)) {
        var U = M.slice(M.indexOf(",") + 1);
        $ = i(U, "base64").toString(), M = _;
      } else
        M = f(_, M), $ = w(M);
      return $ ? {
        url: M,
        map: $
      } : null;
    });
    function N(_) {
      var M = g[_.source];
      if (!M) {
        var $ = b(_.source);
        $ ? (M = g[_.source] = {
          url: $.url,
          map: new r($.map)
        }, M.map.sourcesContent && M.map.sources.forEach(function(J, j) {
          var te = M.map.sourcesContent[j];
          if (te) {
            var ie = f(M.url, J);
            u[ie] = te;
          }
        })) : M = g[_.source] = {
          url: null,
          map: null
        };
      }
      if (M && M.map && typeof M.map.originalPositionFor == "function") {
        var U = M.map.originalPositionFor(_);
        if (U.source !== null)
          return U.source = f(
            M.url,
            U.source
          ), U;
      }
      return _;
    }
    function v(_) {
      var M = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(_);
      if (M) {
        var $ = N({
          source: M[2],
          line: +M[3],
          column: M[4] - 1
        });
        return "eval at " + M[1] + " (" + $.source + ":" + $.line + ":" + ($.column + 1) + ")";
      }
      return M = /^eval at ([^(]+) \((.+)\)$/.exec(_), M ? "eval at " + M[1] + " (" + v(M[2]) + ")" : _;
    }
    function R() {
      var _, M = "";
      if (this.isNative())
        M = "native";
      else {
        _ = this.getScriptNameOrSourceURL(), !_ && this.isEval() && (M = this.getEvalOrigin(), M += ", "), _ ? M += _ : M += "<anonymous>";
        var $ = this.getLineNumber();
        if ($ != null) {
          M += ":" + $;
          var U = this.getColumnNumber();
          U && (M += ":" + U);
        }
      }
      var J = "", j = this.getFunctionName(), te = !0, ie = this.isConstructor(), G = !(this.isToplevel() || ie);
      if (G) {
        var q = this.getTypeName();
        q === "[object Object]" && (q = "null");
        var Z = this.getMethodName();
        j ? (q && j.indexOf(q) != 0 && (J += q + "."), J += j, Z && j.indexOf("." + Z) != j.length - Z.length - 1 && (J += " [as " + Z + "]")) : J += q + "." + (Z || "<anonymous>");
      } else ie ? J += "new " + (j || "<anonymous>") : j ? J += j : (J += M, te = !1);
      return te && (J += " (" + M + ")"), J;
    }
    function x(_) {
      var M = {};
      return Object.getOwnPropertyNames(Object.getPrototypeOf(_)).forEach(function($) {
        M[$] = /^(?:is|get)/.test($) ? function() {
          return _[$].call(_);
        } : _[$];
      }), M.toString = R, M;
    }
    function S(_, M) {
      if (M === void 0 && (M = { nextPosition: null, curPosition: null }), _.isNative())
        return M.curPosition = null, _;
      var $ = _.getFileName() || _.getScriptNameOrSourceURL();
      if ($) {
        var U = _.getLineNumber(), J = _.getColumnNumber() - 1, j = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/, te = j.test(B()) ? 0 : 62;
        U === 1 && J > te && !p() && !_.isEval() && (J -= te);
        var ie = N({
          source: $,
          line: U,
          column: J
        });
        M.curPosition = ie, _ = x(_);
        var G = _.getFunctionName;
        return _.getFunctionName = function() {
          return M.nextPosition == null ? G() : M.nextPosition.name || G();
        }, _.getFileName = function() {
          return ie.source;
        }, _.getLineNumber = function() {
          return ie.line;
        }, _.getColumnNumber = function() {
          return ie.column + 1;
        }, _.getScriptNameOrSourceURL = function() {
          return ie.source;
        }, _;
      }
      var q = _.isEval() && _.getEvalOrigin();
      return q && (q = v(q), _ = x(_), _.getEvalOrigin = function() {
        return q;
      }), _;
    }
    function D(_, M) {
      A && (u = {}, g = {});
      for (var $ = _.name || "Error", U = _.message || "", J = $ + ": " + U, j = { nextPosition: null, curPosition: null }, te = [], ie = M.length - 1; ie >= 0; ie--)
        te.push(`
    at ` + S(M[ie], j)), j.nextPosition = j.curPosition;
      return j.curPosition = j.nextPosition = null, J + te.reverse().join("");
    }
    function T(_) {
      var M = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(_.stack);
      if (M) {
        var $ = M[1], U = +M[2], J = +M[3], j = u[$];
        if (!j && s && s.existsSync($))
          try {
            j = s.readFileSync($, "utf8");
          } catch {
            j = "";
          }
        if (j) {
          var te = j.split(/(?:\r\n|\r|\n)/)[U - 1];
          if (te)
            return $ + ":" + U + `
` + te + `
` + new Array(J).join(" ") + "^";
        }
      }
      return null;
    }
    function k(_) {
      var M = T(_), $ = y();
      $ && $._handle && $._handle.setBlocking && $._handle.setBlocking(!0), M && (console.error(), console.error(M)), console.error(_.stack), Q(1);
    }
    function L() {
      var _ = process.emit;
      process.emit = function(M) {
        if (M === "uncaughtException") {
          var $ = arguments[1] && arguments[1].stack, U = this.listeners(M).length > 0;
          if ($ && !U)
            return k(arguments[1]);
        }
        return _.apply(this, arguments);
      };
    }
    var W = m.slice(0), O = d.slice(0);
    e.wrapCallSite = S, e.getErrorSource = T, e.mapSourcePosition = N, e.retrieveSourceMap = b, e.install = function(_) {
      if (_ = _ || {}, _.environment && (a = _.environment, ["node", "browser", "auto"].indexOf(a) === -1))
        throw new Error("environment " + a + " was unknown. Available options are {auto, browser, node}");
      if (_.retrieveFile && (_.overrideRetrieveFile && (m.length = 0), m.unshift(_.retrieveFile)), _.retrieveSourceMap && (_.overrideRetrieveSourceMap && (d.length = 0), d.unshift(_.retrieveSourceMap)), _.hookRequire && !p()) {
        var M = o(t, "module"), $ = M.prototype._compile;
        $.__sourceMapSupport || (M.prototype._compile = function(j, te) {
          return u[te] = j, g[te] = void 0, $.call(this, j, te);
        }, M.prototype._compile.__sourceMapSupport = !0);
      }
      if (A || (A = "emptyCacheBetweenOperations" in _ ? _.emptyCacheBetweenOperations : !1), c || (c = !0, Error.prepareStackTrace = D), !l) {
        var U = "handleUncaughtExceptions" in _ ? _.handleUncaughtExceptions : !0;
        try {
          var J = o(t, "worker_threads");
          J.isMainThread === !1 && (U = !1);
        } catch {
        }
        U && E() && (l = !0, L());
      }
    }, e.resetRetrieveHandlers = function() {
      m.length = 0, d.length = 0, m = W.slice(0), d = O.slice(0), b = I(d), w = I(m);
    };
  }(wi, wi.exports)), wi.exports;
}
var _d;
function $Q() {
  return _d || (_d = 1, jQ().install()), bd;
}
$Q();
var Jr = {}, wr = {}, On = {}, Md;
function ou() {
  if (Md) return On;
  Md = 1, Object.defineProperty(On, "__esModule", { value: !0 }), On.toCommandProperties = On.toCommandValue = void 0;
  function t(r) {
    return r == null ? "" : typeof r == "string" || r instanceof String ? r : JSON.stringify(r);
  }
  On.toCommandValue = t;
  function e(r) {
    return Object.keys(r).length ? {
      title: r.title,
      file: r.file,
      line: r.startLine,
      endLine: r.endLine,
      col: r.startColumn,
      endColumn: r.endColumn
    } : {};
  }
  return On.toCommandProperties = e, On;
}
var Od;
function XQ() {
  if (Od) return wr;
  Od = 1;
  var t = wr && wr.__createBinding || (Object.create ? function(u, g, h, m) {
    m === void 0 && (m = h);
    var d = Object.getOwnPropertyDescriptor(g, h);
    (!d || ("get" in d ? !g.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return g[h];
    } }), Object.defineProperty(u, m, d);
  } : function(u, g, h, m) {
    m === void 0 && (m = h), u[m] = g[h];
  }), e = wr && wr.__setModuleDefault || (Object.create ? function(u, g) {
    Object.defineProperty(u, "default", { enumerable: !0, value: g });
  } : function(u, g) {
    u.default = g;
  }), r = wr && wr.__importStar || function(u) {
    if (u && u.__esModule) return u;
    var g = {};
    if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && t(g, u, h);
    return e(g, u), g;
  };
  Object.defineProperty(wr, "__esModule", { value: !0 }), wr.issue = wr.issueCommand = void 0;
  const n = r(cn), s = ou();
  function i(u, g, h) {
    const m = new l(u, g, h);
    process.stdout.write(m.toString() + n.EOL);
  }
  wr.issueCommand = i;
  function o(u, g = "") {
    i(u, {}, g);
  }
  wr.issue = o;
  const c = "::";
  class l {
    constructor(g, h, m) {
      g || (g = "missing.command"), this.command = g, this.properties = h, this.message = m;
    }
    toString() {
      let g = c + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        g += " ";
        let h = !0;
        for (const m in this.properties)
          if (this.properties.hasOwnProperty(m)) {
            const d = this.properties[m];
            d && (h ? h = !1 : g += ",", g += `${m}=${a(d)}`);
          }
      }
      return g += `${c}${A(this.message)}`, g;
    }
  }
  function A(u) {
    return (0, s.toCommandValue)(u).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function a(u) {
    return (0, s.toCommandValue)(u).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
  return wr;
}
var Nr = {}, Gd;
function KQ() {
  if (Gd) return Nr;
  Gd = 1;
  var t = Nr && Nr.__createBinding || (Object.create ? function(A, a, u, g) {
    g === void 0 && (g = u);
    var h = Object.getOwnPropertyDescriptor(a, u);
    (!h || ("get" in h ? !a.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return a[u];
    } }), Object.defineProperty(A, g, h);
  } : function(A, a, u, g) {
    g === void 0 && (g = u), A[g] = a[u];
  }), e = Nr && Nr.__setModuleDefault || (Object.create ? function(A, a) {
    Object.defineProperty(A, "default", { enumerable: !0, value: a });
  } : function(A, a) {
    A.default = a;
  }), r = Nr && Nr.__importStar || function(A) {
    if (A && A.__esModule) return A;
    var a = {};
    if (A != null) for (var u in A) u !== "default" && Object.prototype.hasOwnProperty.call(A, u) && t(a, A, u);
    return e(a, A), a;
  };
  Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.prepareKeyValueMessage = Nr.issueFileCommand = void 0;
  const n = r(su), s = r(Zr), i = r(cn), o = ou();
  function c(A, a) {
    const u = process.env[`GITHUB_${A}`];
    if (!u)
      throw new Error(`Unable to find environment variable for file command ${A}`);
    if (!s.existsSync(u))
      throw new Error(`Missing file at path: ${u}`);
    s.appendFileSync(u, `${(0, o.toCommandValue)(a)}${i.EOL}`, {
      encoding: "utf8"
    });
  }
  Nr.issueFileCommand = c;
  function l(A, a) {
    const u = `ghadelimiter_${n.randomUUID()}`, g = (0, o.toCommandValue)(a);
    if (A.includes(u))
      throw new Error(`Unexpected input: name should not contain the delimiter "${u}"`);
    if (g.includes(u))
      throw new Error(`Unexpected input: value should not contain the delimiter "${u}"`);
    return `${A}<<${u}${i.EOL}${g}${i.EOL}${u}`;
  }
  return Nr.prepareKeyValueMessage = l, Nr;
}
var Gn = {}, dt = {}, qn = {}, qd;
function ZQ() {
  if (qd) return qn;
  qd = 1, Object.defineProperty(qn, "__esModule", { value: !0 }), qn.checkBypass = qn.getProxyUrl = void 0;
  function t(s) {
    const i = s.protocol === "https:";
    if (e(s))
      return;
    const o = i ? process.env.https_proxy || process.env.HTTPS_PROXY : process.env.http_proxy || process.env.HTTP_PROXY;
    if (o)
      try {
        return new n(o);
      } catch {
        if (!o.startsWith("http://") && !o.startsWith("https://"))
          return new n(`http://${o}`);
      }
    else
      return;
  }
  qn.getProxyUrl = t;
  function e(s) {
    if (!s.hostname)
      return !1;
    const i = s.hostname;
    if (r(i))
      return !0;
    const o = process.env.no_proxy || process.env.NO_PROXY || "";
    if (!o)
      return !1;
    let c;
    s.port ? c = Number(s.port) : s.protocol === "http:" ? c = 80 : s.protocol === "https:" && (c = 443);
    const l = [s.hostname.toUpperCase()];
    typeof c == "number" && l.push(`${l[0]}:${c}`);
    for (const A of o.split(",").map((a) => a.trim().toUpperCase()).filter((a) => a))
      if (A === "*" || l.some((a) => a === A || a.endsWith(`.${A}`) || A.startsWith(".") && a.endsWith(`${A}`)))
        return !0;
    return !1;
  }
  qn.checkBypass = e;
  function r(s) {
    const i = s.toLowerCase();
    return i === "localhost" || i.startsWith("127.") || i.startsWith("[::1]") || i.startsWith("[0:0:0:0:0:0:0:1]");
  }
  class n extends URL {
    constructor(i, o) {
      super(i, o), this._decodedUsername = decodeURIComponent(super.username), this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
  return qn;
}
var Hn = {}, Hd;
function eb() {
  if (Hd) return Hn;
  Hd = 1;
  var t = Cf, e = Ds, r = Ef, n = Ts, s = Qr;
  Hn.httpOverHttp = i, Hn.httpsOverHttp = o, Hn.httpOverHttps = c, Hn.httpsOverHttps = l;
  function i(m) {
    var d = new A(m);
    return d.request = e.request, d;
  }
  function o(m) {
    var d = new A(m);
    return d.request = e.request, d.createSocket = a, d.defaultPort = 443, d;
  }
  function c(m) {
    var d = new A(m);
    return d.request = r.request, d;
  }
  function l(m) {
    var d = new A(m);
    return d.request = r.request, d.createSocket = a, d.defaultPort = 443, d;
  }
  function A(m) {
    var d = this;
    d.options = m || {}, d.proxyOptions = d.options.proxy || {}, d.maxSockets = d.options.maxSockets || e.Agent.defaultMaxSockets, d.requests = [], d.sockets = [], d.on("free", function(E, B, y, Q) {
      for (var I = u(B, y, Q), w = 0, f = d.requests.length; w < f; ++w) {
        var C = d.requests[w];
        if (C.host === I.host && C.port === I.port) {
          d.requests.splice(w, 1), C.request.onSocket(E);
          return;
        }
      }
      E.destroy(), d.removeSocket(E);
    });
  }
  s.inherits(A, n.EventEmitter), A.prototype.addRequest = function(d, p, E, B) {
    var y = this, Q = g({ request: d }, y.options, u(p, E, B));
    if (y.sockets.length >= this.maxSockets) {
      y.requests.push(Q);
      return;
    }
    y.createSocket(Q, function(I) {
      I.on("free", w), I.on("close", f), I.on("agentRemove", f), d.onSocket(I);
      function w() {
        y.emit("free", I, Q);
      }
      function f(C) {
        y.removeSocket(I), I.removeListener("free", w), I.removeListener("close", f), I.removeListener("agentRemove", f);
      }
    });
  }, A.prototype.createSocket = function(d, p) {
    var E = this, B = {};
    E.sockets.push(B);
    var y = g({}, E.proxyOptions, {
      method: "CONNECT",
      path: d.host + ":" + d.port,
      agent: !1,
      headers: {
        host: d.host + ":" + d.port
      }
    });
    d.localAddress && (y.localAddress = d.localAddress), y.proxyAuth && (y.headers = y.headers || {}, y.headers["Proxy-Authorization"] = "Basic " + new Buffer(y.proxyAuth).toString("base64")), h("making CONNECT request");
    var Q = E.request(y);
    Q.useChunkedEncodingByDefault = !1, Q.once("response", I), Q.once("upgrade", w), Q.once("connect", f), Q.once("error", C), Q.end();
    function I(b) {
      b.upgrade = !0;
    }
    function w(b, N, v) {
      process.nextTick(function() {
        f(b, N, v);
      });
    }
    function f(b, N, v) {
      if (Q.removeAllListeners(), N.removeAllListeners(), b.statusCode !== 200) {
        h(
          "tunneling socket could not be established, statusCode=%d",
          b.statusCode
        ), N.destroy();
        var R = new Error("tunneling socket could not be established, statusCode=" + b.statusCode);
        R.code = "ECONNRESET", d.request.emit("error", R), E.removeSocket(B);
        return;
      }
      if (v.length > 0) {
        h("got illegal response body from proxy"), N.destroy();
        var R = new Error("got illegal response body from proxy");
        R.code = "ECONNRESET", d.request.emit("error", R), E.removeSocket(B);
        return;
      }
      return h("tunneling connection has established"), E.sockets[E.sockets.indexOf(B)] = N, p(N);
    }
    function C(b) {
      Q.removeAllListeners(), h(
        `tunneling socket could not be established, cause=%s
`,
        b.message,
        b.stack
      );
      var N = new Error("tunneling socket could not be established, cause=" + b.message);
      N.code = "ECONNRESET", d.request.emit("error", N), E.removeSocket(B);
    }
  }, A.prototype.removeSocket = function(d) {
    var p = this.sockets.indexOf(d);
    if (p !== -1) {
      this.sockets.splice(p, 1);
      var E = this.requests.shift();
      E && this.createSocket(E, function(B) {
        E.request.onSocket(B);
      });
    }
  };
  function a(m, d) {
    var p = this;
    A.prototype.createSocket.call(p, m, function(E) {
      var B = m.request.getHeader("host"), y = g({}, p.options, {
        socket: E,
        servername: B ? B.replace(/:.*$/, "") : m.host
      }), Q = t.connect(0, y);
      p.sockets[p.sockets.indexOf(E)] = Q, d(Q);
    });
  }
  function u(m, d, p) {
    return typeof m == "string" ? {
      host: m,
      port: d,
      localAddress: p
    } : m;
  }
  function g(m) {
    for (var d = 1, p = arguments.length; d < p; ++d) {
      var E = arguments[d];
      if (typeof E == "object")
        for (var B = Object.keys(E), y = 0, Q = B.length; y < Q; ++y) {
          var I = B[y];
          E[I] !== void 0 && (m[I] = E[I]);
        }
    }
    return m;
  }
  var h;
  return process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? h = function() {
    var m = Array.prototype.slice.call(arguments);
    typeof m[0] == "string" ? m[0] = "TUNNEL: " + m[0] : m.unshift("TUNNEL:"), console.error.apply(console, m);
  } : h = function() {
  }, Hn.debug = h, Hn;
}
var _a, zd;
function tb() {
  return zd || (zd = 1, _a = eb()), _a;
}
var Je = {}, Ma, Yd;
function Nt() {
  return Yd || (Yd = 1, Ma = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable")
  }), Ma;
}
var Oa, Jd;
function ft() {
  if (Jd) return Oa;
  Jd = 1;
  class t extends Error {
    constructor(I) {
      super(I), this.name = "UndiciError", this.code = "UND_ERR";
    }
  }
  class e extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, e), this.name = "ConnectTimeoutError", this.message = I || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }
  class r extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, r), this.name = "HeadersTimeoutError", this.message = I || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }
  class n extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, n), this.name = "HeadersOverflowError", this.message = I || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }
  class s extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, s), this.name = "BodyTimeoutError", this.message = I || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }
  class i extends t {
    constructor(I, w, f, C) {
      super(I), Error.captureStackTrace(this, i), this.name = "ResponseStatusCodeError", this.message = I || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = C, this.status = w, this.statusCode = w, this.headers = f;
    }
  }
  class o extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, o), this.name = "InvalidArgumentError", this.message = I || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
    }
  }
  class c extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, c), this.name = "InvalidReturnValueError", this.message = I || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }
  class l extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, l), this.name = "AbortError", this.message = I || "Request aborted", this.code = "UND_ERR_ABORTED";
    }
  }
  class A extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, A), this.name = "InformationalError", this.message = I || "Request information", this.code = "UND_ERR_INFO";
    }
  }
  class a extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, a), this.name = "RequestContentLengthMismatchError", this.message = I || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }
  class u extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, u), this.name = "ResponseContentLengthMismatchError", this.message = I || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }
  class g extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, g), this.name = "ClientDestroyedError", this.message = I || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
    }
  }
  class h extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, h), this.name = "ClientClosedError", this.message = I || "The client is closed", this.code = "UND_ERR_CLOSED";
    }
  }
  class m extends t {
    constructor(I, w) {
      super(I), Error.captureStackTrace(this, m), this.name = "SocketError", this.message = I || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = w;
    }
  }
  class d extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, d), this.name = "NotSupportedError", this.message = I || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }
  class p extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, d), this.name = "MissingUpstreamError", this.message = I || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }
  class E extends Error {
    constructor(I, w, f) {
      super(I), Error.captureStackTrace(this, E), this.name = "HTTPParserError", this.code = w ? `HPE_${w}` : void 0, this.data = f ? f.toString() : void 0;
    }
  }
  class B extends t {
    constructor(I) {
      super(I), Error.captureStackTrace(this, B), this.name = "ResponseExceededMaxSizeError", this.message = I || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }
  class y extends t {
    constructor(I, w, { headers: f, data: C }) {
      super(I), Error.captureStackTrace(this, y), this.name = "RequestRetryError", this.message = I || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = w, this.data = C, this.headers = f;
    }
  }
  return Oa = {
    HTTPParserError: E,
    UndiciError: t,
    HeadersTimeoutError: r,
    HeadersOverflowError: n,
    BodyTimeoutError: s,
    RequestContentLengthMismatchError: a,
    ConnectTimeoutError: e,
    ResponseStatusCodeError: i,
    InvalidArgumentError: o,
    InvalidReturnValueError: c,
    RequestAbortedError: l,
    ClientDestroyedError: g,
    ClientClosedError: h,
    InformationalError: A,
    SocketError: m,
    NotSupportedError: d,
    ResponseContentLengthMismatchError: u,
    BalancedPoolMissingUpstreamError: p,
    ResponseExceededMaxSizeError: B,
    RequestRetryError: y
  }, Oa;
}
var Ga, Vd;
function rb() {
  if (Vd) return Ga;
  Vd = 1;
  const t = {}, e = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let r = 0; r < e.length; ++r) {
    const n = e[r], s = n.toLowerCase();
    t[n] = t[s] = s;
  }
  return Object.setPrototypeOf(t, null), Ga = {
    wellknownHeaderNames: e,
    headerNameLowerCasedRecord: t
  }, Ga;
}
var qa, Wd;
function rt() {
  if (Wd) return qa;
  Wd = 1;
  const t = bt, { kDestroyed: e, kBodyUsed: r } = Nt(), { IncomingMessage: n } = Ds, s = ln, i = iu, { InvalidArgumentError: o } = ft(), { Blob: c } = Dn, l = Qr, { stringify: A } = kQ, { headerNameLowerCasedRecord: a } = rb(), [u, g] = process.versions.node.split(".").map((F) => Number(F));
  function h() {
  }
  function m(F) {
    return F && typeof F == "object" && typeof F.pipe == "function" && typeof F.on == "function";
  }
  function d(F) {
    return c && F instanceof c || F && typeof F == "object" && (typeof F.stream == "function" || typeof F.arrayBuffer == "function") && /^(Blob|File)$/.test(F[Symbol.toStringTag]);
  }
  function p(F, ne) {
    if (F.includes("?") || F.includes("#"))
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    const de = A(ne);
    return de && (F += "?" + de), F;
  }
  function E(F) {
    if (typeof F == "string") {
      if (F = new URL(F), !/^https?:/.test(F.origin || F.protocol))
        throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return F;
    }
    if (!F || typeof F != "object")
      throw new o("Invalid URL: The URL argument must be a non-null object.");
    if (!/^https?:/.test(F.origin || F.protocol))
      throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    if (!(F instanceof URL)) {
      if (F.port != null && F.port !== "" && !Number.isFinite(parseInt(F.port)))
        throw new o("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (F.path != null && typeof F.path != "string")
        throw new o("Invalid URL path: the path must be a string or null/undefined.");
      if (F.pathname != null && typeof F.pathname != "string")
        throw new o("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (F.hostname != null && typeof F.hostname != "string")
        throw new o("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (F.origin != null && typeof F.origin != "string")
        throw new o("Invalid URL origin: the origin must be a string or null/undefined.");
      const ne = F.port != null ? F.port : F.protocol === "https:" ? 443 : 80;
      let de = F.origin != null ? F.origin : `${F.protocol}//${F.hostname}:${ne}`, ve = F.path != null ? F.path : `${F.pathname || ""}${F.search || ""}`;
      de.endsWith("/") && (de = de.substring(0, de.length - 1)), ve && !ve.startsWith("/") && (ve = `/${ve}`), F = new URL(de + ve);
    }
    return F;
  }
  function B(F) {
    if (F = E(F), F.pathname !== "/" || F.search || F.hash)
      throw new o("invalid url");
    return F;
  }
  function y(F) {
    if (F[0] === "[") {
      const de = F.indexOf("]");
      return t(de !== -1), F.substring(1, de);
    }
    const ne = F.indexOf(":");
    return ne === -1 ? F : F.substring(0, ne);
  }
  function Q(F) {
    if (!F)
      return null;
    t.strictEqual(typeof F, "string");
    const ne = y(F);
    return i.isIP(ne) ? "" : ne;
  }
  function I(F) {
    return JSON.parse(JSON.stringify(F));
  }
  function w(F) {
    return F != null && typeof F[Symbol.asyncIterator] == "function";
  }
  function f(F) {
    return F != null && (typeof F[Symbol.iterator] == "function" || typeof F[Symbol.asyncIterator] == "function");
  }
  function C(F) {
    if (F == null)
      return 0;
    if (m(F)) {
      const ne = F._readableState;
      return ne && ne.objectMode === !1 && ne.ended === !0 && Number.isFinite(ne.length) ? ne.length : null;
    } else {
      if (d(F))
        return F.size != null ? F.size : null;
      if (k(F))
        return F.byteLength;
    }
    return null;
  }
  function b(F) {
    return !F || !!(F.destroyed || F[e]);
  }
  function N(F) {
    const ne = F && F._readableState;
    return b(F) && ne && !ne.endEmitted;
  }
  function v(F, ne) {
    F == null || !m(F) || b(F) || (typeof F.destroy == "function" ? (Object.getPrototypeOf(F).constructor === n && (F.socket = null), F.destroy(ne)) : ne && process.nextTick((de, ve) => {
      de.emit("error", ve);
    }, F, ne), F.destroyed !== !0 && (F[e] = !0));
  }
  const R = /timeout=(\d+)/;
  function x(F) {
    const ne = F.toString().match(R);
    return ne ? parseInt(ne[1], 10) * 1e3 : null;
  }
  function S(F) {
    return a[F] || F.toLowerCase();
  }
  function D(F, ne = {}) {
    if (!Array.isArray(F)) return F;
    for (let de = 0; de < F.length; de += 2) {
      const ve = F[de].toString().toLowerCase();
      let Ce = ne[ve];
      Ce ? (Array.isArray(Ce) || (Ce = [Ce], ne[ve] = Ce), Ce.push(F[de + 1].toString("utf8"))) : Array.isArray(F[de + 1]) ? ne[ve] = F[de + 1].map((Qe) => Qe.toString("utf8")) : ne[ve] = F[de + 1].toString("utf8");
    }
    return "content-length" in ne && "content-disposition" in ne && (ne["content-disposition"] = Buffer.from(ne["content-disposition"]).toString("latin1")), ne;
  }
  function T(F) {
    const ne = [];
    let de = !1, ve = -1;
    for (let Ce = 0; Ce < F.length; Ce += 2) {
      const Qe = F[Ce + 0].toString(), xe = F[Ce + 1].toString("utf8");
      Qe.length === 14 && (Qe === "content-length" || Qe.toLowerCase() === "content-length") ? (ne.push(Qe, xe), de = !0) : Qe.length === 19 && (Qe === "content-disposition" || Qe.toLowerCase() === "content-disposition") ? ve = ne.push(Qe, xe) - 1 : ne.push(Qe, xe);
    }
    return de && ve !== -1 && (ne[ve] = Buffer.from(ne[ve]).toString("latin1")), ne;
  }
  function k(F) {
    return F instanceof Uint8Array || Buffer.isBuffer(F);
  }
  function L(F, ne, de) {
    if (!F || typeof F != "object")
      throw new o("handler must be an object");
    if (typeof F.onConnect != "function")
      throw new o("invalid onConnect method");
    if (typeof F.onError != "function")
      throw new o("invalid onError method");
    if (typeof F.onBodySent != "function" && F.onBodySent !== void 0)
      throw new o("invalid onBodySent method");
    if (de || ne === "CONNECT") {
      if (typeof F.onUpgrade != "function")
        throw new o("invalid onUpgrade method");
    } else {
      if (typeof F.onHeaders != "function")
        throw new o("invalid onHeaders method");
      if (typeof F.onData != "function")
        throw new o("invalid onData method");
      if (typeof F.onComplete != "function")
        throw new o("invalid onComplete method");
    }
  }
  function W(F) {
    return !!(F && (s.isDisturbed ? s.isDisturbed(F) || F[r] : F[r] || F.readableDidRead || F._readableState && F._readableState.dataEmitted || N(F)));
  }
  function O(F) {
    return !!(F && (s.isErrored ? s.isErrored(F) : /state: 'errored'/.test(
      l.inspect(F)
    )));
  }
  function _(F) {
    return !!(F && (s.isReadable ? s.isReadable(F) : /state: 'readable'/.test(
      l.inspect(F)
    )));
  }
  function M(F) {
    return {
      localAddress: F.localAddress,
      localPort: F.localPort,
      remoteAddress: F.remoteAddress,
      remotePort: F.remotePort,
      remoteFamily: F.remoteFamily,
      timeout: F.timeout,
      bytesWritten: F.bytesWritten,
      bytesRead: F.bytesRead
    };
  }
  async function* $(F) {
    for await (const ne of F)
      yield Buffer.isBuffer(ne) ? ne : Buffer.from(ne);
  }
  let U;
  function J(F) {
    if (U || (U = xn.ReadableStream), U.from)
      return U.from($(F));
    let ne;
    return new U(
      {
        async start() {
          ne = F[Symbol.asyncIterator]();
        },
        async pull(de) {
          const { done: ve, value: Ce } = await ne.next();
          if (ve)
            queueMicrotask(() => {
              de.close();
            });
          else {
            const Qe = Buffer.isBuffer(Ce) ? Ce : Buffer.from(Ce);
            de.enqueue(new Uint8Array(Qe));
          }
          return de.desiredSize > 0;
        },
        async cancel(de) {
          await ne.return();
        }
      },
      0
    );
  }
  function j(F) {
    return F && typeof F == "object" && typeof F.append == "function" && typeof F.delete == "function" && typeof F.get == "function" && typeof F.getAll == "function" && typeof F.has == "function" && typeof F.set == "function" && F[Symbol.toStringTag] === "FormData";
  }
  function te(F) {
    if (F) {
      if (typeof F.throwIfAborted == "function")
        F.throwIfAborted();
      else if (F.aborted) {
        const ne = new Error("The operation was aborted");
        throw ne.name = "AbortError", ne;
      }
    }
  }
  function ie(F, ne) {
    return "addEventListener" in F ? (F.addEventListener("abort", ne, { once: !0 }), () => F.removeEventListener("abort", ne)) : (F.addListener("abort", ne), () => F.removeListener("abort", ne));
  }
  const G = !!String.prototype.toWellFormed;
  function q(F) {
    return G ? `${F}`.toWellFormed() : l.toUSVString ? l.toUSVString(F) : `${F}`;
  }
  function Z(F) {
    if (F == null || F === "") return { start: 0, end: null, size: null };
    const ne = F ? F.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return ne ? {
      start: parseInt(ne[1]),
      end: ne[2] ? parseInt(ne[2]) : null,
      size: ne[3] ? parseInt(ne[3]) : null
    } : null;
  }
  const se = /* @__PURE__ */ Object.create(null);
  return se.enumerable = !0, qa = {
    kEnumerableProperty: se,
    nop: h,
    isDisturbed: W,
    isErrored: O,
    isReadable: _,
    toUSVString: q,
    isReadableAborted: N,
    isBlobLike: d,
    parseOrigin: B,
    parseURL: E,
    getServerName: Q,
    isStream: m,
    isIterable: f,
    isAsyncIterable: w,
    isDestroyed: b,
    headerNameToString: S,
    parseRawHeaders: T,
    parseHeaders: D,
    parseKeepAliveTimeout: x,
    destroy: v,
    bodyLength: C,
    deepClone: I,
    ReadableStreamFrom: J,
    isBuffer: k,
    validateHandler: L,
    getSocketInfo: M,
    isFormDataLike: j,
    buildURL: p,
    throwIfAborted: te,
    addAbortListener: ie,
    parseRangeHeader: Z,
    nodeMajor: u,
    nodeMinor: g,
    nodeHasAutoSelectFamily: u > 18 || u === 18 && g >= 13,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
  }, qa;
}
var Ha, jd;
function nb() {
  if (jd) return Ha;
  jd = 1;
  let t = Date.now(), e;
  const r = [];
  function n() {
    t = Date.now();
    let o = r.length, c = 0;
    for (; c < o; ) {
      const l = r[c];
      l.state === 0 ? l.state = t + l.delay : l.state > 0 && t >= l.state && (l.state = -1, l.callback(l.opaque)), l.state === -1 ? (l.state = -2, c !== o - 1 ? r[c] = r.pop() : r.pop(), o -= 1) : c += 1;
    }
    r.length > 0 && s();
  }
  function s() {
    e && e.refresh ? e.refresh() : (clearTimeout(e), e = setTimeout(n, 1e3), e.unref && e.unref());
  }
  class i {
    constructor(c, l, A) {
      this.callback = c, this.delay = l, this.opaque = A, this.state = -2, this.refresh();
    }
    refresh() {
      this.state === -2 && (r.push(this), (!e || r.length === 1) && s()), this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  return Ha = {
    setTimeout(o, c, l) {
      return c < 1e3 ? setTimeout(o, c, l) : new i(o, c, l);
    },
    clearTimeout(o) {
      o instanceof i ? o.clear() : clearTimeout(o);
    }
  }, Ha;
}
var us = { exports: {} }, za, $d;
function xf() {
  if ($d) return za;
  $d = 1;
  const t = Bf.EventEmitter, e = ks.inherits;
  function r(n) {
    if (typeof n == "string" && (n = Buffer.from(n)), !Buffer.isBuffer(n))
      throw new TypeError("The needle has to be a String or a Buffer.");
    const s = n.length;
    if (s === 0)
      throw new Error("The needle cannot be an empty String/Buffer.");
    if (s > 256)
      throw new Error("The needle cannot have a length bigger than 256.");
    this.maxMatches = 1 / 0, this.matches = 0, this._occ = new Array(256).fill(s), this._lookbehind_size = 0, this._needle = n, this._bufpos = 0, this._lookbehind = Buffer.alloc(s);
    for (var i = 0; i < s - 1; ++i)
      this._occ[n[i]] = s - 1 - i;
  }
  return e(r, t), r.prototype.reset = function() {
    this._lookbehind_size = 0, this.matches = 0, this._bufpos = 0;
  }, r.prototype.push = function(n, s) {
    Buffer.isBuffer(n) || (n = Buffer.from(n, "binary"));
    const i = n.length;
    this._bufpos = s || 0;
    let o;
    for (; o !== i && this.matches < this.maxMatches; )
      o = this._sbmh_feed(n);
    return o;
  }, r.prototype._sbmh_feed = function(n) {
    const s = n.length, i = this._needle, o = i.length, c = i[o - 1];
    let l = -this._lookbehind_size, A;
    if (l < 0) {
      for (; l < 0 && l <= s - o; ) {
        if (A = this._sbmh_lookup_char(n, l + o - 1), A === c && this._sbmh_memcmp(n, l, o - 1))
          return this._lookbehind_size = 0, ++this.matches, this.emit("info", !0), this._bufpos = l + o;
        l += this._occ[A];
      }
      if (l < 0)
        for (; l < 0 && !this._sbmh_memcmp(n, l, s - l); )
          ++l;
      if (l >= 0)
        this.emit("info", !1, this._lookbehind, 0, this._lookbehind_size), this._lookbehind_size = 0;
      else {
        const a = this._lookbehind_size + l;
        return a > 0 && this.emit("info", !1, this._lookbehind, 0, a), this._lookbehind.copy(
          this._lookbehind,
          0,
          a,
          this._lookbehind_size - a
        ), this._lookbehind_size -= a, n.copy(this._lookbehind, this._lookbehind_size), this._lookbehind_size += s, this._bufpos = s, s;
      }
    }
    if (l += (l >= 0) * this._bufpos, n.indexOf(i, l) !== -1)
      return l = n.indexOf(i, l), ++this.matches, l > 0 ? this.emit("info", !0, n, this._bufpos, l) : this.emit("info", !0), this._bufpos = l + o;
    for (l = s - o; l < s && (n[l] !== i[0] || Buffer.compare(
      n.subarray(l, l + s - l),
      i.subarray(0, s - l)
    ) !== 0); )
      ++l;
    return l < s && (n.copy(this._lookbehind, 0, l, l + (s - l)), this._lookbehind_size = s - l), l > 0 && this.emit("info", !1, n, this._bufpos, l < s ? l : s), this._bufpos = s, s;
  }, r.prototype._sbmh_lookup_char = function(n, s) {
    return s < 0 ? this._lookbehind[this._lookbehind_size + s] : n[s];
  }, r.prototype._sbmh_memcmp = function(n, s, i) {
    for (var o = 0; o < i; ++o)
      if (this._sbmh_lookup_char(n, s + o) !== this._needle[o])
        return !1;
    return !0;
  }, za = r, za;
}
var Ya, Xd;
function sb() {
  if (Xd) return Ya;
  Xd = 1;
  const t = ks.inherits, e = ra.Readable;
  function r(n) {
    e.call(this, n);
  }
  return t(r, e), r.prototype._read = function(n) {
  }, Ya = r, Ya;
}
var Ja, Kd;
function au() {
  return Kd || (Kd = 1, Ja = function(e, r, n) {
    if (!e || e[r] === void 0 || e[r] === null)
      return n;
    if (typeof e[r] != "number" || isNaN(e[r]))
      throw new TypeError("Limit " + r + " is not a valid number");
    return e[r];
  }), Ja;
}
var Va, Zd;
function ib() {
  if (Zd) return Va;
  Zd = 1;
  const t = Bf.EventEmitter, e = ks.inherits, r = au(), n = xf(), s = Buffer.from(`\r
\r
`), i = /\r\n/g, o = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function c(l) {
    t.call(this), l = l || {};
    const A = this;
    this.nread = 0, this.maxed = !1, this.npairs = 0, this.maxHeaderPairs = r(l, "maxHeaderPairs", 2e3), this.maxHeaderSize = r(l, "maxHeaderSize", 80 * 1024), this.buffer = "", this.header = {}, this.finished = !1, this.ss = new n(s), this.ss.on("info", function(a, u, g, h) {
      u && !A.maxed && (A.nread + h - g >= A.maxHeaderSize ? (h = A.maxHeaderSize - A.nread + g, A.nread = A.maxHeaderSize, A.maxed = !0) : A.nread += h - g, A.buffer += u.toString("binary", g, h)), a && A._finish();
    });
  }
  return e(c, t), c.prototype.push = function(l) {
    const A = this.ss.push(l);
    if (this.finished)
      return A;
  }, c.prototype.reset = function() {
    this.finished = !1, this.buffer = "", this.header = {}, this.ss.reset();
  }, c.prototype._finish = function() {
    this.buffer && this._parseHeader(), this.ss.matches = this.ss.maxMatches;
    const l = this.header;
    this.header = {}, this.buffer = "", this.finished = !0, this.nread = this.npairs = 0, this.maxed = !1, this.emit("header", l);
  }, c.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs)
      return;
    const l = this.buffer.split(i), A = l.length;
    let a, u;
    for (var g = 0; g < A; ++g) {
      if (l[g].length === 0)
        continue;
      if ((l[g][0] === "	" || l[g][0] === " ") && u) {
        this.header[u][this.header[u].length - 1] += l[g];
        continue;
      }
      const h = l[g].indexOf(":");
      if (h === -1 || h === 0)
        return;
      if (a = o.exec(l[g]), u = a[1].toLowerCase(), this.header[u] = this.header[u] || [], this.header[u].push(a[2] || ""), ++this.npairs === this.maxHeaderPairs)
        break;
    }
  }, Va = c, Va;
}
var Wa, eg;
function Df() {
  if (eg) return Wa;
  eg = 1;
  const t = ra.Writable, e = ks.inherits, r = xf(), n = sb(), s = ib(), i = 45, o = Buffer.from("-"), c = Buffer.from(`\r
`), l = function() {
  };
  function A(a) {
    if (!(this instanceof A))
      return new A(a);
    if (t.call(this, a), !a || !a.headerFirst && typeof a.boundary != "string")
      throw new TypeError("Boundary required");
    typeof a.boundary == "string" ? this.setBoundary(a.boundary) : this._bparser = void 0, this._headerFirst = a.headerFirst, this._dashes = 0, this._parts = 0, this._finished = !1, this._realFinish = !1, this._isPreamble = !0, this._justMatched = !1, this._firstWrite = !0, this._inHeader = !0, this._part = void 0, this._cb = void 0, this._ignoreData = !1, this._partOpts = { highWaterMark: a.partHwm }, this._pause = !1;
    const u = this;
    this._hparser = new s(a), this._hparser.on("header", function(g) {
      u._inHeader = !1, u._part.emit("header", g);
    });
  }
  return e(A, t), A.prototype.emit = function(a) {
    if (a === "finish" && !this._realFinish) {
      if (!this._finished) {
        const u = this;
        process.nextTick(function() {
          if (u.emit("error", new Error("Unexpected end of multipart data")), u._part && !u._ignoreData) {
            const g = u._isPreamble ? "Preamble" : "Part";
            u._part.emit("error", new Error(g + " terminated early due to unexpected end of multipart data")), u._part.push(null), process.nextTick(function() {
              u._realFinish = !0, u.emit("finish"), u._realFinish = !1;
            });
            return;
          }
          u._realFinish = !0, u.emit("finish"), u._realFinish = !1;
        });
      }
    } else
      t.prototype.emit.apply(this, arguments);
  }, A.prototype._write = function(a, u, g) {
    if (!this._hparser && !this._bparser)
      return g();
    if (this._headerFirst && this._isPreamble) {
      this._part || (this._part = new n(this._partOpts), this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._ignore());
      const h = this._hparser.push(a);
      if (!this._inHeader && h !== void 0 && h < a.length)
        a = a.slice(h);
      else
        return g();
    }
    this._firstWrite && (this._bparser.push(c), this._firstWrite = !1), this._bparser.push(a), this._pause ? this._cb = g : g();
  }, A.prototype.reset = function() {
    this._part = void 0, this._bparser = void 0, this._hparser = void 0;
  }, A.prototype.setBoundary = function(a) {
    const u = this;
    this._bparser = new r(`\r
--` + a), this._bparser.on("info", function(g, h, m, d) {
      u._oninfo(g, h, m, d);
    });
  }, A.prototype._ignore = function() {
    this._part && !this._ignoreData && (this._ignoreData = !0, this._part.on("error", l), this._part.resume());
  }, A.prototype._oninfo = function(a, u, g, h) {
    let m;
    const d = this;
    let p = 0, E, B = !0;
    if (!this._part && this._justMatched && u) {
      for (; this._dashes < 2 && g + p < h; )
        if (u[g + p] === i)
          ++p, ++this._dashes;
        else {
          this._dashes && (m = o), this._dashes = 0;
          break;
        }
      if (this._dashes === 2 && (g + p < h && this.listenerCount("trailer") !== 0 && this.emit("trailer", u.slice(g + p, h)), this.reset(), this._finished = !0, d._parts === 0 && (d._realFinish = !0, d.emit("finish"), d._realFinish = !1)), this._dashes)
        return;
    }
    this._justMatched && (this._justMatched = !1), this._part || (this._part = new n(this._partOpts), this._part._read = function(y) {
      d._unpause();
    }, this._isPreamble && this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._isPreamble !== !0 && this.listenerCount("part") !== 0 ? this.emit("part", this._part) : this._ignore(), this._isPreamble || (this._inHeader = !0)), u && g < h && !this._ignoreData && (this._isPreamble || !this._inHeader ? (m && (B = this._part.push(m)), B = this._part.push(u.slice(g, h)), B || (this._pause = !0)) : !this._isPreamble && this._inHeader && (m && this._hparser.push(m), E = this._hparser.push(u.slice(g, h)), !this._inHeader && E !== void 0 && E < h && this._oninfo(!1, u, g + E, h))), a && (this._hparser.reset(), this._isPreamble ? this._isPreamble = !1 : g !== h && (++this._parts, this._part.on("end", function() {
      --d._parts === 0 && (d._finished ? (d._realFinish = !0, d.emit("finish"), d._realFinish = !1) : d._unpause());
    })), this._part.push(null), this._part = void 0, this._ignoreData = !1, this._justMatched = !0, this._dashes = 0);
  }, A.prototype._unpause = function() {
    if (this._pause && (this._pause = !1, this._cb)) {
      const a = this._cb;
      this._cb = void 0, a();
    }
  }, Wa = A, Wa;
}
var ja, tg;
function Au() {
  if (tg) return ja;
  tg = 1;
  const t = new TextDecoder("utf-8"), e = /* @__PURE__ */ new Map([
    ["utf-8", t],
    ["utf8", t]
  ]);
  function r(i) {
    let o;
    for (; ; )
      switch (i) {
        case "utf-8":
        case "utf8":
          return n.utf8;
        case "latin1":
        case "ascii":
        // TODO: Make these a separate, strict decoder?
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return n.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return n.utf16le;
        case "base64":
          return n.base64;
        default:
          if (o === void 0) {
            o = !0, i = i.toLowerCase();
            continue;
          }
          return n.other.bind(i);
      }
  }
  const n = {
    utf8: (i, o) => i.length === 0 ? "" : (typeof i == "string" && (i = Buffer.from(i, o)), i.utf8Slice(0, i.length)),
    latin1: (i, o) => i.length === 0 ? "" : typeof i == "string" ? i : i.latin1Slice(0, i.length),
    utf16le: (i, o) => i.length === 0 ? "" : (typeof i == "string" && (i = Buffer.from(i, o)), i.ucs2Slice(0, i.length)),
    base64: (i, o) => i.length === 0 ? "" : (typeof i == "string" && (i = Buffer.from(i, o)), i.base64Slice(0, i.length)),
    other: (i, o) => {
      if (i.length === 0)
        return "";
      if (typeof i == "string" && (i = Buffer.from(i, o)), e.has(this.toString()))
        try {
          return e.get(this).decode(i);
        } catch {
        }
      return typeof i == "string" ? i : i.toString();
    }
  };
  function s(i, o, c) {
    return i && r(c)(i, o);
  }
  return ja = s, ja;
}
var $a, rg;
function Tf() {
  if (rg) return $a;
  rg = 1;
  const t = Au(), e = /%[a-fA-F0-9][a-fA-F0-9]/g, r = {
    "%00": "\0",
    "%01": "",
    "%02": "",
    "%03": "",
    "%04": "",
    "%05": "",
    "%06": "",
    "%07": "\x07",
    "%08": "\b",
    "%09": "	",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": "\r",
    "%0D": "\r",
    "%0e": "",
    "%0E": "",
    "%0f": "",
    "%0F": "",
    "%10": "",
    "%11": "",
    "%12": "",
    "%13": "",
    "%14": "",
    "%15": "",
    "%16": "",
    "%17": "",
    "%18": "",
    "%19": "",
    "%1a": "",
    "%1A": "",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "",
    "%1C": "",
    "%1d": "",
    "%1D": "",
    "%1e": "",
    "%1E": "",
    "%1f": "",
    "%1F": "",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "",
    "%7F": "",
    "%80": "",
    "%81": "",
    "%82": "",
    "%83": "",
    "%84": "",
    "%85": "",
    "%86": "",
    "%87": "",
    "%88": "",
    "%89": "",
    "%8a": "",
    "%8A": "",
    "%8b": "",
    "%8B": "",
    "%8c": "",
    "%8C": "",
    "%8d": "",
    "%8D": "",
    "%8e": "",
    "%8E": "",
    "%8f": "",
    "%8F": "",
    "%90": "",
    "%91": "",
    "%92": "",
    "%93": "",
    "%94": "",
    "%95": "",
    "%96": "",
    "%97": "",
    "%98": "",
    "%99": "",
    "%9a": "",
    "%9A": "",
    "%9b": "",
    "%9B": "",
    "%9c": "",
    "%9C": "",
    "%9d": "",
    "%9D": "",
    "%9e": "",
    "%9E": "",
    "%9f": "",
    "%9F": "",
    "%a0": "",
    "%A0": "",
    "%a1": "",
    "%A1": "",
    "%a2": "",
    "%A2": "",
    "%a3": "",
    "%A3": "",
    "%a4": "",
    "%A4": "",
    "%a5": "",
    "%A5": "",
    "%a6": "",
    "%A6": "",
    "%a7": "",
    "%A7": "",
    "%a8": "",
    "%A8": "",
    "%a9": "",
    "%A9": "",
    "%aa": "",
    "%Aa": "",
    "%aA": "",
    "%AA": "",
    "%ab": "",
    "%Ab": "",
    "%aB": "",
    "%AB": "",
    "%ac": "",
    "%Ac": "",
    "%aC": "",
    "%AC": "",
    "%ad": "",
    "%Ad": "",
    "%aD": "",
    "%AD": "",
    "%ae": "",
    "%Ae": "",
    "%aE": "",
    "%AE": "",
    "%af": "",
    "%Af": "",
    "%aF": "",
    "%AF": "",
    "%b0": "",
    "%B0": "",
    "%b1": "",
    "%B1": "",
    "%b2": "",
    "%B2": "",
    "%b3": "",
    "%B3": "",
    "%b4": "",
    "%B4": "",
    "%b5": "",
    "%B5": "",
    "%b6": "",
    "%B6": "",
    "%b7": "",
    "%B7": "",
    "%b8": "",
    "%B8": "",
    "%b9": "",
    "%B9": "",
    "%ba": "",
    "%Ba": "",
    "%bA": "",
    "%BA": "",
    "%bb": "",
    "%Bb": "",
    "%bB": "",
    "%BB": "",
    "%bc": "",
    "%Bc": "",
    "%bC": "",
    "%BC": "",
    "%bd": "",
    "%Bd": "",
    "%bD": "",
    "%BD": "",
    "%be": "",
    "%Be": "",
    "%bE": "",
    "%BE": "",
    "%bf": "",
    "%Bf": "",
    "%bF": "",
    "%BF": "",
    "%c0": "",
    "%C0": "",
    "%c1": "",
    "%C1": "",
    "%c2": "",
    "%C2": "",
    "%c3": "",
    "%C3": "",
    "%c4": "",
    "%C4": "",
    "%c5": "",
    "%C5": "",
    "%c6": "",
    "%C6": "",
    "%c7": "",
    "%C7": "",
    "%c8": "",
    "%C8": "",
    "%c9": "",
    "%C9": "",
    "%ca": "",
    "%Ca": "",
    "%cA": "",
    "%CA": "",
    "%cb": "",
    "%Cb": "",
    "%cB": "",
    "%CB": "",
    "%cc": "",
    "%Cc": "",
    "%cC": "",
    "%CC": "",
    "%cd": "",
    "%Cd": "",
    "%cD": "",
    "%CD": "",
    "%ce": "",
    "%Ce": "",
    "%cE": "",
    "%CE": "",
    "%cf": "",
    "%Cf": "",
    "%cF": "",
    "%CF": "",
    "%d0": "",
    "%D0": "",
    "%d1": "",
    "%D1": "",
    "%d2": "",
    "%D2": "",
    "%d3": "",
    "%D3": "",
    "%d4": "",
    "%D4": "",
    "%d5": "",
    "%D5": "",
    "%d6": "",
    "%D6": "",
    "%d7": "",
    "%D7": "",
    "%d8": "",
    "%D8": "",
    "%d9": "",
    "%D9": "",
    "%da": "",
    "%Da": "",
    "%dA": "",
    "%DA": "",
    "%db": "",
    "%Db": "",
    "%dB": "",
    "%DB": "",
    "%dc": "",
    "%Dc": "",
    "%dC": "",
    "%DC": "",
    "%dd": "",
    "%Dd": "",
    "%dD": "",
    "%DD": "",
    "%de": "",
    "%De": "",
    "%dE": "",
    "%DE": "",
    "%df": "",
    "%Df": "",
    "%dF": "",
    "%DF": "",
    "%e0": "",
    "%E0": "",
    "%e1": "",
    "%E1": "",
    "%e2": "",
    "%E2": "",
    "%e3": "",
    "%E3": "",
    "%e4": "",
    "%E4": "",
    "%e5": "",
    "%E5": "",
    "%e6": "",
    "%E6": "",
    "%e7": "",
    "%E7": "",
    "%e8": "",
    "%E8": "",
    "%e9": "",
    "%E9": "",
    "%ea": "",
    "%Ea": "",
    "%eA": "",
    "%EA": "",
    "%eb": "",
    "%Eb": "",
    "%eB": "",
    "%EB": "",
    "%ec": "",
    "%Ec": "",
    "%eC": "",
    "%EC": "",
    "%ed": "",
    "%Ed": "",
    "%eD": "",
    "%ED": "",
    "%ee": "",
    "%Ee": "",
    "%eE": "",
    "%EE": "",
    "%ef": "",
    "%Ef": "",
    "%eF": "",
    "%EF": "",
    "%f0": "",
    "%F0": "",
    "%f1": "",
    "%F1": "",
    "%f2": "",
    "%F2": "",
    "%f3": "",
    "%F3": "",
    "%f4": "",
    "%F4": "",
    "%f5": "",
    "%F5": "",
    "%f6": "",
    "%F6": "",
    "%f7": "",
    "%F7": "",
    "%f8": "",
    "%F8": "",
    "%f9": "",
    "%F9": "",
    "%fa": "",
    "%Fa": "",
    "%fA": "",
    "%FA": "",
    "%fb": "",
    "%Fb": "",
    "%fB": "",
    "%FB": "",
    "%fc": "",
    "%Fc": "",
    "%fC": "",
    "%FC": "",
    "%fd": "",
    "%Fd": "",
    "%fD": "",
    "%FD": "",
    "%fe": "",
    "%Fe": "",
    "%fE": "",
    "%FE": "",
    "%ff": "",
    "%Ff": "",
    "%fF": "",
    "%FF": ""
  };
  function n(A) {
    return r[A];
  }
  const s = 0, i = 1, o = 2, c = 3;
  function l(A) {
    const a = [];
    let u = s, g = "", h = !1, m = !1, d = 0, p = "";
    const E = A.length;
    for (var B = 0; B < E; ++B) {
      const y = A[B];
      if (y === "\\" && h)
        if (m)
          m = !1;
        else {
          m = !0;
          continue;
        }
      else if (y === '"')
        if (m)
          m = !1;
        else {
          h ? (h = !1, u = s) : h = !0;
          continue;
        }
      else if (m && h && (p += "\\"), m = !1, (u === o || u === c) && y === "'") {
        u === o ? (u = c, g = p.substring(1)) : u = i, p = "";
        continue;
      } else if (u === s && (y === "*" || y === "=") && a.length) {
        u = y === "*" ? o : i, a[d] = [p, void 0], p = "";
        continue;
      } else if (!h && y === ";") {
        u = s, g ? (p.length && (p = t(
          p.replace(e, n),
          "binary",
          g
        )), g = "") : p.length && (p = t(p, "binary", "utf8")), a[d] === void 0 ? a[d] = p : a[d][1] = p, p = "", ++d;
        continue;
      } else if (!h && (y === " " || y === "	"))
        continue;
      p += y;
    }
    return g && p.length ? p = t(
      p.replace(e, n),
      "binary",
      g
    ) : p && (p = t(p, "binary", "utf8")), a[d] === void 0 ? p && (a[d] = p) : a[d][1] = p, a;
  }
  return $a = l, $a;
}
var Xa, ng;
function ob() {
  return ng || (ng = 1, Xa = function(e) {
    if (typeof e != "string")
      return "";
    for (var r = e.length - 1; r >= 0; --r)
      switch (e.charCodeAt(r)) {
        case 47:
        // '/'
        case 92:
          return e = e.slice(r + 1), e === ".." || e === "." ? "" : e;
      }
    return e === ".." || e === "." ? "" : e;
  }), Xa;
}
var Ka, sg;
function ab() {
  if (sg) return Ka;
  sg = 1;
  const { Readable: t } = ra, { inherits: e } = ks, r = Df(), n = Tf(), s = Au(), i = ob(), o = au(), c = /^boundary$/i, l = /^form-data$/i, A = /^charset$/i, a = /^filename$/i, u = /^name$/i;
  g.detect = /^multipart\/form-data/i;
  function g(d, p) {
    let E, B;
    const y = this;
    let Q;
    const I = p.limits, w = p.isPartAFile || ((j, te, ie) => te === "application/octet-stream" || ie !== void 0), f = p.parsedConType || [], C = p.defCharset || "utf8", b = p.preservePath, N = { highWaterMark: p.fileHwm };
    for (E = 0, B = f.length; E < B; ++E)
      if (Array.isArray(f[E]) && c.test(f[E][0])) {
        Q = f[E][1];
        break;
      }
    function v() {
      _ === 0 && U && !d._done && (U = !1, y.end());
    }
    if (typeof Q != "string")
      throw new Error("Multipart: Boundary not found");
    const R = o(I, "fieldSize", 1 * 1024 * 1024), x = o(I, "fileSize", 1 / 0), S = o(I, "files", 1 / 0), D = o(I, "fields", 1 / 0), T = o(I, "parts", 1 / 0), k = o(I, "headerPairs", 2e3), L = o(I, "headerSize", 80 * 1024);
    let W = 0, O = 0, _ = 0, M, $, U = !1;
    this._needDrain = !1, this._pause = !1, this._cb = void 0, this._nparts = 0, this._boy = d;
    const J = {
      boundary: Q,
      maxHeaderPairs: k,
      maxHeaderSize: L,
      partHwm: N.highWaterMark,
      highWaterMark: p.highWaterMark
    };
    this.parser = new r(J), this.parser.on("drain", function() {
      if (y._needDrain = !1, y._cb && !y._pause) {
        const j = y._cb;
        y._cb = void 0, j();
      }
    }).on("part", function j(te) {
      if (++y._nparts > T)
        return y.parser.removeListener("part", j), y.parser.on("part", h), d.hitPartsLimit = !0, d.emit("partsLimit"), h(te);
      if ($) {
        const ie = $;
        ie.emit("end"), ie.removeAllListeners("end");
      }
      te.on("header", function(ie) {
        let G, q, Z, se, F, ne, de = 0;
        if (ie["content-type"] && (Z = n(ie["content-type"][0]), Z[0])) {
          for (G = Z[0].toLowerCase(), E = 0, B = Z.length; E < B; ++E)
            if (A.test(Z[E][0])) {
              se = Z[E][1].toLowerCase();
              break;
            }
        }
        if (G === void 0 && (G = "text/plain"), se === void 0 && (se = C), ie["content-disposition"]) {
          if (Z = n(ie["content-disposition"][0]), !l.test(Z[0]))
            return h(te);
          for (E = 0, B = Z.length; E < B; ++E)
            u.test(Z[E][0]) ? q = Z[E][1] : a.test(Z[E][0]) && (ne = Z[E][1], b || (ne = i(ne)));
        } else
          return h(te);
        ie["content-transfer-encoding"] ? F = ie["content-transfer-encoding"][0].toLowerCase() : F = "7bit";
        let ve, Ce;
        if (w(q, G, ne)) {
          if (W === S)
            return d.hitFilesLimit || (d.hitFilesLimit = !0, d.emit("filesLimit")), h(te);
          if (++W, d.listenerCount("file") === 0) {
            y.parser._ignore();
            return;
          }
          ++_;
          const Qe = new m(N);
          M = Qe, Qe.on("end", function() {
            if (--_, y._pause = !1, v(), y._cb && !y._needDrain) {
              const xe = y._cb;
              y._cb = void 0, xe();
            }
          }), Qe._read = function(xe) {
            if (y._pause && (y._pause = !1, y._cb && !y._needDrain)) {
              const _e = y._cb;
              y._cb = void 0, _e();
            }
          }, d.emit("file", q, Qe, ne, F, G), ve = function(xe) {
            if ((de += xe.length) > x) {
              const _e = x - de + xe.length;
              _e > 0 && Qe.push(xe.slice(0, _e)), Qe.truncated = !0, Qe.bytesRead = x, te.removeAllListeners("data"), Qe.emit("limit");
              return;
            } else Qe.push(xe) || (y._pause = !0);
            Qe.bytesRead = de;
          }, Ce = function() {
            M = void 0, Qe.push(null);
          };
        } else {
          if (O === D)
            return d.hitFieldsLimit || (d.hitFieldsLimit = !0, d.emit("fieldsLimit")), h(te);
          ++O, ++_;
          let Qe = "", xe = !1;
          $ = te, ve = function(_e) {
            if ((de += _e.length) > R) {
              const Et = R - (de - _e.length);
              Qe += _e.toString("binary", 0, Et), xe = !0, te.removeAllListeners("data");
            } else
              Qe += _e.toString("binary");
          }, Ce = function() {
            $ = void 0, Qe.length && (Qe = s(Qe, "binary", se)), d.emit("field", q, Qe, !1, xe, F, G), --_, v();
          };
        }
        te._readableState.sync = !1, te.on("data", ve), te.on("end", Ce);
      }).on("error", function(ie) {
        M && M.emit("error", ie);
      });
    }).on("error", function(j) {
      d.emit("error", j);
    }).on("finish", function() {
      U = !0, v();
    });
  }
  g.prototype.write = function(d, p) {
    const E = this.parser.write(d);
    E && !this._pause ? p() : (this._needDrain = !E, this._cb = p);
  }, g.prototype.end = function() {
    const d = this;
    d.parser.writable ? d.parser.end() : d._boy._done || process.nextTick(function() {
      d._boy._done = !0, d._boy.emit("finish");
    });
  };
  function h(d) {
    d.resume();
  }
  function m(d) {
    t.call(this, d), this.bytesRead = 0, this.truncated = !1;
  }
  return e(m, t), m.prototype._read = function(d) {
  }, Ka = g, Ka;
}
var Za, ig;
function Ab() {
  if (ig) return Za;
  ig = 1;
  const t = /\+/g, e = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function r() {
    this.buffer = void 0;
  }
  return r.prototype.write = function(n) {
    n = n.replace(t, " ");
    let s = "", i = 0, o = 0;
    const c = n.length;
    for (; i < c; ++i)
      this.buffer !== void 0 ? e[n.charCodeAt(i)] ? (this.buffer += n[i], ++o, this.buffer.length === 2 && (s += String.fromCharCode(parseInt(this.buffer, 16)), this.buffer = void 0)) : (s += "%" + this.buffer, this.buffer = void 0, --i) : n[i] === "%" && (i > o && (s += n.substring(o, i), o = i), this.buffer = "", ++o);
    return o < c && this.buffer === void 0 && (s += n.substring(o)), s;
  }, r.prototype.reset = function() {
    this.buffer = void 0;
  }, Za = r, Za;
}
var eA, og;
function cb() {
  if (og) return eA;
  og = 1;
  const t = Ab(), e = Au(), r = au(), n = /^charset$/i;
  s.detect = /^application\/x-www-form-urlencoded/i;
  function s(i, o) {
    const c = o.limits, l = o.parsedConType;
    this.boy = i, this.fieldSizeLimit = r(c, "fieldSize", 1 * 1024 * 1024), this.fieldNameSizeLimit = r(c, "fieldNameSize", 100), this.fieldsLimit = r(c, "fields", 1 / 0);
    let A;
    for (var a = 0, u = l.length; a < u; ++a)
      if (Array.isArray(l[a]) && n.test(l[a][0])) {
        A = l[a][1].toLowerCase();
        break;
      }
    A === void 0 && (A = o.defCharset || "utf8"), this.decoder = new t(), this.charset = A, this._fields = 0, this._state = "key", this._checkingBytes = !0, this._bytesKey = 0, this._bytesVal = 0, this._key = "", this._val = "", this._keyTrunc = !1, this._valTrunc = !1, this._hitLimit = !1;
  }
  return s.prototype.write = function(i, o) {
    if (this._fields === this.fieldsLimit)
      return this.boy.hitFieldsLimit || (this.boy.hitFieldsLimit = !0, this.boy.emit("fieldsLimit")), o();
    let c, l, A, a = 0;
    const u = i.length;
    for (; a < u; )
      if (this._state === "key") {
        for (c = l = void 0, A = a; A < u; ++A) {
          if (this._checkingBytes || ++a, i[A] === 61) {
            c = A;
            break;
          } else if (i[A] === 38) {
            l = A;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = !0;
            break;
          } else this._checkingBytes && ++this._bytesKey;
        }
        if (c !== void 0)
          c > a && (this._key += this.decoder.write(i.toString("binary", a, c))), this._state = "val", this._hitLimit = !1, this._checkingBytes = !0, this._val = "", this._bytesVal = 0, this._valTrunc = !1, this.decoder.reset(), a = c + 1;
        else if (l !== void 0) {
          ++this._fields;
          let g;
          const h = this._keyTrunc;
          if (l > a ? g = this._key += this.decoder.write(i.toString("binary", a, l)) : g = this._key, this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), g.length && this.boy.emit(
            "field",
            e(g, "binary", this.charset),
            "",
            h,
            !1
          ), a = l + 1, this._fields === this.fieldsLimit)
            return o();
        } else this._hitLimit ? (A > a && (this._key += this.decoder.write(i.toString("binary", a, A))), a = A, (this._bytesKey = this._key.length) === this.fieldNameSizeLimit && (this._checkingBytes = !1, this._keyTrunc = !0)) : (a < u && (this._key += this.decoder.write(i.toString("binary", a))), a = u);
      } else {
        for (l = void 0, A = a; A < u; ++A) {
          if (this._checkingBytes || ++a, i[A] === 38) {
            l = A;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = !0;
            break;
          } else this._checkingBytes && ++this._bytesVal;
        }
        if (l !== void 0) {
          if (++this._fields, l > a && (this._val += this.decoder.write(i.toString("binary", a, l))), this.boy.emit(
            "field",
            e(this._key, "binary", this.charset),
            e(this._val, "binary", this.charset),
            this._keyTrunc,
            this._valTrunc
          ), this._state = "key", this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), a = l + 1, this._fields === this.fieldsLimit)
            return o();
        } else this._hitLimit ? (A > a && (this._val += this.decoder.write(i.toString("binary", a, A))), a = A, (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) && (this._checkingBytes = !1, this._valTrunc = !0)) : (a < u && (this._val += this.decoder.write(i.toString("binary", a))), a = u);
      }
    o();
  }, s.prototype.end = function() {
    this.boy._done || (this._state === "key" && this._key.length > 0 ? this.boy.emit(
      "field",
      e(this._key, "binary", this.charset),
      "",
      this._keyTrunc,
      !1
    ) : this._state === "val" && this.boy.emit(
      "field",
      e(this._key, "binary", this.charset),
      e(this._val, "binary", this.charset),
      this._keyTrunc,
      this._valTrunc
    ), this.boy._done = !0, this.boy.emit("finish"));
  }, eA = s, eA;
}
var ag;
function lb() {
  if (ag) return us.exports;
  ag = 1;
  const t = ra.Writable, { inherits: e } = ks, r = Df(), n = ab(), s = cb(), i = Tf();
  function o(c) {
    if (!(this instanceof o))
      return new o(c);
    if (typeof c != "object")
      throw new TypeError("Busboy expected an options-Object.");
    if (typeof c.headers != "object")
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    if (typeof c.headers["content-type"] != "string")
      throw new TypeError("Missing Content-Type-header.");
    const {
      headers: l,
      ...A
    } = c;
    this.opts = {
      autoDestroy: !1,
      ...A
    }, t.call(this, this.opts), this._done = !1, this._parser = this.getParserByHeaders(l), this._finished = !1;
  }
  return e(o, t), o.prototype.emit = function(c) {
    if (c === "finish") {
      if (this._done) {
        if (this._finished)
          return;
      } else {
        this._parser?.end();
        return;
      }
      this._finished = !0;
    }
    t.prototype.emit.apply(this, arguments);
  }, o.prototype.getParserByHeaders = function(c) {
    const l = i(c["content-type"]), A = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers: c,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: l,
      preservePath: this.opts.preservePath
    };
    if (n.detect.test(l[0]))
      return new n(this, A);
    if (s.detect.test(l[0]))
      return new s(this, A);
    throw new Error("Unsupported Content-Type.");
  }, o.prototype._write = function(c, l, A) {
    this._parser.write(c, A);
  }, us.exports = o, us.exports.default = o, us.exports.Busboy = o, us.exports.Dicer = r, us.exports;
}
var tA, Ag;
function ns() {
  if (Ag) return tA;
  Ag = 1;
  const { MessageChannel: t, receiveMessageOnPort: e } = If, r = ["GET", "HEAD", "POST"], n = new Set(r), s = [101, 204, 205, 304], i = [301, 302, 303, 307, 308], o = new Set(i), c = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ], l = new Set(c), A = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ], a = new Set(A), u = ["follow", "manual", "error"], g = ["GET", "HEAD", "OPTIONS", "TRACE"], h = new Set(g), m = ["navigate", "same-origin", "no-cors", "cors"], d = ["omit", "same-origin", "include"], p = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ], E = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    // See https://github.com/nodejs/undici/issues/2021
    // 'Content-Length' is a forbidden header name, which is typically
    // removed in the Headers implementation. However, undici doesn't
    // filter out headers, so we add it here.
    "content-length"
  ], B = [
    "half"
  ], y = ["CONNECT", "TRACE", "TRACK"], Q = new Set(y), I = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ], w = new Set(I), f = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (N) {
      return Object.getPrototypeOf(N).constructor;
    }
  })();
  let C;
  const b = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
  // structuredClone was added in v17.0.0, but fetch supports v16.8
  function(v, R = void 0) {
    if (arguments.length === 0)
      throw new TypeError("missing argument");
    return C || (C = new t()), C.port1.unref(), C.port2.unref(), C.port1.postMessage(v, R?.transfer), e(C.port2).message;
  };
  return tA = {
    DOMException: f,
    structuredClone: b,
    subresource: I,
    forbiddenMethods: y,
    requestBodyHeader: E,
    referrerPolicy: A,
    requestRedirect: u,
    requestMode: m,
    requestCredentials: d,
    requestCache: p,
    redirectStatus: i,
    corsSafeListedMethods: r,
    nullBodyStatus: s,
    safeMethods: g,
    badPorts: c,
    requestDuplex: B,
    subresourceSet: w,
    badPortsSet: l,
    redirectStatusSet: o,
    corsSafeListedMethodsSet: n,
    safeMethodsSet: h,
    forbiddenMethodsSet: Q,
    referrerPolicySet: a
  }, tA;
}
var rA, cg;
function ji() {
  if (cg) return rA;
  cg = 1;
  const t = Symbol.for("undici.globalOrigin.1");
  function e() {
    return globalThis[t];
  }
  function r(n) {
    if (n === void 0) {
      Object.defineProperty(globalThis, t, {
        value: void 0,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
      return;
    }
    const s = new URL(n);
    if (s.protocol !== "http:" && s.protocol !== "https:")
      throw new TypeError(`Only http & https urls are allowed, received ${s.protocol}`);
    Object.defineProperty(globalThis, t, {
      value: s,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  return rA = {
    getGlobalOrigin: e,
    setGlobalOrigin: r
  }, rA;
}
var nA, lg;
function en() {
  if (lg) return nA;
  lg = 1;
  const { redirectStatusSet: t, referrerPolicySet: e, badPortsSet: r } = ns(), { getGlobalOrigin: n } = ji(), { performance: s } = FQ, { isBlobLike: i, toUSVString: o, ReadableStreamFrom: c } = rt(), l = bt, { isUint8Array: A } = yf;
  let a = [], u;
  try {
    u = require("crypto");
    const K = ["sha256", "sha384", "sha512"];
    a = u.getHashes().filter((ce) => K.includes(ce));
  } catch {
  }
  function g(K) {
    const ce = K.urlList, Ee = ce.length;
    return Ee === 0 ? null : ce[Ee - 1].toString();
  }
  function h(K, ce) {
    if (!t.has(K.status))
      return null;
    let Ee = K.headersList.get("location");
    return Ee !== null && I(Ee) && (Ee = new URL(Ee, g(K))), Ee && !Ee.hash && (Ee.hash = ce), Ee;
  }
  function m(K) {
    return K.urlList[K.urlList.length - 1];
  }
  function d(K) {
    const ce = m(K);
    return Er(ce) && r.has(ce.port) ? "blocked" : "allowed";
  }
  function p(K) {
    return K instanceof Error || K?.constructor?.name === "Error" || K?.constructor?.name === "DOMException";
  }
  function E(K) {
    for (let ce = 0; ce < K.length; ++ce) {
      const Ee = K.charCodeAt(ce);
      if (!(Ee === 9 || // HTAB
      Ee >= 32 && Ee <= 126 || // SP / VCHAR
      Ee >= 128 && Ee <= 255))
        return !1;
    }
    return !0;
  }
  function B(K) {
    switch (K) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return K >= 33 && K <= 126;
    }
  }
  function y(K) {
    if (K.length === 0)
      return !1;
    for (let ce = 0; ce < K.length; ++ce)
      if (!B(K.charCodeAt(ce)))
        return !1;
    return !0;
  }
  function Q(K) {
    return y(K);
  }
  function I(K) {
    return !(K.startsWith("	") || K.startsWith(" ") || K.endsWith("	") || K.endsWith(" ") || K.includes("\0") || K.includes("\r") || K.includes(`
`));
  }
  function w(K, ce) {
    const { headersList: Ee } = ce, Ue = (Ee.get("referrer-policy") ?? "").split(",");
    let $e = "";
    if (Ue.length > 0)
      for (let Ct = Ue.length; Ct !== 0; Ct--) {
        const St = Ue[Ct - 1].trim();
        if (e.has(St)) {
          $e = St;
          break;
        }
      }
    $e !== "" && (K.referrerPolicy = $e);
  }
  function f() {
    return "allowed";
  }
  function C() {
    return "success";
  }
  function b() {
    return "success";
  }
  function N(K) {
    let ce = null;
    ce = K.mode, K.headersList.set("sec-fetch-mode", ce);
  }
  function v(K) {
    let ce = K.origin;
    if (K.responseTainting === "cors" || K.mode === "websocket")
      ce && K.headersList.append("origin", ce);
    else if (K.method !== "GET" && K.method !== "HEAD") {
      switch (K.referrerPolicy) {
        case "no-referrer":
          ce = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          K.origin && pt(K.origin) && !pt(m(K)) && (ce = null);
          break;
        case "same-origin":
          j(K, m(K)) || (ce = null);
          break;
      }
      ce && K.headersList.append("origin", ce);
    }
  }
  function R(K) {
    return s.now();
  }
  function x(K) {
    return {
      startTime: K.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: K.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function S() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function D(K) {
    return {
      referrerPolicy: K.referrerPolicy
    };
  }
  function T(K) {
    const ce = K.referrerPolicy;
    l(ce);
    let Ee = null;
    if (K.referrer === "client") {
      const Vt = n();
      if (!Vt || Vt.origin === "null")
        return "no-referrer";
      Ee = new URL(Vt);
    } else K.referrer instanceof URL && (Ee = K.referrer);
    let Ue = k(Ee);
    const $e = k(Ee, !0);
    Ue.toString().length > 4096 && (Ue = $e);
    const Ct = j(K, Ue), St = L(Ue) && !L(K.url);
    switch (ce) {
      case "origin":
        return $e ?? k(Ee, !0);
      case "unsafe-url":
        return Ue;
      case "same-origin":
        return Ct ? $e : "no-referrer";
      case "origin-when-cross-origin":
        return Ct ? Ue : $e;
      case "strict-origin-when-cross-origin": {
        const Vt = m(K);
        return j(Ue, Vt) ? Ue : L(Ue) && !L(Vt) ? "no-referrer" : $e;
      }
      case "strict-origin":
      // eslint-disable-line
      /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * requests current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
      case "no-referrer-when-downgrade":
      // eslint-disable-line
      /**
       * 1. If referrerURL is a potentially trustworthy URL and
       * requests current URL is not a potentially trustworthy URL,
       * then return no referrer.
       * 2. Return referrerOrigin
      */
      default:
        return St ? "no-referrer" : $e;
    }
  }
  function k(K, ce) {
    return l(K instanceof URL), K.protocol === "file:" || K.protocol === "about:" || K.protocol === "blank:" ? "no-referrer" : (K.username = "", K.password = "", K.hash = "", ce && (K.pathname = "", K.search = ""), K);
  }
  function L(K) {
    if (!(K instanceof URL))
      return !1;
    if (K.href === "about:blank" || K.href === "about:srcdoc" || K.protocol === "data:" || K.protocol === "file:") return !0;
    return ce(K.origin);
    function ce(Ee) {
      if (Ee == null || Ee === "null") return !1;
      const Ue = new URL(Ee);
      return !!(Ue.protocol === "https:" || Ue.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(Ue.hostname) || Ue.hostname === "localhost" || Ue.hostname.includes("localhost.") || Ue.hostname.endsWith(".localhost"));
    }
  }
  function W(K, ce) {
    if (u === void 0)
      return !0;
    const Ee = _(ce);
    if (Ee === "no metadata" || Ee.length === 0)
      return !0;
    const Ue = M(Ee), $e = $(Ee, Ue);
    for (const Ct of $e) {
      const St = Ct.algo, Vt = Ct.hash;
      let P = u.createHash(St).update(K).digest("base64");
      if (P[P.length - 1] === "=" && (P[P.length - 2] === "=" ? P = P.slice(0, -2) : P = P.slice(0, -1)), U(P, Vt))
        return !0;
    }
    return !1;
  }
  const O = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function _(K) {
    const ce = [];
    let Ee = !0;
    for (const Ue of K.split(" ")) {
      Ee = !1;
      const $e = O.exec(Ue);
      if ($e === null || $e.groups === void 0 || $e.groups.algo === void 0)
        continue;
      const Ct = $e.groups.algo.toLowerCase();
      a.includes(Ct) && ce.push($e.groups);
    }
    return Ee === !0 ? "no metadata" : ce;
  }
  function M(K) {
    let ce = K[0].algo;
    if (ce[3] === "5")
      return ce;
    for (let Ee = 1; Ee < K.length; ++Ee) {
      const Ue = K[Ee];
      if (Ue.algo[3] === "5") {
        ce = "sha512";
        break;
      } else {
        if (ce[3] === "3")
          continue;
        Ue.algo[3] === "3" && (ce = "sha384");
      }
    }
    return ce;
  }
  function $(K, ce) {
    if (K.length === 1)
      return K;
    let Ee = 0;
    for (let Ue = 0; Ue < K.length; ++Ue)
      K[Ue].algo === ce && (K[Ee++] = K[Ue]);
    return K.length = Ee, K;
  }
  function U(K, ce) {
    if (K.length !== ce.length)
      return !1;
    for (let Ee = 0; Ee < K.length; ++Ee)
      if (K[Ee] !== ce[Ee]) {
        if (K[Ee] === "+" && ce[Ee] === "-" || K[Ee] === "/" && ce[Ee] === "_")
          continue;
        return !1;
      }
    return !0;
  }
  function J(K) {
  }
  function j(K, ce) {
    return K.origin === ce.origin && K.origin === "null" || K.protocol === ce.protocol && K.hostname === ce.hostname && K.port === ce.port;
  }
  function te() {
    let K, ce;
    return { promise: new Promise((Ue, $e) => {
      K = Ue, ce = $e;
    }), resolve: K, reject: ce };
  }
  function ie(K) {
    return K.controller.state === "aborted";
  }
  function G(K) {
    return K.controller.state === "aborted" || K.controller.state === "terminated";
  }
  const q = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(q, null);
  function Z(K) {
    return q[K.toLowerCase()] ?? K;
  }
  function se(K) {
    const ce = JSON.stringify(K);
    if (ce === void 0)
      throw new TypeError("Value is not JSON serializable");
    return l(typeof ce == "string"), ce;
  }
  const F = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function ne(K, ce, Ee) {
    const Ue = {
      index: 0,
      kind: Ee,
      target: K
    }, $e = {
      next() {
        if (Object.getPrototypeOf(this) !== $e)
          throw new TypeError(
            `'next' called on an object that does not implement interface ${ce} Iterator.`
          );
        const { index: Ct, kind: St, target: Vt } = Ue, P = Vt(), z = P.length;
        if (Ct >= z)
          return { value: void 0, done: !0 };
        const X = P[Ct];
        return Ue.index = Ct + 1, de(X, St);
      },
      // The class string of an iterator prototype object for a given interface is the
      // result of concatenating the identifier of the interface and the string " Iterator".
      [Symbol.toStringTag]: `${ce} Iterator`
    };
    return Object.setPrototypeOf($e, F), Object.setPrototypeOf({}, $e);
  }
  function de(K, ce) {
    let Ee;
    switch (ce) {
      case "key": {
        Ee = K[0];
        break;
      }
      case "value": {
        Ee = K[1];
        break;
      }
      case "key+value": {
        Ee = K;
        break;
      }
    }
    return { value: Ee, done: !1 };
  }
  async function ve(K, ce, Ee) {
    const Ue = ce, $e = Ee;
    let Ct;
    try {
      Ct = K.stream.getReader();
    } catch (St) {
      $e(St);
      return;
    }
    try {
      const St = await je(Ct);
      Ue(St);
    } catch (St) {
      $e(St);
    }
  }
  let Ce = globalThis.ReadableStream;
  function Qe(K) {
    return Ce || (Ce = xn.ReadableStream), K instanceof Ce || K[Symbol.toStringTag] === "ReadableStream" && typeof K.tee == "function";
  }
  const xe = 65535;
  function _e(K) {
    return K.length < xe ? String.fromCharCode(...K) : K.reduce((ce, Ee) => ce + String.fromCharCode(Ee), "");
  }
  function Et(K) {
    try {
      K.close();
    } catch (ce) {
      if (!ce.message.includes("Controller is already closed"))
        throw ce;
    }
  }
  function Jt(K) {
    for (let ce = 0; ce < K.length; ce++)
      l(K.charCodeAt(ce) <= 255);
    return K;
  }
  async function je(K) {
    const ce = [];
    let Ee = 0;
    for (; ; ) {
      const { done: Ue, value: $e } = await K.read();
      if (Ue)
        return Buffer.concat(ce, Ee);
      if (!A($e))
        throw new TypeError("Received non-Uint8Array chunk");
      ce.push($e), Ee += $e.length;
    }
  }
  function st(K) {
    l("protocol" in K);
    const ce = K.protocol;
    return ce === "about:" || ce === "blob:" || ce === "data:";
  }
  function pt(K) {
    return typeof K == "string" ? K.startsWith("https:") : K.protocol === "https:";
  }
  function Er(K) {
    l("protocol" in K);
    const ce = K.protocol;
    return ce === "http:" || ce === "https:";
  }
  const Ot = Object.hasOwn || ((K, ce) => Object.prototype.hasOwnProperty.call(K, ce));
  return nA = {
    isAborted: ie,
    isCancelled: G,
    createDeferredPromise: te,
    ReadableStreamFrom: c,
    toUSVString: o,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: J,
    coarsenedSharedCurrentTime: R,
    determineRequestsReferrer: T,
    makePolicyContainer: S,
    clonePolicyContainer: D,
    appendFetchMetadata: N,
    appendRequestOriginHeader: v,
    TAOCheck: b,
    corsCheck: C,
    crossOriginResourcePolicyCheck: f,
    createOpaqueTimingInfo: x,
    setRequestReferrerPolicyOnRedirect: w,
    isValidHTTPToken: y,
    requestBadPort: d,
    requestCurrentURL: m,
    responseURL: g,
    responseLocationURL: h,
    isBlobLike: i,
    isURLPotentiallyTrustworthy: L,
    isValidReasonPhrase: E,
    sameOrigin: j,
    normalizeMethod: Z,
    serializeJavascriptValueToJSONString: se,
    makeIterator: ne,
    isValidHeaderName: Q,
    isValidHeaderValue: I,
    hasOwn: Ot,
    isErrorLike: p,
    fullyReadBody: ve,
    bytesMatch: W,
    isReadableStreamLike: Qe,
    readableStreamClose: Et,
    isomorphicEncode: Jt,
    isomorphicDecode: _e,
    urlIsLocal: st,
    urlHasHttpsScheme: pt,
    urlIsHttpHttpsScheme: Er,
    readAllBytes: je,
    normalizeMethodRecord: q,
    parseMetadata: _
  }, nA;
}
var sA, ug;
function Tn() {
  return ug || (ug = 1, sA = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  }), sA;
}
var iA, dg;
function br() {
  if (dg) return iA;
  dg = 1;
  const { types: t } = Qr, { hasOwn: e, toUSVString: r } = en(), n = {};
  return n.converters = {}, n.util = {}, n.errors = {}, n.errors.exception = function(s) {
    return new TypeError(`${s.header}: ${s.message}`);
  }, n.errors.conversionFailed = function(s) {
    const i = s.types.length === 1 ? "" : " one of", o = `${s.argument} could not be converted to${i}: ${s.types.join(", ")}.`;
    return n.errors.exception({
      header: s.prefix,
      message: o
    });
  }, n.errors.invalidArgument = function(s) {
    return n.errors.exception({
      header: s.prefix,
      message: `"${s.value}" is an invalid ${s.type}.`
    });
  }, n.brandCheck = function(s, i, o = void 0) {
    if (o?.strict !== !1 && !(s instanceof i))
      throw new TypeError("Illegal invocation");
    return s?.[Symbol.toStringTag] === i.prototype[Symbol.toStringTag];
  }, n.argumentLengthCheck = function({ length: s }, i, o) {
    if (s < i)
      throw n.errors.exception({
        message: `${i} argument${i !== 1 ? "s" : ""} required, but${s ? " only" : ""} ${s} found.`,
        ...o
      });
  }, n.illegalConstructor = function() {
    throw n.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  }, n.util.Type = function(s) {
    switch (typeof s) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object":
        return s === null ? "Null" : "Object";
    }
  }, n.util.ConvertToInt = function(s, i, o, c = {}) {
    let l, A;
    i === 64 ? (l = Math.pow(2, 53) - 1, o === "unsigned" ? A = 0 : A = Math.pow(-2, 53) + 1) : o === "unsigned" ? (A = 0, l = Math.pow(2, i) - 1) : (A = Math.pow(-2, i) - 1, l = Math.pow(2, i - 1) - 1);
    let a = Number(s);
    if (a === 0 && (a = 0), c.enforceRange === !0) {
      if (Number.isNaN(a) || a === Number.POSITIVE_INFINITY || a === Number.NEGATIVE_INFINITY)
        throw n.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${s} to an integer.`
        });
      if (a = n.util.IntegerPart(a), a < A || a > l)
        throw n.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${A}-${l}, got ${a}.`
        });
      return a;
    }
    return !Number.isNaN(a) && c.clamp === !0 ? (a = Math.min(Math.max(a, A), l), Math.floor(a) % 2 === 0 ? a = Math.floor(a) : a = Math.ceil(a), a) : Number.isNaN(a) || a === 0 && Object.is(0, a) || a === Number.POSITIVE_INFINITY || a === Number.NEGATIVE_INFINITY ? 0 : (a = n.util.IntegerPart(a), a = a % Math.pow(2, i), o === "signed" && a >= Math.pow(2, i) - 1 ? a - Math.pow(2, i) : a);
  }, n.util.IntegerPart = function(s) {
    const i = Math.floor(Math.abs(s));
    return s < 0 ? -1 * i : i;
  }, n.sequenceConverter = function(s) {
    return (i) => {
      if (n.util.Type(i) !== "Object")
        throw n.errors.exception({
          header: "Sequence",
          message: `Value of type ${n.util.Type(i)} is not an Object.`
        });
      const o = i?.[Symbol.iterator]?.(), c = [];
      if (o === void 0 || typeof o.next != "function")
        throw n.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      for (; ; ) {
        const { done: l, value: A } = o.next();
        if (l)
          break;
        c.push(s(A));
      }
      return c;
    };
  }, n.recordConverter = function(s, i) {
    return (o) => {
      if (n.util.Type(o) !== "Object")
        throw n.errors.exception({
          header: "Record",
          message: `Value of type ${n.util.Type(o)} is not an Object.`
        });
      const c = {};
      if (!t.isProxy(o)) {
        const A = Object.keys(o);
        for (const a of A) {
          const u = s(a), g = i(o[a]);
          c[u] = g;
        }
        return c;
      }
      const l = Reflect.ownKeys(o);
      for (const A of l)
        if (Reflect.getOwnPropertyDescriptor(o, A)?.enumerable) {
          const u = s(A), g = i(o[A]);
          c[u] = g;
        }
      return c;
    };
  }, n.interfaceConverter = function(s) {
    return (i, o = {}) => {
      if (o.strict !== !1 && !(i instanceof s))
        throw n.errors.exception({
          header: s.name,
          message: `Expected ${i} to be an instance of ${s.name}.`
        });
      return i;
    };
  }, n.dictionaryConverter = function(s) {
    return (i) => {
      const o = n.util.Type(i), c = {};
      if (o === "Null" || o === "Undefined")
        return c;
      if (o !== "Object")
        throw n.errors.exception({
          header: "Dictionary",
          message: `Expected ${i} to be one of: Null, Undefined, Object.`
        });
      for (const l of s) {
        const { key: A, defaultValue: a, required: u, converter: g } = l;
        if (u === !0 && !e(i, A))
          throw n.errors.exception({
            header: "Dictionary",
            message: `Missing required key "${A}".`
          });
        let h = i[A];
        const m = e(l, "defaultValue");
        if (m && h !== null && (h = h ?? a), u || m || h !== void 0) {
          if (h = g(h), l.allowedValues && !l.allowedValues.includes(h))
            throw n.errors.exception({
              header: "Dictionary",
              message: `${h} is not an accepted type. Expected one of ${l.allowedValues.join(", ")}.`
            });
          c[A] = h;
        }
      }
      return c;
    };
  }, n.nullableConverter = function(s) {
    return (i) => i === null ? i : s(i);
  }, n.converters.DOMString = function(s, i = {}) {
    if (s === null && i.legacyNullToEmptyString)
      return "";
    if (typeof s == "symbol")
      throw new TypeError("Could not convert argument of type symbol to string.");
    return String(s);
  }, n.converters.ByteString = function(s) {
    const i = n.converters.DOMString(s);
    for (let o = 0; o < i.length; o++)
      if (i.charCodeAt(o) > 255)
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${o} has a value of ${i.charCodeAt(o)} which is greater than 255.`
        );
    return i;
  }, n.converters.USVString = r, n.converters.boolean = function(s) {
    return !!s;
  }, n.converters.any = function(s) {
    return s;
  }, n.converters["long long"] = function(s) {
    return n.util.ConvertToInt(s, 64, "signed");
  }, n.converters["unsigned long long"] = function(s) {
    return n.util.ConvertToInt(s, 64, "unsigned");
  }, n.converters["unsigned long"] = function(s) {
    return n.util.ConvertToInt(s, 32, "unsigned");
  }, n.converters["unsigned short"] = function(s, i) {
    return n.util.ConvertToInt(s, 16, "unsigned", i);
  }, n.converters.ArrayBuffer = function(s, i = {}) {
    if (n.util.Type(s) !== "Object" || !t.isAnyArrayBuffer(s))
      throw n.errors.conversionFailed({
        prefix: `${s}`,
        argument: `${s}`,
        types: ["ArrayBuffer"]
      });
    if (i.allowShared === !1 && t.isSharedArrayBuffer(s))
      throw n.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return s;
  }, n.converters.TypedArray = function(s, i, o = {}) {
    if (n.util.Type(s) !== "Object" || !t.isTypedArray(s) || s.constructor.name !== i.name)
      throw n.errors.conversionFailed({
        prefix: `${i.name}`,
        argument: `${s}`,
        types: [i.name]
      });
    if (o.allowShared === !1 && t.isSharedArrayBuffer(s.buffer))
      throw n.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return s;
  }, n.converters.DataView = function(s, i = {}) {
    if (n.util.Type(s) !== "Object" || !t.isDataView(s))
      throw n.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    if (i.allowShared === !1 && t.isSharedArrayBuffer(s.buffer))
      throw n.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return s;
  }, n.converters.BufferSource = function(s, i = {}) {
    if (t.isAnyArrayBuffer(s))
      return n.converters.ArrayBuffer(s, i);
    if (t.isTypedArray(s))
      return n.converters.TypedArray(s, s.constructor);
    if (t.isDataView(s))
      return n.converters.DataView(s, i);
    throw new TypeError(`Could not convert ${s} to a BufferSource.`);
  }, n.converters["sequence<ByteString>"] = n.sequenceConverter(
    n.converters.ByteString
  ), n.converters["sequence<sequence<ByteString>>"] = n.sequenceConverter(
    n.converters["sequence<ByteString>"]
  ), n.converters["record<ByteString, ByteString>"] = n.recordConverter(
    n.converters.ByteString,
    n.converters.ByteString
  ), iA = {
    webidl: n
  }, iA;
}
var oA, gg;
function un() {
  if (gg) return oA;
  gg = 1;
  const t = bt, { atob: e } = Dn, { isomorphicDecode: r } = en(), n = new TextEncoder(), s = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, i = /(\u000A|\u000D|\u0009|\u0020)/, o = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function c(I) {
    t(I.protocol === "data:");
    let w = l(I, !0);
    w = w.slice(5);
    const f = { position: 0 };
    let C = a(
      ",",
      w,
      f
    );
    const b = C.length;
    if (C = Q(C, !0, !0), f.position >= w.length)
      return "failure";
    f.position++;
    const N = w.slice(b + 1);
    let v = u(N);
    if (/;(\u0020){0,}base64$/i.test(C)) {
      const x = r(v);
      if (v = m(x), v === "failure")
        return "failure";
      C = C.slice(0, -6), C = C.replace(/(\u0020)+$/, ""), C = C.slice(0, -1);
    }
    C.startsWith(";") && (C = "text/plain" + C);
    let R = h(C);
    return R === "failure" && (R = h("text/plain;charset=US-ASCII")), { mimeType: R, body: v };
  }
  function l(I, w = !1) {
    if (!w)
      return I.href;
    const f = I.href, C = I.hash.length;
    return C === 0 ? f : f.substring(0, f.length - C);
  }
  function A(I, w, f) {
    let C = "";
    for (; f.position < w.length && I(w[f.position]); )
      C += w[f.position], f.position++;
    return C;
  }
  function a(I, w, f) {
    const C = w.indexOf(I, f.position), b = f.position;
    return C === -1 ? (f.position = w.length, w.slice(b)) : (f.position = C, w.slice(b, f.position));
  }
  function u(I) {
    const w = n.encode(I);
    return g(w);
  }
  function g(I) {
    const w = [];
    for (let f = 0; f < I.length; f++) {
      const C = I[f];
      if (C !== 37)
        w.push(C);
      else if (C === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(I[f + 1], I[f + 2])))
        w.push(37);
      else {
        const b = String.fromCharCode(I[f + 1], I[f + 2]), N = Number.parseInt(b, 16);
        w.push(N), f += 2;
      }
    }
    return Uint8Array.from(w);
  }
  function h(I) {
    I = B(I, !0, !0);
    const w = { position: 0 }, f = a(
      "/",
      I,
      w
    );
    if (f.length === 0 || !s.test(f) || w.position > I.length)
      return "failure";
    w.position++;
    let C = a(
      ";",
      I,
      w
    );
    if (C = B(C, !1, !0), C.length === 0 || !s.test(C))
      return "failure";
    const b = f.toLowerCase(), N = C.toLowerCase(), v = {
      type: b,
      subtype: N,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${b}/${N}`
    };
    for (; w.position < I.length; ) {
      w.position++, A(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (S) => i.test(S),
        I,
        w
      );
      let R = A(
        (S) => S !== ";" && S !== "=",
        I,
        w
      );
      if (R = R.toLowerCase(), w.position < I.length) {
        if (I[w.position] === ";")
          continue;
        w.position++;
      }
      if (w.position > I.length)
        break;
      let x = null;
      if (I[w.position] === '"')
        x = d(I, w, !0), a(
          ";",
          I,
          w
        );
      else if (x = a(
        ";",
        I,
        w
      ), x = B(x, !1, !0), x.length === 0)
        continue;
      R.length !== 0 && s.test(R) && (x.length === 0 || o.test(x)) && !v.parameters.has(R) && v.parameters.set(R, x);
    }
    return v;
  }
  function m(I) {
    if (I = I.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, ""), I.length % 4 === 0 && (I = I.replace(/=?=$/, "")), I.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(I))
      return "failure";
    const w = e(I), f = new Uint8Array(w.length);
    for (let C = 0; C < w.length; C++)
      f[C] = w.charCodeAt(C);
    return f;
  }
  function d(I, w, f) {
    const C = w.position;
    let b = "";
    for (t(I[w.position] === '"'), w.position++; b += A(
      (v) => v !== '"' && v !== "\\",
      I,
      w
    ), !(w.position >= I.length); ) {
      const N = I[w.position];
      if (w.position++, N === "\\") {
        if (w.position >= I.length) {
          b += "\\";
          break;
        }
        b += I[w.position], w.position++;
      } else {
        t(N === '"');
        break;
      }
    }
    return f ? b : I.slice(C, w.position);
  }
  function p(I) {
    t(I !== "failure");
    const { parameters: w, essence: f } = I;
    let C = f;
    for (let [b, N] of w.entries())
      C += ";", C += b, C += "=", s.test(N) || (N = N.replace(/(\\|")/g, "\\$1"), N = '"' + N, N += '"'), C += N;
    return C;
  }
  function E(I) {
    return I === "\r" || I === `
` || I === "	" || I === " ";
  }
  function B(I, w = !0, f = !0) {
    let C = 0, b = I.length - 1;
    if (w)
      for (; C < I.length && E(I[C]); C++) ;
    if (f)
      for (; b > 0 && E(I[b]); b--) ;
    return I.slice(C, b + 1);
  }
  function y(I) {
    return I === "\r" || I === `
` || I === "	" || I === "\f" || I === " ";
  }
  function Q(I, w = !0, f = !0) {
    let C = 0, b = I.length - 1;
    if (w)
      for (; C < I.length && y(I[C]); C++) ;
    if (f)
      for (; b > 0 && y(I[b]); b--) ;
    return I.slice(C, b + 1);
  }
  return oA = {
    dataURLProcessor: c,
    URLSerializer: l,
    collectASequenceOfCodePoints: A,
    collectASequenceOfCodePointsFast: a,
    stringPercentDecode: u,
    parseMIMEType: h,
    collectAnHTTPQuotedString: d,
    serializeAMimeType: p
  }, oA;
}
var aA, mg;
function cu() {
  if (mg) return aA;
  mg = 1;
  const { Blob: t, File: e } = Dn, { types: r } = Qr, { kState: n } = Tn(), { isBlobLike: s } = en(), { webidl: i } = br(), { parseMIMEType: o, serializeAMimeType: c } = un(), { kEnumerableProperty: l } = rt(), A = new TextEncoder();
  class a extends t {
    constructor(p, E, B = {}) {
      i.argumentLengthCheck(arguments, 2, { header: "File constructor" }), p = i.converters["sequence<BlobPart>"](p), E = i.converters.USVString(E), B = i.converters.FilePropertyBag(B);
      const y = E;
      let Q = B.type, I;
      e: {
        if (Q) {
          if (Q = o(Q), Q === "failure") {
            Q = "";
            break e;
          }
          Q = c(Q).toLowerCase();
        }
        I = B.lastModified;
      }
      super(g(p, B), { type: Q }), this[n] = {
        name: y,
        lastModified: I,
        type: Q
      };
    }
    get name() {
      return i.brandCheck(this, a), this[n].name;
    }
    get lastModified() {
      return i.brandCheck(this, a), this[n].lastModified;
    }
    get type() {
      return i.brandCheck(this, a), this[n].type;
    }
  }
  class u {
    constructor(p, E, B = {}) {
      const y = E, Q = B.type, I = B.lastModified ?? Date.now();
      this[n] = {
        blobLike: p,
        name: y,
        type: Q,
        lastModified: I
      };
    }
    stream(...p) {
      return i.brandCheck(this, u), this[n].blobLike.stream(...p);
    }
    arrayBuffer(...p) {
      return i.brandCheck(this, u), this[n].blobLike.arrayBuffer(...p);
    }
    slice(...p) {
      return i.brandCheck(this, u), this[n].blobLike.slice(...p);
    }
    text(...p) {
      return i.brandCheck(this, u), this[n].blobLike.text(...p);
    }
    get size() {
      return i.brandCheck(this, u), this[n].blobLike.size;
    }
    get type() {
      return i.brandCheck(this, u), this[n].blobLike.type;
    }
    get name() {
      return i.brandCheck(this, u), this[n].name;
    }
    get lastModified() {
      return i.brandCheck(this, u), this[n].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(a.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: !0
    },
    name: l,
    lastModified: l
  }), i.converters.Blob = i.interfaceConverter(t), i.converters.BlobPart = function(d, p) {
    if (i.util.Type(d) === "Object") {
      if (s(d))
        return i.converters.Blob(d, { strict: !1 });
      if (ArrayBuffer.isView(d) || r.isAnyArrayBuffer(d))
        return i.converters.BufferSource(d, p);
    }
    return i.converters.USVString(d, p);
  }, i.converters["sequence<BlobPart>"] = i.sequenceConverter(
    i.converters.BlobPart
  ), i.converters.FilePropertyBag = i.dictionaryConverter([
    {
      key: "lastModified",
      converter: i.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: i.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (d) => (d = i.converters.DOMString(d), d = d.toLowerCase(), d !== "native" && (d = "transparent"), d),
      defaultValue: "transparent"
    }
  ]);
  function g(d, p) {
    const E = [];
    for (const B of d)
      if (typeof B == "string") {
        let y = B;
        p.endings === "native" && (y = h(y)), E.push(A.encode(y));
      } else r.isAnyArrayBuffer(B) || r.isTypedArray(B) ? B.buffer ? E.push(
        new Uint8Array(B.buffer, B.byteOffset, B.byteLength)
      ) : E.push(new Uint8Array(B)) : s(B) && E.push(B);
    return E;
  }
  function h(d) {
    let p = `
`;
    return process.platform === "win32" && (p = `\r
`), d.replace(/\r?\n/g, p);
  }
  function m(d) {
    return e && d instanceof e || d instanceof a || d && (typeof d.stream == "function" || typeof d.arrayBuffer == "function") && d[Symbol.toStringTag] === "File";
  }
  return aA = { File: a, FileLike: u, isFileLike: m }, aA;
}
var AA, hg;
function lu() {
  if (hg) return AA;
  hg = 1;
  const { isBlobLike: t, toUSVString: e, makeIterator: r } = en(), { kState: n } = Tn(), { File: s, FileLike: i, isFileLike: o } = cu(), { webidl: c } = br(), { Blob: l, File: A } = Dn, a = A ?? s;
  class u {
    constructor(m) {
      if (m !== void 0)
        throw c.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      this[n] = [];
    }
    append(m, d, p = void 0) {
      if (c.brandCheck(this, u), c.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !t(d))
        throw new TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      m = c.converters.USVString(m), d = t(d) ? c.converters.Blob(d, { strict: !1 }) : c.converters.USVString(d), p = arguments.length === 3 ? c.converters.USVString(p) : void 0;
      const E = g(m, d, p);
      this[n].push(E);
    }
    delete(m) {
      c.brandCheck(this, u), c.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), m = c.converters.USVString(m), this[n] = this[n].filter((d) => d.name !== m);
    }
    get(m) {
      c.brandCheck(this, u), c.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), m = c.converters.USVString(m);
      const d = this[n].findIndex((p) => p.name === m);
      return d === -1 ? null : this[n][d].value;
    }
    getAll(m) {
      return c.brandCheck(this, u), c.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), m = c.converters.USVString(m), this[n].filter((d) => d.name === m).map((d) => d.value);
    }
    has(m) {
      return c.brandCheck(this, u), c.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), m = c.converters.USVString(m), this[n].findIndex((d) => d.name === m) !== -1;
    }
    set(m, d, p = void 0) {
      if (c.brandCheck(this, u), c.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !t(d))
        throw new TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      m = c.converters.USVString(m), d = t(d) ? c.converters.Blob(d, { strict: !1 }) : c.converters.USVString(d), p = arguments.length === 3 ? e(p) : void 0;
      const E = g(m, d, p), B = this[n].findIndex((y) => y.name === m);
      B !== -1 ? this[n] = [
        ...this[n].slice(0, B),
        E,
        ...this[n].slice(B + 1).filter((y) => y.name !== m)
      ] : this[n].push(E);
    }
    entries() {
      return c.brandCheck(this, u), r(
        () => this[n].map((m) => [m.name, m.value]),
        "FormData",
        "key+value"
      );
    }
    keys() {
      return c.brandCheck(this, u), r(
        () => this[n].map((m) => [m.name, m.value]),
        "FormData",
        "key"
      );
    }
    values() {
      return c.brandCheck(this, u), r(
        () => this[n].map((m) => [m.name, m.value]),
        "FormData",
        "value"
      );
    }
    /**
     * @param {(value: string, key: string, self: FormData) => void} callbackFn
     * @param {unknown} thisArg
     */
    forEach(m, d = globalThis) {
      if (c.brandCheck(this, u), c.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" }), typeof m != "function")
        throw new TypeError(
          "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
        );
      for (const [p, E] of this)
        m.apply(d, [E, p, this]);
    }
  }
  u.prototype[Symbol.iterator] = u.prototype.entries, Object.defineProperties(u.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: !0
    }
  });
  function g(h, m, d) {
    if (h = Buffer.from(h).toString("utf8"), typeof m == "string")
      m = Buffer.from(m).toString("utf8");
    else if (o(m) || (m = m instanceof l ? new a([m], "blob", { type: m.type }) : new i(m, "blob", { type: m.type })), d !== void 0) {
      const p = {
        type: m.type,
        lastModified: m.lastModified
      };
      m = A && m instanceof A || m instanceof s ? new a([m], d, p) : new i(m, d, p);
    }
    return { name: h, value: m };
  }
  return AA = { FormData: u }, AA;
}
var cA, pg;
function na() {
  if (pg) return cA;
  pg = 1;
  const t = lb(), e = rt(), {
    ReadableStreamFrom: r,
    isBlobLike: n,
    isReadableStreamLike: s,
    readableStreamClose: i,
    createDeferredPromise: o,
    fullyReadBody: c
  } = en(), { FormData: l } = lu(), { kState: A } = Tn(), { webidl: a } = br(), { DOMException: u, structuredClone: g } = ns(), { Blob: h, File: m } = Dn, { kBodyUsed: d } = Nt(), p = bt, { isErrored: E } = rt(), { isUint8Array: B, isArrayBuffer: y } = yf, { File: Q } = cu(), { parseMIMEType: I, serializeAMimeType: w } = un();
  let f;
  try {
    const U = require("node:crypto");
    f = (J) => U.randomInt(0, J);
  } catch {
    f = (U) => Math.floor(Math.random(U));
  }
  let C = globalThis.ReadableStream;
  const b = m ?? Q, N = new TextEncoder(), v = new TextDecoder();
  function R(U, J = !1) {
    C || (C = xn.ReadableStream);
    let j = null;
    U instanceof C ? j = U : n(U) ? j = U.stream() : j = new C({
      async pull(se) {
        se.enqueue(
          typeof ie == "string" ? N.encode(ie) : ie
        ), queueMicrotask(() => i(se));
      },
      start() {
      },
      type: void 0
    }), p(s(j));
    let te = null, ie = null, G = null, q = null;
    if (typeof U == "string")
      ie = U, q = "text/plain;charset=UTF-8";
    else if (U instanceof URLSearchParams)
      ie = U.toString(), q = "application/x-www-form-urlencoded;charset=UTF-8";
    else if (y(U))
      ie = new Uint8Array(U.slice());
    else if (ArrayBuffer.isView(U))
      ie = new Uint8Array(U.buffer.slice(U.byteOffset, U.byteOffset + U.byteLength));
    else if (e.isFormDataLike(U)) {
      const se = `----formdata-undici-0${`${f(1e11)}`.padStart(11, "0")}`, F = `--${se}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const ne = (_e) => _e.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), de = (_e) => _e.replace(/\r?\n|\r/g, `\r
`), ve = [], Ce = new Uint8Array([13, 10]);
      G = 0;
      let Qe = !1;
      for (const [_e, Et] of U)
        if (typeof Et == "string") {
          const Jt = N.encode(F + `; name="${ne(de(_e))}"\r
\r
${de(Et)}\r
`);
          ve.push(Jt), G += Jt.byteLength;
        } else {
          const Jt = N.encode(`${F}; name="${ne(de(_e))}"` + (Et.name ? `; filename="${ne(Et.name)}"` : "") + `\r
Content-Type: ${Et.type || "application/octet-stream"}\r
\r
`);
          ve.push(Jt, Et, Ce), typeof Et.size == "number" ? G += Jt.byteLength + Et.size + Ce.byteLength : Qe = !0;
        }
      const xe = N.encode(`--${se}--`);
      ve.push(xe), G += xe.byteLength, Qe && (G = null), ie = U, te = async function* () {
        for (const _e of ve)
          _e.stream ? yield* _e.stream() : yield _e;
      }, q = "multipart/form-data; boundary=" + se;
    } else if (n(U))
      ie = U, G = U.size, U.type && (q = U.type);
    else if (typeof U[Symbol.asyncIterator] == "function") {
      if (J)
        throw new TypeError("keepalive");
      if (e.isDisturbed(U) || U.locked)
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      j = U instanceof C ? U : r(U);
    }
    if ((typeof ie == "string" || e.isBuffer(ie)) && (G = Buffer.byteLength(ie)), te != null) {
      let se;
      j = new C({
        async start() {
          se = te(U)[Symbol.asyncIterator]();
        },
        async pull(F) {
          const { value: ne, done: de } = await se.next();
          return de ? queueMicrotask(() => {
            F.close();
          }) : E(j) || F.enqueue(new Uint8Array(ne)), F.desiredSize > 0;
        },
        async cancel(F) {
          await se.return();
        },
        type: void 0
      });
    }
    return [{ stream: j, source: ie, length: G }, q];
  }
  function x(U, J = !1) {
    return C || (C = xn.ReadableStream), U instanceof C && (p(!e.isDisturbed(U), "The body has already been consumed."), p(!U.locked, "The stream is locked.")), R(U, J);
  }
  function S(U) {
    const [J, j] = U.stream.tee(), te = g(j, { transfer: [j] }), [, ie] = te.tee();
    return U.stream = J, {
      stream: ie,
      length: U.length,
      source: U.source
    };
  }
  async function* D(U) {
    if (U)
      if (B(U))
        yield U;
      else {
        const J = U.stream;
        if (e.isDisturbed(J))
          throw new TypeError("The body has already been consumed.");
        if (J.locked)
          throw new TypeError("The stream is locked.");
        J[d] = !0, yield* J;
      }
  }
  function T(U) {
    if (U.aborted)
      throw new u("The operation was aborted.", "AbortError");
  }
  function k(U) {
    return {
      blob() {
        return W(this, (j) => {
          let te = $(this);
          return te === "failure" ? te = "" : te && (te = w(te)), new h([j], { type: te });
        }, U);
      },
      arrayBuffer() {
        return W(this, (j) => new Uint8Array(j).buffer, U);
      },
      text() {
        return W(this, _, U);
      },
      json() {
        return W(this, M, U);
      },
      async formData() {
        a.brandCheck(this, U), T(this[A]);
        const j = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(j)) {
          const te = {};
          for (const [Z, se] of this.headers) te[Z.toLowerCase()] = se;
          const ie = new l();
          let G;
          try {
            G = new t({
              headers: te,
              preservePath: !0
            });
          } catch (Z) {
            throw new u(`${Z}`, "AbortError");
          }
          G.on("field", (Z, se) => {
            ie.append(Z, se);
          }), G.on("file", (Z, se, F, ne, de) => {
            const ve = [];
            if (ne === "base64" || ne.toLowerCase() === "base64") {
              let Ce = "";
              se.on("data", (Qe) => {
                Ce += Qe.toString().replace(/[\r\n]/gm, "");
                const xe = Ce.length - Ce.length % 4;
                ve.push(Buffer.from(Ce.slice(0, xe), "base64")), Ce = Ce.slice(xe);
              }), se.on("end", () => {
                ve.push(Buffer.from(Ce, "base64")), ie.append(Z, new b(ve, F, { type: de }));
              });
            } else
              se.on("data", (Ce) => {
                ve.push(Ce);
              }), se.on("end", () => {
                ie.append(Z, new b(ve, F, { type: de }));
              });
          });
          const q = new Promise((Z, se) => {
            G.on("finish", Z), G.on("error", (F) => se(new TypeError(F)));
          });
          if (this.body !== null) for await (const Z of D(this[A].body)) G.write(Z);
          return G.end(), await q, ie;
        } else if (/application\/x-www-form-urlencoded/.test(j)) {
          let te;
          try {
            let G = "";
            const q = new TextDecoder("utf-8", { ignoreBOM: !0 });
            for await (const Z of D(this[A].body)) {
              if (!B(Z))
                throw new TypeError("Expected Uint8Array chunk");
              G += q.decode(Z, { stream: !0 });
            }
            G += q.decode(), te = new URLSearchParams(G);
          } catch (G) {
            throw Object.assign(new TypeError(), { cause: G });
          }
          const ie = new l();
          for (const [G, q] of te)
            ie.append(G, q);
          return ie;
        } else
          throw await Promise.resolve(), T(this[A]), a.errors.exception({
            header: `${U.name}.formData`,
            message: "Could not parse content as FormData."
          });
      }
    };
  }
  function L(U) {
    Object.assign(U.prototype, k(U));
  }
  async function W(U, J, j) {
    if (a.brandCheck(U, j), T(U[A]), O(U[A].body))
      throw new TypeError("Body is unusable");
    const te = o(), ie = (q) => te.reject(q), G = (q) => {
      try {
        te.resolve(J(q));
      } catch (Z) {
        ie(Z);
      }
    };
    return U[A].body == null ? (G(new Uint8Array()), te.promise) : (await c(U[A].body, G, ie), te.promise);
  }
  function O(U) {
    return U != null && (U.stream.locked || e.isDisturbed(U.stream));
  }
  function _(U) {
    return U.length === 0 ? "" : (U[0] === 239 && U[1] === 187 && U[2] === 191 && (U = U.subarray(3)), v.decode(U));
  }
  function M(U) {
    return JSON.parse(_(U));
  }
  function $(U) {
    const { headersList: J } = U[A], j = J.get("content-type");
    return j === null ? "failure" : I(j);
  }
  return cA = {
    extractBody: R,
    safelyExtractBody: x,
    cloneBody: S,
    mixinBody: L
  }, cA;
}
var lA, fg;
function ub() {
  if (fg) return lA;
  fg = 1;
  const {
    InvalidArgumentError: t,
    NotSupportedError: e
  } = ft(), r = bt, { kHTTP2BuildRequest: n, kHTTP2CopyHeaders: s, kHTTP1BuildRequest: i } = Nt(), o = rt(), c = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/, l = /[^\t\x20-\x7e\x80-\xff]/, A = /[^\u0021-\u00ff]/, a = Symbol("handler"), u = {};
  let g;
  try {
    const p = require("diagnostics_channel");
    u.create = p.channel("undici:request:create"), u.bodySent = p.channel("undici:request:bodySent"), u.headers = p.channel("undici:request:headers"), u.trailers = p.channel("undici:request:trailers"), u.error = p.channel("undici:request:error");
  } catch {
    u.create = { hasSubscribers: !1 }, u.bodySent = { hasSubscribers: !1 }, u.headers = { hasSubscribers: !1 }, u.trailers = { hasSubscribers: !1 }, u.error = { hasSubscribers: !1 };
  }
  class h {
    constructor(E, {
      path: B,
      method: y,
      body: Q,
      headers: I,
      query: w,
      idempotent: f,
      blocking: C,
      upgrade: b,
      headersTimeout: N,
      bodyTimeout: v,
      reset: R,
      throwOnError: x,
      expectContinue: S
    }, D) {
      if (typeof B != "string")
        throw new t("path must be a string");
      if (B[0] !== "/" && !(B.startsWith("http://") || B.startsWith("https://")) && y !== "CONNECT")
        throw new t("path must be an absolute URL or start with a slash");
      if (A.exec(B) !== null)
        throw new t("invalid request path");
      if (typeof y != "string")
        throw new t("method must be a string");
      if (c.exec(y) === null)
        throw new t("invalid request method");
      if (b && typeof b != "string")
        throw new t("upgrade must be a string");
      if (N != null && (!Number.isFinite(N) || N < 0))
        throw new t("invalid headersTimeout");
      if (v != null && (!Number.isFinite(v) || v < 0))
        throw new t("invalid bodyTimeout");
      if (R != null && typeof R != "boolean")
        throw new t("invalid reset");
      if (S != null && typeof S != "boolean")
        throw new t("invalid expectContinue");
      if (this.headersTimeout = N, this.bodyTimeout = v, this.throwOnError = x === !0, this.method = y, this.abort = null, Q == null)
        this.body = null;
      else if (o.isStream(Q)) {
        this.body = Q;
        const T = this.body._readableState;
        (!T || !T.autoDestroy) && (this.endHandler = function() {
          o.destroy(this);
        }, this.body.on("end", this.endHandler)), this.errorHandler = (k) => {
          this.abort ? this.abort(k) : this.error = k;
        }, this.body.on("error", this.errorHandler);
      } else if (o.isBuffer(Q))
        this.body = Q.byteLength ? Q : null;
      else if (ArrayBuffer.isView(Q))
        this.body = Q.buffer.byteLength ? Buffer.from(Q.buffer, Q.byteOffset, Q.byteLength) : null;
      else if (Q instanceof ArrayBuffer)
        this.body = Q.byteLength ? Buffer.from(Q) : null;
      else if (typeof Q == "string")
        this.body = Q.length ? Buffer.from(Q) : null;
      else if (o.isFormDataLike(Q) || o.isIterable(Q) || o.isBlobLike(Q))
        this.body = Q;
      else
        throw new t("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      if (this.completed = !1, this.aborted = !1, this.upgrade = b || null, this.path = w ? o.buildURL(B, w) : B, this.origin = E, this.idempotent = f ?? (y === "HEAD" || y === "GET"), this.blocking = C ?? !1, this.reset = R ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = "", this.expectContinue = S ?? !1, Array.isArray(I)) {
        if (I.length % 2 !== 0)
          throw new t("headers array must be even");
        for (let T = 0; T < I.length; T += 2)
          d(this, I[T], I[T + 1]);
      } else if (I && typeof I == "object") {
        const T = Object.keys(I);
        for (let k = 0; k < T.length; k++) {
          const L = T[k];
          d(this, L, I[L]);
        }
      } else if (I != null)
        throw new t("headers must be an object or an array");
      if (o.isFormDataLike(this.body)) {
        if (o.nodeMajor < 16 || o.nodeMajor === 16 && o.nodeMinor < 8)
          throw new t("Form-Data bodies are only supported in node v16.8 and newer.");
        g || (g = na().extractBody);
        const [T, k] = g(Q);
        this.contentType == null && (this.contentType = k, this.headers += `content-type: ${k}\r
`), this.body = T.stream, this.contentLength = T.length;
      } else o.isBlobLike(Q) && this.contentType == null && Q.type && (this.contentType = Q.type, this.headers += `content-type: ${Q.type}\r
`);
      o.validateHandler(D, y, b), this.servername = o.getServerName(this.host), this[a] = D, u.create.hasSubscribers && u.create.publish({ request: this });
    }
    onBodySent(E) {
      if (this[a].onBodySent)
        try {
          return this[a].onBodySent(E);
        } catch (B) {
          this.abort(B);
        }
    }
    onRequestSent() {
      if (u.bodySent.hasSubscribers && u.bodySent.publish({ request: this }), this[a].onRequestSent)
        try {
          return this[a].onRequestSent();
        } catch (E) {
          this.abort(E);
        }
    }
    onConnect(E) {
      if (r(!this.aborted), r(!this.completed), this.error)
        E(this.error);
      else
        return this.abort = E, this[a].onConnect(E);
    }
    onHeaders(E, B, y, Q) {
      r(!this.aborted), r(!this.completed), u.headers.hasSubscribers && u.headers.publish({ request: this, response: { statusCode: E, headers: B, statusText: Q } });
      try {
        return this[a].onHeaders(E, B, y, Q);
      } catch (I) {
        this.abort(I);
      }
    }
    onData(E) {
      r(!this.aborted), r(!this.completed);
      try {
        return this[a].onData(E);
      } catch (B) {
        return this.abort(B), !1;
      }
    }
    onUpgrade(E, B, y) {
      return r(!this.aborted), r(!this.completed), this[a].onUpgrade(E, B, y);
    }
    onComplete(E) {
      this.onFinally(), r(!this.aborted), this.completed = !0, u.trailers.hasSubscribers && u.trailers.publish({ request: this, trailers: E });
      try {
        return this[a].onComplete(E);
      } catch (B) {
        this.onError(B);
      }
    }
    onError(E) {
      if (this.onFinally(), u.error.hasSubscribers && u.error.publish({ request: this, error: E }), !this.aborted)
        return this.aborted = !0, this[a].onError(E);
    }
    onFinally() {
      this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
    }
    // TODO: adjust to support H2
    addHeader(E, B) {
      return d(this, E, B), this;
    }
    static [i](E, B, y) {
      return new h(E, B, y);
    }
    static [n](E, B, y) {
      const Q = B.headers;
      B = { ...B, headers: null };
      const I = new h(E, B, y);
      if (I.headers = {}, Array.isArray(Q)) {
        if (Q.length % 2 !== 0)
          throw new t("headers array must be even");
        for (let w = 0; w < Q.length; w += 2)
          d(I, Q[w], Q[w + 1], !0);
      } else if (Q && typeof Q == "object") {
        const w = Object.keys(Q);
        for (let f = 0; f < w.length; f++) {
          const C = w[f];
          d(I, C, Q[C], !0);
        }
      } else if (Q != null)
        throw new t("headers must be an object or an array");
      return I;
    }
    static [s](E) {
      const B = E.split(`\r
`), y = {};
      for (const Q of B) {
        const [I, w] = Q.split(": ");
        w == null || w.length === 0 || (y[I] ? y[I] += `,${w}` : y[I] = w);
      }
      return y;
    }
  }
  function m(p, E, B) {
    if (E && typeof E == "object")
      throw new t(`invalid ${p} header`);
    if (E = E != null ? `${E}` : "", l.exec(E) !== null)
      throw new t(`invalid ${p} header`);
    return B ? E : `${p}: ${E}\r
`;
  }
  function d(p, E, B, y = !1) {
    if (B && typeof B == "object" && !Array.isArray(B))
      throw new t(`invalid ${E} header`);
    if (B === void 0)
      return;
    if (p.host === null && E.length === 4 && E.toLowerCase() === "host") {
      if (l.exec(B) !== null)
        throw new t(`invalid ${E} header`);
      p.host = B;
    } else if (p.contentLength === null && E.length === 14 && E.toLowerCase() === "content-length") {
      if (p.contentLength = parseInt(B, 10), !Number.isFinite(p.contentLength))
        throw new t("invalid content-length header");
    } else if (p.contentType === null && E.length === 12 && E.toLowerCase() === "content-type")
      p.contentType = B, y ? p.headers[E] = m(E, B, y) : p.headers += m(E, B);
    else {
      if (E.length === 17 && E.toLowerCase() === "transfer-encoding")
        throw new t("invalid transfer-encoding header");
      if (E.length === 10 && E.toLowerCase() === "connection") {
        const Q = typeof B == "string" ? B.toLowerCase() : null;
        if (Q !== "close" && Q !== "keep-alive")
          throw new t("invalid connection header");
        Q === "close" && (p.reset = !0);
      } else {
        if (E.length === 10 && E.toLowerCase() === "keep-alive")
          throw new t("invalid keep-alive header");
        if (E.length === 7 && E.toLowerCase() === "upgrade")
          throw new t("invalid upgrade header");
        if (E.length === 6 && E.toLowerCase() === "expect")
          throw new e("expect header not supported");
        if (c.exec(E) === null)
          throw new t("invalid header key");
        if (Array.isArray(B))
          for (let Q = 0; Q < B.length; Q++)
            y ? p.headers[E] ? p.headers[E] += `,${m(E, B[Q], y)}` : p.headers[E] = m(E, B[Q], y) : p.headers += m(E, B[Q]);
        else
          y ? p.headers[E] = m(E, B, y) : p.headers += m(E, B);
      }
    }
  }
  return lA = h, lA;
}
var uA, Eg;
function uu() {
  if (Eg) return uA;
  Eg = 1;
  const t = Ts;
  class e extends t {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
  }
  return uA = e, uA;
}
var dA, Cg;
function sa() {
  if (Cg) return dA;
  Cg = 1;
  const t = uu(), {
    ClientDestroyedError: e,
    ClientClosedError: r,
    InvalidArgumentError: n
  } = ft(), { kDestroy: s, kClose: i, kDispatch: o, kInterceptors: c } = Nt(), l = Symbol("destroyed"), A = Symbol("closed"), a = Symbol("onDestroyed"), u = Symbol("onClosed"), g = Symbol("Intercepted Dispatch");
  class h extends t {
    constructor() {
      super(), this[l] = !1, this[a] = null, this[A] = !1, this[u] = [];
    }
    get destroyed() {
      return this[l];
    }
    get closed() {
      return this[A];
    }
    get interceptors() {
      return this[c];
    }
    set interceptors(d) {
      if (d) {
        for (let p = d.length - 1; p >= 0; p--)
          if (typeof this[c][p] != "function")
            throw new n("interceptor must be an function");
      }
      this[c] = d;
    }
    close(d) {
      if (d === void 0)
        return new Promise((E, B) => {
          this.close((y, Q) => y ? B(y) : E(Q));
        });
      if (typeof d != "function")
        throw new n("invalid callback");
      if (this[l]) {
        queueMicrotask(() => d(new e(), null));
        return;
      }
      if (this[A]) {
        this[u] ? this[u].push(d) : queueMicrotask(() => d(null, null));
        return;
      }
      this[A] = !0, this[u].push(d);
      const p = () => {
        const E = this[u];
        this[u] = null;
        for (let B = 0; B < E.length; B++)
          E[B](null, null);
      };
      this[i]().then(() => this.destroy()).then(() => {
        queueMicrotask(p);
      });
    }
    destroy(d, p) {
      if (typeof d == "function" && (p = d, d = null), p === void 0)
        return new Promise((B, y) => {
          this.destroy(d, (Q, I) => Q ? (
            /* istanbul ignore next: should never error */
            y(Q)
          ) : B(I));
        });
      if (typeof p != "function")
        throw new n("invalid callback");
      if (this[l]) {
        this[a] ? this[a].push(p) : queueMicrotask(() => p(null, null));
        return;
      }
      d || (d = new e()), this[l] = !0, this[a] = this[a] || [], this[a].push(p);
      const E = () => {
        const B = this[a];
        this[a] = null;
        for (let y = 0; y < B.length; y++)
          B[y](null, null);
      };
      this[s](d).then(() => {
        queueMicrotask(E);
      });
    }
    [g](d, p) {
      if (!this[c] || this[c].length === 0)
        return this[g] = this[o], this[o](d, p);
      let E = this[o].bind(this);
      for (let B = this[c].length - 1; B >= 0; B--)
        E = this[c][B](E);
      return this[g] = E, E(d, p);
    }
    dispatch(d, p) {
      if (!p || typeof p != "object")
        throw new n("handler must be an object");
      try {
        if (!d || typeof d != "object")
          throw new n("opts must be an object.");
        if (this[l] || this[a])
          throw new e();
        if (this[A])
          throw new r();
        return this[g](d, p);
      } catch (E) {
        if (typeof p.onError != "function")
          throw new n("invalid onError method");
        return p.onError(E), !1;
      }
    }
  }
  return dA = h, dA;
}
var gA, Bg;
function ia() {
  if (Bg) return gA;
  Bg = 1;
  const t = iu, e = bt, r = rt(), { InvalidArgumentError: n, ConnectTimeoutError: s } = ft();
  let i, o;
  Ui.FinalizationRegistry && !process.env.NODE_V8_COVERAGE ? o = class {
    constructor(u) {
      this._maxCachedSessions = u, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new Ui.FinalizationRegistry((g) => {
        if (this._sessionCache.size < this._maxCachedSessions)
          return;
        const h = this._sessionCache.get(g);
        h !== void 0 && h.deref() === void 0 && this._sessionCache.delete(g);
      });
    }
    get(u) {
      const g = this._sessionCache.get(u);
      return g ? g.deref() : null;
    }
    set(u, g) {
      this._maxCachedSessions !== 0 && (this._sessionCache.set(u, new WeakRef(g)), this._sessionRegistry.register(g, u));
    }
  } : o = class {
    constructor(u) {
      this._maxCachedSessions = u, this._sessionCache = /* @__PURE__ */ new Map();
    }
    get(u) {
      return this._sessionCache.get(u);
    }
    set(u, g) {
      if (this._maxCachedSessions !== 0) {
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: h } = this._sessionCache.keys().next();
          this._sessionCache.delete(h);
        }
        this._sessionCache.set(u, g);
      }
    }
  };
  function c({ allowH2: a, maxCachedSessions: u, socketPath: g, timeout: h, ...m }) {
    if (u != null && (!Number.isInteger(u) || u < 0))
      throw new n("maxCachedSessions must be a positive integer or zero");
    const d = { path: g, ...m }, p = new o(u ?? 100);
    return h = h ?? 1e4, a = a ?? !1, function({ hostname: B, host: y, protocol: Q, port: I, servername: w, localAddress: f, httpSocket: C }, b) {
      let N;
      if (Q === "https:") {
        i || (i = Cf), w = w || d.servername || r.getServerName(y) || null;
        const R = w || B, x = p.get(R) || null;
        e(R), N = i.connect({
          highWaterMark: 16384,
          // TLS in node can't have bigger HWM anyway...
          ...d,
          servername: w,
          session: x,
          localAddress: f,
          // TODO(HTTP/2): Add support for h2c
          ALPNProtocols: a ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: C,
          // upgrade socket connection
          port: I || 443,
          host: B
        }), N.on("session", function(S) {
          p.set(R, S);
        });
      } else
        e(!C, "httpSocket can only be sent on TLS update"), N = t.connect({
          highWaterMark: 64 * 1024,
          // Same as nodejs fs streams.
          ...d,
          localAddress: f,
          port: I || 80,
          host: B
        });
      if (d.keepAlive == null || d.keepAlive) {
        const R = d.keepAliveInitialDelay === void 0 ? 6e4 : d.keepAliveInitialDelay;
        N.setKeepAlive(!0, R);
      }
      const v = l(() => A(N), h);
      return N.setNoDelay(!0).once(Q === "https:" ? "secureConnect" : "connect", function() {
        if (v(), b) {
          const R = b;
          b = null, R(null, this);
        }
      }).on("error", function(R) {
        if (v(), b) {
          const x = b;
          b = null, x(R);
        }
      }), N;
    };
  }
  function l(a, u) {
    if (!u)
      return () => {
      };
    let g = null, h = null;
    const m = setTimeout(() => {
      g = setImmediate(() => {
        process.platform === "win32" ? h = setImmediate(() => a()) : a();
      });
    }, u);
    return () => {
      clearTimeout(m), clearImmediate(g), clearImmediate(h);
    };
  }
  function A(a) {
    r.destroy(a, new s());
  }
  return gA = c, gA;
}
var mA = {}, hi = {}, Ig;
function db() {
  if (Ig) return hi;
  Ig = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.enumToMap = void 0;
  function t(e) {
    const r = {};
    return Object.keys(e).forEach((n) => {
      const s = e[n];
      typeof s == "number" && (r[n] = s);
    }), r;
  }
  return hi.enumToMap = t, hi;
}
var yg;
function gb() {
  return yg || (yg = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SPECIAL_HEADERS = t.HEADER_STATE = t.MINOR = t.MAJOR = t.CONNECTION_TOKEN_CHARS = t.HEADER_CHARS = t.TOKEN = t.STRICT_TOKEN = t.HEX = t.URL_CHAR = t.STRICT_URL_CHAR = t.USERINFO_CHARS = t.MARK = t.ALPHANUM = t.NUM = t.HEX_MAP = t.NUM_MAP = t.ALPHA = t.FINISH = t.H_METHOD_MAP = t.METHOD_MAP = t.METHODS_RTSP = t.METHODS_ICE = t.METHODS_HTTP = t.METHODS = t.LENIENT_FLAGS = t.FLAGS = t.TYPE = t.ERROR = void 0;
    const e = db();
    (function(s) {
      s[s.OK = 0] = "OK", s[s.INTERNAL = 1] = "INTERNAL", s[s.STRICT = 2] = "STRICT", s[s.LF_EXPECTED = 3] = "LF_EXPECTED", s[s.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", s[s.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", s[s.INVALID_METHOD = 6] = "INVALID_METHOD", s[s.INVALID_URL = 7] = "INVALID_URL", s[s.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", s[s.INVALID_VERSION = 9] = "INVALID_VERSION", s[s.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", s[s.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", s[s.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", s[s.INVALID_STATUS = 13] = "INVALID_STATUS", s[s.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", s[s.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", s[s.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", s[s.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", s[s.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", s[s.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", s[s.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", s[s.PAUSED = 21] = "PAUSED", s[s.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", s[s.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", s[s.USER = 24] = "USER";
    })(t.ERROR || (t.ERROR = {})), function(s) {
      s[s.BOTH = 0] = "BOTH", s[s.REQUEST = 1] = "REQUEST", s[s.RESPONSE = 2] = "RESPONSE";
    }(t.TYPE || (t.TYPE = {})), function(s) {
      s[s.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", s[s.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", s[s.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", s[s.CHUNKED = 8] = "CHUNKED", s[s.UPGRADE = 16] = "UPGRADE", s[s.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", s[s.SKIPBODY = 64] = "SKIPBODY", s[s.TRAILING = 128] = "TRAILING", s[s.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
    }(t.FLAGS || (t.FLAGS = {})), function(s) {
      s[s.HEADERS = 1] = "HEADERS", s[s.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", s[s.KEEP_ALIVE = 4] = "KEEP_ALIVE";
    }(t.LENIENT_FLAGS || (t.LENIENT_FLAGS = {}));
    var r;
    (function(s) {
      s[s.DELETE = 0] = "DELETE", s[s.GET = 1] = "GET", s[s.HEAD = 2] = "HEAD", s[s.POST = 3] = "POST", s[s.PUT = 4] = "PUT", s[s.CONNECT = 5] = "CONNECT", s[s.OPTIONS = 6] = "OPTIONS", s[s.TRACE = 7] = "TRACE", s[s.COPY = 8] = "COPY", s[s.LOCK = 9] = "LOCK", s[s.MKCOL = 10] = "MKCOL", s[s.MOVE = 11] = "MOVE", s[s.PROPFIND = 12] = "PROPFIND", s[s.PROPPATCH = 13] = "PROPPATCH", s[s.SEARCH = 14] = "SEARCH", s[s.UNLOCK = 15] = "UNLOCK", s[s.BIND = 16] = "BIND", s[s.REBIND = 17] = "REBIND", s[s.UNBIND = 18] = "UNBIND", s[s.ACL = 19] = "ACL", s[s.REPORT = 20] = "REPORT", s[s.MKACTIVITY = 21] = "MKACTIVITY", s[s.CHECKOUT = 22] = "CHECKOUT", s[s.MERGE = 23] = "MERGE", s[s["M-SEARCH"] = 24] = "M-SEARCH", s[s.NOTIFY = 25] = "NOTIFY", s[s.SUBSCRIBE = 26] = "SUBSCRIBE", s[s.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", s[s.PATCH = 28] = "PATCH", s[s.PURGE = 29] = "PURGE", s[s.MKCALENDAR = 30] = "MKCALENDAR", s[s.LINK = 31] = "LINK", s[s.UNLINK = 32] = "UNLINK", s[s.SOURCE = 33] = "SOURCE", s[s.PRI = 34] = "PRI", s[s.DESCRIBE = 35] = "DESCRIBE", s[s.ANNOUNCE = 36] = "ANNOUNCE", s[s.SETUP = 37] = "SETUP", s[s.PLAY = 38] = "PLAY", s[s.PAUSE = 39] = "PAUSE", s[s.TEARDOWN = 40] = "TEARDOWN", s[s.GET_PARAMETER = 41] = "GET_PARAMETER", s[s.SET_PARAMETER = 42] = "SET_PARAMETER", s[s.REDIRECT = 43] = "REDIRECT", s[s.RECORD = 44] = "RECORD", s[s.FLUSH = 45] = "FLUSH";
    })(r = t.METHODS || (t.METHODS = {})), t.METHODS_HTTP = [
      r.DELETE,
      r.GET,
      r.HEAD,
      r.POST,
      r.PUT,
      r.CONNECT,
      r.OPTIONS,
      r.TRACE,
      r.COPY,
      r.LOCK,
      r.MKCOL,
      r.MOVE,
      r.PROPFIND,
      r.PROPPATCH,
      r.SEARCH,
      r.UNLOCK,
      r.BIND,
      r.REBIND,
      r.UNBIND,
      r.ACL,
      r.REPORT,
      r.MKACTIVITY,
      r.CHECKOUT,
      r.MERGE,
      r["M-SEARCH"],
      r.NOTIFY,
      r.SUBSCRIBE,
      r.UNSUBSCRIBE,
      r.PATCH,
      r.PURGE,
      r.MKCALENDAR,
      r.LINK,
      r.UNLINK,
      r.PRI,
      // TODO(indutny): should we allow it with HTTP?
      r.SOURCE
    ], t.METHODS_ICE = [
      r.SOURCE
    ], t.METHODS_RTSP = [
      r.OPTIONS,
      r.DESCRIBE,
      r.ANNOUNCE,
      r.SETUP,
      r.PLAY,
      r.PAUSE,
      r.TEARDOWN,
      r.GET_PARAMETER,
      r.SET_PARAMETER,
      r.REDIRECT,
      r.RECORD,
      r.FLUSH,
      // For AirPlay
      r.GET,
      r.POST
    ], t.METHOD_MAP = e.enumToMap(r), t.H_METHOD_MAP = {}, Object.keys(t.METHOD_MAP).forEach((s) => {
      /^H/.test(s) && (t.H_METHOD_MAP[s] = t.METHOD_MAP[s]);
    }), function(s) {
      s[s.SAFE = 0] = "SAFE", s[s.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", s[s.UNSAFE = 2] = "UNSAFE";
    }(t.FINISH || (t.FINISH = {})), t.ALPHA = [];
    for (let s = 65; s <= 90; s++)
      t.ALPHA.push(String.fromCharCode(s)), t.ALPHA.push(String.fromCharCode(s + 32));
    t.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    }, t.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    }, t.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ], t.ALPHANUM = t.ALPHA.concat(t.NUM), t.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], t.USERINFO_CHARS = t.ALPHANUM.concat(t.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), t.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(t.ALPHANUM), t.URL_CHAR = t.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let s = 128; s <= 255; s++)
      t.URL_CHAR.push(s);
    t.HEX = t.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), t.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(t.ALPHANUM), t.TOKEN = t.STRICT_TOKEN.concat([" "]), t.HEADER_CHARS = ["	"];
    for (let s = 32; s <= 255; s++)
      s !== 127 && t.HEADER_CHARS.push(s);
    t.CONNECTION_TOKEN_CHARS = t.HEADER_CHARS.filter((s) => s !== 44), t.MAJOR = t.NUM_MAP, t.MINOR = t.MAJOR;
    var n;
    (function(s) {
      s[s.GENERAL = 0] = "GENERAL", s[s.CONNECTION = 1] = "CONNECTION", s[s.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", s[s.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", s[s.UPGRADE = 4] = "UPGRADE", s[s.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", s[s.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", s[s.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", s[s.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(n = t.HEADER_STATE || (t.HEADER_STATE = {})), t.SPECIAL_HEADERS = {
      connection: n.CONNECTION,
      "content-length": n.CONTENT_LENGTH,
      "proxy-connection": n.CONNECTION,
      "transfer-encoding": n.TRANSFER_ENCODING,
      upgrade: n.UPGRADE
    };
  }(mA)), mA;
}
var hA, Qg;
function kf() {
  if (Qg) return hA;
  Qg = 1;
  const t = rt(), { kBodyUsed: e } = Nt(), r = bt, { InvalidArgumentError: n } = ft(), s = Ts, i = [300, 301, 302, 303, 307, 308], o = Symbol("body");
  class c {
    constructor(h) {
      this[o] = h, this[e] = !1;
    }
    async *[Symbol.asyncIterator]() {
      r(!this[e], "disturbed"), this[e] = !0, yield* this[o];
    }
  }
  class l {
    constructor(h, m, d, p) {
      if (m != null && (!Number.isInteger(m) || m < 0))
        throw new n("maxRedirections must be a positive number");
      t.validateHandler(p, d.method, d.upgrade), this.dispatch = h, this.location = null, this.abort = null, this.opts = { ...d, maxRedirections: 0 }, this.maxRedirections = m, this.handler = p, this.history = [], t.isStream(this.opts.body) ? (t.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
        r(!1);
      }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[e] = !1, s.prototype.on.call(this.opts.body, "data", function() {
        this[e] = !0;
      }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new c(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && t.isIterable(this.opts.body) && (this.opts.body = new c(this.opts.body));
    }
    onConnect(h) {
      this.abort = h, this.handler.onConnect(h, { history: this.history });
    }
    onUpgrade(h, m, d) {
      this.handler.onUpgrade(h, m, d);
    }
    onError(h) {
      this.handler.onError(h);
    }
    onHeaders(h, m, d, p) {
      if (this.location = this.history.length >= this.maxRedirections || t.isDisturbed(this.opts.body) ? null : A(h, m), this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
        return this.handler.onHeaders(h, m, d, p);
      const { origin: E, pathname: B, search: y } = t.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), Q = y ? `${B}${y}` : B;
      this.opts.headers = u(this.opts.headers, h === 303, this.opts.origin !== E), this.opts.path = Q, this.opts.origin = E, this.opts.maxRedirections = 0, this.opts.query = null, h === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
    }
    onData(h) {
      if (!this.location) return this.handler.onData(h);
    }
    onComplete(h) {
      this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(h);
    }
    onBodySent(h) {
      this.handler.onBodySent && this.handler.onBodySent(h);
    }
  }
  function A(g, h) {
    if (i.indexOf(g) === -1)
      return null;
    for (let m = 0; m < h.length; m += 2)
      if (h[m].toString().toLowerCase() === "location")
        return h[m + 1];
  }
  function a(g, h, m) {
    if (g.length === 4)
      return t.headerNameToString(g) === "host";
    if (h && t.headerNameToString(g).startsWith("content-"))
      return !0;
    if (m && (g.length === 13 || g.length === 6 || g.length === 19)) {
      const d = t.headerNameToString(g);
      return d === "authorization" || d === "cookie" || d === "proxy-authorization";
    }
    return !1;
  }
  function u(g, h, m) {
    const d = [];
    if (Array.isArray(g))
      for (let p = 0; p < g.length; p += 2)
        a(g[p], h, m) || d.push(g[p], g[p + 1]);
    else if (g && typeof g == "object")
      for (const p of Object.keys(g))
        a(p, h, m) || d.push(p, g[p]);
    else
      r(g == null, "headers must be an object or an array");
    return d;
  }
  return hA = l, hA;
}
var pA, bg;
function du() {
  if (bg) return pA;
  bg = 1;
  const t = kf();
  function e({ maxRedirections: r }) {
    return (n) => function(i, o) {
      const { maxRedirections: c = r } = i;
      if (!c)
        return n(i, o);
      const l = new t(n, c, i, o);
      return i = { ...i, maxRedirections: 0 }, n(i, l);
    };
  }
  return pA = e, pA;
}
var fA, wg;
function Ng() {
  return wg || (wg = 1, fA = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8="), fA;
}
var EA, Rg;
function mb() {
  return Rg || (Rg = 1, EA = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw=="), EA;
}
var CA, Sg;
function oa() {
  if (Sg) return CA;
  Sg = 1;
  const t = bt, e = iu, r = Ds, { pipeline: n } = ln, s = rt(), i = nb(), o = ub(), c = sa(), {
    RequestContentLengthMismatchError: l,
    ResponseContentLengthMismatchError: A,
    InvalidArgumentError: a,
    RequestAbortedError: u,
    HeadersTimeoutError: g,
    HeadersOverflowError: h,
    SocketError: m,
    InformationalError: d,
    BodyTimeoutError: p,
    HTTPParserError: E,
    ResponseExceededMaxSizeError: B,
    ClientDestroyedError: y
  } = ft(), Q = ia(), {
    kUrl: I,
    kReset: w,
    kServerName: f,
    kClient: C,
    kBusy: b,
    kParser: N,
    kConnect: v,
    kBlocking: R,
    kResuming: x,
    kRunning: S,
    kPending: D,
    kSize: T,
    kWriting: k,
    kQueue: L,
    kConnected: W,
    kConnecting: O,
    kNeedDrain: _,
    kNoRef: M,
    kKeepAliveDefaultTimeout: $,
    kHostHeader: U,
    kPendingIdx: J,
    kRunningIdx: j,
    kError: te,
    kPipelining: ie,
    kSocket: G,
    kKeepAliveTimeoutValue: q,
    kMaxHeadersSize: Z,
    kKeepAliveMaxTimeout: se,
    kKeepAliveTimeoutThreshold: F,
    kHeadersTimeout: ne,
    kBodyTimeout: de,
    kStrictContentLength: ve,
    kConnector: Ce,
    kMaxRedirections: Qe,
    kMaxRequests: xe,
    kCounter: _e,
    kClose: Et,
    kDestroy: Jt,
    kDispatch: je,
    kInterceptors: st,
    kLocalAddress: pt,
    kMaxResponseSize: Er,
    kHTTPConnVersion: Ot,
    // HTTP2
    kHost: K,
    kHTTP2Session: ce,
    kHTTP2SessionState: Ee,
    kHTTP2BuildRequest: Ue,
    kHTTP2CopyHeaders: $e,
    kHTTP1BuildRequest: Ct
  } = Nt();
  let St;
  try {
    St = require("http2");
  } catch {
    St = { constants: {} };
  }
  const {
    constants: {
      HTTP2_HEADER_AUTHORITY: Vt,
      HTTP2_HEADER_METHOD: P,
      HTTP2_HEADER_PATH: z,
      HTTP2_HEADER_SCHEME: X,
      HTTP2_HEADER_CONTENT_LENGTH: ae,
      HTTP2_HEADER_EXPECT: ge,
      HTTP2_HEADER_STATUS: Ie
    }
  } = St;
  let De = !1;
  const Ve = Buffer[Symbol.species], Pe = Symbol("kClosedResolve"), ee = {};
  try {
    const H = require("diagnostics_channel");
    ee.sendHeaders = H.channel("undici:client:sendHeaders"), ee.beforeConnect = H.channel("undici:client:beforeConnect"), ee.connectError = H.channel("undici:client:connectError"), ee.connected = H.channel("undici:client:connected");
  } catch {
    ee.sendHeaders = { hasSubscribers: !1 }, ee.beforeConnect = { hasSubscribers: !1 }, ee.connectError = { hasSubscribers: !1 }, ee.connected = { hasSubscribers: !1 };
  }
  class fe extends c {
    /**
     *
     * @param {string|URL} url
     * @param {import('../types/client').Client.Options} options
     */
    constructor(Y, {
      interceptors: V,
      maxHeaderSize: re,
      headersTimeout: oe,
      socketTimeout: me,
      requestTimeout: Ge,
      connectTimeout: He,
      bodyTimeout: Oe,
      idleTimeout: We,
      keepAlive: lt,
      keepAliveTimeout: it,
      maxKeepAliveTimeout: ke,
      keepAliveMaxTimeout: Le,
      keepAliveTimeoutThreshold: Ye,
      socketPath: ut,
      pipelining: Yr,
      tls: po,
      strictContentLength: Br,
      maxCachedSessions: ci,
      maxRedirections: on,
      connect: Mn,
      maxRequestsPerClient: fo,
      localAddress: li,
      maxResponseSize: ui,
      autoSelectFamily: Qd,
      autoSelectFamilyAttemptTimeout: Eo,
      // h2
      allowH2: Co,
      maxConcurrentStreams: di
    } = {}) {
      if (super(), lt !== void 0)
        throw new a("unsupported keepAlive, use pipelining=0 instead");
      if (me !== void 0)
        throw new a("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (Ge !== void 0)
        throw new a("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (We !== void 0)
        throw new a("unsupported idleTimeout, use keepAliveTimeout instead");
      if (ke !== void 0)
        throw new a("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (re != null && !Number.isFinite(re))
        throw new a("invalid maxHeaderSize");
      if (ut != null && typeof ut != "string")
        throw new a("invalid socketPath");
      if (He != null && (!Number.isFinite(He) || He < 0))
        throw new a("invalid connectTimeout");
      if (it != null && (!Number.isFinite(it) || it <= 0))
        throw new a("invalid keepAliveTimeout");
      if (Le != null && (!Number.isFinite(Le) || Le <= 0))
        throw new a("invalid keepAliveMaxTimeout");
      if (Ye != null && !Number.isFinite(Ye))
        throw new a("invalid keepAliveTimeoutThreshold");
      if (oe != null && (!Number.isInteger(oe) || oe < 0))
        throw new a("headersTimeout must be a positive integer or zero");
      if (Oe != null && (!Number.isInteger(Oe) || Oe < 0))
        throw new a("bodyTimeout must be a positive integer or zero");
      if (Mn != null && typeof Mn != "function" && typeof Mn != "object")
        throw new a("connect must be a function or an object");
      if (on != null && (!Number.isInteger(on) || on < 0))
        throw new a("maxRedirections must be a positive number");
      if (fo != null && (!Number.isInteger(fo) || fo < 0))
        throw new a("maxRequestsPerClient must be a positive number");
      if (li != null && (typeof li != "string" || e.isIP(li) === 0))
        throw new a("localAddress must be valid string IP address");
      if (ui != null && (!Number.isInteger(ui) || ui < -1))
        throw new a("maxResponseSize must be a positive number");
      if (Eo != null && (!Number.isInteger(Eo) || Eo < -1))
        throw new a("autoSelectFamilyAttemptTimeout must be a positive number");
      if (Co != null && typeof Co != "boolean")
        throw new a("allowH2 must be a valid boolean value");
      if (di != null && (typeof di != "number" || di < 1))
        throw new a("maxConcurrentStreams must be a possitive integer, greater than 0");
      typeof Mn != "function" && (Mn = Q({
        ...po,
        maxCachedSessions: ci,
        allowH2: Co,
        socketPath: ut,
        timeout: He,
        ...s.nodeHasAutoSelectFamily && Qd ? { autoSelectFamily: Qd, autoSelectFamilyAttemptTimeout: Eo } : void 0,
        ...Mn
      })), this[st] = V && V.Client && Array.isArray(V.Client) ? V.Client : [Wt({ maxRedirections: on })], this[I] = s.parseOrigin(Y), this[Ce] = Mn, this[G] = null, this[ie] = Yr ?? 1, this[Z] = re || r.maxHeaderSize, this[$] = it ?? 4e3, this[se] = Le ?? 6e5, this[F] = Ye ?? 1e3, this[q] = this[$], this[f] = null, this[pt] = li ?? null, this[x] = 0, this[_] = 0, this[U] = `host: ${this[I].hostname}${this[I].port ? `:${this[I].port}` : ""}\r
`, this[de] = Oe ?? 3e5, this[ne] = oe ?? 3e5, this[ve] = Br ?? !0, this[Qe] = on, this[xe] = fo, this[Pe] = null, this[Er] = ui > -1 ? ui : -1, this[Ot] = "h1", this[ce] = null, this[Ee] = Co ? {
        // streams: null, // Fixed queue of streams - For future support of `push`
        openStreams: 0,
        // Keep track of them to decide wether or not unref the session
        maxConcurrentStreams: di ?? 100
        // Max peerConcurrentStreams for a Node h2 server
      } : null, this[K] = `${this[I].hostname}${this[I].port ? `:${this[I].port}` : ""}`, this[L] = [], this[j] = 0, this[J] = 0;
    }
    get pipelining() {
      return this[ie];
    }
    set pipelining(Y) {
      this[ie] = Y, Ut(this, !0);
    }
    get [D]() {
      return this[L].length - this[J];
    }
    get [S]() {
      return this[J] - this[j];
    }
    get [T]() {
      return this[L].length - this[j];
    }
    get [W]() {
      return !!this[G] && !this[O] && !this[G].destroyed;
    }
    get [b]() {
      const Y = this[G];
      return Y && (Y[w] || Y[k] || Y[R]) || this[T] >= (this[ie] || 1) || this[D] > 0;
    }
    /* istanbul ignore: only used for test */
    [v](Y) {
      Cr(this), this.once("connect", Y);
    }
    [je](Y, V) {
      const re = Y.origin || this[I].origin, oe = this[Ot] === "h2" ? o[Ue](re, Y, V) : o[Ct](re, Y, V);
      return this[L].push(oe), this[x] || (s.bodyLength(oe.body) == null && s.isIterable(oe.body) ? (this[x] = 1, process.nextTick(Ut, this)) : Ut(this, !0)), this[x] && this[_] !== 2 && this[b] && (this[_] = 2), this[_] < 2;
    }
    async [Et]() {
      return new Promise((Y) => {
        this[T] ? this[Pe] = Y : Y(null);
      });
    }
    async [Jt](Y) {
      return new Promise((V) => {
        const re = this[L].splice(this[J]);
        for (let me = 0; me < re.length; me++) {
          const Ge = re[me];
          cr(this, Ge, Y);
        }
        const oe = () => {
          this[Pe] && (this[Pe](), this[Pe] = null), V();
        };
        this[ce] != null && (s.destroy(this[ce], Y), this[ce] = null, this[Ee] = null), this[G] ? s.destroy(this[G].on("close", oe), Y) : queueMicrotask(oe), Ut(this);
      });
    }
  }
  function le(H) {
    t(H.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[G][te] = H, sn(this[C], H);
  }
  function Ae(H, Y, V) {
    const re = new d(`HTTP/2: "frameError" received - type ${H}, code ${Y}`);
    V === 0 && (this[G][te] = re, sn(this[C], re));
  }
  function Be() {
    s.destroy(this, new m("other side closed")), s.destroy(this[G], new m("other side closed"));
  }
  function he(H) {
    const Y = this[C], V = new d(`HTTP/2: "GOAWAY" frame received with code ${H}`);
    if (Y[G] = null, Y[ce] = null, Y.destroyed) {
      t(this[D] === 0);
      const re = Y[L].splice(Y[j]);
      for (let oe = 0; oe < re.length; oe++) {
        const me = re[oe];
        cr(this, me, V);
      }
    } else if (Y[S] > 0) {
      const re = Y[L][Y[j]];
      Y[L][Y[j]++] = null, cr(Y, re, V);
    }
    Y[J] = Y[j], t(Y[S] === 0), Y.emit(
      "disconnect",
      Y[I],
      [Y],
      V
    ), Ut(Y);
  }
  const Me = gb(), Wt = du(), ar = Buffer.alloc(0);
  async function vt() {
    const H = process.env.JEST_WORKER_ID ? Ng() : void 0;
    let Y;
    try {
      Y = await WebAssembly.compile(Buffer.from(mb(), "base64"));
    } catch {
      Y = await WebAssembly.compile(Buffer.from(H || Ng(), "base64"));
    }
    return await WebAssembly.instantiate(Y, {
      env: {
        /* eslint-disable camelcase */
        wasm_on_url: (V, re, oe) => 0,
        wasm_on_status: (V, re, oe) => {
          t.strictEqual(Te.ptr, V);
          const me = re - ct + Bt.byteOffset;
          return Te.onStatus(new Ve(Bt.buffer, me, oe)) || 0;
        },
        wasm_on_message_begin: (V) => (t.strictEqual(Te.ptr, V), Te.onMessageBegin() || 0),
        wasm_on_header_field: (V, re, oe) => {
          t.strictEqual(Te.ptr, V);
          const me = re - ct + Bt.byteOffset;
          return Te.onHeaderField(new Ve(Bt.buffer, me, oe)) || 0;
        },
        wasm_on_header_value: (V, re, oe) => {
          t.strictEqual(Te.ptr, V);
          const me = re - ct + Bt.byteOffset;
          return Te.onHeaderValue(new Ve(Bt.buffer, me, oe)) || 0;
        },
        wasm_on_headers_complete: (V, re, oe, me) => (t.strictEqual(Te.ptr, V), Te.onHeadersComplete(re, !!oe, !!me) || 0),
        wasm_on_body: (V, re, oe) => {
          t.strictEqual(Te.ptr, V);
          const me = re - ct + Bt.byteOffset;
          return Te.onBody(new Ve(Bt.buffer, me, oe)) || 0;
        },
        wasm_on_message_complete: (V) => (t.strictEqual(Te.ptr, V), Te.onMessageComplete() || 0)
        /* eslint-enable camelcase */
      }
    });
  }
  let _r = null, bn = vt();
  bn.catch();
  let Te = null, Bt = null, Ar = 0, ct = null;
  const qr = 1, It = 2, Gt = 3;
  class oi {
    constructor(Y, V, { exports: re }) {
      t(Number.isFinite(Y[Z]) && Y[Z] > 0), this.llhttp = re, this.ptr = this.llhttp.llhttp_alloc(Me.TYPE.RESPONSE), this.client = Y, this.socket = V, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = Y[Z], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = Y[Er];
    }
    setTimeout(Y, V) {
      this.timeoutType = V, Y !== this.timeoutValue ? (i.clearTimeout(this.timeout), Y ? (this.timeout = i.setTimeout(ls, Y, this), this.timeout.unref && this.timeout.unref()) : this.timeout = null, this.timeoutValue = Y) : this.timeout && this.timeout.refresh && this.timeout.refresh();
    }
    resume() {
      this.socket.destroyed || !this.paused || (t(this.ptr != null), t(Te == null), this.llhttp.llhttp_resume(this.ptr), t(this.timeoutType === It), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = !1, this.execute(this.socket.read() || ar), this.readMore());
    }
    readMore() {
      for (; !this.paused && this.ptr; ) {
        const Y = this.socket.read();
        if (Y === null)
          break;
        this.execute(Y);
      }
    }
    execute(Y) {
      t(this.ptr != null), t(Te == null), t(!this.paused);
      const { socket: V, llhttp: re } = this;
      Y.length > Ar && (ct && re.free(ct), Ar = Math.ceil(Y.length / 4096) * 4096, ct = re.malloc(Ar)), new Uint8Array(re.memory.buffer, ct, Ar).set(Y);
      try {
        let oe;
        try {
          Bt = Y, Te = this, oe = re.llhttp_execute(this.ptr, ct, Y.length);
        } catch (Ge) {
          throw Ge;
        } finally {
          Te = null, Bt = null;
        }
        const me = re.llhttp_get_error_pos(this.ptr) - ct;
        if (oe === Me.ERROR.PAUSED_UPGRADE)
          this.onUpgrade(Y.slice(me));
        else if (oe === Me.ERROR.PAUSED)
          this.paused = !0, V.unshift(Y.slice(me));
        else if (oe !== Me.ERROR.OK) {
          const Ge = re.llhttp_get_error_reason(this.ptr);
          let He = "";
          if (Ge) {
            const Oe = new Uint8Array(re.memory.buffer, Ge).indexOf(0);
            He = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(re.memory.buffer, Ge, Oe).toString() + ")";
          }
          throw new E(He, Me.ERROR[oe], Y.slice(me));
        }
      } catch (oe) {
        s.destroy(V, oe);
      }
    }
    destroy() {
      t(this.ptr != null), t(Te == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, i.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
    }
    onStatus(Y) {
      this.statusText = Y.toString();
    }
    onMessageBegin() {
      const { socket: Y, client: V } = this;
      if (Y.destroyed || !V[L][V[j]])
        return -1;
    }
    onHeaderField(Y) {
      const V = this.headers.length;
      (V & 1) === 0 ? this.headers.push(Y) : this.headers[V - 1] = Buffer.concat([this.headers[V - 1], Y]), this.trackHeader(Y.length);
    }
    onHeaderValue(Y) {
      let V = this.headers.length;
      (V & 1) === 1 ? (this.headers.push(Y), V += 1) : this.headers[V - 1] = Buffer.concat([this.headers[V - 1], Y]);
      const re = this.headers[V - 2];
      re.length === 10 && re.toString().toLowerCase() === "keep-alive" ? this.keepAlive += Y.toString() : re.length === 10 && re.toString().toLowerCase() === "connection" ? this.connection += Y.toString() : re.length === 14 && re.toString().toLowerCase() === "content-length" && (this.contentLength += Y.toString()), this.trackHeader(Y.length);
    }
    trackHeader(Y) {
      this.headersSize += Y, this.headersSize >= this.headersMaxSize && s.destroy(this.socket, new h());
    }
    onUpgrade(Y) {
      const { upgrade: V, client: re, socket: oe, headers: me, statusCode: Ge } = this;
      t(V);
      const He = re[L][re[j]];
      t(He), t(!oe.destroyed), t(oe === re[G]), t(!this.paused), t(He.upgrade || He.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, t(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, oe.unshift(Y), oe[N].destroy(), oe[N] = null, oe[C] = null, oe[te] = null, oe.removeListener("error", wn).removeListener("readable", Hr).removeListener("end", gn).removeListener("close", ai), re[G] = null, re[L][re[j]++] = null, re.emit("disconnect", re[I], [re], new d("upgrade"));
      try {
        He.onUpgrade(Ge, me, oe);
      } catch (Oe) {
        s.destroy(oe, Oe);
      }
      Ut(re);
    }
    onHeadersComplete(Y, V, re) {
      const { client: oe, socket: me, headers: Ge, statusText: He } = this;
      if (me.destroyed)
        return -1;
      const Oe = oe[L][oe[j]];
      if (!Oe)
        return -1;
      if (t(!this.upgrade), t(this.statusCode < 200), Y === 100)
        return s.destroy(me, new m("bad response", s.getSocketInfo(me))), -1;
      if (V && !Oe.upgrade)
        return s.destroy(me, new m("bad upgrade", s.getSocketInfo(me))), -1;
      if (t.strictEqual(this.timeoutType, qr), this.statusCode = Y, this.shouldKeepAlive = re || // Override llhttp value which does not allow keepAlive for HEAD.
      Oe.method === "HEAD" && !me[w] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
        const lt = Oe.bodyTimeout != null ? Oe.bodyTimeout : oe[de];
        this.setTimeout(lt, It);
      } else this.timeout && this.timeout.refresh && this.timeout.refresh();
      if (Oe.method === "CONNECT")
        return t(oe[S] === 1), this.upgrade = !0, 2;
      if (V)
        return t(oe[S] === 1), this.upgrade = !0, 2;
      if (t(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && oe[ie]) {
        const lt = this.keepAlive ? s.parseKeepAliveTimeout(this.keepAlive) : null;
        if (lt != null) {
          const it = Math.min(
            lt - oe[F],
            oe[se]
          );
          it <= 0 ? me[w] = !0 : oe[q] = it;
        } else
          oe[q] = oe[$];
      } else
        me[w] = !0;
      const We = Oe.onHeaders(Y, Ge, this.resume, He) === !1;
      return Oe.aborted ? -1 : Oe.method === "HEAD" || Y < 200 ? 1 : (me[R] && (me[R] = !1, Ut(oe)), We ? Me.ERROR.PAUSED : 0);
    }
    onBody(Y) {
      const { client: V, socket: re, statusCode: oe, maxResponseSize: me } = this;
      if (re.destroyed)
        return -1;
      const Ge = V[L][V[j]];
      if (t(Ge), t.strictEqual(this.timeoutType, It), this.timeout && this.timeout.refresh && this.timeout.refresh(), t(oe >= 200), me > -1 && this.bytesRead + Y.length > me)
        return s.destroy(re, new B()), -1;
      if (this.bytesRead += Y.length, Ge.onData(Y) === !1)
        return Me.ERROR.PAUSED;
    }
    onMessageComplete() {
      const { client: Y, socket: V, statusCode: re, upgrade: oe, headers: me, contentLength: Ge, bytesRead: He, shouldKeepAlive: Oe } = this;
      if (V.destroyed && (!re || Oe))
        return -1;
      if (oe)
        return;
      const We = Y[L][Y[j]];
      if (t(We), t(re >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", t(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, !(re < 200)) {
        if (We.method !== "HEAD" && Ge && He !== parseInt(Ge, 10))
          return s.destroy(V, new A()), -1;
        if (We.onComplete(me), Y[L][Y[j]++] = null, V[k])
          return t.strictEqual(Y[S], 0), s.destroy(V, new d("reset")), Me.ERROR.PAUSED;
        if (Oe) {
          if (V[w] && Y[S] === 0)
            return s.destroy(V, new d("reset")), Me.ERROR.PAUSED;
          Y[ie] === 1 ? setImmediate(Ut, Y) : Ut(Y);
        } else return s.destroy(V, new d("reset")), Me.ERROR.PAUSED;
      }
    }
  }
  function ls(H) {
    const { socket: Y, timeoutType: V, client: re } = H;
    V === qr ? (!Y[k] || Y.writableNeedDrain || re[S] > 1) && (t(!H.paused, "cannot be paused while waiting for headers"), s.destroy(Y, new g())) : V === It ? H.paused || s.destroy(Y, new p()) : V === Gt && (t(re[S] === 0 && re[q]), s.destroy(Y, new d("socket idle timeout")));
  }
  function Hr() {
    const { [N]: H } = this;
    H && H.readMore();
  }
  function wn(H) {
    const { [C]: Y, [N]: V } = this;
    if (t(H.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), Y[Ot] !== "h2" && H.code === "ECONNRESET" && V.statusCode && !V.shouldKeepAlive) {
      V.onMessageComplete();
      return;
    }
    this[te] = H, sn(this[C], H);
  }
  function sn(H, Y) {
    if (H[S] === 0 && Y.code !== "UND_ERR_INFO" && Y.code !== "UND_ERR_SOCKET") {
      t(H[J] === H[j]);
      const V = H[L].splice(H[j]);
      for (let re = 0; re < V.length; re++) {
        const oe = V[re];
        cr(H, oe, Y);
      }
      t(H[T] === 0);
    }
  }
  function gn() {
    const { [N]: H, [C]: Y } = this;
    if (Y[Ot] !== "h2" && H.statusCode && !H.shouldKeepAlive) {
      H.onMessageComplete();
      return;
    }
    s.destroy(this, new m("other side closed", s.getSocketInfo(this)));
  }
  function ai() {
    const { [C]: H, [N]: Y } = this;
    H[Ot] === "h1" && Y && (!this[te] && Y.statusCode && !Y.shouldKeepAlive && Y.onMessageComplete(), this[N].destroy(), this[N] = null);
    const V = this[te] || new m("closed", s.getSocketInfo(this));
    if (H[G] = null, H.destroyed) {
      t(H[D] === 0);
      const re = H[L].splice(H[j]);
      for (let oe = 0; oe < re.length; oe++) {
        const me = re[oe];
        cr(H, me, V);
      }
    } else if (H[S] > 0 && V.code !== "UND_ERR_INFO") {
      const re = H[L][H[j]];
      H[L][H[j]++] = null, cr(H, re, V);
    }
    H[J] = H[j], t(H[S] === 0), H.emit("disconnect", H[I], [H], V), Ut(H);
  }
  async function Cr(H) {
    t(!H[O]), t(!H[G]);
    let { host: Y, hostname: V, protocol: re, port: oe } = H[I];
    if (V[0] === "[") {
      const me = V.indexOf("]");
      t(me !== -1);
      const Ge = V.substring(1, me);
      t(e.isIP(Ge)), V = Ge;
    }
    H[O] = !0, ee.beforeConnect.hasSubscribers && ee.beforeConnect.publish({
      connectParams: {
        host: Y,
        hostname: V,
        protocol: re,
        port: oe,
        servername: H[f],
        localAddress: H[pt]
      },
      connector: H[Ce]
    });
    try {
      const me = await new Promise((He, Oe) => {
        H[Ce]({
          host: Y,
          hostname: V,
          protocol: re,
          port: oe,
          servername: H[f],
          localAddress: H[pt]
        }, (We, lt) => {
          We ? Oe(We) : He(lt);
        });
      });
      if (H.destroyed) {
        s.destroy(me.on("error", () => {
        }), new y());
        return;
      }
      if (H[O] = !1, t(me), me.alpnProtocol === "h2") {
        De || (De = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
          code: "UNDICI-H2"
        }));
        const He = St.connect(H[I], {
          createConnection: () => me,
          peerMaxConcurrentStreams: H[Ee].maxConcurrentStreams
        });
        H[Ot] = "h2", He[C] = H, He[G] = me, He.on("error", le), He.on("frameError", Ae), He.on("end", Be), He.on("goaway", he), He.on("close", ai), He.unref(), H[ce] = He, me[ce] = He;
      } else
        _r || (_r = await bn, bn = null), me[M] = !1, me[k] = !1, me[w] = !1, me[R] = !1, me[N] = new oi(H, me, _r);
      me[_e] = 0, me[xe] = H[xe], me[C] = H, me[te] = null, me.on("error", wn).on("readable", Hr).on("end", gn).on("close", ai), H[G] = me, ee.connected.hasSubscribers && ee.connected.publish({
        connectParams: {
          host: Y,
          hostname: V,
          protocol: re,
          port: oe,
          servername: H[f],
          localAddress: H[pt]
        },
        connector: H[Ce],
        socket: me
      }), H.emit("connect", H[I], [H]);
    } catch (me) {
      if (H.destroyed)
        return;
      if (H[O] = !1, ee.connectError.hasSubscribers && ee.connectError.publish({
        connectParams: {
          host: Y,
          hostname: V,
          protocol: re,
          port: oe,
          servername: H[f],
          localAddress: H[pt]
        },
        connector: H[Ce],
        error: me
      }), me.code === "ERR_TLS_CERT_ALTNAME_INVALID")
        for (t(H[S] === 0); H[D] > 0 && H[L][H[J]].servername === H[f]; ) {
          const Ge = H[L][H[J]++];
          cr(H, Ge, me);
        }
      else
        sn(H, me);
      H.emit("connectionError", H[I], [H], me);
    }
    Ut(H);
  }
  function zr(H) {
    H[_] = 0, H.emit("drain", H[I], [H]);
  }
  function Ut(H, Y) {
    H[x] !== 2 && (H[x] = 2, Ai(H, Y), H[x] = 0, H[j] > 256 && (H[L].splice(0, H[j]), H[J] -= H[j], H[j] = 0));
  }
  function Ai(H, Y) {
    for (; ; ) {
      if (H.destroyed) {
        t(H[D] === 0);
        return;
      }
      if (H[Pe] && !H[T]) {
        H[Pe](), H[Pe] = null;
        return;
      }
      const V = H[G];
      if (V && !V.destroyed && V.alpnProtocol !== "h2") {
        if (H[T] === 0 ? !V[M] && V.unref && (V.unref(), V[M] = !0) : V[M] && V.ref && (V.ref(), V[M] = !1), H[T] === 0)
          V[N].timeoutType !== Gt && V[N].setTimeout(H[q], Gt);
        else if (H[S] > 0 && V[N].statusCode < 200 && V[N].timeoutType !== qr) {
          const oe = H[L][H[j]], me = oe.headersTimeout != null ? oe.headersTimeout : H[ne];
          V[N].setTimeout(me, qr);
        }
      }
      if (H[b])
        H[_] = 2;
      else if (H[_] === 2) {
        Y ? (H[_] = 1, process.nextTick(zr, H)) : zr(H);
        continue;
      }
      if (H[D] === 0 || H[S] >= (H[ie] || 1))
        return;
      const re = H[L][H[J]];
      if (H[I].protocol === "https:" && H[f] !== re.servername) {
        if (H[S] > 0)
          return;
        if (H[f] = re.servername, V && V.servername !== re.servername) {
          s.destroy(V, new d("servername changed"));
          return;
        }
      }
      if (H[O])
        return;
      if (!V && !H[ce]) {
        Cr(H);
        return;
      }
      if (V.destroyed || V[k] || V[w] || V[R] || H[S] > 0 && !re.idempotent || H[S] > 0 && (re.upgrade || re.method === "CONNECT") || H[S] > 0 && s.bodyLength(re.body) !== 0 && (s.isStream(re.body) || s.isAsyncIterable(re.body)))
        return;
      !re.aborted && xQ(H, re) ? H[J]++ : H[L].splice(H[J], 1);
    }
  }
  function Cd(H) {
    return H !== "GET" && H !== "HEAD" && H !== "OPTIONS" && H !== "TRACE" && H !== "CONNECT";
  }
  function xQ(H, Y) {
    if (H[Ot] === "h2") {
      DQ(H, H[ce], Y);
      return;
    }
    const { body: V, method: re, path: oe, host: me, upgrade: Ge, headers: He, blocking: Oe, reset: We } = Y, lt = re === "PUT" || re === "POST" || re === "PATCH";
    V && typeof V.read == "function" && V.read(0);
    const it = s.bodyLength(V);
    let ke = it;
    if (ke === null && (ke = Y.contentLength), ke === 0 && !lt && (ke = null), Cd(re) && ke > 0 && Y.contentLength !== null && Y.contentLength !== ke) {
      if (H[ve])
        return cr(H, Y, new l()), !1;
      process.emitWarning(new l());
    }
    const Le = H[G];
    try {
      Y.onConnect((ut) => {
        Y.aborted || Y.completed || (cr(H, Y, ut || new u()), s.destroy(Le, new d("aborted")));
      });
    } catch (ut) {
      cr(H, Y, ut);
    }
    if (Y.aborted)
      return !1;
    re === "HEAD" && (Le[w] = !0), (Ge || re === "CONNECT") && (Le[w] = !0), We != null && (Le[w] = We), H[xe] && Le[_e]++ >= H[xe] && (Le[w] = !0), Oe && (Le[R] = !0);
    let Ye = `${re} ${oe} HTTP/1.1\r
`;
    return typeof me == "string" ? Ye += `host: ${me}\r
` : Ye += H[U], Ge ? Ye += `connection: upgrade\r
upgrade: ${Ge}\r
` : H[ie] && !Le[w] ? Ye += `connection: keep-alive\r
` : Ye += `connection: close\r
`, He && (Ye += He), ee.sendHeaders.hasSubscribers && ee.sendHeaders.publish({ request: Y, headers: Ye, socket: Le }), !V || it === 0 ? (ke === 0 ? Le.write(`${Ye}content-length: 0\r
\r
`, "latin1") : (t(ke === null, "no body must not have content length"), Le.write(`${Ye}\r
`, "latin1")), Y.onRequestSent()) : s.isBuffer(V) ? (t(ke === V.byteLength, "buffer body must have content length"), Le.cork(), Le.write(`${Ye}content-length: ${ke}\r
\r
`, "latin1"), Le.write(V), Le.uncork(), Y.onBodySent(V), Y.onRequestSent(), lt || (Le[w] = !0)) : s.isBlobLike(V) ? typeof V.stream == "function" ? ho({ body: V.stream(), client: H, request: Y, socket: Le, contentLength: ke, header: Ye, expectsPayload: lt }) : Id({ body: V, client: H, request: Y, socket: Le, contentLength: ke, header: Ye, expectsPayload: lt }) : s.isStream(V) ? Bd({ body: V, client: H, request: Y, socket: Le, contentLength: ke, header: Ye, expectsPayload: lt }) : s.isIterable(V) ? ho({ body: V, client: H, request: Y, socket: Le, contentLength: ke, header: Ye, expectsPayload: lt }) : t(!1), !0;
  }
  function DQ(H, Y, V) {
    const { body: re, method: oe, path: me, host: Ge, upgrade: He, expectContinue: Oe, signal: We, headers: lt } = V;
    let it;
    if (typeof lt == "string" ? it = o[$e](lt.trim()) : it = lt, He)
      return cr(H, V, new Error("Upgrade not supported for H2")), !1;
    try {
      V.onConnect((Br) => {
        V.aborted || V.completed || cr(H, V, Br || new u());
      });
    } catch (Br) {
      cr(H, V, Br);
    }
    if (V.aborted)
      return !1;
    let ke;
    const Le = H[Ee];
    if (it[Vt] = Ge || H[K], it[P] = oe, oe === "CONNECT")
      return Y.ref(), ke = Y.request(it, { endStream: !1, signal: We }), ke.id && !ke.pending ? (V.onUpgrade(null, null, ke), ++Le.openStreams) : ke.once("ready", () => {
        V.onUpgrade(null, null, ke), ++Le.openStreams;
      }), ke.once("close", () => {
        Le.openStreams -= 1, Le.openStreams === 0 && Y.unref();
      }), !0;
    it[z] = me, it[X] = "https";
    const Ye = oe === "PUT" || oe === "POST" || oe === "PATCH";
    re && typeof re.read == "function" && re.read(0);
    let ut = s.bodyLength(re);
    if (ut == null && (ut = V.contentLength), (ut === 0 || !Ye) && (ut = null), Cd(oe) && ut > 0 && V.contentLength != null && V.contentLength !== ut) {
      if (H[ve])
        return cr(H, V, new l()), !1;
      process.emitWarning(new l());
    }
    ut != null && (t(re, "no body must not have content length"), it[ae] = `${ut}`), Y.ref();
    const Yr = oe === "GET" || oe === "HEAD";
    return Oe ? (it[ge] = "100-continue", ke = Y.request(it, { endStream: Yr, signal: We }), ke.once("continue", po)) : (ke = Y.request(it, {
      endStream: Yr,
      signal: We
    }), po()), ++Le.openStreams, ke.once("response", (Br) => {
      const { [Ie]: ci, ...on } = Br;
      V.onHeaders(Number(ci), on, ke.resume.bind(ke), "") === !1 && ke.pause();
    }), ke.once("end", () => {
      V.onComplete([]);
    }), ke.on("data", (Br) => {
      V.onData(Br) === !1 && ke.pause();
    }), ke.once("close", () => {
      Le.openStreams -= 1, Le.openStreams === 0 && Y.unref();
    }), ke.once("error", function(Br) {
      H[ce] && !H[ce].destroyed && !this.closed && !this.destroyed && (Le.streams -= 1, s.destroy(ke, Br));
    }), ke.once("frameError", (Br, ci) => {
      const on = new d(`HTTP/2: "frameError" received - type ${Br}, code ${ci}`);
      cr(H, V, on), H[ce] && !H[ce].destroyed && !this.closed && !this.destroyed && (Le.streams -= 1, s.destroy(ke, on));
    }), !0;
    function po() {
      re ? s.isBuffer(re) ? (t(ut === re.byteLength, "buffer body must have content length"), ke.cork(), ke.write(re), ke.uncork(), ke.end(), V.onBodySent(re), V.onRequestSent()) : s.isBlobLike(re) ? typeof re.stream == "function" ? ho({
        client: H,
        request: V,
        contentLength: ut,
        h2stream: ke,
        expectsPayload: Ye,
        body: re.stream(),
        socket: H[G],
        header: ""
      }) : Id({
        body: re,
        client: H,
        request: V,
        contentLength: ut,
        expectsPayload: Ye,
        h2stream: ke,
        header: "",
        socket: H[G]
      }) : s.isStream(re) ? Bd({
        body: re,
        client: H,
        request: V,
        contentLength: ut,
        expectsPayload: Ye,
        socket: H[G],
        h2stream: ke,
        header: ""
      }) : s.isIterable(re) ? ho({
        body: re,
        client: H,
        request: V,
        contentLength: ut,
        expectsPayload: Ye,
        header: "",
        h2stream: ke,
        socket: H[G]
      }) : t(!1) : V.onRequestSent();
    }
  }
  function Bd({ h2stream: H, body: Y, client: V, request: re, socket: oe, contentLength: me, header: Ge, expectsPayload: He }) {
    if (t(me !== 0 || V[S] === 0, "stream body cannot be pipelined"), V[Ot] === "h2") {
      let ut = function(Yr) {
        re.onBodySent(Yr);
      };
      const Ye = n(
        Y,
        H,
        (Yr) => {
          Yr ? (s.destroy(Y, Yr), s.destroy(H, Yr)) : re.onRequestSent();
        }
      );
      Ye.on("data", ut), Ye.once("end", () => {
        Ye.removeListener("data", ut), s.destroy(Ye);
      });
      return;
    }
    let Oe = !1;
    const We = new yd({ socket: oe, request: re, contentLength: me, client: V, expectsPayload: He, header: Ge }), lt = function(Ye) {
      if (!Oe)
        try {
          !We.write(Ye) && this.pause && this.pause();
        } catch (ut) {
          s.destroy(this, ut);
        }
    }, it = function() {
      Oe || Y.resume && Y.resume();
    }, ke = function() {
      if (Oe)
        return;
      const Ye = new u();
      queueMicrotask(() => Le(Ye));
    }, Le = function(Ye) {
      if (!Oe) {
        if (Oe = !0, t(oe.destroyed || oe[k] && V[S] <= 1), oe.off("drain", it).off("error", Le), Y.removeListener("data", lt).removeListener("end", Le).removeListener("error", Le).removeListener("close", ke), !Ye)
          try {
            We.end();
          } catch (ut) {
            Ye = ut;
          }
        We.destroy(Ye), Ye && (Ye.code !== "UND_ERR_INFO" || Ye.message !== "reset") ? s.destroy(Y, Ye) : s.destroy(Y);
      }
    };
    Y.on("data", lt).on("end", Le).on("error", Le).on("close", ke), Y.resume && Y.resume(), oe.on("drain", it).on("error", Le);
  }
  async function Id({ h2stream: H, body: Y, client: V, request: re, socket: oe, contentLength: me, header: Ge, expectsPayload: He }) {
    t(me === Y.size, "blob body must have content length");
    const Oe = V[Ot] === "h2";
    try {
      if (me != null && me !== Y.size)
        throw new l();
      const We = Buffer.from(await Y.arrayBuffer());
      Oe ? (H.cork(), H.write(We), H.uncork()) : (oe.cork(), oe.write(`${Ge}content-length: ${me}\r
\r
`, "latin1"), oe.write(We), oe.uncork()), re.onBodySent(We), re.onRequestSent(), He || (oe[w] = !0), Ut(V);
    } catch (We) {
      s.destroy(Oe ? H : oe, We);
    }
  }
  async function ho({ h2stream: H, body: Y, client: V, request: re, socket: oe, contentLength: me, header: Ge, expectsPayload: He }) {
    t(me !== 0 || V[S] === 0, "iterator body cannot be pipelined");
    let Oe = null;
    function We() {
      if (Oe) {
        const ke = Oe;
        Oe = null, ke();
      }
    }
    const lt = () => new Promise((ke, Le) => {
      t(Oe === null), oe[te] ? Le(oe[te]) : Oe = ke;
    });
    if (V[Ot] === "h2") {
      H.on("close", We).on("drain", We);
      try {
        for await (const ke of Y) {
          if (oe[te])
            throw oe[te];
          const Le = H.write(ke);
          re.onBodySent(ke), Le || await lt();
        }
      } catch (ke) {
        H.destroy(ke);
      } finally {
        re.onRequestSent(), H.end(), H.off("close", We).off("drain", We);
      }
      return;
    }
    oe.on("close", We).on("drain", We);
    const it = new yd({ socket: oe, request: re, contentLength: me, client: V, expectsPayload: He, header: Ge });
    try {
      for await (const ke of Y) {
        if (oe[te])
          throw oe[te];
        it.write(ke) || await lt();
      }
      it.end();
    } catch (ke) {
      it.destroy(ke);
    } finally {
      oe.off("close", We).off("drain", We);
    }
  }
  class yd {
    constructor({ socket: Y, request: V, contentLength: re, client: oe, expectsPayload: me, header: Ge }) {
      this.socket = Y, this.request = V, this.contentLength = re, this.client = oe, this.bytesWritten = 0, this.expectsPayload = me, this.header = Ge, Y[k] = !0;
    }
    write(Y) {
      const { socket: V, request: re, contentLength: oe, client: me, bytesWritten: Ge, expectsPayload: He, header: Oe } = this;
      if (V[te])
        throw V[te];
      if (V.destroyed)
        return !1;
      const We = Buffer.byteLength(Y);
      if (!We)
        return !0;
      if (oe !== null && Ge + We > oe) {
        if (me[ve])
          throw new l();
        process.emitWarning(new l());
      }
      V.cork(), Ge === 0 && (He || (V[w] = !0), oe === null ? V.write(`${Oe}transfer-encoding: chunked\r
`, "latin1") : V.write(`${Oe}content-length: ${oe}\r
\r
`, "latin1")), oe === null && V.write(`\r
${We.toString(16)}\r
`, "latin1"), this.bytesWritten += We;
      const lt = V.write(Y);
      return V.uncork(), re.onBodySent(Y), lt || V[N].timeout && V[N].timeoutType === qr && V[N].timeout.refresh && V[N].timeout.refresh(), lt;
    }
    end() {
      const { socket: Y, contentLength: V, client: re, bytesWritten: oe, expectsPayload: me, header: Ge, request: He } = this;
      if (He.onRequestSent(), Y[k] = !1, Y[te])
        throw Y[te];
      if (!Y.destroyed) {
        if (oe === 0 ? me ? Y.write(`${Ge}content-length: 0\r
\r
`, "latin1") : Y.write(`${Ge}\r
`, "latin1") : V === null && Y.write(`\r
0\r
\r
`, "latin1"), V !== null && oe !== V) {
          if (re[ve])
            throw new l();
          process.emitWarning(new l());
        }
        Y[N].timeout && Y[N].timeoutType === qr && Y[N].timeout.refresh && Y[N].timeout.refresh(), Ut(re);
      }
    }
    destroy(Y) {
      const { socket: V, client: re } = this;
      V[k] = !1, Y && (t(re[S] <= 1, "pipeline should only contain this request"), s.destroy(V, Y));
    }
  }
  function cr(H, Y, V) {
    try {
      Y.onError(V), t(Y.aborted);
    } catch (re) {
      H.emit("error", re);
    }
  }
  return CA = fe, CA;
}
var BA, vg;
function hb() {
  if (vg) return BA;
  vg = 1;
  const t = 2048, e = t - 1;
  class r {
    constructor() {
      this.bottom = 0, this.top = 0, this.list = new Array(t), this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & e) === this.bottom;
    }
    push(s) {
      this.list[this.top] = s, this.top = this.top + 1 & e;
    }
    shift() {
      const s = this.list[this.bottom];
      return s === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & e, s);
    }
  }
  return BA = class {
    constructor() {
      this.head = this.tail = new r();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(s) {
      this.head.isFull() && (this.head = this.head.next = new r()), this.head.push(s);
    }
    shift() {
      const s = this.tail, i = s.shift();
      return s.isEmpty() && s.next !== null && (this.tail = s.next), i;
    }
  }, BA;
}
var IA, xg;
function pb() {
  if (xg) return IA;
  xg = 1;
  const { kFree: t, kConnected: e, kPending: r, kQueued: n, kRunning: s, kSize: i } = Nt(), o = Symbol("pool");
  class c {
    constructor(A) {
      this[o] = A;
    }
    get connected() {
      return this[o][e];
    }
    get free() {
      return this[o][t];
    }
    get pending() {
      return this[o][r];
    }
    get queued() {
      return this[o][n];
    }
    get running() {
      return this[o][s];
    }
    get size() {
      return this[o][i];
    }
  }
  return IA = c, IA;
}
var yA, Dg;
function Ff() {
  if (Dg) return yA;
  Dg = 1;
  const t = sa(), e = hb(), { kConnected: r, kSize: n, kRunning: s, kPending: i, kQueued: o, kBusy: c, kFree: l, kUrl: A, kClose: a, kDestroy: u, kDispatch: g } = Nt(), h = pb(), m = Symbol("clients"), d = Symbol("needDrain"), p = Symbol("queue"), E = Symbol("closed resolve"), B = Symbol("onDrain"), y = Symbol("onConnect"), Q = Symbol("onDisconnect"), I = Symbol("onConnectionError"), w = Symbol("get dispatcher"), f = Symbol("add client"), C = Symbol("remove client"), b = Symbol("stats");
  class N extends t {
    constructor() {
      super(), this[p] = new e(), this[m] = [], this[o] = 0;
      const R = this;
      this[B] = function(S, D) {
        const T = R[p];
        let k = !1;
        for (; !k; ) {
          const L = T.shift();
          if (!L)
            break;
          R[o]--, k = !this.dispatch(L.opts, L.handler);
        }
        this[d] = k, !this[d] && R[d] && (R[d] = !1, R.emit("drain", S, [R, ...D])), R[E] && T.isEmpty() && Promise.all(R[m].map((L) => L.close())).then(R[E]);
      }, this[y] = (x, S) => {
        R.emit("connect", x, [R, ...S]);
      }, this[Q] = (x, S, D) => {
        R.emit("disconnect", x, [R, ...S], D);
      }, this[I] = (x, S, D) => {
        R.emit("connectionError", x, [R, ...S], D);
      }, this[b] = new h(this);
    }
    get [c]() {
      return this[d];
    }
    get [r]() {
      return this[m].filter((R) => R[r]).length;
    }
    get [l]() {
      return this[m].filter((R) => R[r] && !R[d]).length;
    }
    get [i]() {
      let R = this[o];
      for (const { [i]: x } of this[m])
        R += x;
      return R;
    }
    get [s]() {
      let R = 0;
      for (const { [s]: x } of this[m])
        R += x;
      return R;
    }
    get [n]() {
      let R = this[o];
      for (const { [n]: x } of this[m])
        R += x;
      return R;
    }
    get stats() {
      return this[b];
    }
    async [a]() {
      return this[p].isEmpty() ? Promise.all(this[m].map((R) => R.close())) : new Promise((R) => {
        this[E] = R;
      });
    }
    async [u](R) {
      for (; ; ) {
        const x = this[p].shift();
        if (!x)
          break;
        x.handler.onError(R);
      }
      return Promise.all(this[m].map((x) => x.destroy(R)));
    }
    [g](R, x) {
      const S = this[w]();
      return S ? S.dispatch(R, x) || (S[d] = !0, this[d] = !this[w]()) : (this[d] = !0, this[p].push({ opts: R, handler: x }), this[o]++), !this[d];
    }
    [f](R) {
      return R.on("drain", this[B]).on("connect", this[y]).on("disconnect", this[Q]).on("connectionError", this[I]), this[m].push(R), this[d] && process.nextTick(() => {
        this[d] && this[B](R[A], [this, R]);
      }), this;
    }
    [C](R) {
      R.close(() => {
        const x = this[m].indexOf(R);
        x !== -1 && this[m].splice(x, 1);
      }), this[d] = this[m].some((x) => !x[d] && x.closed !== !0 && x.destroyed !== !0);
    }
  }
  return yA = {
    PoolBase: N,
    kClients: m,
    kNeedDrain: d,
    kAddClient: f,
    kRemoveClient: C,
    kGetDispatcher: w
  }, yA;
}
var QA, Tg;
function $i() {
  if (Tg) return QA;
  Tg = 1;
  const {
    PoolBase: t,
    kClients: e,
    kNeedDrain: r,
    kAddClient: n,
    kGetDispatcher: s
  } = Ff(), i = oa(), {
    InvalidArgumentError: o
  } = ft(), c = rt(), { kUrl: l, kInterceptors: A } = Nt(), a = ia(), u = Symbol("options"), g = Symbol("connections"), h = Symbol("factory");
  function m(p, E) {
    return new i(p, E);
  }
  class d extends t {
    constructor(E, {
      connections: B,
      factory: y = m,
      connect: Q,
      connectTimeout: I,
      tls: w,
      maxCachedSessions: f,
      socketPath: C,
      autoSelectFamily: b,
      autoSelectFamilyAttemptTimeout: N,
      allowH2: v,
      ...R
    } = {}) {
      if (super(), B != null && (!Number.isFinite(B) || B < 0))
        throw new o("invalid connections");
      if (typeof y != "function")
        throw new o("factory must be a function.");
      if (Q != null && typeof Q != "function" && typeof Q != "object")
        throw new o("connect must be a function or an object");
      typeof Q != "function" && (Q = a({
        ...w,
        maxCachedSessions: f,
        allowH2: v,
        socketPath: C,
        timeout: I,
        ...c.nodeHasAutoSelectFamily && b ? { autoSelectFamily: b, autoSelectFamilyAttemptTimeout: N } : void 0,
        ...Q
      })), this[A] = R.interceptors && R.interceptors.Pool && Array.isArray(R.interceptors.Pool) ? R.interceptors.Pool : [], this[g] = B || null, this[l] = c.parseOrigin(E), this[u] = { ...c.deepClone(R), connect: Q, allowH2: v }, this[u].interceptors = R.interceptors ? { ...R.interceptors } : void 0, this[h] = y, this.on("connectionError", (x, S, D) => {
        for (const T of S) {
          const k = this[e].indexOf(T);
          k !== -1 && this[e].splice(k, 1);
        }
      });
    }
    [s]() {
      let E = this[e].find((B) => !B[r]);
      return E || ((!this[g] || this[e].length < this[g]) && (E = this[h](this[l], this[u]), this[n](E)), E);
    }
  }
  return QA = d, QA;
}
var bA, kg;
function fb() {
  if (kg) return bA;
  kg = 1;
  const {
    BalancedPoolMissingUpstreamError: t,
    InvalidArgumentError: e
  } = ft(), {
    PoolBase: r,
    kClients: n,
    kNeedDrain: s,
    kAddClient: i,
    kRemoveClient: o,
    kGetDispatcher: c
  } = Ff(), l = $i(), { kUrl: A, kInterceptors: a } = Nt(), { parseOrigin: u } = rt(), g = Symbol("factory"), h = Symbol("options"), m = Symbol("kGreatestCommonDivisor"), d = Symbol("kCurrentWeight"), p = Symbol("kIndex"), E = Symbol("kWeight"), B = Symbol("kMaxWeightPerServer"), y = Symbol("kErrorPenalty");
  function Q(f, C) {
    return C === 0 ? f : Q(C, f % C);
  }
  function I(f, C) {
    return new l(f, C);
  }
  class w extends r {
    constructor(C = [], { factory: b = I, ...N } = {}) {
      if (super(), this[h] = N, this[p] = -1, this[d] = 0, this[B] = this[h].maxWeightPerServer || 100, this[y] = this[h].errorPenalty || 15, Array.isArray(C) || (C = [C]), typeof b != "function")
        throw new e("factory must be a function.");
      this[a] = N.interceptors && N.interceptors.BalancedPool && Array.isArray(N.interceptors.BalancedPool) ? N.interceptors.BalancedPool : [], this[g] = b;
      for (const v of C)
        this.addUpstream(v);
      this._updateBalancedPoolStats();
    }
    addUpstream(C) {
      const b = u(C).origin;
      if (this[n].find((v) => v[A].origin === b && v.closed !== !0 && v.destroyed !== !0))
        return this;
      const N = this[g](b, Object.assign({}, this[h]));
      this[i](N), N.on("connect", () => {
        N[E] = Math.min(this[B], N[E] + this[y]);
      }), N.on("connectionError", () => {
        N[E] = Math.max(1, N[E] - this[y]), this._updateBalancedPoolStats();
      }), N.on("disconnect", (...v) => {
        const R = v[2];
        R && R.code === "UND_ERR_SOCKET" && (N[E] = Math.max(1, N[E] - this[y]), this._updateBalancedPoolStats());
      });
      for (const v of this[n])
        v[E] = this[B];
      return this._updateBalancedPoolStats(), this;
    }
    _updateBalancedPoolStats() {
      this[m] = this[n].map((C) => C[E]).reduce(Q, 0);
    }
    removeUpstream(C) {
      const b = u(C).origin, N = this[n].find((v) => v[A].origin === b && v.closed !== !0 && v.destroyed !== !0);
      return N && this[o](N), this;
    }
    get upstreams() {
      return this[n].filter((C) => C.closed !== !0 && C.destroyed !== !0).map((C) => C[A].origin);
    }
    [c]() {
      if (this[n].length === 0)
        throw new t();
      if (!this[n].find((R) => !R[s] && R.closed !== !0 && R.destroyed !== !0) || this[n].map((R) => R[s]).reduce((R, x) => R && x, !0))
        return;
      let N = 0, v = this[n].findIndex((R) => !R[s]);
      for (; N++ < this[n].length; ) {
        this[p] = (this[p] + 1) % this[n].length;
        const R = this[n][this[p]];
        if (R[E] > this[n][v][E] && !R[s] && (v = this[p]), this[p] === 0 && (this[d] = this[d] - this[m], this[d] <= 0 && (this[d] = this[B])), R[E] >= this[d] && !R[s])
          return R;
      }
      return this[d] = this[n][v][E], this[p] = v, this[n][v];
    }
  }
  return bA = w, bA;
}
var wA, Fg;
function Pf() {
  if (Fg) return wA;
  Fg = 1;
  const { kConnected: t, kSize: e } = Nt();
  class r {
    constructor(i) {
      this.value = i;
    }
    deref() {
      return this.value[t] === 0 && this.value[e] === 0 ? void 0 : this.value;
    }
  }
  class n {
    constructor(i) {
      this.finalizer = i;
    }
    register(i, o) {
      i.on && i.on("disconnect", () => {
        i[t] === 0 && i[e] === 0 && this.finalizer(o);
      });
    }
  }
  return wA = function() {
    return process.env.NODE_V8_COVERAGE ? {
      WeakRef: r,
      FinalizationRegistry: n
    } : {
      WeakRef: Ui.WeakRef || r,
      FinalizationRegistry: Ui.FinalizationRegistry || n
    };
  }, wA;
}
var NA, Pg;
function aa() {
  if (Pg) return NA;
  Pg = 1;
  const { InvalidArgumentError: t } = ft(), { kClients: e, kRunning: r, kClose: n, kDestroy: s, kDispatch: i, kInterceptors: o } = Nt(), c = sa(), l = $i(), A = oa(), a = rt(), u = du(), { WeakRef: g, FinalizationRegistry: h } = Pf()(), m = Symbol("onConnect"), d = Symbol("onDisconnect"), p = Symbol("onConnectionError"), E = Symbol("maxRedirections"), B = Symbol("onDrain"), y = Symbol("factory"), Q = Symbol("finalizer"), I = Symbol("options");
  function w(C, b) {
    return b && b.connections === 1 ? new A(C, b) : new l(C, b);
  }
  class f extends c {
    constructor({ factory: b = w, maxRedirections: N = 0, connect: v, ...R } = {}) {
      if (super(), typeof b != "function")
        throw new t("factory must be a function.");
      if (v != null && typeof v != "function" && typeof v != "object")
        throw new t("connect must be a function or an object");
      if (!Number.isInteger(N) || N < 0)
        throw new t("maxRedirections must be a positive number");
      v && typeof v != "function" && (v = { ...v }), this[o] = R.interceptors && R.interceptors.Agent && Array.isArray(R.interceptors.Agent) ? R.interceptors.Agent : [u({ maxRedirections: N })], this[I] = { ...a.deepClone(R), connect: v }, this[I].interceptors = R.interceptors ? { ...R.interceptors } : void 0, this[E] = N, this[y] = b, this[e] = /* @__PURE__ */ new Map(), this[Q] = new h(
        /* istanbul ignore next: gc is undeterministic */
        (S) => {
          const D = this[e].get(S);
          D !== void 0 && D.deref() === void 0 && this[e].delete(S);
        }
      );
      const x = this;
      this[B] = (S, D) => {
        x.emit("drain", S, [x, ...D]);
      }, this[m] = (S, D) => {
        x.emit("connect", S, [x, ...D]);
      }, this[d] = (S, D, T) => {
        x.emit("disconnect", S, [x, ...D], T);
      }, this[p] = (S, D, T) => {
        x.emit("connectionError", S, [x, ...D], T);
      };
    }
    get [r]() {
      let b = 0;
      for (const N of this[e].values()) {
        const v = N.deref();
        v && (b += v[r]);
      }
      return b;
    }
    [i](b, N) {
      let v;
      if (b.origin && (typeof b.origin == "string" || b.origin instanceof URL))
        v = String(b.origin);
      else
        throw new t("opts.origin must be a non-empty string or URL.");
      const R = this[e].get(v);
      let x = R ? R.deref() : null;
      return x || (x = this[y](b.origin, this[I]).on("drain", this[B]).on("connect", this[m]).on("disconnect", this[d]).on("connectionError", this[p]), this[e].set(v, new g(x)), this[Q].register(x, v)), x.dispatch(b, N);
    }
    async [n]() {
      const b = [];
      for (const N of this[e].values()) {
        const v = N.deref();
        v && b.push(v.close());
      }
      await Promise.all(b);
    }
    async [s](b) {
      const N = [];
      for (const v of this[e].values()) {
        const R = v.deref();
        R && N.push(R.destroy(b));
      }
      await Promise.all(N);
    }
  }
  return NA = f, NA;
}
var zn = {}, yo = { exports: {} }, RA, Ug;
function Eb() {
  if (Ug) return RA;
  Ug = 1;
  const t = bt, { Readable: e } = ln, { RequestAbortedError: r, NotSupportedError: n, InvalidArgumentError: s } = ft(), i = rt(), { ReadableStreamFrom: o, toUSVString: c } = rt();
  let l;
  const A = Symbol("kConsume"), a = Symbol("kReading"), u = Symbol("kBody"), g = Symbol("abort"), h = Symbol("kContentType"), m = () => {
  };
  RA = class extends e {
    constructor({
      resume: f,
      abort: C,
      contentType: b = "",
      highWaterMark: N = 64 * 1024
      // Same as nodejs fs streams.
    }) {
      super({
        autoDestroy: !0,
        read: f,
        highWaterMark: N
      }), this._readableState.dataEmitted = !1, this[g] = C, this[A] = null, this[u] = null, this[h] = b, this[a] = !1;
    }
    destroy(f) {
      return this.destroyed ? this : (!f && !this._readableState.endEmitted && (f = new r()), f && this[g](), super.destroy(f));
    }
    emit(f, ...C) {
      return f === "data" ? this._readableState.dataEmitted = !0 : f === "error" && (this._readableState.errorEmitted = !0), super.emit(f, ...C);
    }
    on(f, ...C) {
      return (f === "data" || f === "readable") && (this[a] = !0), super.on(f, ...C);
    }
    addListener(f, ...C) {
      return this.on(f, ...C);
    }
    off(f, ...C) {
      const b = super.off(f, ...C);
      return (f === "data" || f === "readable") && (this[a] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), b;
    }
    removeListener(f, ...C) {
      return this.off(f, ...C);
    }
    push(f) {
      return this[A] && f !== null && this.readableLength === 0 ? (Q(this[A], f), this[a] ? super.push(f) : !0) : super.push(f);
    }
    // https://fetch.spec.whatwg.org/#dom-body-text
    async text() {
      return E(this, "text");
    }
    // https://fetch.spec.whatwg.org/#dom-body-json
    async json() {
      return E(this, "json");
    }
    // https://fetch.spec.whatwg.org/#dom-body-blob
    async blob() {
      return E(this, "blob");
    }
    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
    async arrayBuffer() {
      return E(this, "arrayBuffer");
    }
    // https://fetch.spec.whatwg.org/#dom-body-formdata
    async formData() {
      throw new n();
    }
    // https://fetch.spec.whatwg.org/#dom-body-bodyused
    get bodyUsed() {
      return i.isDisturbed(this);
    }
    // https://fetch.spec.whatwg.org/#dom-body-body
    get body() {
      return this[u] || (this[u] = o(this), this[A] && (this[u].getReader(), t(this[u].locked))), this[u];
    }
    dump(f) {
      let C = f && Number.isFinite(f.limit) ? f.limit : 262144;
      const b = f && f.signal;
      if (b)
        try {
          if (typeof b != "object" || !("aborted" in b))
            throw new s("signal must be an AbortSignal");
          i.throwIfAborted(b);
        } catch (N) {
          return Promise.reject(N);
        }
      return this.closed ? Promise.resolve(null) : new Promise((N, v) => {
        const R = b ? i.addAbortListener(b, () => {
          this.destroy();
        }) : m;
        this.on("close", function() {
          R(), b && b.aborted ? v(b.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" })) : N(null);
        }).on("error", m).on("data", function(x) {
          C -= x.length, C <= 0 && this.destroy();
        }).resume();
      });
    }
  };
  function d(w) {
    return w[u] && w[u].locked === !0 || w[A];
  }
  function p(w) {
    return i.isDisturbed(w) || d(w);
  }
  async function E(w, f) {
    if (p(w))
      throw new TypeError("unusable");
    return t(!w[A]), new Promise((C, b) => {
      w[A] = {
        type: f,
        stream: w,
        resolve: C,
        reject: b,
        length: 0,
        body: []
      }, w.on("error", function(N) {
        I(this[A], N);
      }).on("close", function() {
        this[A].body !== null && I(this[A], new r());
      }), process.nextTick(B, w[A]);
    });
  }
  function B(w) {
    if (w.body === null)
      return;
    const { _readableState: f } = w.stream;
    for (const C of f.buffer)
      Q(w, C);
    for (f.endEmitted ? y(this[A]) : w.stream.on("end", function() {
      y(this[A]);
    }), w.stream.resume(); w.stream.read() != null; )
      ;
  }
  function y(w) {
    const { type: f, body: C, resolve: b, stream: N, length: v } = w;
    try {
      if (f === "text")
        b(c(Buffer.concat(C)));
      else if (f === "json")
        b(JSON.parse(Buffer.concat(C)));
      else if (f === "arrayBuffer") {
        const R = new Uint8Array(v);
        let x = 0;
        for (const S of C)
          R.set(S, x), x += S.byteLength;
        b(R.buffer);
      } else f === "blob" && (l || (l = require("buffer").Blob), b(new l(C, { type: N[h] })));
      I(w);
    } catch (R) {
      N.destroy(R);
    }
  }
  function Q(w, f) {
    w.length += f.length, w.body.push(f);
  }
  function I(w, f) {
    w.body !== null && (f ? w.reject(f) : w.resolve(), w.type = null, w.stream = null, w.resolve = null, w.reject = null, w.length = 0, w.body = null);
  }
  return RA;
}
var SA, Lg;
function Uf() {
  if (Lg) return SA;
  Lg = 1;
  const t = bt, {
    ResponseStatusCodeError: e
  } = ft(), { toUSVString: r } = rt();
  async function n({ callback: s, body: i, contentType: o, statusCode: c, statusMessage: l, headers: A }) {
    t(i);
    let a = [], u = 0;
    for await (const g of i)
      if (a.push(g), u += g.length, u > 128 * 1024) {
        a = null;
        break;
      }
    if (c === 204 || !o || !a) {
      process.nextTick(s, new e(`Response status code ${c}${l ? `: ${l}` : ""}`, c, A));
      return;
    }
    try {
      if (o.startsWith("application/json")) {
        const g = JSON.parse(r(Buffer.concat(a)));
        process.nextTick(s, new e(`Response status code ${c}${l ? `: ${l}` : ""}`, c, A, g));
        return;
      }
      if (o.startsWith("text/")) {
        const g = r(Buffer.concat(a));
        process.nextTick(s, new e(`Response status code ${c}${l ? `: ${l}` : ""}`, c, A, g));
        return;
      }
    } catch {
    }
    process.nextTick(s, new e(`Response status code ${c}${l ? `: ${l}` : ""}`, c, A));
  }
  return SA = { getResolveErrorBodyCallback: n }, SA;
}
var vA, _g;
function Xi() {
  if (_g) return vA;
  _g = 1;
  const { addAbortListener: t } = rt(), { RequestAbortedError: e } = ft(), r = Symbol("kListener"), n = Symbol("kSignal");
  function s(c) {
    c.abort ? c.abort() : c.onError(new e());
  }
  function i(c, l) {
    if (c[n] = null, c[r] = null, !!l) {
      if (l.aborted) {
        s(c);
        return;
      }
      c[n] = l, c[r] = () => {
        s(c);
      }, t(c[n], c[r]);
    }
  }
  function o(c) {
    c[n] && ("removeEventListener" in c[n] ? c[n].removeEventListener("abort", c[r]) : c[n].removeListener("abort", c[r]), c[n] = null, c[r] = null);
  }
  return vA = {
    addSignal: i,
    removeSignal: o
  }, vA;
}
var Mg;
function Cb() {
  if (Mg) return yo.exports;
  Mg = 1;
  const t = Eb(), {
    InvalidArgumentError: e,
    RequestAbortedError: r
  } = ft(), n = rt(), { getResolveErrorBodyCallback: s } = Uf(), { AsyncResource: i } = Vi, { addSignal: o, removeSignal: c } = Xi();
  class l extends i {
    constructor(u, g) {
      if (!u || typeof u != "object")
        throw new e("invalid opts");
      const { signal: h, method: m, opaque: d, body: p, onInfo: E, responseHeaders: B, throwOnError: y, highWaterMark: Q } = u;
      try {
        if (typeof g != "function")
          throw new e("invalid callback");
        if (Q && (typeof Q != "number" || Q < 0))
          throw new e("invalid highWaterMark");
        if (h && typeof h.on != "function" && typeof h.addEventListener != "function")
          throw new e("signal must be an EventEmitter or EventTarget");
        if (m === "CONNECT")
          throw new e("invalid method");
        if (E && typeof E != "function")
          throw new e("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (I) {
        throw n.isStream(p) && n.destroy(p.on("error", n.nop), I), I;
      }
      this.responseHeaders = B || null, this.opaque = d || null, this.callback = g, this.res = null, this.abort = null, this.body = p, this.trailers = {}, this.context = null, this.onInfo = E || null, this.throwOnError = y, this.highWaterMark = Q, n.isStream(p) && p.on("error", (I) => {
        this.onError(I);
      }), o(this, h);
    }
    onConnect(u, g) {
      if (!this.callback)
        throw new r();
      this.abort = u, this.context = g;
    }
    onHeaders(u, g, h, m) {
      const { callback: d, opaque: p, abort: E, context: B, responseHeaders: y, highWaterMark: Q } = this, I = y === "raw" ? n.parseRawHeaders(g) : n.parseHeaders(g);
      if (u < 200) {
        this.onInfo && this.onInfo({ statusCode: u, headers: I });
        return;
      }
      const f = (y === "raw" ? n.parseHeaders(g) : I)["content-type"], C = new t({ resume: h, abort: E, contentType: f, highWaterMark: Q });
      this.callback = null, this.res = C, d !== null && (this.throwOnError && u >= 400 ? this.runInAsyncScope(
        s,
        null,
        { callback: d, body: C, contentType: f, statusCode: u, statusMessage: m, headers: I }
      ) : this.runInAsyncScope(d, null, null, {
        statusCode: u,
        headers: I,
        trailers: this.trailers,
        opaque: p,
        body: C,
        context: B
      }));
    }
    onData(u) {
      const { res: g } = this;
      return g.push(u);
    }
    onComplete(u) {
      const { res: g } = this;
      c(this), n.parseHeaders(u, this.trailers), g.push(null);
    }
    onError(u) {
      const { res: g, callback: h, body: m, opaque: d } = this;
      c(this), h && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(h, null, u, { opaque: d });
      })), g && (this.res = null, queueMicrotask(() => {
        n.destroy(g, u);
      })), m && (this.body = null, n.destroy(m, u));
    }
  }
  function A(a, u) {
    if (u === void 0)
      return new Promise((g, h) => {
        A.call(this, a, (m, d) => m ? h(m) : g(d));
      });
    try {
      this.dispatch(a, new l(a, u));
    } catch (g) {
      if (typeof u != "function")
        throw g;
      const h = a && a.opaque;
      queueMicrotask(() => u(g, { opaque: h }));
    }
  }
  return yo.exports = A, yo.exports.RequestHandler = l, yo.exports;
}
var xA, Og;
function Bb() {
  if (Og) return xA;
  Og = 1;
  const { finished: t, PassThrough: e } = ln, {
    InvalidArgumentError: r,
    InvalidReturnValueError: n,
    RequestAbortedError: s
  } = ft(), i = rt(), { getResolveErrorBodyCallback: o } = Uf(), { AsyncResource: c } = Vi, { addSignal: l, removeSignal: A } = Xi();
  class a extends c {
    constructor(h, m, d) {
      if (!h || typeof h != "object")
        throw new r("invalid opts");
      const { signal: p, method: E, opaque: B, body: y, onInfo: Q, responseHeaders: I, throwOnError: w } = h;
      try {
        if (typeof d != "function")
          throw new r("invalid callback");
        if (typeof m != "function")
          throw new r("invalid factory");
        if (p && typeof p.on != "function" && typeof p.addEventListener != "function")
          throw new r("signal must be an EventEmitter or EventTarget");
        if (E === "CONNECT")
          throw new r("invalid method");
        if (Q && typeof Q != "function")
          throw new r("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (f) {
        throw i.isStream(y) && i.destroy(y.on("error", i.nop), f), f;
      }
      this.responseHeaders = I || null, this.opaque = B || null, this.factory = m, this.callback = d, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = y, this.onInfo = Q || null, this.throwOnError = w || !1, i.isStream(y) && y.on("error", (f) => {
        this.onError(f);
      }), l(this, p);
    }
    onConnect(h, m) {
      if (!this.callback)
        throw new s();
      this.abort = h, this.context = m;
    }
    onHeaders(h, m, d, p) {
      const { factory: E, opaque: B, context: y, callback: Q, responseHeaders: I } = this, w = I === "raw" ? i.parseRawHeaders(m) : i.parseHeaders(m);
      if (h < 200) {
        this.onInfo && this.onInfo({ statusCode: h, headers: w });
        return;
      }
      this.factory = null;
      let f;
      if (this.throwOnError && h >= 400) {
        const N = (I === "raw" ? i.parseHeaders(m) : w)["content-type"];
        f = new e(), this.callback = null, this.runInAsyncScope(
          o,
          null,
          { callback: Q, body: f, contentType: N, statusCode: h, statusMessage: p, headers: w }
        );
      } else {
        if (E === null)
          return;
        if (f = this.runInAsyncScope(E, null, {
          statusCode: h,
          headers: w,
          opaque: B,
          context: y
        }), !f || typeof f.write != "function" || typeof f.end != "function" || typeof f.on != "function")
          throw new n("expected Writable");
        t(f, { readable: !1 }, (b) => {
          const { callback: N, res: v, opaque: R, trailers: x, abort: S } = this;
          this.res = null, (b || !v.readable) && i.destroy(v, b), this.callback = null, this.runInAsyncScope(N, null, b || null, { opaque: R, trailers: x }), b && S();
        });
      }
      return f.on("drain", d), this.res = f, (f.writableNeedDrain !== void 0 ? f.writableNeedDrain : f._writableState && f._writableState.needDrain) !== !0;
    }
    onData(h) {
      const { res: m } = this;
      return m ? m.write(h) : !0;
    }
    onComplete(h) {
      const { res: m } = this;
      A(this), m && (this.trailers = i.parseHeaders(h), m.end());
    }
    onError(h) {
      const { res: m, callback: d, opaque: p, body: E } = this;
      A(this), this.factory = null, m ? (this.res = null, i.destroy(m, h)) : d && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(d, null, h, { opaque: p });
      })), E && (this.body = null, i.destroy(E, h));
    }
  }
  function u(g, h, m) {
    if (m === void 0)
      return new Promise((d, p) => {
        u.call(this, g, h, (E, B) => E ? p(E) : d(B));
      });
    try {
      this.dispatch(g, new a(g, h, m));
    } catch (d) {
      if (typeof m != "function")
        throw d;
      const p = g && g.opaque;
      queueMicrotask(() => m(d, { opaque: p }));
    }
  }
  return xA = u, xA;
}
var DA, Gg;
function Ib() {
  if (Gg) return DA;
  Gg = 1;
  const {
    Readable: t,
    Duplex: e,
    PassThrough: r
  } = ln, {
    InvalidArgumentError: n,
    InvalidReturnValueError: s,
    RequestAbortedError: i
  } = ft(), o = rt(), { AsyncResource: c } = Vi, { addSignal: l, removeSignal: A } = Xi(), a = bt, u = Symbol("resume");
  class g extends t {
    constructor() {
      super({ autoDestroy: !0 }), this[u] = null;
    }
    _read() {
      const { [u]: E } = this;
      E && (this[u] = null, E());
    }
    _destroy(E, B) {
      this._read(), B(E);
    }
  }
  class h extends t {
    constructor(E) {
      super({ autoDestroy: !0 }), this[u] = E;
    }
    _read() {
      this[u]();
    }
    _destroy(E, B) {
      !E && !this._readableState.endEmitted && (E = new i()), B(E);
    }
  }
  class m extends c {
    constructor(E, B) {
      if (!E || typeof E != "object")
        throw new n("invalid opts");
      if (typeof B != "function")
        throw new n("invalid handler");
      const { signal: y, method: Q, opaque: I, onInfo: w, responseHeaders: f } = E;
      if (y && typeof y.on != "function" && typeof y.addEventListener != "function")
        throw new n("signal must be an EventEmitter or EventTarget");
      if (Q === "CONNECT")
        throw new n("invalid method");
      if (w && typeof w != "function")
        throw new n("invalid onInfo callback");
      super("UNDICI_PIPELINE"), this.opaque = I || null, this.responseHeaders = f || null, this.handler = B, this.abort = null, this.context = null, this.onInfo = w || null, this.req = new g().on("error", o.nop), this.ret = new e({
        readableObjectMode: E.objectMode,
        autoDestroy: !0,
        read: () => {
          const { body: C } = this;
          C && C.resume && C.resume();
        },
        write: (C, b, N) => {
          const { req: v } = this;
          v.push(C, b) || v._readableState.destroyed ? N() : v[u] = N;
        },
        destroy: (C, b) => {
          const { body: N, req: v, res: R, ret: x, abort: S } = this;
          !C && !x._readableState.endEmitted && (C = new i()), S && C && S(), o.destroy(N, C), o.destroy(v, C), o.destroy(R, C), A(this), b(C);
        }
      }).on("prefinish", () => {
        const { req: C } = this;
        C.push(null);
      }), this.res = null, l(this, y);
    }
    onConnect(E, B) {
      const { ret: y, res: Q } = this;
      if (a(!Q, "pipeline cannot be retried"), y.destroyed)
        throw new i();
      this.abort = E, this.context = B;
    }
    onHeaders(E, B, y) {
      const { opaque: Q, handler: I, context: w } = this;
      if (E < 200) {
        if (this.onInfo) {
          const C = this.responseHeaders === "raw" ? o.parseRawHeaders(B) : o.parseHeaders(B);
          this.onInfo({ statusCode: E, headers: C });
        }
        return;
      }
      this.res = new h(y);
      let f;
      try {
        this.handler = null;
        const C = this.responseHeaders === "raw" ? o.parseRawHeaders(B) : o.parseHeaders(B);
        f = this.runInAsyncScope(I, null, {
          statusCode: E,
          headers: C,
          opaque: Q,
          body: this.res,
          context: w
        });
      } catch (C) {
        throw this.res.on("error", o.nop), C;
      }
      if (!f || typeof f.on != "function")
        throw new s("expected Readable");
      f.on("data", (C) => {
        const { ret: b, body: N } = this;
        !b.push(C) && N.pause && N.pause();
      }).on("error", (C) => {
        const { ret: b } = this;
        o.destroy(b, C);
      }).on("end", () => {
        const { ret: C } = this;
        C.push(null);
      }).on("close", () => {
        const { ret: C } = this;
        C._readableState.ended || o.destroy(C, new i());
      }), this.body = f;
    }
    onData(E) {
      const { res: B } = this;
      return B.push(E);
    }
    onComplete(E) {
      const { res: B } = this;
      B.push(null);
    }
    onError(E) {
      const { ret: B } = this;
      this.handler = null, o.destroy(B, E);
    }
  }
  function d(p, E) {
    try {
      const B = new m(p, E);
      return this.dispatch({ ...p, body: B.req }, B), B.ret;
    } catch (B) {
      return new r().destroy(B);
    }
  }
  return DA = d, DA;
}
var TA, qg;
function yb() {
  if (qg) return TA;
  qg = 1;
  const { InvalidArgumentError: t, RequestAbortedError: e, SocketError: r } = ft(), { AsyncResource: n } = Vi, s = rt(), { addSignal: i, removeSignal: o } = Xi(), c = bt;
  class l extends n {
    constructor(u, g) {
      if (!u || typeof u != "object")
        throw new t("invalid opts");
      if (typeof g != "function")
        throw new t("invalid callback");
      const { signal: h, opaque: m, responseHeaders: d } = u;
      if (h && typeof h.on != "function" && typeof h.addEventListener != "function")
        throw new t("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE"), this.responseHeaders = d || null, this.opaque = m || null, this.callback = g, this.abort = null, this.context = null, i(this, h);
    }
    onConnect(u, g) {
      if (!this.callback)
        throw new e();
      this.abort = u, this.context = null;
    }
    onHeaders() {
      throw new r("bad upgrade", null);
    }
    onUpgrade(u, g, h) {
      const { callback: m, opaque: d, context: p } = this;
      c.strictEqual(u, 101), o(this), this.callback = null;
      const E = this.responseHeaders === "raw" ? s.parseRawHeaders(g) : s.parseHeaders(g);
      this.runInAsyncScope(m, null, null, {
        headers: E,
        socket: h,
        opaque: d,
        context: p
      });
    }
    onError(u) {
      const { callback: g, opaque: h } = this;
      o(this), g && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(g, null, u, { opaque: h });
      }));
    }
  }
  function A(a, u) {
    if (u === void 0)
      return new Promise((g, h) => {
        A.call(this, a, (m, d) => m ? h(m) : g(d));
      });
    try {
      const g = new l(a, u);
      this.dispatch({
        ...a,
        method: a.method || "GET",
        upgrade: a.protocol || "Websocket"
      }, g);
    } catch (g) {
      if (typeof u != "function")
        throw g;
      const h = a && a.opaque;
      queueMicrotask(() => u(g, { opaque: h }));
    }
  }
  return TA = A, TA;
}
var kA, Hg;
function Qb() {
  if (Hg) return kA;
  Hg = 1;
  const { AsyncResource: t } = Vi, { InvalidArgumentError: e, RequestAbortedError: r, SocketError: n } = ft(), s = rt(), { addSignal: i, removeSignal: o } = Xi();
  class c extends t {
    constructor(a, u) {
      if (!a || typeof a != "object")
        throw new e("invalid opts");
      if (typeof u != "function")
        throw new e("invalid callback");
      const { signal: g, opaque: h, responseHeaders: m } = a;
      if (g && typeof g.on != "function" && typeof g.addEventListener != "function")
        throw new e("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT"), this.opaque = h || null, this.responseHeaders = m || null, this.callback = u, this.abort = null, i(this, g);
    }
    onConnect(a, u) {
      if (!this.callback)
        throw new r();
      this.abort = a, this.context = u;
    }
    onHeaders() {
      throw new n("bad connect", null);
    }
    onUpgrade(a, u, g) {
      const { callback: h, opaque: m, context: d } = this;
      o(this), this.callback = null;
      let p = u;
      p != null && (p = this.responseHeaders === "raw" ? s.parseRawHeaders(u) : s.parseHeaders(u)), this.runInAsyncScope(h, null, null, {
        statusCode: a,
        headers: p,
        socket: g,
        opaque: m,
        context: d
      });
    }
    onError(a) {
      const { callback: u, opaque: g } = this;
      o(this), u && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(u, null, a, { opaque: g });
      }));
    }
  }
  function l(A, a) {
    if (a === void 0)
      return new Promise((u, g) => {
        l.call(this, A, (h, m) => h ? g(h) : u(m));
      });
    try {
      const u = new c(A, a);
      this.dispatch({ ...A, method: "CONNECT" }, u);
    } catch (u) {
      if (typeof a != "function")
        throw u;
      const g = A && A.opaque;
      queueMicrotask(() => a(u, { opaque: g }));
    }
  }
  return kA = l, kA;
}
var zg;
function bb() {
  return zg || (zg = 1, zn.request = Cb(), zn.stream = Bb(), zn.pipeline = Ib(), zn.upgrade = yb(), zn.connect = Qb()), zn;
}
var FA, Yg;
function Lf() {
  if (Yg) return FA;
  Yg = 1;
  const { UndiciError: t } = ft();
  class e extends t {
    constructor(n) {
      super(n), Error.captureStackTrace(this, e), this.name = "MockNotMatchedError", this.message = n || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  return FA = {
    MockNotMatchedError: e
  }, FA;
}
var PA, Jg;
function Ki() {
  return Jg || (Jg = 1, PA = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  }), PA;
}
var UA, Vg;
function Aa() {
  if (Vg) return UA;
  Vg = 1;
  const { MockNotMatchedError: t } = Lf(), {
    kDispatches: e,
    kMockAgent: r,
    kOriginalDispatch: n,
    kOrigin: s,
    kGetNetConnect: i
  } = Ki(), { buildURL: o, nop: c } = rt(), { STATUS_CODES: l } = Ds, {
    types: {
      isPromise: A
    }
  } = Qr;
  function a(x, S) {
    return typeof x == "string" ? x === S : x instanceof RegExp ? x.test(S) : typeof x == "function" ? x(S) === !0 : !1;
  }
  function u(x) {
    return Object.fromEntries(
      Object.entries(x).map(([S, D]) => [S.toLocaleLowerCase(), D])
    );
  }
  function g(x, S) {
    if (Array.isArray(x)) {
      for (let D = 0; D < x.length; D += 2)
        if (x[D].toLocaleLowerCase() === S.toLocaleLowerCase())
          return x[D + 1];
      return;
    } else return typeof x.get == "function" ? x.get(S) : u(x)[S.toLocaleLowerCase()];
  }
  function h(x) {
    const S = x.slice(), D = [];
    for (let T = 0; T < S.length; T += 2)
      D.push([S[T], S[T + 1]]);
    return Object.fromEntries(D);
  }
  function m(x, S) {
    if (typeof x.headers == "function")
      return Array.isArray(S) && (S = h(S)), x.headers(S ? u(S) : {});
    if (typeof x.headers > "u")
      return !0;
    if (typeof S != "object" || typeof x.headers != "object")
      return !1;
    for (const [D, T] of Object.entries(x.headers)) {
      const k = g(S, D);
      if (!a(T, k))
        return !1;
    }
    return !0;
  }
  function d(x) {
    if (typeof x != "string")
      return x;
    const S = x.split("?");
    if (S.length !== 2)
      return x;
    const D = new URLSearchParams(S.pop());
    return D.sort(), [...S, D.toString()].join("?");
  }
  function p(x, { path: S, method: D, body: T, headers: k }) {
    const L = a(x.path, S), W = a(x.method, D), O = typeof x.body < "u" ? a(x.body, T) : !0, _ = m(x, k);
    return L && W && O && _;
  }
  function E(x) {
    return Buffer.isBuffer(x) ? x : typeof x == "object" ? JSON.stringify(x) : x.toString();
  }
  function B(x, S) {
    const D = S.query ? o(S.path, S.query) : S.path, T = typeof D == "string" ? d(D) : D;
    let k = x.filter(({ consumed: L }) => !L).filter(({ path: L }) => a(d(L), T));
    if (k.length === 0)
      throw new t(`Mock dispatch not matched for path '${T}'`);
    if (k = k.filter(({ method: L }) => a(L, S.method)), k.length === 0)
      throw new t(`Mock dispatch not matched for method '${S.method}'`);
    if (k = k.filter(({ body: L }) => typeof L < "u" ? a(L, S.body) : !0), k.length === 0)
      throw new t(`Mock dispatch not matched for body '${S.body}'`);
    if (k = k.filter((L) => m(L, S.headers)), k.length === 0)
      throw new t(`Mock dispatch not matched for headers '${typeof S.headers == "object" ? JSON.stringify(S.headers) : S.headers}'`);
    return k[0];
  }
  function y(x, S, D) {
    const T = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 }, k = typeof D == "function" ? { callback: D } : { ...D }, L = { ...T, ...S, pending: !0, data: { error: null, ...k } };
    return x.push(L), L;
  }
  function Q(x, S) {
    const D = x.findIndex((T) => T.consumed ? p(T, S) : !1);
    D !== -1 && x.splice(D, 1);
  }
  function I(x) {
    const { path: S, method: D, body: T, headers: k, query: L } = x;
    return {
      path: S,
      method: D,
      body: T,
      headers: k,
      query: L
    };
  }
  function w(x) {
    return Object.entries(x).reduce((S, [D, T]) => [
      ...S,
      Buffer.from(`${D}`),
      Array.isArray(T) ? T.map((k) => Buffer.from(`${k}`)) : Buffer.from(`${T}`)
    ], []);
  }
  function f(x) {
    return l[x] || "unknown";
  }
  async function C(x) {
    const S = [];
    for await (const D of x)
      S.push(D);
    return Buffer.concat(S).toString("utf8");
  }
  function b(x, S) {
    const D = I(x), T = B(this[e], D);
    T.timesInvoked++, T.data.callback && (T.data = { ...T.data, ...T.data.callback(x) });
    const { data: { statusCode: k, data: L, headers: W, trailers: O, error: _ }, delay: M, persist: $ } = T, { timesInvoked: U, times: J } = T;
    if (T.consumed = !$ && U >= J, T.pending = U < J, _ !== null)
      return Q(this[e], D), S.onError(_), !0;
    typeof M == "number" && M > 0 ? setTimeout(() => {
      j(this[e]);
    }, M) : j(this[e]);
    function j(ie, G = L) {
      const q = Array.isArray(x.headers) ? h(x.headers) : x.headers, Z = typeof G == "function" ? G({ ...x, headers: q }) : G;
      if (A(Z)) {
        Z.then((de) => j(ie, de));
        return;
      }
      const se = E(Z), F = w(W), ne = w(O);
      S.abort = c, S.onHeaders(k, F, te, f(k)), S.onData(Buffer.from(se)), S.onComplete(ne), Q(ie, D);
    }
    function te() {
    }
    return !0;
  }
  function N() {
    const x = this[r], S = this[s], D = this[n];
    return function(k, L) {
      if (x.isMockActive)
        try {
          b.call(this, k, L);
        } catch (W) {
          if (W instanceof t) {
            const O = x[i]();
            if (O === !1)
              throw new t(`${W.message}: subsequent request to origin ${S} was not allowed (net.connect disabled)`);
            if (v(O, S))
              D.call(this, k, L);
            else
              throw new t(`${W.message}: subsequent request to origin ${S} was not allowed (net.connect is not enabled for this origin)`);
          } else
            throw W;
        }
      else
        D.call(this, k, L);
    };
  }
  function v(x, S) {
    const D = new URL(S);
    return x === !0 ? !0 : !!(Array.isArray(x) && x.some((T) => a(T, D.host)));
  }
  function R(x) {
    if (x) {
      const { agent: S, ...D } = x;
      return D;
    }
  }
  return UA = {
    getResponseData: E,
    getMockDispatch: B,
    addMockDispatch: y,
    deleteMockDispatch: Q,
    buildKey: I,
    generateKeyValues: w,
    matchValue: a,
    getResponse: C,
    getStatusText: f,
    mockDispatch: b,
    buildMockDispatch: N,
    checkNetConnect: v,
    buildMockOptions: R,
    getHeaderByName: g
  }, UA;
}
var Qo = {}, Wg;
function _f() {
  if (Wg) return Qo;
  Wg = 1;
  const { getResponseData: t, buildKey: e, addMockDispatch: r } = Aa(), {
    kDispatches: n,
    kDispatchKey: s,
    kDefaultHeaders: i,
    kDefaultTrailers: o,
    kContentLength: c,
    kMockDispatch: l
  } = Ki(), { InvalidArgumentError: A } = ft(), { buildURL: a } = rt();
  class u {
    constructor(m) {
      this[l] = m;
    }
    /**
     * Delay a reply by a set amount in ms.
     */
    delay(m) {
      if (typeof m != "number" || !Number.isInteger(m) || m <= 0)
        throw new A("waitInMs must be a valid integer > 0");
      return this[l].delay = m, this;
    }
    /**
     * For a defined reply, never mark as consumed.
     */
    persist() {
      return this[l].persist = !0, this;
    }
    /**
     * Allow one to define a reply for a set amount of matching requests.
     */
    times(m) {
      if (typeof m != "number" || !Number.isInteger(m) || m <= 0)
        throw new A("repeatTimes must be a valid integer > 0");
      return this[l].times = m, this;
    }
  }
  class g {
    constructor(m, d) {
      if (typeof m != "object")
        throw new A("opts must be an object");
      if (typeof m.path > "u")
        throw new A("opts.path must be defined");
      if (typeof m.method > "u" && (m.method = "GET"), typeof m.path == "string")
        if (m.query)
          m.path = a(m.path, m.query);
        else {
          const p = new URL(m.path, "data://");
          m.path = p.pathname + p.search;
        }
      typeof m.method == "string" && (m.method = m.method.toUpperCase()), this[s] = e(m), this[n] = d, this[i] = {}, this[o] = {}, this[c] = !1;
    }
    createMockScopeDispatchData(m, d, p = {}) {
      const E = t(d), B = this[c] ? { "content-length": E.length } : {}, y = { ...this[i], ...B, ...p.headers }, Q = { ...this[o], ...p.trailers };
      return { statusCode: m, data: d, headers: y, trailers: Q };
    }
    validateReplyParameters(m, d, p) {
      if (typeof m > "u")
        throw new A("statusCode must be defined");
      if (typeof d > "u")
        throw new A("data must be defined");
      if (typeof p != "object")
        throw new A("responseOptions must be an object");
    }
    /**
     * Mock an undici request with a defined reply.
     */
    reply(m) {
      if (typeof m == "function") {
        const Q = (w) => {
          const f = m(w);
          if (typeof f != "object")
            throw new A("reply options callback must return an object");
          const { statusCode: C, data: b = "", responseOptions: N = {} } = f;
          return this.validateReplyParameters(C, b, N), {
            ...this.createMockScopeDispatchData(C, b, N)
          };
        }, I = r(this[n], this[s], Q);
        return new u(I);
      }
      const [d, p = "", E = {}] = [...arguments];
      this.validateReplyParameters(d, p, E);
      const B = this.createMockScopeDispatchData(d, p, E), y = r(this[n], this[s], B);
      return new u(y);
    }
    /**
     * Mock an undici request with a defined error.
     */
    replyWithError(m) {
      if (typeof m > "u")
        throw new A("error must be defined");
      const d = r(this[n], this[s], { error: m });
      return new u(d);
    }
    /**
     * Set default reply headers on the interceptor for subsequent replies
     */
    defaultReplyHeaders(m) {
      if (typeof m > "u")
        throw new A("headers must be defined");
      return this[i] = m, this;
    }
    /**
     * Set default reply trailers on the interceptor for subsequent replies
     */
    defaultReplyTrailers(m) {
      if (typeof m > "u")
        throw new A("trailers must be defined");
      return this[o] = m, this;
    }
    /**
     * Set reply content length header for replies on the interceptor
     */
    replyContentLength() {
      return this[c] = !0, this;
    }
  }
  return Qo.MockInterceptor = g, Qo.MockScope = u, Qo;
}
var LA, jg;
function Mf() {
  if (jg) return LA;
  jg = 1;
  const { promisify: t } = Qr, e = oa(), { buildMockDispatch: r } = Aa(), {
    kDispatches: n,
    kMockAgent: s,
    kClose: i,
    kOriginalClose: o,
    kOrigin: c,
    kOriginalDispatch: l,
    kConnected: A
  } = Ki(), { MockInterceptor: a } = _f(), u = Nt(), { InvalidArgumentError: g } = ft();
  class h extends e {
    constructor(d, p) {
      if (super(d, p), !p || !p.agent || typeof p.agent.dispatch != "function")
        throw new g("Argument opts.agent must implement Agent");
      this[s] = p.agent, this[c] = d, this[n] = [], this[A] = 1, this[l] = this.dispatch, this[o] = this.close.bind(this), this.dispatch = r.call(this), this.close = this[i];
    }
    get [u.kConnected]() {
      return this[A];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(d) {
      return new a(d, this[n]);
    }
    async [i]() {
      await t(this[o])(), this[A] = 0, this[s][u.kClients].delete(this[c]);
    }
  }
  return LA = h, LA;
}
var _A, $g;
function Of() {
  if ($g) return _A;
  $g = 1;
  const { promisify: t } = Qr, e = $i(), { buildMockDispatch: r } = Aa(), {
    kDispatches: n,
    kMockAgent: s,
    kClose: i,
    kOriginalClose: o,
    kOrigin: c,
    kOriginalDispatch: l,
    kConnected: A
  } = Ki(), { MockInterceptor: a } = _f(), u = Nt(), { InvalidArgumentError: g } = ft();
  class h extends e {
    constructor(d, p) {
      if (super(d, p), !p || !p.agent || typeof p.agent.dispatch != "function")
        throw new g("Argument opts.agent must implement Agent");
      this[s] = p.agent, this[c] = d, this[n] = [], this[A] = 1, this[l] = this.dispatch, this[o] = this.close.bind(this), this.dispatch = r.call(this), this.close = this[i];
    }
    get [u.kConnected]() {
      return this[A];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(d) {
      return new a(d, this[n]);
    }
    async [i]() {
      await t(this[o])(), this[A] = 0, this[s][u.kClients].delete(this[c]);
    }
  }
  return _A = h, _A;
}
var MA, Xg;
function wb() {
  if (Xg) return MA;
  Xg = 1;
  const t = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  }, e = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  return MA = class {
    constructor(n, s) {
      this.singular = n, this.plural = s;
    }
    pluralize(n) {
      const s = n === 1, i = s ? t : e, o = s ? this.singular : this.plural;
      return { ...i, count: n, noun: o };
    }
  }, MA;
}
var OA, Kg;
function Nb() {
  if (Kg) return OA;
  Kg = 1;
  const { Transform: t } = ln, { Console: e } = PQ;
  return OA = class {
    constructor({ disableColors: n } = {}) {
      this.transform = new t({
        transform(s, i, o) {
          o(null, s);
        }
      }), this.logger = new e({
        stdout: this.transform,
        inspectOptions: {
          colors: !n && !process.env.CI
        }
      });
    }
    format(n) {
      const s = n.map(
        ({ method: i, path: o, data: { statusCode: c }, persist: l, times: A, timesInvoked: a, origin: u }) => ({
          Method: i,
          Origin: u,
          Path: o,
          "Status code": c,
          Persistent: l ? "" : "",
          Invocations: a,
          Remaining: l ? 1 / 0 : A - a
        })
      );
      return this.logger.table(s), this.transform.read().toString();
    }
  }, OA;
}
var GA, Zg;
function Rb() {
  if (Zg) return GA;
  Zg = 1;
  const { kClients: t } = Nt(), e = aa(), {
    kAgent: r,
    kMockAgentSet: n,
    kMockAgentGet: s,
    kDispatches: i,
    kIsMockActive: o,
    kNetConnect: c,
    kGetNetConnect: l,
    kOptions: A,
    kFactory: a
  } = Ki(), u = Mf(), g = Of(), { matchValue: h, buildMockOptions: m } = Aa(), { InvalidArgumentError: d, UndiciError: p } = ft(), E = uu(), B = wb(), y = Nb();
  class Q {
    constructor(f) {
      this.value = f;
    }
    deref() {
      return this.value;
    }
  }
  class I extends E {
    constructor(f) {
      if (super(f), this[c] = !0, this[o] = !0, f && f.agent && typeof f.agent.dispatch != "function")
        throw new d("Argument opts.agent must implement Agent");
      const C = f && f.agent ? f.agent : new e(f);
      this[r] = C, this[t] = C[t], this[A] = m(f);
    }
    get(f) {
      let C = this[s](f);
      return C || (C = this[a](f), this[n](f, C)), C;
    }
    dispatch(f, C) {
      return this.get(f.origin), this[r].dispatch(f, C);
    }
    async close() {
      await this[r].close(), this[t].clear();
    }
    deactivate() {
      this[o] = !1;
    }
    activate() {
      this[o] = !0;
    }
    enableNetConnect(f) {
      if (typeof f == "string" || typeof f == "function" || f instanceof RegExp)
        Array.isArray(this[c]) ? this[c].push(f) : this[c] = [f];
      else if (typeof f > "u")
        this[c] = !0;
      else
        throw new d("Unsupported matcher. Must be one of String|Function|RegExp.");
    }
    disableNetConnect() {
      this[c] = !1;
    }
    // This is required to bypass issues caused by using global symbols - see:
    // https://github.com/nodejs/undici/issues/1447
    get isMockActive() {
      return this[o];
    }
    [n](f, C) {
      this[t].set(f, new Q(C));
    }
    [a](f) {
      const C = Object.assign({ agent: this }, this[A]);
      return this[A] && this[A].connections === 1 ? new u(f, C) : new g(f, C);
    }
    [s](f) {
      const C = this[t].get(f);
      if (C)
        return C.deref();
      if (typeof f != "string") {
        const b = this[a]("http://localhost:9999");
        return this[n](f, b), b;
      }
      for (const [b, N] of Array.from(this[t])) {
        const v = N.deref();
        if (v && typeof b != "string" && h(b, f)) {
          const R = this[a](f);
          return this[n](f, R), R[i] = v[i], R;
        }
      }
    }
    [l]() {
      return this[c];
    }
    pendingInterceptors() {
      const f = this[t];
      return Array.from(f.entries()).flatMap(([C, b]) => b.deref()[i].map((N) => ({ ...N, origin: C }))).filter(({ pending: C }) => C);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter: f = new y() } = {}) {
      const C = this.pendingInterceptors();
      if (C.length === 0)
        return;
      const b = new B("interceptor", "interceptors").pluralize(C.length);
      throw new p(`
${b.count} ${b.noun} ${b.is} pending:

${f.format(C)}
`.trim());
    }
  }
  return GA = I, GA;
}
var qA, em;
function Sb() {
  if (em) return qA;
  em = 1;
  const { kProxy: t, kClose: e, kDestroy: r, kInterceptors: n } = Nt(), { URL: s } = Qf, i = aa(), o = $i(), c = sa(), { InvalidArgumentError: l, RequestAbortedError: A } = ft(), a = ia(), u = Symbol("proxy agent"), g = Symbol("proxy client"), h = Symbol("proxy headers"), m = Symbol("request tls settings"), d = Symbol("proxy tls settings"), p = Symbol("connect endpoint function");
  function E(f) {
    return f === "https:" ? 443 : 80;
  }
  function B(f) {
    if (typeof f == "string" && (f = { uri: f }), !f || !f.uri)
      throw new l("Proxy opts.uri is mandatory");
    return {
      uri: f.uri,
      protocol: f.protocol || "https"
    };
  }
  function y(f, C) {
    return new o(f, C);
  }
  class Q extends c {
    constructor(C) {
      if (super(C), this[t] = B(C), this[u] = new i(C), this[n] = C.interceptors && C.interceptors.ProxyAgent && Array.isArray(C.interceptors.ProxyAgent) ? C.interceptors.ProxyAgent : [], typeof C == "string" && (C = { uri: C }), !C || !C.uri)
        throw new l("Proxy opts.uri is mandatory");
      const { clientFactory: b = y } = C;
      if (typeof b != "function")
        throw new l("Proxy opts.clientFactory must be a function.");
      this[m] = C.requestTls, this[d] = C.proxyTls, this[h] = C.headers || {};
      const N = new s(C.uri), { origin: v, port: R, host: x, username: S, password: D } = N;
      if (C.auth && C.token)
        throw new l("opts.auth cannot be used in combination with opts.token");
      C.auth ? this[h]["proxy-authorization"] = `Basic ${C.auth}` : C.token ? this[h]["proxy-authorization"] = C.token : S && D && (this[h]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(S)}:${decodeURIComponent(D)}`).toString("base64")}`);
      const T = a({ ...C.proxyTls });
      this[p] = a({ ...C.requestTls }), this[g] = b(N, { connect: T }), this[u] = new i({
        ...C,
        connect: async (k, L) => {
          let W = k.host;
          k.port || (W += `:${E(k.protocol)}`);
          try {
            const { socket: O, statusCode: _ } = await this[g].connect({
              origin: v,
              port: R,
              path: W,
              signal: k.signal,
              headers: {
                ...this[h],
                host: x
              }
            });
            if (_ !== 200 && (O.on("error", () => {
            }).destroy(), L(new A(`Proxy response (${_}) !== 200 when HTTP Tunneling`))), k.protocol !== "https:") {
              L(null, O);
              return;
            }
            let M;
            this[m] ? M = this[m].servername : M = k.servername, this[p]({ ...k, servername: M, httpSocket: O }, L);
          } catch (O) {
            L(O);
          }
        }
      });
    }
    dispatch(C, b) {
      const { host: N } = new s(C.origin), v = I(C.headers);
      return w(v), this[u].dispatch(
        {
          ...C,
          headers: {
            ...v,
            host: N
          }
        },
        b
      );
    }
    async [e]() {
      await this[u].close(), await this[g].close();
    }
    async [r]() {
      await this[u].destroy(), await this[g].destroy();
    }
  }
  function I(f) {
    if (Array.isArray(f)) {
      const C = {};
      for (let b = 0; b < f.length; b += 2)
        C[f[b]] = f[b + 1];
      return C;
    }
    return f;
  }
  function w(f) {
    if (f && Object.keys(f).find((b) => b.toLowerCase() === "proxy-authorization"))
      throw new l("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  return qA = Q, qA;
}
var HA, tm;
function vb() {
  if (tm) return HA;
  tm = 1;
  const t = bt, { kRetryHandlerDefaultRetry: e } = Nt(), { RequestRetryError: r } = ft(), { isDisturbed: n, parseHeaders: s, parseRangeHeader: i } = rt();
  function o(l) {
    const A = Date.now();
    return new Date(l).getTime() - A;
  }
  class c {
    constructor(A, a) {
      const { retryOptions: u, ...g } = A, {
        // Retry scoped
        retry: h,
        maxRetries: m,
        maxTimeout: d,
        minTimeout: p,
        timeoutFactor: E,
        // Response scoped
        methods: B,
        errorCodes: y,
        retryAfter: Q,
        statusCodes: I
      } = u ?? {};
      this.dispatch = a.dispatch, this.handler = a.handler, this.opts = g, this.abort = null, this.aborted = !1, this.retryOpts = {
        retry: h ?? c[e],
        retryAfter: Q ?? !0,
        maxTimeout: d ?? 30 * 1e3,
        // 30s,
        timeout: p ?? 500,
        // .5s
        timeoutFactor: E ?? 2,
        maxRetries: m ?? 5,
        // What errors we should retry
        methods: B ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        // Indicates which errors to retry
        statusCodes: I ?? [500, 502, 503, 504, 429],
        // List of errors to retry
        errorCodes: y ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE"
        ]
      }, this.retryCount = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((w) => {
        this.aborted = !0, this.abort ? this.abort(w) : this.reason = w;
      });
    }
    onRequestSent() {
      this.handler.onRequestSent && this.handler.onRequestSent();
    }
    onUpgrade(A, a, u) {
      this.handler.onUpgrade && this.handler.onUpgrade(A, a, u);
    }
    onConnect(A) {
      this.aborted ? A(this.reason) : this.abort = A;
    }
    onBodySent(A) {
      if (this.handler.onBodySent) return this.handler.onBodySent(A);
    }
    static [e](A, { state: a, opts: u }, g) {
      const { statusCode: h, code: m, headers: d } = A, { method: p, retryOptions: E } = u, {
        maxRetries: B,
        timeout: y,
        maxTimeout: Q,
        timeoutFactor: I,
        statusCodes: w,
        errorCodes: f,
        methods: C
      } = E;
      let { counter: b, currentTimeout: N } = a;
      if (N = N != null && N > 0 ? N : y, m && m !== "UND_ERR_REQ_RETRY" && m !== "UND_ERR_SOCKET" && !f.includes(m)) {
        g(A);
        return;
      }
      if (Array.isArray(C) && !C.includes(p)) {
        g(A);
        return;
      }
      if (h != null && Array.isArray(w) && !w.includes(h)) {
        g(A);
        return;
      }
      if (b > B) {
        g(A);
        return;
      }
      let v = d != null && d["retry-after"];
      v && (v = Number(v), v = isNaN(v) ? o(v) : v * 1e3);
      const R = v > 0 ? Math.min(v, Q) : Math.min(N * I ** b, Q);
      a.currentTimeout = R, setTimeout(() => g(null), R);
    }
    onHeaders(A, a, u, g) {
      const h = s(a);
      if (this.retryCount += 1, A >= 300)
        return this.abort(
          new r("Request failed", A, {
            headers: h,
            count: this.retryCount
          })
        ), !1;
      if (this.resume != null) {
        if (this.resume = null, A !== 206)
          return !0;
        const d = i(h["content-range"]);
        if (!d)
          return this.abort(
            new r("Content-Range mismatch", A, {
              headers: h,
              count: this.retryCount
            })
          ), !1;
        if (this.etag != null && this.etag !== h.etag)
          return this.abort(
            new r("ETag mismatch", A, {
              headers: h,
              count: this.retryCount
            })
          ), !1;
        const { start: p, size: E, end: B = E } = d;
        return t(this.start === p, "content-range mismatch"), t(this.end == null || this.end === B, "content-range mismatch"), this.resume = u, !0;
      }
      if (this.end == null) {
        if (A === 206) {
          const d = i(h["content-range"]);
          if (d == null)
            return this.handler.onHeaders(
              A,
              a,
              u,
              g
            );
          const { start: p, size: E, end: B = E } = d;
          t(
            p != null && Number.isFinite(p) && this.start !== p,
            "content-range mismatch"
          ), t(Number.isFinite(p)), t(
            B != null && Number.isFinite(B) && this.end !== B,
            "invalid content-length"
          ), this.start = p, this.end = B;
        }
        if (this.end == null) {
          const d = h["content-length"];
          this.end = d != null ? Number(d) : null;
        }
        return t(Number.isFinite(this.start)), t(
          this.end == null || Number.isFinite(this.end),
          "invalid content-length"
        ), this.resume = u, this.etag = h.etag != null ? h.etag : null, this.handler.onHeaders(
          A,
          a,
          u,
          g
        );
      }
      const m = new r("Request failed", A, {
        headers: h,
        count: this.retryCount
      });
      return this.abort(m), !1;
    }
    onData(A) {
      return this.start += A.length, this.handler.onData(A);
    }
    onComplete(A) {
      return this.retryCount = 0, this.handler.onComplete(A);
    }
    onError(A) {
      if (this.aborted || n(this.opts.body))
        return this.handler.onError(A);
      this.retryOpts.retry(
        A,
        {
          state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
          opts: { retryOptions: this.retryOpts, ...this.opts }
        },
        a.bind(this)
      );
      function a(u) {
        if (u != null || this.aborted || n(this.opts.body))
          return this.handler.onError(u);
        this.start !== 0 && (this.opts = {
          ...this.opts,
          headers: {
            ...this.opts.headers,
            range: `bytes=${this.start}-${this.end ?? ""}`
          }
        });
        try {
          this.dispatch(this.opts, this);
        } catch (g) {
          this.handler.onError(g);
        }
      }
    }
  }
  return HA = c, HA;
}
var zA, rm;
function Zi() {
  if (rm) return zA;
  rm = 1;
  const t = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: e } = ft(), r = aa();
  s() === void 0 && n(new r());
  function n(i) {
    if (!i || typeof i.dispatch != "function")
      throw new e("Argument agent must implement Agent");
    Object.defineProperty(globalThis, t, {
      value: i,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  function s() {
    return globalThis[t];
  }
  return zA = {
    setGlobalDispatcher: n,
    getGlobalDispatcher: s
  }, zA;
}
var YA, nm;
function xb() {
  return nm || (nm = 1, YA = class {
    constructor(e) {
      this.handler = e;
    }
    onConnect(...e) {
      return this.handler.onConnect(...e);
    }
    onError(...e) {
      return this.handler.onError(...e);
    }
    onUpgrade(...e) {
      return this.handler.onUpgrade(...e);
    }
    onHeaders(...e) {
      return this.handler.onHeaders(...e);
    }
    onData(...e) {
      return this.handler.onData(...e);
    }
    onComplete(...e) {
      return this.handler.onComplete(...e);
    }
    onBodySent(...e) {
      return this.handler.onBodySent(...e);
    }
  }), YA;
}
var JA, sm;
function Fs() {
  if (sm) return JA;
  sm = 1;
  const { kHeadersList: t, kConstruct: e } = Nt(), { kGuard: r } = Tn(), { kEnumerableProperty: n } = rt(), {
    makeIterator: s,
    isValidHeaderName: i,
    isValidHeaderValue: o
  } = en(), c = Qr, { webidl: l } = br(), A = bt, a = Symbol("headers map"), u = Symbol("headers map sorted");
  function g(B) {
    return B === 10 || B === 13 || B === 9 || B === 32;
  }
  function h(B) {
    let y = 0, Q = B.length;
    for (; Q > y && g(B.charCodeAt(Q - 1)); ) --Q;
    for (; Q > y && g(B.charCodeAt(y)); ) ++y;
    return y === 0 && Q === B.length ? B : B.substring(y, Q);
  }
  function m(B, y) {
    if (Array.isArray(y))
      for (let Q = 0; Q < y.length; ++Q) {
        const I = y[Q];
        if (I.length !== 2)
          throw l.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${I.length}.`
          });
        d(B, I[0], I[1]);
      }
    else if (typeof y == "object" && y !== null) {
      const Q = Object.keys(y);
      for (let I = 0; I < Q.length; ++I)
        d(B, Q[I], y[Q[I]]);
    } else
      throw l.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
  }
  function d(B, y, Q) {
    if (Q = h(Q), i(y)) {
      if (!o(Q))
        throw l.errors.invalidArgument({
          prefix: "Headers.append",
          value: Q,
          type: "header value"
        });
    } else throw l.errors.invalidArgument({
      prefix: "Headers.append",
      value: y,
      type: "header name"
    });
    if (B[r] === "immutable")
      throw new TypeError("immutable");
    return B[r], B[t].append(y, Q);
  }
  class p {
    /** @type {[string, string][]|null} */
    cookies = null;
    constructor(y) {
      y instanceof p ? (this[a] = new Map(y[a]), this[u] = y[u], this.cookies = y.cookies === null ? null : [...y.cookies]) : (this[a] = new Map(y), this[u] = null);
    }
    // https://fetch.spec.whatwg.org/#header-list-contains
    contains(y) {
      return y = y.toLowerCase(), this[a].has(y);
    }
    clear() {
      this[a].clear(), this[u] = null, this.cookies = null;
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-append
    append(y, Q) {
      this[u] = null;
      const I = y.toLowerCase(), w = this[a].get(I);
      if (w) {
        const f = I === "cookie" ? "; " : ", ";
        this[a].set(I, {
          name: w.name,
          value: `${w.value}${f}${Q}`
        });
      } else
        this[a].set(I, { name: y, value: Q });
      I === "set-cookie" && (this.cookies ??= [], this.cookies.push(Q));
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-set
    set(y, Q) {
      this[u] = null;
      const I = y.toLowerCase();
      I === "set-cookie" && (this.cookies = [Q]), this[a].set(I, { name: y, value: Q });
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-delete
    delete(y) {
      this[u] = null, y = y.toLowerCase(), y === "set-cookie" && (this.cookies = null), this[a].delete(y);
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-get
    get(y) {
      const Q = this[a].get(y.toLowerCase());
      return Q === void 0 ? null : Q.value;
    }
    *[Symbol.iterator]() {
      for (const [y, { value: Q }] of this[a])
        yield [y, Q];
    }
    get entries() {
      const y = {};
      if (this[a].size)
        for (const { name: Q, value: I } of this[a].values())
          y[Q] = I;
      return y;
    }
  }
  class E {
    constructor(y = void 0) {
      y !== e && (this[t] = new p(), this[r] = "none", y !== void 0 && (y = l.converters.HeadersInit(y), m(this, y)));
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(y, Q) {
      return l.brandCheck(this, E), l.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), y = l.converters.ByteString(y), Q = l.converters.ByteString(Q), d(this, y, Q);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(y) {
      if (l.brandCheck(this, E), l.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), y = l.converters.ByteString(y), !i(y))
        throw l.errors.invalidArgument({
          prefix: "Headers.delete",
          value: y,
          type: "header name"
        });
      if (this[r] === "immutable")
        throw new TypeError("immutable");
      this[r], this[t].contains(y) && this[t].delete(y);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(y) {
      if (l.brandCheck(this, E), l.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), y = l.converters.ByteString(y), !i(y))
        throw l.errors.invalidArgument({
          prefix: "Headers.get",
          value: y,
          type: "header name"
        });
      return this[t].get(y);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(y) {
      if (l.brandCheck(this, E), l.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), y = l.converters.ByteString(y), !i(y))
        throw l.errors.invalidArgument({
          prefix: "Headers.has",
          value: y,
          type: "header name"
        });
      return this[t].contains(y);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(y, Q) {
      if (l.brandCheck(this, E), l.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), y = l.converters.ByteString(y), Q = l.converters.ByteString(Q), Q = h(Q), i(y)) {
        if (!o(Q))
          throw l.errors.invalidArgument({
            prefix: "Headers.set",
            value: Q,
            type: "header value"
          });
      } else throw l.errors.invalidArgument({
        prefix: "Headers.set",
        value: y,
        type: "header name"
      });
      if (this[r] === "immutable")
        throw new TypeError("immutable");
      this[r], this[t].set(y, Q);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      l.brandCheck(this, E);
      const y = this[t].cookies;
      return y ? [...y] : [];
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
    get [u]() {
      if (this[t][u])
        return this[t][u];
      const y = [], Q = [...this[t]].sort((w, f) => w[0] < f[0] ? -1 : 1), I = this[t].cookies;
      for (let w = 0; w < Q.length; ++w) {
        const [f, C] = Q[w];
        if (f === "set-cookie")
          for (let b = 0; b < I.length; ++b)
            y.push([f, I[b]]);
        else
          A(C !== null), y.push([f, C]);
      }
      return this[t][u] = y, y;
    }
    keys() {
      if (l.brandCheck(this, E), this[r] === "immutable") {
        const y = this[u];
        return s(
          () => y,
          "Headers",
          "key"
        );
      }
      return s(
        () => [...this[u].values()],
        "Headers",
        "key"
      );
    }
    values() {
      if (l.brandCheck(this, E), this[r] === "immutable") {
        const y = this[u];
        return s(
          () => y,
          "Headers",
          "value"
        );
      }
      return s(
        () => [...this[u].values()],
        "Headers",
        "value"
      );
    }
    entries() {
      if (l.brandCheck(this, E), this[r] === "immutable") {
        const y = this[u];
        return s(
          () => y,
          "Headers",
          "key+value"
        );
      }
      return s(
        () => [...this[u].values()],
        "Headers",
        "key+value"
      );
    }
    /**
     * @param {(value: string, key: string, self: Headers) => void} callbackFn
     * @param {unknown} thisArg
     */
    forEach(y, Q = globalThis) {
      if (l.brandCheck(this, E), l.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" }), typeof y != "function")
        throw new TypeError(
          "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
        );
      for (const [I, w] of this)
        y.apply(Q, [w, I, this]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return l.brandCheck(this, E), this[t];
    }
  }
  return E.prototype[Symbol.iterator] = E.prototype.entries, Object.defineProperties(E.prototype, {
    append: n,
    delete: n,
    get: n,
    has: n,
    set: n,
    getSetCookie: n,
    keys: n,
    values: n,
    entries: n,
    forEach: n,
    [Symbol.iterator]: { enumerable: !1 },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: !0
    },
    [c.inspect.custom]: {
      enumerable: !1
    }
  }), l.converters.HeadersInit = function(B) {
    if (l.util.Type(B) === "Object")
      return B[Symbol.iterator] ? l.converters["sequence<sequence<ByteString>>"](B) : l.converters["record<ByteString, ByteString>"](B);
    throw l.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  }, JA = {
    fill: m,
    Headers: E,
    HeadersList: p
  }, JA;
}
var VA, im;
function gu() {
  if (im) return VA;
  im = 1;
  const { Headers: t, HeadersList: e, fill: r } = Fs(), { extractBody: n, cloneBody: s, mixinBody: i } = na(), o = rt(), { kEnumerableProperty: c } = o, {
    isValidReasonPhrase: l,
    isCancelled: A,
    isAborted: a,
    isBlobLike: u,
    serializeJavascriptValueToJSONString: g,
    isErrorLike: h,
    isomorphicEncode: m
  } = en(), {
    redirectStatusSet: d,
    nullBodyStatus: p,
    DOMException: E
  } = ns(), { kState: B, kHeaders: y, kGuard: Q, kRealm: I } = Tn(), { webidl: w } = br(), { FormData: f } = lu(), { getGlobalOrigin: C } = ji(), { URLSerializer: b } = un(), { kHeadersList: N, kConstruct: v } = Nt(), R = bt, { types: x } = Qr, S = globalThis.ReadableStream || xn.ReadableStream, D = new TextEncoder("utf-8");
  class T {
    // Creates network error Response.
    static error() {
      const J = { settingsObject: {} }, j = new T();
      return j[B] = W(), j[I] = J, j[y][N] = j[B].headersList, j[y][Q] = "immutable", j[y][I] = J, j;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(J, j = {}) {
      w.argumentLengthCheck(arguments, 1, { header: "Response.json" }), j !== null && (j = w.converters.ResponseInit(j));
      const te = D.encode(
        g(J)
      ), ie = n(te), G = { settingsObject: {} }, q = new T();
      return q[I] = G, q[y][Q] = "response", q[y][I] = G, $(q, j, { body: ie[0], type: "application/json" }), q;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(J, j = 302) {
      const te = { settingsObject: {} };
      w.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), J = w.converters.USVString(J), j = w.converters["unsigned short"](j);
      let ie;
      try {
        ie = new URL(J, C());
      } catch (Z) {
        throw Object.assign(new TypeError("Failed to parse URL from " + J), {
          cause: Z
        });
      }
      if (!d.has(j))
        throw new RangeError("Invalid status code " + j);
      const G = new T();
      G[I] = te, G[y][Q] = "immutable", G[y][I] = te, G[B].status = j;
      const q = m(b(ie));
      return G[B].headersList.append("location", q), G;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(J = null, j = {}) {
      J !== null && (J = w.converters.BodyInit(J)), j = w.converters.ResponseInit(j), this[I] = { settingsObject: {} }, this[B] = L({}), this[y] = new t(v), this[y][Q] = "response", this[y][N] = this[B].headersList, this[y][I] = this[I];
      let te = null;
      if (J != null) {
        const [ie, G] = n(J);
        te = { body: ie, type: G };
      }
      $(this, j, te);
    }
    // Returns responses type, e.g., "cors".
    get type() {
      return w.brandCheck(this, T), this[B].type;
    }
    // Returns responses URL, if it has one; otherwise the empty string.
    get url() {
      w.brandCheck(this, T);
      const J = this[B].urlList, j = J[J.length - 1] ?? null;
      return j === null ? "" : b(j, !0);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      return w.brandCheck(this, T), this[B].urlList.length > 1;
    }
    // Returns responses status.
    get status() {
      return w.brandCheck(this, T), this[B].status;
    }
    // Returns whether responses status is an ok status.
    get ok() {
      return w.brandCheck(this, T), this[B].status >= 200 && this[B].status <= 299;
    }
    // Returns responses status message.
    get statusText() {
      return w.brandCheck(this, T), this[B].statusText;
    }
    // Returns responses headers as Headers.
    get headers() {
      return w.brandCheck(this, T), this[y];
    }
    get body() {
      return w.brandCheck(this, T), this[B].body ? this[B].body.stream : null;
    }
    get bodyUsed() {
      return w.brandCheck(this, T), !!this[B].body && o.isDisturbed(this[B].body.stream);
    }
    // Returns a clone of response.
    clone() {
      if (w.brandCheck(this, T), this.bodyUsed || this.body && this.body.locked)
        throw w.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      const J = k(this[B]), j = new T();
      return j[B] = J, j[I] = this[I], j[y][N] = J.headersList, j[y][Q] = this[y][Q], j[y][I] = this[y][I], j;
    }
  }
  i(T), Object.defineProperties(T.prototype, {
    type: c,
    url: c,
    status: c,
    ok: c,
    redirected: c,
    statusText: c,
    headers: c,
    clone: c,
    body: c,
    bodyUsed: c,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: !0
    }
  }), Object.defineProperties(T, {
    json: c,
    redirect: c,
    error: c
  });
  function k(U) {
    if (U.internalResponse)
      return _(
        k(U.internalResponse),
        U.type
      );
    const J = L({ ...U, body: null });
    return U.body != null && (J.body = s(U.body)), J;
  }
  function L(U) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...U,
      headersList: U.headersList ? new e(U.headersList) : new e(),
      urlList: U.urlList ? [...U.urlList] : []
    };
  }
  function W(U) {
    const J = h(U);
    return L({
      type: "error",
      status: 0,
      error: J ? U : new Error(U && String(U)),
      aborted: U && U.name === "AbortError"
    });
  }
  function O(U, J) {
    return J = {
      internalResponse: U,
      ...J
    }, new Proxy(U, {
      get(j, te) {
        return te in J ? J[te] : j[te];
      },
      set(j, te, ie) {
        return R(!(te in J)), j[te] = ie, !0;
      }
    });
  }
  function _(U, J) {
    if (J === "basic")
      return O(U, {
        type: "basic",
        headersList: U.headersList
      });
    if (J === "cors")
      return O(U, {
        type: "cors",
        headersList: U.headersList
      });
    if (J === "opaque")
      return O(U, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    if (J === "opaqueredirect")
      return O(U, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    R(!1);
  }
  function M(U, J = null) {
    return R(A(U)), a(U) ? W(Object.assign(new E("The operation was aborted.", "AbortError"), { cause: J })) : W(Object.assign(new E("Request was cancelled."), { cause: J }));
  }
  function $(U, J, j) {
    if (J.status !== null && (J.status < 200 || J.status > 599))
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    if ("statusText" in J && J.statusText != null && !l(String(J.statusText)))
      throw new TypeError("Invalid statusText");
    if ("status" in J && J.status != null && (U[B].status = J.status), "statusText" in J && J.statusText != null && (U[B].statusText = J.statusText), "headers" in J && J.headers != null && r(U[y], J.headers), j) {
      if (p.includes(U.status))
        throw w.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + U.status
        });
      U[B].body = j.body, j.type != null && !U[B].headersList.contains("Content-Type") && U[B].headersList.append("content-type", j.type);
    }
  }
  return w.converters.ReadableStream = w.interfaceConverter(
    S
  ), w.converters.FormData = w.interfaceConverter(
    f
  ), w.converters.URLSearchParams = w.interfaceConverter(
    URLSearchParams
  ), w.converters.XMLHttpRequestBodyInit = function(U) {
    return typeof U == "string" ? w.converters.USVString(U) : u(U) ? w.converters.Blob(U, { strict: !1 }) : x.isArrayBuffer(U) || x.isTypedArray(U) || x.isDataView(U) ? w.converters.BufferSource(U) : o.isFormDataLike(U) ? w.converters.FormData(U, { strict: !1 }) : U instanceof URLSearchParams ? w.converters.URLSearchParams(U) : w.converters.DOMString(U);
  }, w.converters.BodyInit = function(U) {
    return U instanceof S ? w.converters.ReadableStream(U) : U?.[Symbol.asyncIterator] ? U : w.converters.XMLHttpRequestBodyInit(U);
  }, w.converters.ResponseInit = w.dictionaryConverter([
    {
      key: "status",
      converter: w.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: w.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: w.converters.HeadersInit
    }
  ]), VA = {
    makeNetworkError: W,
    makeResponse: L,
    makeAppropriateNetworkError: M,
    filterResponse: _,
    Response: T,
    cloneResponse: k
  }, VA;
}
var WA, om;
function ca() {
  if (om) return WA;
  om = 1;
  const { extractBody: t, mixinBody: e, cloneBody: r } = na(), { Headers: n, fill: s, HeadersList: i } = Fs(), { FinalizationRegistry: o } = Pf()(), c = rt(), {
    isValidHTTPToken: l,
    sameOrigin: A,
    normalizeMethod: a,
    makePolicyContainer: u,
    normalizeMethodRecord: g
  } = en(), {
    forbiddenMethodsSet: h,
    corsSafeListedMethodsSet: m,
    referrerPolicy: d,
    requestRedirect: p,
    requestMode: E,
    requestCredentials: B,
    requestCache: y,
    requestDuplex: Q
  } = ns(), { kEnumerableProperty: I } = c, { kHeaders: w, kSignal: f, kState: C, kGuard: b, kRealm: N } = Tn(), { webidl: v } = br(), { getGlobalOrigin: R } = ji(), { URLSerializer: x } = un(), { kHeadersList: S, kConstruct: D } = Nt(), T = bt, { getMaxListeners: k, setMaxListeners: L, getEventListeners: W, defaultMaxListeners: O } = Ts;
  let _ = globalThis.TransformStream;
  const M = Symbol("abortController"), $ = new o(({ signal: te, abort: ie }) => {
    te.removeEventListener("abort", ie);
  });
  class U {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(ie, G = {}) {
      if (ie === D)
        return;
      v.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), ie = v.converters.RequestInfo(ie), G = v.converters.RequestInit(G), this[N] = {
        settingsObject: {
          baseUrl: R(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: u()
        }
      };
      let q = null, Z = null;
      const se = this[N].settingsObject.baseUrl;
      let F = null;
      if (typeof ie == "string") {
        let je;
        try {
          je = new URL(ie, se);
        } catch (st) {
          throw new TypeError("Failed to parse URL from " + ie, { cause: st });
        }
        if (je.username || je.password)
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + ie
          );
        q = J({ urlList: [je] }), Z = "cors";
      } else
        T(ie instanceof U), q = ie[C], F = ie[f];
      const ne = this[N].settingsObject.origin;
      let de = "client";
      if (q.window?.constructor?.name === "EnvironmentSettingsObject" && A(q.window, ne) && (de = q.window), G.window != null)
        throw new TypeError(`'window' option '${de}' must be null`);
      "window" in G && (de = "no-window"), q = J({
        // URL requests URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method requests method.
        method: q.method,
        // header list A copy of requests header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: q.headersList,
        // unsafe-request flag Set.
        unsafeRequest: q.unsafeRequest,
        // client Thiss relevant settings object.
        client: this[N].settingsObject,
        // window window.
        window: de,
        // priority requests priority.
        priority: q.priority,
        // origin requests origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: q.origin,
        // referrer requests referrer.
        referrer: q.referrer,
        // referrer policy requests referrer policy.
        referrerPolicy: q.referrerPolicy,
        // mode requests mode.
        mode: q.mode,
        // credentials mode requests credentials mode.
        credentials: q.credentials,
        // cache mode requests cache mode.
        cache: q.cache,
        // redirect mode requests redirect mode.
        redirect: q.redirect,
        // integrity metadata requests integrity metadata.
        integrity: q.integrity,
        // keepalive requests keepalive.
        keepalive: q.keepalive,
        // reload-navigation flag requests reload-navigation flag.
        reloadNavigation: q.reloadNavigation,
        // history-navigation flag requests history-navigation flag.
        historyNavigation: q.historyNavigation,
        // URL list A clone of requests URL list.
        urlList: [...q.urlList]
      });
      const ve = Object.keys(G).length !== 0;
      if (ve && (q.mode === "navigate" && (q.mode = "same-origin"), q.reloadNavigation = !1, q.historyNavigation = !1, q.origin = "client", q.referrer = "client", q.referrerPolicy = "", q.url = q.urlList[q.urlList.length - 1], q.urlList = [q.url]), G.referrer !== void 0) {
        const je = G.referrer;
        if (je === "")
          q.referrer = "no-referrer";
        else {
          let st;
          try {
            st = new URL(je, se);
          } catch (pt) {
            throw new TypeError(`Referrer "${je}" is not a valid URL.`, { cause: pt });
          }
          st.protocol === "about:" && st.hostname === "client" || ne && !A(st, this[N].settingsObject.baseUrl) ? q.referrer = "client" : q.referrer = st;
        }
      }
      G.referrerPolicy !== void 0 && (q.referrerPolicy = G.referrerPolicy);
      let Ce;
      if (G.mode !== void 0 ? Ce = G.mode : Ce = Z, Ce === "navigate")
        throw v.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      if (Ce != null && (q.mode = Ce), G.credentials !== void 0 && (q.credentials = G.credentials), G.cache !== void 0 && (q.cache = G.cache), q.cache === "only-if-cached" && q.mode !== "same-origin")
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      if (G.redirect !== void 0 && (q.redirect = G.redirect), G.integrity != null && (q.integrity = String(G.integrity)), G.keepalive !== void 0 && (q.keepalive = !!G.keepalive), G.method !== void 0) {
        let je = G.method;
        if (!l(je))
          throw new TypeError(`'${je}' is not a valid HTTP method.`);
        if (h.has(je.toUpperCase()))
          throw new TypeError(`'${je}' HTTP method is unsupported.`);
        je = g[je] ?? a(je), q.method = je;
      }
      G.signal !== void 0 && (F = G.signal), this[C] = q;
      const Qe = new AbortController();
      if (this[f] = Qe.signal, this[f][N] = this[N], F != null) {
        if (!F || typeof F.aborted != "boolean" || typeof F.addEventListener != "function")
          throw new TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal."
          );
        if (F.aborted)
          Qe.abort(F.reason);
        else {
          this[M] = Qe;
          const je = new WeakRef(Qe), st = function() {
            const pt = je.deref();
            pt !== void 0 && pt.abort(this.reason);
          };
          try {
            (typeof k == "function" && k(F) === O || W(F, "abort").length >= O) && L(100, F);
          } catch {
          }
          c.addAbortListener(F, st), $.register(Qe, { signal: F, abort: st });
        }
      }
      if (this[w] = new n(D), this[w][S] = q.headersList, this[w][b] = "request", this[w][N] = this[N], Ce === "no-cors") {
        if (!m.has(q.method))
          throw new TypeError(
            `'${q.method} is unsupported in no-cors mode.`
          );
        this[w][b] = "request-no-cors";
      }
      if (ve) {
        const je = this[w][S], st = G.headers !== void 0 ? G.headers : new i(je);
        if (je.clear(), st instanceof i) {
          for (const [pt, Er] of st)
            je.append(pt, Er);
          je.cookies = st.cookies;
        } else
          s(this[w], st);
      }
      const xe = ie instanceof U ? ie[C].body : null;
      if ((G.body != null || xe != null) && (q.method === "GET" || q.method === "HEAD"))
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      let _e = null;
      if (G.body != null) {
        const [je, st] = t(
          G.body,
          q.keepalive
        );
        _e = je, st && !this[w][S].contains("content-type") && this[w].append("content-type", st);
      }
      const Et = _e ?? xe;
      if (Et != null && Et.source == null) {
        if (_e != null && G.duplex == null)
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        if (q.mode !== "same-origin" && q.mode !== "cors")
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        q.useCORSPreflightFlag = !0;
      }
      let Jt = Et;
      if (_e == null && xe != null) {
        if (c.isDisturbed(xe.stream) || xe.stream.locked)
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        _ || (_ = xn.TransformStream);
        const je = new _();
        xe.stream.pipeThrough(je), Jt = {
          source: xe.source,
          length: xe.length,
          stream: je.readable
        };
      }
      this[C].body = Jt;
    }
    // Returns requests HTTP method, which is "GET" by default.
    get method() {
      return v.brandCheck(this, U), this[C].method;
    }
    // Returns the URL of request as a string.
    get url() {
      return v.brandCheck(this, U), x(this[C].url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      return v.brandCheck(this, U), this[w];
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      return v.brandCheck(this, U), this[C].destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the globals default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      return v.brandCheck(this, U), this[C].referrer === "no-referrer" ? "" : this[C].referrer === "client" ? "about:client" : this[C].referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the requests
    // referrer.
    get referrerPolicy() {
      return v.brandCheck(this, U), this[C].referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      return v.brandCheck(this, U), this[C].mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      return this[C].credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browsers cache when fetching.
    get cache() {
      return v.brandCheck(this, U), this[C].cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      return v.brandCheck(this, U), this[C].redirect;
    }
    // Returns requests subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      return v.brandCheck(this, U), this[C].integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      return v.brandCheck(this, U), this[C].keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      return v.brandCheck(this, U), this[C].reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-foward navigation).
    get isHistoryNavigation() {
      return v.brandCheck(this, U), this[C].historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      return v.brandCheck(this, U), this[f];
    }
    get body() {
      return v.brandCheck(this, U), this[C].body ? this[C].body.stream : null;
    }
    get bodyUsed() {
      return v.brandCheck(this, U), !!this[C].body && c.isDisturbed(this[C].body.stream);
    }
    get duplex() {
      return v.brandCheck(this, U), "half";
    }
    // Returns a clone of request.
    clone() {
      if (v.brandCheck(this, U), this.bodyUsed || this.body?.locked)
        throw new TypeError("unusable");
      const ie = j(this[C]), G = new U(D);
      G[C] = ie, G[N] = this[N], G[w] = new n(D), G[w][S] = ie.headersList, G[w][b] = this[w][b], G[w][N] = this[w][N];
      const q = new AbortController();
      return this.signal.aborted ? q.abort(this.signal.reason) : c.addAbortListener(
        this.signal,
        () => {
          q.abort(this.signal.reason);
        }
      ), G[f] = q.signal, G;
    }
  }
  e(U);
  function J(te) {
    const ie = {
      method: "GET",
      localURLsOnly: !1,
      unsafeRequest: !1,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: !1,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: !1,
      credentials: "same-origin",
      useCredentials: !1,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: !1,
      historyNavigation: !1,
      userActivation: !1,
      taintedOrigin: !1,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: !1,
      done: !1,
      timingAllowFailed: !1,
      ...te,
      headersList: te.headersList ? new i(te.headersList) : new i()
    };
    return ie.url = ie.urlList[0], ie;
  }
  function j(te) {
    const ie = J({ ...te, body: null });
    return te.body != null && (ie.body = r(te.body)), ie;
  }
  return Object.defineProperties(U.prototype, {
    method: I,
    url: I,
    headers: I,
    redirect: I,
    clone: I,
    signal: I,
    duplex: I,
    destination: I,
    body: I,
    bodyUsed: I,
    isHistoryNavigation: I,
    isReloadNavigation: I,
    keepalive: I,
    integrity: I,
    cache: I,
    credentials: I,
    attribute: I,
    referrerPolicy: I,
    referrer: I,
    mode: I,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: !0
    }
  }), v.converters.Request = v.interfaceConverter(
    U
  ), v.converters.RequestInfo = function(te) {
    return typeof te == "string" ? v.converters.USVString(te) : te instanceof U ? v.converters.Request(te) : v.converters.USVString(te);
  }, v.converters.AbortSignal = v.interfaceConverter(
    AbortSignal
  ), v.converters.RequestInit = v.dictionaryConverter([
    {
      key: "method",
      converter: v.converters.ByteString
    },
    {
      key: "headers",
      converter: v.converters.HeadersInit
    },
    {
      key: "body",
      converter: v.nullableConverter(
        v.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: v.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: v.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: d
    },
    {
      key: "mode",
      converter: v.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: E
    },
    {
      key: "credentials",
      converter: v.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: B
    },
    {
      key: "cache",
      converter: v.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: y
    },
    {
      key: "redirect",
      converter: v.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: p
    },
    {
      key: "integrity",
      converter: v.converters.DOMString
    },
    {
      key: "keepalive",
      converter: v.converters.boolean
    },
    {
      key: "signal",
      converter: v.nullableConverter(
        (te) => v.converters.AbortSignal(
          te,
          { strict: !1 }
        )
      )
    },
    {
      key: "window",
      converter: v.converters.any
    },
    {
      key: "duplex",
      converter: v.converters.DOMString,
      allowedValues: Q
    }
  ]), WA = { Request: U, makeRequest: J }, WA;
}
var jA, am;
function mu() {
  if (am) return jA;
  am = 1;
  const {
    Response: t,
    makeNetworkError: e,
    makeAppropriateNetworkError: r,
    filterResponse: n,
    makeResponse: s
  } = gu(), { Headers: i } = Fs(), { Request: o, makeRequest: c } = ca(), l = UQ, {
    bytesMatch: A,
    makePolicyContainer: a,
    clonePolicyContainer: u,
    requestBadPort: g,
    TAOCheck: h,
    appendRequestOriginHeader: m,
    responseLocationURL: d,
    requestCurrentURL: p,
    setRequestReferrerPolicyOnRedirect: E,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: B,
    createOpaqueTimingInfo: y,
    appendFetchMetadata: Q,
    corsCheck: I,
    crossOriginResourcePolicyCheck: w,
    determineRequestsReferrer: f,
    coarsenedSharedCurrentTime: C,
    createDeferredPromise: b,
    isBlobLike: N,
    sameOrigin: v,
    isCancelled: R,
    isAborted: x,
    isErrorLike: S,
    fullyReadBody: D,
    readableStreamClose: T,
    isomorphicEncode: k,
    urlIsLocal: L,
    urlIsHttpHttpsScheme: W,
    urlHasHttpsScheme: O
  } = en(), { kState: _, kHeaders: M, kGuard: $, kRealm: U } = Tn(), J = bt, { safelyExtractBody: j } = na(), {
    redirectStatusSet: te,
    nullBodyStatus: ie,
    safeMethodsSet: G,
    requestBodyHeader: q,
    subresourceSet: Z,
    DOMException: se
  } = ns(), { kHeadersList: F } = Nt(), ne = Ts, { Readable: de, pipeline: ve } = ln, { addAbortListener: Ce, isErrored: Qe, isReadable: xe, nodeMajor: _e, nodeMinor: Et } = rt(), { dataURLProcessor: Jt, serializeAMimeType: je } = un(), { TransformStream: st } = xn, { getGlobalDispatcher: pt } = Zi(), { webidl: Er } = br(), { STATUS_CODES: Ot } = Ds, K = ["GET", "HEAD"];
  let ce, Ee = globalThis.ReadableStream;
  class Ue extends ne {
    constructor(fe) {
      super(), this.dispatcher = fe, this.connection = null, this.dump = !1, this.state = "ongoing", this.setMaxListeners(21);
    }
    terminate(fe) {
      this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(fe), this.emit("terminated", fe));
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(fe) {
      this.state === "ongoing" && (this.state = "aborted", fe || (fe = new se("The operation was aborted.", "AbortError")), this.serializedAbortReason = fe, this.connection?.destroy(fe), this.emit("terminated", fe));
    }
  }
  function $e(ee, fe = {}) {
    Er.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const le = b();
    let Ae;
    try {
      Ae = new o(ee, fe);
    } catch (Te) {
      return le.reject(Te), le.promise;
    }
    const Be = Ae[_];
    if (Ae.signal.aborted)
      return Vt(le, Be, null, Ae.signal.reason), le.promise;
    Be.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (Be.serviceWorkers = "none");
    let Me = null;
    const Wt = null;
    let ar = !1, vt = null;
    return Ce(
      Ae.signal,
      () => {
        ar = !0, J(vt != null), vt.abort(Ae.signal.reason), Vt(le, Be, Me, Ae.signal.reason);
      }
    ), vt = P({
      request: Be,
      processResponseEndOfBody: (Te) => Ct(Te, "fetch"),
      processResponse: (Te) => {
        if (ar)
          return Promise.resolve();
        if (Te.aborted)
          return Vt(le, Be, Me, vt.serializedAbortReason), Promise.resolve();
        if (Te.type === "error")
          return le.reject(
            Object.assign(new TypeError("fetch failed"), { cause: Te.error })
          ), Promise.resolve();
        Me = new t(), Me[_] = Te, Me[U] = Wt, Me[M][F] = Te.headersList, Me[M][$] = "immutable", Me[M][U] = Wt, le.resolve(Me);
      },
      dispatcher: fe.dispatcher ?? pt()
      // undici
    }), le.promise;
  }
  function Ct(ee, fe = "other") {
    if (ee.type === "error" && ee.aborted || !ee.urlList?.length)
      return;
    const le = ee.urlList[0];
    let Ae = ee.timingInfo, Be = ee.cacheState;
    W(le) && Ae !== null && (ee.timingAllowPassed || (Ae = y({
      startTime: Ae.startTime
    }), Be = ""), Ae.endTime = C(), ee.timingInfo = Ae, St(
      Ae,
      le,
      fe,
      globalThis,
      Be
    ));
  }
  function St(ee, fe, le, Ae, Be) {
    (_e > 18 || _e === 18 && Et >= 2) && performance.markResourceTiming(ee, fe.href, le, Ae, Be);
  }
  function Vt(ee, fe, le, Ae) {
    if (Ae || (Ae = new se("The operation was aborted.", "AbortError")), ee.reject(Ae), fe.body != null && xe(fe.body?.stream) && fe.body.stream.cancel(Ae).catch((he) => {
      if (he.code !== "ERR_INVALID_STATE")
        throw he;
    }), le == null)
      return;
    const Be = le[_];
    Be.body != null && xe(Be.body?.stream) && Be.body.stream.cancel(Ae).catch((he) => {
      if (he.code !== "ERR_INVALID_STATE")
        throw he;
    });
  }
  function P({
    request: ee,
    processRequestBodyChunkLength: fe,
    processRequestEndOfBody: le,
    processResponse: Ae,
    processResponseEndOfBody: Be,
    processResponseConsumeBody: he,
    useParallelQueue: Me = !1,
    dispatcher: Wt
    // undici
  }) {
    let ar = null, vt = !1;
    ee.client != null && (ar = ee.client.globalObject, vt = ee.client.crossOriginIsolatedCapability);
    const _r = C(vt), bn = y({
      startTime: _r
    }), Te = {
      controller: new Ue(Wt),
      request: ee,
      timingInfo: bn,
      processRequestBodyChunkLength: fe,
      processRequestEndOfBody: le,
      processResponse: Ae,
      processResponseConsumeBody: he,
      processResponseEndOfBody: Be,
      taskDestination: ar,
      crossOriginIsolatedCapability: vt
    };
    return J(!ee.body || ee.body.stream), ee.window === "client" && (ee.window = ee.client?.globalObject?.constructor?.name === "Window" ? ee.client : "no-window"), ee.origin === "client" && (ee.origin = ee.client?.origin), ee.policyContainer === "client" && (ee.client != null ? ee.policyContainer = u(
      ee.client.policyContainer
    ) : ee.policyContainer = a()), ee.headersList.contains("accept") || ee.headersList.append("accept", "*/*"), ee.headersList.contains("accept-language") || ee.headersList.append("accept-language", "*"), ee.priority, Z.has(ee.destination), z(Te).catch((Bt) => {
      Te.controller.terminate(Bt);
    }), Te.controller;
  }
  async function z(ee, fe = !1) {
    const le = ee.request;
    let Ae = null;
    if (le.localURLsOnly && !L(p(le)) && (Ae = e("local URLs only")), B(le), g(le) === "blocked" && (Ae = e("bad port")), le.referrerPolicy === "" && (le.referrerPolicy = le.policyContainer.referrerPolicy), le.referrer !== "no-referrer" && (le.referrer = f(le)), Ae === null && (Ae = await (async () => {
      const he = p(le);
      return (
        // - requests current URLs origin is same origin with requests origin,
        //   and requests response tainting is "basic"
        v(he, le.url) && le.responseTainting === "basic" || // requests current URLs scheme is "data"
        he.protocol === "data:" || // - requests mode is "navigate" or "websocket"
        le.mode === "navigate" || le.mode === "websocket" ? (le.responseTainting = "basic", await X(ee)) : le.mode === "same-origin" ? e('request mode cannot be "same-origin"') : le.mode === "no-cors" ? le.redirect !== "follow" ? e(
          'redirect mode cannot be "follow" for "no-cors" request'
        ) : (le.responseTainting = "opaque", await X(ee)) : W(p(le)) ? (le.responseTainting = "cors", await Ie(ee)) : e("URL scheme must be a HTTP(S) scheme")
      );
    })()), fe)
      return Ae;
    Ae.status !== 0 && !Ae.internalResponse && (le.responseTainting, le.responseTainting === "basic" ? Ae = n(Ae, "basic") : le.responseTainting === "cors" ? Ae = n(Ae, "cors") : le.responseTainting === "opaque" ? Ae = n(Ae, "opaque") : J(!1));
    let Be = Ae.status === 0 ? Ae : Ae.internalResponse;
    if (Be.urlList.length === 0 && Be.urlList.push(...le.urlList), le.timingAllowFailed || (Ae.timingAllowPassed = !0), Ae.type === "opaque" && Be.status === 206 && Be.rangeRequested && !le.headers.contains("range") && (Ae = Be = e()), Ae.status !== 0 && (le.method === "HEAD" || le.method === "CONNECT" || ie.includes(Be.status)) && (Be.body = null, ee.controller.dump = !0), le.integrity) {
      const he = (Wt) => ge(ee, e(Wt));
      if (le.responseTainting === "opaque" || Ae.body == null) {
        he(Ae.error);
        return;
      }
      const Me = (Wt) => {
        if (!A(Wt, le.integrity)) {
          he("integrity mismatch");
          return;
        }
        Ae.body = j(Wt)[0], ge(ee, Ae);
      };
      await D(Ae.body, Me, he);
    } else
      ge(ee, Ae);
  }
  function X(ee) {
    if (R(ee) && ee.request.redirectCount === 0)
      return Promise.resolve(r(ee));
    const { request: fe } = ee, { protocol: le } = p(fe);
    switch (le) {
      case "about:":
        return Promise.resolve(e("about scheme is not supported"));
      case "blob:": {
        ce || (ce = Dn.resolveObjectURL);
        const Ae = p(fe);
        if (Ae.search.length !== 0)
          return Promise.resolve(e("NetworkError when attempting to fetch resource."));
        const Be = ce(Ae.toString());
        if (fe.method !== "GET" || !N(Be))
          return Promise.resolve(e("invalid method"));
        const he = j(Be), Me = he[0], Wt = k(`${Me.length}`), ar = he[1] ?? "", vt = s({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: Wt }],
            ["content-type", { name: "Content-Type", value: ar }]
          ]
        });
        return vt.body = Me, Promise.resolve(vt);
      }
      case "data:": {
        const Ae = p(fe), Be = Jt(Ae);
        if (Be === "failure")
          return Promise.resolve(e("failed to fetch the data URL"));
        const he = je(Be.mimeType);
        return Promise.resolve(s({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: he }]
          ],
          body: j(Be.body)[0]
        }));
      }
      case "file:":
        return Promise.resolve(e("not implemented... yet..."));
      case "http:":
      case "https:":
        return Ie(ee).catch((Ae) => e(Ae));
      default:
        return Promise.resolve(e("unknown scheme"));
    }
  }
  function ae(ee, fe) {
    ee.request.done = !0, ee.processResponseDone != null && queueMicrotask(() => ee.processResponseDone(fe));
  }
  function ge(ee, fe) {
    fe.type === "error" && (fe.urlList = [ee.request.urlList[0]], fe.timingInfo = y({
      startTime: ee.timingInfo.startTime
    }));
    const le = () => {
      ee.request.done = !0, ee.processResponseEndOfBody != null && queueMicrotask(() => ee.processResponseEndOfBody(fe));
    };
    if (ee.processResponse != null && queueMicrotask(() => ee.processResponse(fe)), fe.body == null)
      le();
    else {
      const Ae = (he, Me) => {
        Me.enqueue(he);
      }, Be = new st({
        start() {
        },
        transform: Ae,
        flush: le
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      fe.body = { stream: fe.body.stream.pipeThrough(Be) };
    }
    if (ee.processResponseConsumeBody != null) {
      const Ae = (he) => ee.processResponseConsumeBody(fe, he), Be = (he) => ee.processResponseConsumeBody(fe, he);
      if (fe.body == null)
        queueMicrotask(() => Ae(null));
      else
        return D(fe.body, Ae, Be);
      return Promise.resolve();
    }
  }
  async function Ie(ee) {
    const fe = ee.request;
    let le = null, Ae = null;
    const Be = ee.timingInfo;
    if (fe.serviceWorkers, le === null) {
      if (fe.redirect === "follow" && (fe.serviceWorkers = "none"), Ae = le = await Ve(ee), fe.responseTainting === "cors" && I(fe, le) === "failure")
        return e("cors failure");
      h(fe, le) === "failure" && (fe.timingAllowFailed = !0);
    }
    return (fe.responseTainting === "opaque" || le.type === "opaque") && w(
      fe.origin,
      fe.client,
      fe.destination,
      Ae
    ) === "blocked" ? e("blocked") : (te.has(Ae.status) && (fe.redirect !== "manual" && ee.controller.connection.destroy(), fe.redirect === "error" ? le = e("unexpected redirect") : fe.redirect === "manual" ? le = Ae : fe.redirect === "follow" ? le = await De(ee, le) : J(!1)), le.timingInfo = Be, le);
  }
  function De(ee, fe) {
    const le = ee.request, Ae = fe.internalResponse ? fe.internalResponse : fe;
    let Be;
    try {
      if (Be = d(
        Ae,
        p(le).hash
      ), Be == null)
        return fe;
    } catch (Me) {
      return Promise.resolve(e(Me));
    }
    if (!W(Be))
      return Promise.resolve(e("URL scheme must be a HTTP(S) scheme"));
    if (le.redirectCount === 20)
      return Promise.resolve(e("redirect count exceeded"));
    if (le.redirectCount += 1, le.mode === "cors" && (Be.username || Be.password) && !v(le, Be))
      return Promise.resolve(e('cross origin not allowed for request mode "cors"'));
    if (le.responseTainting === "cors" && (Be.username || Be.password))
      return Promise.resolve(e(
        'URL cannot contain credentials for request mode "cors"'
      ));
    if (Ae.status !== 303 && le.body != null && le.body.source == null)
      return Promise.resolve(e());
    if ([301, 302].includes(Ae.status) && le.method === "POST" || Ae.status === 303 && !K.includes(le.method)) {
      le.method = "GET", le.body = null;
      for (const Me of q)
        le.headersList.delete(Me);
    }
    v(p(le), Be) || (le.headersList.delete("authorization"), le.headersList.delete("proxy-authorization", !0), le.headersList.delete("cookie"), le.headersList.delete("host")), le.body != null && (J(le.body.source != null), le.body = j(le.body.source)[0]);
    const he = ee.timingInfo;
    return he.redirectEndTime = he.postRedirectStartTime = C(ee.crossOriginIsolatedCapability), he.redirectStartTime === 0 && (he.redirectStartTime = he.startTime), le.urlList.push(Be), E(le, Ae), z(ee, !0);
  }
  async function Ve(ee, fe = !1, le = !1) {
    const Ae = ee.request;
    let Be = null, he = null, Me = null;
    Ae.window === "no-window" && Ae.redirect === "error" ? (Be = ee, he = Ae) : (he = c(Ae), Be = { ...ee }, Be.request = he);
    const Wt = Ae.credentials === "include" || Ae.credentials === "same-origin" && Ae.responseTainting === "basic", ar = he.body ? he.body.length : null;
    let vt = null;
    if (he.body == null && ["POST", "PUT"].includes(he.method) && (vt = "0"), ar != null && (vt = k(`${ar}`)), vt != null && he.headersList.append("content-length", vt), ar != null && he.keepalive, he.referrer instanceof URL && he.headersList.append("referer", k(he.referrer.href)), m(he), Q(he), he.headersList.contains("user-agent") || he.headersList.append("user-agent", typeof esbuildDetection > "u" ? "undici" : "node"), he.cache === "default" && (he.headersList.contains("if-modified-since") || he.headersList.contains("if-none-match") || he.headersList.contains("if-unmodified-since") || he.headersList.contains("if-match") || he.headersList.contains("if-range")) && (he.cache = "no-store"), he.cache === "no-cache" && !he.preventNoCacheCacheControlHeaderModification && !he.headersList.contains("cache-control") && he.headersList.append("cache-control", "max-age=0"), (he.cache === "no-store" || he.cache === "reload") && (he.headersList.contains("pragma") || he.headersList.append("pragma", "no-cache"), he.headersList.contains("cache-control") || he.headersList.append("cache-control", "no-cache")), he.headersList.contains("range") && he.headersList.append("accept-encoding", "identity"), he.headersList.contains("accept-encoding") || (O(p(he)) ? he.headersList.append("accept-encoding", "br, gzip, deflate") : he.headersList.append("accept-encoding", "gzip, deflate")), he.headersList.delete("host"), he.cache = "no-store", he.mode !== "no-store" && he.mode, Me == null) {
      if (he.mode === "only-if-cached")
        return e("only if cached");
      const _r = await Pe(
        Be,
        Wt,
        le
      );
      !G.has(he.method) && _r.status >= 200 && _r.status <= 399, Me == null && (Me = _r);
    }
    if (Me.urlList = [...he.urlList], he.headersList.contains("range") && (Me.rangeRequested = !0), Me.requestIncludesCredentials = Wt, Me.status === 407)
      return Ae.window === "no-window" ? e() : R(ee) ? r(ee) : e("proxy authentication required");
    if (
      // responses status is 421
      Me.status === 421 && // isNewConnectionFetch is false
      !le && // requests body is null, or requests body is non-null and requests bodys source is non-null
      (Ae.body == null || Ae.body.source != null)
    ) {
      if (R(ee))
        return r(ee);
      ee.controller.connection.destroy(), Me = await Ve(
        ee,
        fe,
        !0
      );
    }
    return Me;
  }
  async function Pe(ee, fe = !1, le = !1) {
    J(!ee.controller.connection || ee.controller.connection.destroyed), ee.controller.connection = {
      abort: null,
      destroyed: !1,
      destroy(Te) {
        this.destroyed || (this.destroyed = !0, this.abort?.(Te ?? new se("The operation was aborted.", "AbortError")));
      }
    };
    const Ae = ee.request;
    let Be = null;
    const he = ee.timingInfo;
    Ae.cache = "no-store", Ae.mode;
    let Me = null;
    if (Ae.body == null && ee.processRequestEndOfBody)
      queueMicrotask(() => ee.processRequestEndOfBody());
    else if (Ae.body != null) {
      const Te = async function* (ct) {
        R(ee) || (yield ct, ee.processRequestBodyChunkLength?.(ct.byteLength));
      }, Bt = () => {
        R(ee) || ee.processRequestEndOfBody && ee.processRequestEndOfBody();
      }, Ar = (ct) => {
        R(ee) || (ct.name === "AbortError" ? ee.controller.abort() : ee.controller.terminate(ct));
      };
      Me = async function* () {
        try {
          for await (const ct of Ae.body.stream)
            yield* Te(ct);
          Bt();
        } catch (ct) {
          Ar(ct);
        }
      }();
    }
    try {
      const { body: Te, status: Bt, statusText: Ar, headersList: ct, socket: qr } = await bn({ body: Me });
      if (qr)
        Be = s({ status: Bt, statusText: Ar, headersList: ct, socket: qr });
      else {
        const It = Te[Symbol.asyncIterator]();
        ee.controller.next = () => It.next(), Be = s({ status: Bt, statusText: Ar, headersList: ct });
      }
    } catch (Te) {
      return Te.name === "AbortError" ? (ee.controller.connection.destroy(), r(ee, Te)) : e(Te);
    }
    const Wt = () => {
      ee.controller.resume();
    }, ar = (Te) => {
      ee.controller.abort(Te);
    };
    Ee || (Ee = xn.ReadableStream);
    const vt = new Ee(
      {
        async start(Te) {
          ee.controller.controller = Te;
        },
        async pull(Te) {
          await Wt();
        },
        async cancel(Te) {
          await ar(Te);
        }
      },
      {
        highWaterMark: 0,
        size() {
          return 1;
        }
      }
    );
    Be.body = { stream: vt }, ee.controller.on("terminated", _r), ee.controller.resume = async () => {
      for (; ; ) {
        let Te, Bt;
        try {
          const { done: Ar, value: ct } = await ee.controller.next();
          if (x(ee))
            break;
          Te = Ar ? void 0 : ct;
        } catch (Ar) {
          ee.controller.ended && !he.encodedBodySize ? Te = void 0 : (Te = Ar, Bt = !0);
        }
        if (Te === void 0) {
          T(ee.controller.controller), ae(ee, Be);
          return;
        }
        if (he.decodedBodySize += Te?.byteLength ?? 0, Bt) {
          ee.controller.terminate(Te);
          return;
        }
        if (ee.controller.controller.enqueue(new Uint8Array(Te)), Qe(vt)) {
          ee.controller.terminate();
          return;
        }
        if (!ee.controller.controller.desiredSize)
          return;
      }
    };
    function _r(Te) {
      x(ee) ? (Be.aborted = !0, xe(vt) && ee.controller.controller.error(
        ee.controller.serializedAbortReason
      )) : xe(vt) && ee.controller.controller.error(new TypeError("terminated", {
        cause: S(Te) ? Te : void 0
      })), ee.controller.connection.destroy();
    }
    return Be;
    async function bn({ body: Te }) {
      const Bt = p(Ae), Ar = ee.controller.dispatcher;
      return new Promise((ct, qr) => Ar.dispatch(
        {
          path: Bt.pathname + Bt.search,
          origin: Bt.origin,
          method: Ae.method,
          body: ee.controller.dispatcher.isMockActive ? Ae.body && (Ae.body.source || Ae.body.stream) : Te,
          headers: Ae.headersList.entries,
          maxRedirections: 0,
          upgrade: Ae.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(It) {
            const { connection: Gt } = ee.controller;
            Gt.destroyed ? It(new se("The operation was aborted.", "AbortError")) : (ee.controller.on("terminated", It), this.abort = Gt.abort = It);
          },
          onHeaders(It, Gt, oi, ls) {
            if (It < 200)
              return;
            let Hr = [], wn = "";
            const sn = new i();
            if (Array.isArray(Gt))
              for (let Cr = 0; Cr < Gt.length; Cr += 2) {
                const zr = Gt[Cr + 0].toString("latin1"), Ut = Gt[Cr + 1].toString("latin1");
                zr.toLowerCase() === "content-encoding" ? Hr = Ut.toLowerCase().split(",").map((Ai) => Ai.trim()) : zr.toLowerCase() === "location" && (wn = Ut), sn[F].append(zr, Ut);
              }
            else {
              const Cr = Object.keys(Gt);
              for (const zr of Cr) {
                const Ut = Gt[zr];
                zr.toLowerCase() === "content-encoding" ? Hr = Ut.toLowerCase().split(",").map((Ai) => Ai.trim()).reverse() : zr.toLowerCase() === "location" && (wn = Ut), sn[F].append(zr, Ut);
              }
            }
            this.body = new de({ read: oi });
            const gn = [], ai = Ae.redirect === "follow" && wn && te.has(It);
            if (Ae.method !== "HEAD" && Ae.method !== "CONNECT" && !ie.includes(It) && !ai)
              for (const Cr of Hr)
                if (Cr === "x-gzip" || Cr === "gzip")
                  gn.push(l.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: l.constants.Z_SYNC_FLUSH,
                    finishFlush: l.constants.Z_SYNC_FLUSH
                  }));
                else if (Cr === "deflate")
                  gn.push(l.createInflate());
                else if (Cr === "br")
                  gn.push(l.createBrotliDecompress());
                else {
                  gn.length = 0;
                  break;
                }
            return ct({
              status: It,
              statusText: ls,
              headersList: sn[F],
              body: gn.length ? ve(this.body, ...gn, () => {
              }) : this.body.on("error", () => {
              })
            }), !0;
          },
          onData(It) {
            if (ee.controller.dump)
              return;
            const Gt = It;
            return he.encodedBodySize += Gt.byteLength, this.body.push(Gt);
          },
          onComplete() {
            this.abort && ee.controller.off("terminated", this.abort), ee.controller.ended = !0, this.body.push(null);
          },
          onError(It) {
            this.abort && ee.controller.off("terminated", this.abort), this.body?.destroy(It), ee.controller.terminate(It), qr(It);
          },
          onUpgrade(It, Gt, oi) {
            if (It !== 101)
              return;
            const ls = new i();
            for (let Hr = 0; Hr < Gt.length; Hr += 2) {
              const wn = Gt[Hr + 0].toString("latin1"), sn = Gt[Hr + 1].toString("latin1");
              ls[F].append(wn, sn);
            }
            return ct({
              status: It,
              statusText: Ot[It],
              headersList: ls[F],
              socket: oi
            }), !0;
          }
        }
      ));
    }
  }
  return jA = {
    fetch: $e,
    Fetch: Ue,
    fetching: P,
    finalizeAndReportTiming: Ct
  }, jA;
}
var $A, Am;
function Gf() {
  return Am || (Am = 1, $A = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  }), $A;
}
var XA, cm;
function Db() {
  if (cm) return XA;
  cm = 1;
  const { webidl: t } = br(), e = Symbol("ProgressEvent state");
  class r extends Event {
    constructor(s, i = {}) {
      s = t.converters.DOMString(s), i = t.converters.ProgressEventInit(i ?? {}), super(s, i), this[e] = {
        lengthComputable: i.lengthComputable,
        loaded: i.loaded,
        total: i.total
      };
    }
    get lengthComputable() {
      return t.brandCheck(this, r), this[e].lengthComputable;
    }
    get loaded() {
      return t.brandCheck(this, r), this[e].loaded;
    }
    get total() {
      return t.brandCheck(this, r), this[e].total;
    }
  }
  return t.converters.ProgressEventInit = t.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: t.converters.boolean,
      defaultValue: !1
    },
    {
      key: "loaded",
      converter: t.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: t.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: t.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: t.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: t.converters.boolean,
      defaultValue: !1
    }
  ]), XA = {
    ProgressEvent: r
  }, XA;
}
var KA, lm;
function Tb() {
  if (lm) return KA;
  lm = 1;
  function t(e) {
    if (!e)
      return "failure";
    switch (e.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  return KA = {
    getEncoding: t
  }, KA;
}
var ZA, um;
function kb() {
  if (um) return ZA;
  um = 1;
  const {
    kState: t,
    kError: e,
    kResult: r,
    kAborted: n,
    kLastProgressEventFired: s
  } = Gf(), { ProgressEvent: i } = Db(), { getEncoding: o } = Tb(), { DOMException: c } = ns(), { serializeAMimeType: l, parseMIMEType: A } = un(), { types: a } = Qr, { StringDecoder: u } = bf, { btoa: g } = Dn, h = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  };
  function m(Q, I, w, f) {
    if (Q[t] === "loading")
      throw new c("Invalid state", "InvalidStateError");
    Q[t] = "loading", Q[r] = null, Q[e] = null;
    const b = I.stream().getReader(), N = [];
    let v = b.read(), R = !0;
    (async () => {
      for (; !Q[n]; )
        try {
          const { done: x, value: S } = await v;
          if (R && !Q[n] && queueMicrotask(() => {
            d("loadstart", Q);
          }), R = !1, !x && a.isUint8Array(S))
            N.push(S), (Q[s] === void 0 || Date.now() - Q[s] >= 50) && !Q[n] && (Q[s] = Date.now(), queueMicrotask(() => {
              d("progress", Q);
            })), v = b.read();
          else if (x) {
            queueMicrotask(() => {
              Q[t] = "done";
              try {
                const D = p(N, w, I.type, f);
                if (Q[n])
                  return;
                Q[r] = D, d("load", Q);
              } catch (D) {
                Q[e] = D, d("error", Q);
              }
              Q[t] !== "loading" && d("loadend", Q);
            });
            break;
          }
        } catch (x) {
          if (Q[n])
            return;
          queueMicrotask(() => {
            Q[t] = "done", Q[e] = x, d("error", Q), Q[t] !== "loading" && d("loadend", Q);
          });
          break;
        }
    })();
  }
  function d(Q, I) {
    const w = new i(Q, {
      bubbles: !1,
      cancelable: !1
    });
    I.dispatchEvent(w);
  }
  function p(Q, I, w, f) {
    switch (I) {
      case "DataURL": {
        let C = "data:";
        const b = A(w || "application/octet-stream");
        b !== "failure" && (C += l(b)), C += ";base64,";
        const N = new u("latin1");
        for (const v of Q)
          C += g(N.write(v));
        return C += g(N.end()), C;
      }
      case "Text": {
        let C = "failure";
        if (f && (C = o(f)), C === "failure" && w) {
          const b = A(w);
          b !== "failure" && (C = o(b.parameters.get("charset")));
        }
        return C === "failure" && (C = "UTF-8"), E(Q, C);
      }
      case "ArrayBuffer":
        return y(Q).buffer;
      case "BinaryString": {
        let C = "";
        const b = new u("latin1");
        for (const N of Q)
          C += b.write(N);
        return C += b.end(), C;
      }
    }
  }
  function E(Q, I) {
    const w = y(Q), f = B(w);
    let C = 0;
    f !== null && (I = f, C = f === "UTF-8" ? 3 : 2);
    const b = w.slice(C);
    return new TextDecoder(I).decode(b);
  }
  function B(Q) {
    const [I, w, f] = Q;
    return I === 239 && w === 187 && f === 191 ? "UTF-8" : I === 254 && w === 255 ? "UTF-16BE" : I === 255 && w === 254 ? "UTF-16LE" : null;
  }
  function y(Q) {
    const I = Q.reduce((f, C) => f + C.byteLength, 0);
    let w = 0;
    return Q.reduce((f, C) => (f.set(C, w), w += C.byteLength, f), new Uint8Array(I));
  }
  return ZA = {
    staticPropertyDescriptors: h,
    readOperation: m,
    fireAProgressEvent: d
  }, ZA;
}
var ec, dm;
function Fb() {
  if (dm) return ec;
  dm = 1;
  const {
    staticPropertyDescriptors: t,
    readOperation: e,
    fireAProgressEvent: r
  } = kb(), {
    kState: n,
    kError: s,
    kResult: i,
    kEvents: o,
    kAborted: c
  } = Gf(), { webidl: l } = br(), { kEnumerableProperty: A } = rt();
  class a extends EventTarget {
    constructor() {
      super(), this[n] = "empty", this[i] = null, this[s] = null, this[o] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
     * @param {import('buffer').Blob} blob
     */
    readAsArrayBuffer(g) {
      l.brandCheck(this, a), l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), g = l.converters.Blob(g, { strict: !1 }), e(this, g, "ArrayBuffer");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsBinaryString
     * @param {import('buffer').Blob} blob
     */
    readAsBinaryString(g) {
      l.brandCheck(this, a), l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), g = l.converters.Blob(g, { strict: !1 }), e(this, g, "BinaryString");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsDataText
     * @param {import('buffer').Blob} blob
     * @param {string?} encoding
     */
    readAsText(g, h = void 0) {
      l.brandCheck(this, a), l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), g = l.converters.Blob(g, { strict: !1 }), h !== void 0 && (h = l.converters.DOMString(h)), e(this, g, "Text", h);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
     * @param {import('buffer').Blob} blob
     */
    readAsDataURL(g) {
      l.brandCheck(this, a), l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), g = l.converters.Blob(g, { strict: !1 }), e(this, g, "DataURL");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-abort
     */
    abort() {
      if (this[n] === "empty" || this[n] === "done") {
        this[i] = null;
        return;
      }
      this[n] === "loading" && (this[n] = "done", this[i] = null), this[c] = !0, r("abort", this), this[n] !== "loading" && r("loadend", this);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
     */
    get readyState() {
      switch (l.brandCheck(this, a), this[n]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-result
     */
    get result() {
      return l.brandCheck(this, a), this[i];
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-error
     */
    get error() {
      return l.brandCheck(this, a), this[s];
    }
    get onloadend() {
      return l.brandCheck(this, a), this[o].loadend;
    }
    set onloadend(g) {
      l.brandCheck(this, a), this[o].loadend && this.removeEventListener("loadend", this[o].loadend), typeof g == "function" ? (this[o].loadend = g, this.addEventListener("loadend", g)) : this[o].loadend = null;
    }
    get onerror() {
      return l.brandCheck(this, a), this[o].error;
    }
    set onerror(g) {
      l.brandCheck(this, a), this[o].error && this.removeEventListener("error", this[o].error), typeof g == "function" ? (this[o].error = g, this.addEventListener("error", g)) : this[o].error = null;
    }
    get onloadstart() {
      return l.brandCheck(this, a), this[o].loadstart;
    }
    set onloadstart(g) {
      l.brandCheck(this, a), this[o].loadstart && this.removeEventListener("loadstart", this[o].loadstart), typeof g == "function" ? (this[o].loadstart = g, this.addEventListener("loadstart", g)) : this[o].loadstart = null;
    }
    get onprogress() {
      return l.brandCheck(this, a), this[o].progress;
    }
    set onprogress(g) {
      l.brandCheck(this, a), this[o].progress && this.removeEventListener("progress", this[o].progress), typeof g == "function" ? (this[o].progress = g, this.addEventListener("progress", g)) : this[o].progress = null;
    }
    get onload() {
      return l.brandCheck(this, a), this[o].load;
    }
    set onload(g) {
      l.brandCheck(this, a), this[o].load && this.removeEventListener("load", this[o].load), typeof g == "function" ? (this[o].load = g, this.addEventListener("load", g)) : this[o].load = null;
    }
    get onabort() {
      return l.brandCheck(this, a), this[o].abort;
    }
    set onabort(g) {
      l.brandCheck(this, a), this[o].abort && this.removeEventListener("abort", this[o].abort), typeof g == "function" ? (this[o].abort = g, this.addEventListener("abort", g)) : this[o].abort = null;
    }
  }
  return a.EMPTY = a.prototype.EMPTY = 0, a.LOADING = a.prototype.LOADING = 1, a.DONE = a.prototype.DONE = 2, Object.defineProperties(a.prototype, {
    EMPTY: t,
    LOADING: t,
    DONE: t,
    readAsArrayBuffer: A,
    readAsBinaryString: A,
    readAsText: A,
    readAsDataURL: A,
    abort: A,
    readyState: A,
    result: A,
    error: A,
    onloadstart: A,
    onprogress: A,
    onload: A,
    onabort: A,
    onerror: A,
    onloadend: A,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  }), Object.defineProperties(a, {
    EMPTY: t,
    LOADING: t,
    DONE: t
  }), ec = {
    FileReader: a
  }, ec;
}
var tc, gm;
function hu() {
  return gm || (gm = 1, tc = {
    kConstruct: Nt().kConstruct
  }), tc;
}
var rc, mm;
function Pb() {
  if (mm) return rc;
  mm = 1;
  const t = bt, { URLSerializer: e } = un(), { isValidHeaderName: r } = en();
  function n(i, o, c = !1) {
    const l = e(i, c), A = e(o, c);
    return l === A;
  }
  function s(i) {
    t(i !== null);
    const o = [];
    for (let c of i.split(",")) {
      if (c = c.trim(), c.length) {
        if (!r(c))
          continue;
      } else continue;
      o.push(c);
    }
    return o;
  }
  return rc = {
    urlEquals: n,
    fieldValues: s
  }, rc;
}
var nc, hm;
function Ub() {
  if (hm) return nc;
  hm = 1;
  const { kConstruct: t } = hu(), { urlEquals: e, fieldValues: r } = Pb(), { kEnumerableProperty: n, isDisturbed: s } = rt(), { kHeadersList: i } = Nt(), { webidl: o } = br(), { Response: c, cloneResponse: l } = gu(), { Request: A } = ca(), { kState: a, kHeaders: u, kGuard: g, kRealm: h } = Tn(), { fetching: m } = mu(), { urlIsHttpHttpsScheme: d, createDeferredPromise: p, readAllBytes: E } = en(), B = bt, { getGlobalDispatcher: y } = Zi();
  class Q {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
     * @type {requestResponseList}
     */
    #e;
    constructor() {
      arguments[0] !== t && o.illegalConstructor(), this.#e = arguments[1];
    }
    async match(f, C = {}) {
      o.brandCheck(this, Q), o.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), f = o.converters.RequestInfo(f), C = o.converters.CacheQueryOptions(C);
      const b = await this.matchAll(f, C);
      if (b.length !== 0)
        return b[0];
    }
    async matchAll(f = void 0, C = {}) {
      o.brandCheck(this, Q), f !== void 0 && (f = o.converters.RequestInfo(f)), C = o.converters.CacheQueryOptions(C);
      let b = null;
      if (f !== void 0)
        if (f instanceof A) {
          if (b = f[a], b.method !== "GET" && !C.ignoreMethod)
            return [];
        } else typeof f == "string" && (b = new A(f)[a]);
      const N = [];
      if (f === void 0)
        for (const R of this.#e)
          N.push(R[1]);
      else {
        const R = this.#n(b, C);
        for (const x of R)
          N.push(x[1]);
      }
      const v = [];
      for (const R of N) {
        const x = new c(R.body?.source ?? null), S = x[a].body;
        x[a] = R, x[a].body = S, x[u][i] = R.headersList, x[u][g] = "immutable", v.push(x);
      }
      return Object.freeze(v);
    }
    async add(f) {
      o.brandCheck(this, Q), o.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), f = o.converters.RequestInfo(f);
      const C = [f];
      return await this.addAll(C);
    }
    async addAll(f) {
      o.brandCheck(this, Q), o.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" }), f = o.converters["sequence<RequestInfo>"](f);
      const C = [], b = [];
      for (const k of f) {
        if (typeof k == "string")
          continue;
        const L = k[a];
        if (!d(L.url) || L.method !== "GET")
          throw o.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
      }
      const N = [];
      for (const k of f) {
        const L = new A(k)[a];
        if (!d(L.url))
          throw o.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        L.initiator = "fetch", L.destination = "subresource", b.push(L);
        const W = p();
        N.push(m({
          request: L,
          dispatcher: y(),
          processResponse(O) {
            if (O.type === "error" || O.status === 206 || O.status < 200 || O.status > 299)
              W.reject(o.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            else if (O.headersList.contains("vary")) {
              const _ = r(O.headersList.get("vary"));
              for (const M of _)
                if (M === "*") {
                  W.reject(o.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const $ of N)
                    $.abort();
                  return;
                }
            }
          },
          processResponseEndOfBody(O) {
            if (O.aborted) {
              W.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            W.resolve(O);
          }
        })), C.push(W.promise);
      }
      const R = await Promise.all(C), x = [];
      let S = 0;
      for (const k of R) {
        const L = {
          type: "put",
          // 7.3.2
          request: b[S],
          // 7.3.3
          response: k
          // 7.3.4
        };
        x.push(L), S++;
      }
      const D = p();
      let T = null;
      try {
        this.#r(x);
      } catch (k) {
        T = k;
      }
      return queueMicrotask(() => {
        T === null ? D.resolve(void 0) : D.reject(T);
      }), D.promise;
    }
    async put(f, C) {
      o.brandCheck(this, Q), o.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), f = o.converters.RequestInfo(f), C = o.converters.Response(C);
      let b = null;
      if (f instanceof A ? b = f[a] : b = new A(f)[a], !d(b.url) || b.method !== "GET")
        throw o.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      const N = C[a];
      if (N.status === 206)
        throw o.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      if (N.headersList.contains("vary")) {
        const L = r(N.headersList.get("vary"));
        for (const W of L)
          if (W === "*")
            throw o.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
      }
      if (N.body && (s(N.body.stream) || N.body.stream.locked))
        throw o.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      const v = l(N), R = p();
      if (N.body != null) {
        const W = N.body.stream.getReader();
        E(W).then(R.resolve, R.reject);
      } else
        R.resolve(void 0);
      const x = [], S = {
        type: "put",
        // 14.
        request: b,
        // 15.
        response: v
        // 16.
      };
      x.push(S);
      const D = await R.promise;
      v.body != null && (v.body.source = D);
      const T = p();
      let k = null;
      try {
        this.#r(x);
      } catch (L) {
        k = L;
      }
      return queueMicrotask(() => {
        k === null ? T.resolve() : T.reject(k);
      }), T.promise;
    }
    async delete(f, C = {}) {
      o.brandCheck(this, Q), o.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), f = o.converters.RequestInfo(f), C = o.converters.CacheQueryOptions(C);
      let b = null;
      if (f instanceof A) {
        if (b = f[a], b.method !== "GET" && !C.ignoreMethod)
          return !1;
      } else
        B(typeof f == "string"), b = new A(f)[a];
      const N = [], v = {
        type: "delete",
        request: b,
        options: C
      };
      N.push(v);
      const R = p();
      let x = null, S;
      try {
        S = this.#r(N);
      } catch (D) {
        x = D;
      }
      return queueMicrotask(() => {
        x === null ? R.resolve(!!S?.length) : R.reject(x);
      }), R.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {readonly Request[]}
     */
    async keys(f = void 0, C = {}) {
      o.brandCheck(this, Q), f !== void 0 && (f = o.converters.RequestInfo(f)), C = o.converters.CacheQueryOptions(C);
      let b = null;
      if (f !== void 0)
        if (f instanceof A) {
          if (b = f[a], b.method !== "GET" && !C.ignoreMethod)
            return [];
        } else typeof f == "string" && (b = new A(f)[a]);
      const N = p(), v = [];
      if (f === void 0)
        for (const R of this.#e)
          v.push(R[0]);
      else {
        const R = this.#n(b, C);
        for (const x of R)
          v.push(x[0]);
      }
      return queueMicrotask(() => {
        const R = [];
        for (const x of v) {
          const S = new A("https://a");
          S[a] = x, S[u][i] = x.headersList, S[u][g] = "immutable", S[h] = x.client, R.push(S);
        }
        N.resolve(Object.freeze(R));
      }), N.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    #r(f) {
      const C = this.#e, b = [...C], N = [], v = [];
      try {
        for (const R of f) {
          if (R.type !== "delete" && R.type !== "put")
            throw o.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          if (R.type === "delete" && R.response != null)
            throw o.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          if (this.#n(R.request, R.options, N).length)
            throw new DOMException("???", "InvalidStateError");
          let x;
          if (R.type === "delete") {
            if (x = this.#n(R.request, R.options), x.length === 0)
              return [];
            for (const S of x) {
              const D = C.indexOf(S);
              B(D !== -1), C.splice(D, 1);
            }
          } else if (R.type === "put") {
            if (R.response == null)
              throw o.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            const S = R.request;
            if (!d(S.url))
              throw o.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            if (S.method !== "GET")
              throw o.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            if (R.options != null)
              throw o.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            x = this.#n(R.request);
            for (const D of x) {
              const T = C.indexOf(D);
              B(T !== -1), C.splice(T, 1);
            }
            C.push([R.request, R.response]), N.push([R.request, R.response]);
          }
          v.push([R.request, R.response]);
        }
        return v;
      } catch (R) {
        throw this.#e.length = 0, this.#e = b, R;
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    #n(f, C, b) {
      const N = [], v = b ?? this.#e;
      for (const R of v) {
        const [x, S] = R;
        this.#t(f, x, S, C) && N.push(R);
      }
      return N;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    #t(f, C, b = null, N) {
      const v = new URL(f.url), R = new URL(C.url);
      if (N?.ignoreSearch && (R.search = "", v.search = ""), !e(v, R, !0))
        return !1;
      if (b == null || N?.ignoreVary || !b.headersList.contains("vary"))
        return !0;
      const x = r(b.headersList.get("vary"));
      for (const S of x) {
        if (S === "*")
          return !1;
        const D = C.headersList.get(S), T = f.headersList.get(S);
        if (D !== T)
          return !1;
      }
      return !0;
    }
  }
  Object.defineProperties(Q.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: !0
    },
    match: n,
    matchAll: n,
    add: n,
    addAll: n,
    put: n,
    delete: n,
    keys: n
  });
  const I = [
    {
      key: "ignoreSearch",
      converter: o.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreMethod",
      converter: o.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreVary",
      converter: o.converters.boolean,
      defaultValue: !1
    }
  ];
  return o.converters.CacheQueryOptions = o.dictionaryConverter(I), o.converters.MultiCacheQueryOptions = o.dictionaryConverter([
    ...I,
    {
      key: "cacheName",
      converter: o.converters.DOMString
    }
  ]), o.converters.Response = o.interfaceConverter(c), o.converters["sequence<RequestInfo>"] = o.sequenceConverter(
    o.converters.RequestInfo
  ), nc = {
    Cache: Q
  }, nc;
}
var sc, pm;
function Lb() {
  if (pm) return sc;
  pm = 1;
  const { kConstruct: t } = hu(), { Cache: e } = Ub(), { webidl: r } = br(), { kEnumerableProperty: n } = rt();
  class s {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
     * @type {Map<string, import('./cache').requestResponseList}
     */
    #e = /* @__PURE__ */ new Map();
    constructor() {
      arguments[0] !== t && r.illegalConstructor();
    }
    async match(o, c = {}) {
      if (r.brandCheck(this, s), r.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), o = r.converters.RequestInfo(o), c = r.converters.MultiCacheQueryOptions(c), c.cacheName != null) {
        if (this.#e.has(c.cacheName)) {
          const l = this.#e.get(c.cacheName);
          return await new e(t, l).match(o, c);
        }
      } else
        for (const l of this.#e.values()) {
          const a = await new e(t, l).match(o, c);
          if (a !== void 0)
            return a;
        }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(o) {
      return r.brandCheck(this, s), r.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), o = r.converters.DOMString(o), this.#e.has(o);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(o) {
      if (r.brandCheck(this, s), r.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), o = r.converters.DOMString(o), this.#e.has(o)) {
        const l = this.#e.get(o);
        return new e(t, l);
      }
      const c = [];
      return this.#e.set(o, c), new e(t, c);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(o) {
      return r.brandCheck(this, s), r.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), o = r.converters.DOMString(o), this.#e.delete(o);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {string[]}
     */
    async keys() {
      return r.brandCheck(this, s), [...this.#e.keys()];
    }
  }
  return Object.defineProperties(s.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: !0
    },
    match: n,
    has: n,
    open: n,
    delete: n,
    keys: n
  }), sc = {
    CacheStorage: s
  }, sc;
}
var ic, fm;
function _b() {
  return fm || (fm = 1, ic = {
    maxAttributeValueSize: 1024,
    maxNameValuePairSize: 4096
  }), ic;
}
var oc, Em;
function qf() {
  if (Em) return oc;
  Em = 1;
  function t(l) {
    if (l.length === 0)
      return !1;
    for (const A of l) {
      const a = A.charCodeAt(0);
      if (a >= 0 || a <= 8 || a >= 10 || a <= 31 || a === 127)
        return !1;
    }
  }
  function e(l) {
    for (const A of l) {
      const a = A.charCodeAt(0);
      if (a <= 32 || a > 127 || A === "(" || A === ")" || A === ">" || A === "<" || A === "@" || A === "," || A === ";" || A === ":" || A === "\\" || A === '"' || A === "/" || A === "[" || A === "]" || A === "?" || A === "=" || A === "{" || A === "}")
        throw new Error("Invalid cookie name");
    }
  }
  function r(l) {
    for (const A of l) {
      const a = A.charCodeAt(0);
      if (a < 33 || // exclude CTLs (0-31)
      a === 34 || a === 44 || a === 59 || a === 92 || a > 126)
        throw new Error("Invalid header value");
    }
  }
  function n(l) {
    for (const A of l)
      if (A.charCodeAt(0) < 33 || A === ";")
        throw new Error("Invalid cookie path");
  }
  function s(l) {
    if (l.startsWith("-") || l.endsWith(".") || l.endsWith("-"))
      throw new Error("Invalid cookie domain");
  }
  function i(l) {
    typeof l == "number" && (l = new Date(l));
    const A = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ], a = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ], u = A[l.getUTCDay()], g = l.getUTCDate().toString().padStart(2, "0"), h = a[l.getUTCMonth()], m = l.getUTCFullYear(), d = l.getUTCHours().toString().padStart(2, "0"), p = l.getUTCMinutes().toString().padStart(2, "0"), E = l.getUTCSeconds().toString().padStart(2, "0");
    return `${u}, ${g} ${h} ${m} ${d}:${p}:${E} GMT`;
  }
  function o(l) {
    if (l < 0)
      throw new Error("Invalid cookie max-age");
  }
  function c(l) {
    if (l.name.length === 0)
      return null;
    e(l.name), r(l.value);
    const A = [`${l.name}=${l.value}`];
    l.name.startsWith("__Secure-") && (l.secure = !0), l.name.startsWith("__Host-") && (l.secure = !0, l.domain = null, l.path = "/"), l.secure && A.push("Secure"), l.httpOnly && A.push("HttpOnly"), typeof l.maxAge == "number" && (o(l.maxAge), A.push(`Max-Age=${l.maxAge}`)), l.domain && (s(l.domain), A.push(`Domain=${l.domain}`)), l.path && (n(l.path), A.push(`Path=${l.path}`)), l.expires && l.expires.toString() !== "Invalid Date" && A.push(`Expires=${i(l.expires)}`), l.sameSite && A.push(`SameSite=${l.sameSite}`);
    for (const a of l.unparsed) {
      if (!a.includes("="))
        throw new Error("Invalid unparsed");
      const [u, ...g] = a.split("=");
      A.push(`${u.trim()}=${g.join("=")}`);
    }
    return A.join("; ");
  }
  return oc = {
    isCTLExcludingHtab: t,
    validateCookieName: e,
    validateCookiePath: n,
    validateCookieValue: r,
    toIMFDate: i,
    stringify: c
  }, oc;
}
var ac, Cm;
function Mb() {
  if (Cm) return ac;
  Cm = 1;
  const { maxNameValuePairSize: t, maxAttributeValueSize: e } = _b(), { isCTLExcludingHtab: r } = qf(), { collectASequenceOfCodePointsFast: n } = un(), s = bt;
  function i(c) {
    if (r(c))
      return null;
    let l = "", A = "", a = "", u = "";
    if (c.includes(";")) {
      const g = { position: 0 };
      l = n(";", c, g), A = c.slice(g.position);
    } else
      l = c;
    if (!l.includes("="))
      u = l;
    else {
      const g = { position: 0 };
      a = n(
        "=",
        l,
        g
      ), u = l.slice(g.position + 1);
    }
    return a = a.trim(), u = u.trim(), a.length + u.length > t ? null : {
      name: a,
      value: u,
      ...o(A)
    };
  }
  function o(c, l = {}) {
    if (c.length === 0)
      return l;
    s(c[0] === ";"), c = c.slice(1);
    let A = "";
    c.includes(";") ? (A = n(
      ";",
      c,
      { position: 0 }
    ), c = c.slice(A.length)) : (A = c, c = "");
    let a = "", u = "";
    if (A.includes("=")) {
      const h = { position: 0 };
      a = n(
        "=",
        A,
        h
      ), u = A.slice(h.position + 1);
    } else
      a = A;
    if (a = a.trim(), u = u.trim(), u.length > e)
      return o(c, l);
    const g = a.toLowerCase();
    if (g === "expires") {
      const h = new Date(u);
      l.expires = h;
    } else if (g === "max-age") {
      const h = u.charCodeAt(0);
      if ((h < 48 || h > 57) && u[0] !== "-" || !/^\d+$/.test(u))
        return o(c, l);
      const m = Number(u);
      l.maxAge = m;
    } else if (g === "domain") {
      let h = u;
      h[0] === "." && (h = h.slice(1)), h = h.toLowerCase(), l.domain = h;
    } else if (g === "path") {
      let h = "";
      u.length === 0 || u[0] !== "/" ? h = "/" : h = u, l.path = h;
    } else if (g === "secure")
      l.secure = !0;
    else if (g === "httponly")
      l.httpOnly = !0;
    else if (g === "samesite") {
      let h = "Default";
      const m = u.toLowerCase();
      m.includes("none") && (h = "None"), m.includes("strict") && (h = "Strict"), m.includes("lax") && (h = "Lax"), l.sameSite = h;
    } else
      l.unparsed ??= [], l.unparsed.push(`${a}=${u}`);
    return o(c, l);
  }
  return ac = {
    parseSetCookie: i,
    parseUnparsedAttributes: o
  }, ac;
}
var Ac, Bm;
function Ob() {
  if (Bm) return Ac;
  Bm = 1;
  const { parseSetCookie: t } = Mb(), { stringify: e } = qf(), { webidl: r } = br(), { Headers: n } = Fs();
  function s(l) {
    r.argumentLengthCheck(arguments, 1, { header: "getCookies" }), r.brandCheck(l, n, { strict: !1 });
    const A = l.get("cookie"), a = {};
    if (!A)
      return a;
    for (const u of A.split(";")) {
      const [g, ...h] = u.split("=");
      a[g.trim()] = h.join("=");
    }
    return a;
  }
  function i(l, A, a) {
    r.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), r.brandCheck(l, n, { strict: !1 }), A = r.converters.DOMString(A), a = r.converters.DeleteCookieAttributes(a), c(l, {
      name: A,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...a
    });
  }
  function o(l) {
    r.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), r.brandCheck(l, n, { strict: !1 });
    const A = l.getSetCookie();
    return A ? A.map((a) => t(a)) : [];
  }
  function c(l, A) {
    r.argumentLengthCheck(arguments, 2, { header: "setCookie" }), r.brandCheck(l, n, { strict: !1 }), A = r.converters.Cookie(A), e(A) && l.append("Set-Cookie", e(A));
  }
  return r.converters.DeleteCookieAttributes = r.dictionaryConverter([
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]), r.converters.Cookie = r.dictionaryConverter([
    {
      converter: r.converters.DOMString,
      key: "name"
    },
    {
      converter: r.converters.DOMString,
      key: "value"
    },
    {
      converter: r.nullableConverter((l) => typeof l == "number" ? r.converters["unsigned long long"](l) : new Date(l)),
      key: "expires",
      defaultValue: null
    },
    {
      converter: r.nullableConverter(r.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: r.nullableConverter(r.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: r.nullableConverter(r.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: r.nullableConverter(r.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: r.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: r.sequenceConverter(r.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]), Ac = {
    getCookies: s,
    deleteCookie: i,
    getSetCookies: o,
    setCookie: c
  }, Ac;
}
var cc, Im;
function eo() {
  if (Im) return cc;
  Im = 1;
  const t = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", e = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  }, r = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  }, n = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  }, s = 2 ** 16 - 1, i = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  }, o = Buffer.allocUnsafe(0);
  return cc = {
    uid: t,
    staticPropertyDescriptors: e,
    states: r,
    opcodes: n,
    maxUnsigned16Bit: s,
    parserStates: i,
    emptyBuffer: o
  }, cc;
}
var lc, ym;
function la() {
  return ym || (ym = 1, lc = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  }), lc;
}
var uc, Qm;
function Hf() {
  if (Qm) return uc;
  Qm = 1;
  const { webidl: t } = br(), { kEnumerableProperty: e } = rt(), { MessagePort: r } = If;
  class n extends Event {
    #e;
    constructor(l, A = {}) {
      t.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), l = t.converters.DOMString(l), A = t.converters.MessageEventInit(A), super(l, A), this.#e = A;
    }
    get data() {
      return t.brandCheck(this, n), this.#e.data;
    }
    get origin() {
      return t.brandCheck(this, n), this.#e.origin;
    }
    get lastEventId() {
      return t.brandCheck(this, n), this.#e.lastEventId;
    }
    get source() {
      return t.brandCheck(this, n), this.#e.source;
    }
    get ports() {
      return t.brandCheck(this, n), Object.isFrozen(this.#e.ports) || Object.freeze(this.#e.ports), this.#e.ports;
    }
    initMessageEvent(l, A = !1, a = !1, u = null, g = "", h = "", m = null, d = []) {
      return t.brandCheck(this, n), t.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new n(l, {
        bubbles: A,
        cancelable: a,
        data: u,
        origin: g,
        lastEventId: h,
        source: m,
        ports: d
      });
    }
  }
  class s extends Event {
    #e;
    constructor(l, A = {}) {
      t.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), l = t.converters.DOMString(l), A = t.converters.CloseEventInit(A), super(l, A), this.#e = A;
    }
    get wasClean() {
      return t.brandCheck(this, s), this.#e.wasClean;
    }
    get code() {
      return t.brandCheck(this, s), this.#e.code;
    }
    get reason() {
      return t.brandCheck(this, s), this.#e.reason;
    }
  }
  class i extends Event {
    #e;
    constructor(l, A) {
      t.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" }), super(l, A), l = t.converters.DOMString(l), A = t.converters.ErrorEventInit(A ?? {}), this.#e = A;
    }
    get message() {
      return t.brandCheck(this, i), this.#e.message;
    }
    get filename() {
      return t.brandCheck(this, i), this.#e.filename;
    }
    get lineno() {
      return t.brandCheck(this, i), this.#e.lineno;
    }
    get colno() {
      return t.brandCheck(this, i), this.#e.colno;
    }
    get error() {
      return t.brandCheck(this, i), this.#e.error;
    }
  }
  Object.defineProperties(n.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: !0
    },
    data: e,
    origin: e,
    lastEventId: e,
    source: e,
    ports: e,
    initMessageEvent: e
  }), Object.defineProperties(s.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: !0
    },
    reason: e,
    code: e,
    wasClean: e
  }), Object.defineProperties(i.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: !0
    },
    message: e,
    filename: e,
    lineno: e,
    colno: e,
    error: e
  }), t.converters.MessagePort = t.interfaceConverter(r), t.converters["sequence<MessagePort>"] = t.sequenceConverter(
    t.converters.MessagePort
  );
  const o = [
    {
      key: "bubbles",
      converter: t.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: t.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: t.converters.boolean,
      defaultValue: !1
    }
  ];
  return t.converters.MessageEventInit = t.dictionaryConverter([
    ...o,
    {
      key: "data",
      converter: t.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: t.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: t.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: t.nullableConverter(t.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: t.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]), t.converters.CloseEventInit = t.dictionaryConverter([
    ...o,
    {
      key: "wasClean",
      converter: t.converters.boolean,
      defaultValue: !1
    },
    {
      key: "code",
      converter: t.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: t.converters.USVString,
      defaultValue: ""
    }
  ]), t.converters.ErrorEventInit = t.dictionaryConverter([
    ...o,
    {
      key: "message",
      converter: t.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: t.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: t.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: t.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: t.converters.any
    }
  ]), uc = {
    MessageEvent: n,
    CloseEvent: s,
    ErrorEvent: i
  }, uc;
}
var dc, bm;
function pu() {
  if (bm) return dc;
  bm = 1;
  const { kReadyState: t, kController: e, kResponse: r, kBinaryType: n, kWebSocketURL: s } = la(), { states: i, opcodes: o } = eo(), { MessageEvent: c, ErrorEvent: l } = Hf();
  function A(E) {
    return E[t] === i.OPEN;
  }
  function a(E) {
    return E[t] === i.CLOSING;
  }
  function u(E) {
    return E[t] === i.CLOSED;
  }
  function g(E, B, y = Event, Q) {
    const I = new y(E, Q);
    B.dispatchEvent(I);
  }
  function h(E, B, y) {
    if (E[t] !== i.OPEN)
      return;
    let Q;
    if (B === o.TEXT)
      try {
        Q = new TextDecoder("utf-8", { fatal: !0 }).decode(y);
      } catch {
        p(E, "Received invalid UTF-8 in text frame.");
        return;
      }
    else B === o.BINARY && (E[n] === "blob" ? Q = new Blob([y]) : Q = new Uint8Array(y).buffer);
    g("message", E, c, {
      origin: E[s].origin,
      data: Q
    });
  }
  function m(E) {
    if (E.length === 0)
      return !1;
    for (const B of E) {
      const y = B.charCodeAt(0);
      if (y < 33 || y > 126 || B === "(" || B === ")" || B === "<" || B === ">" || B === "@" || B === "," || B === ";" || B === ":" || B === "\\" || B === '"' || B === "/" || B === "[" || B === "]" || B === "?" || B === "=" || B === "{" || B === "}" || y === 32 || // SP
      y === 9)
        return !1;
    }
    return !0;
  }
  function d(E) {
    return E >= 1e3 && E < 1015 ? E !== 1004 && // reserved
    E !== 1005 && // "MUST NOT be set as a status code"
    E !== 1006 : E >= 3e3 && E <= 4999;
  }
  function p(E, B) {
    const { [e]: y, [r]: Q } = E;
    y.abort(), Q?.socket && !Q.socket.destroyed && Q.socket.destroy(), B && g("error", E, l, {
      error: new Error(B)
    });
  }
  return dc = {
    isEstablished: A,
    isClosing: a,
    isClosed: u,
    fireEvent: g,
    isValidSubprotocol: m,
    isValidStatusCode: d,
    failWebsocketConnection: p,
    websocketMessageReceived: h
  }, dc;
}
var gc, wm;
function Gb() {
  if (wm) return gc;
  wm = 1;
  const t = wf, { uid: e, states: r } = eo(), {
    kReadyState: n,
    kSentClose: s,
    kByteParser: i,
    kReceivedClose: o
  } = la(), { fireEvent: c, failWebsocketConnection: l } = pu(), { CloseEvent: A } = Hf(), { makeRequest: a } = ca(), { fetching: u } = mu(), { Headers: g } = Fs(), { getGlobalDispatcher: h } = Zi(), { kHeadersList: m } = Nt(), d = {};
  d.open = t.channel("undici:websocket:open"), d.close = t.channel("undici:websocket:close"), d.socketError = t.channel("undici:websocket:socket_error");
  let p;
  try {
    p = require("crypto");
  } catch {
  }
  function E(I, w, f, C, b) {
    const N = I;
    N.protocol = I.protocol === "ws:" ? "http:" : "https:";
    const v = a({
      urlList: [N],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (b.headers) {
      const D = new g(b.headers)[m];
      v.headersList = D;
    }
    const R = p.randomBytes(16).toString("base64");
    v.headersList.append("sec-websocket-key", R), v.headersList.append("sec-websocket-version", "13");
    for (const D of w)
      v.headersList.append("sec-websocket-protocol", D);
    const x = "";
    return u({
      request: v,
      useParallelQueue: !0,
      dispatcher: b.dispatcher ?? h(),
      processResponse(D) {
        if (D.type === "error" || D.status !== 101) {
          l(f, "Received network error or non-101 status code.");
          return;
        }
        if (w.length !== 0 && !D.headersList.get("Sec-WebSocket-Protocol")) {
          l(f, "Server did not respond with sent protocols.");
          return;
        }
        if (D.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          l(f, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (D.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          l(f, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const T = D.headersList.get("Sec-WebSocket-Accept"), k = p.createHash("sha1").update(R + e).digest("base64");
        if (T !== k) {
          l(f, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const L = D.headersList.get("Sec-WebSocket-Extensions");
        if (L !== null && L !== x) {
          l(f, "Received different permessage-deflate than the one set.");
          return;
        }
        const W = D.headersList.get("Sec-WebSocket-Protocol");
        if (W !== null && W !== v.headersList.get("Sec-WebSocket-Protocol")) {
          l(f, "Protocol was not set in the opening handshake.");
          return;
        }
        D.socket.on("data", B), D.socket.on("close", y), D.socket.on("error", Q), d.open.hasSubscribers && d.open.publish({
          address: D.socket.address(),
          protocol: W,
          extensions: L
        }), C(D);
      }
    });
  }
  function B(I) {
    this.ws[i].write(I) || this.pause();
  }
  function y() {
    const { ws: I } = this, w = I[s] && I[o];
    let f = 1005, C = "";
    const b = I[i].closingInfo;
    b ? (f = b.code ?? 1005, C = b.reason) : I[s] || (f = 1006), I[n] = r.CLOSED, c("close", I, A, {
      wasClean: w,
      code: f,
      reason: C
    }), d.close.hasSubscribers && d.close.publish({
      websocket: I,
      code: f,
      reason: C
    });
  }
  function Q(I) {
    const { ws: w } = this;
    w[n] = r.CLOSING, d.socketError.hasSubscribers && d.socketError.publish(I), this.destroy();
  }
  return gc = {
    establishWebSocketConnection: E
  }, gc;
}
var mc, Nm;
function zf() {
  if (Nm) return mc;
  Nm = 1;
  const { maxUnsigned16Bit: t } = eo();
  let e;
  try {
    e = require("crypto");
  } catch {
  }
  class r {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(s) {
      this.frameData = s, this.maskKey = e.randomBytes(4);
    }
    createFrame(s) {
      const i = this.frameData?.byteLength ?? 0;
      let o = i, c = 6;
      i > t ? (c += 8, o = 127) : i > 125 && (c += 2, o = 126);
      const l = Buffer.allocUnsafe(i + c);
      l[0] = l[1] = 0, l[0] |= 128, l[0] = (l[0] & 240) + s;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      l[c - 4] = this.maskKey[0], l[c - 3] = this.maskKey[1], l[c - 2] = this.maskKey[2], l[c - 1] = this.maskKey[3], l[1] = o, o === 126 ? l.writeUInt16BE(i, 2) : o === 127 && (l[2] = l[3] = 0, l.writeUIntBE(i, 4, 6)), l[1] |= 128;
      for (let A = 0; A < i; A++)
        l[c + A] = this.frameData[A] ^ this.maskKey[A % 4];
      return l;
    }
  }
  return mc = {
    WebsocketFrameSend: r
  }, mc;
}
var hc, Rm;
function qb() {
  if (Rm) return hc;
  Rm = 1;
  const { Writable: t } = ln, e = wf, { parserStates: r, opcodes: n, states: s, emptyBuffer: i } = eo(), { kReadyState: o, kSentClose: c, kResponse: l, kReceivedClose: A } = la(), { isValidStatusCode: a, failWebsocketConnection: u, websocketMessageReceived: g } = pu(), { WebsocketFrameSend: h } = zf(), m = {};
  m.ping = e.channel("undici:websocket:ping"), m.pong = e.channel("undici:websocket:pong");
  class d extends t {
    #e = [];
    #r = 0;
    #n = r.INFO;
    #t = {};
    #s = [];
    constructor(E) {
      super(), this.ws = E;
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(E, B, y) {
      this.#e.push(E), this.#r += E.length, this.run(y);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(E) {
      for (; ; ) {
        if (this.#n === r.INFO) {
          if (this.#r < 2)
            return E();
          const B = this.consume(2);
          if (this.#t.fin = (B[0] & 128) !== 0, this.#t.opcode = B[0] & 15, this.#t.originalOpcode ??= this.#t.opcode, this.#t.fragmented = !this.#t.fin && this.#t.opcode !== n.CONTINUATION, this.#t.fragmented && this.#t.opcode !== n.BINARY && this.#t.opcode !== n.TEXT) {
            u(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const y = B[1] & 127;
          if (y <= 125 ? (this.#t.payloadLength = y, this.#n = r.READ_DATA) : y === 126 ? this.#n = r.PAYLOADLENGTH_16 : y === 127 && (this.#n = r.PAYLOADLENGTH_64), this.#t.fragmented && y > 125) {
            u(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#t.opcode === n.PING || this.#t.opcode === n.PONG || this.#t.opcode === n.CLOSE) && y > 125) {
            u(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#t.opcode === n.CLOSE) {
            if (y === 1) {
              u(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const Q = this.consume(y);
            if (this.#t.closeInfo = this.parseCloseBody(!1, Q), !this.ws[c]) {
              const I = Buffer.allocUnsafe(2);
              I.writeUInt16BE(this.#t.closeInfo.code, 0);
              const w = new h(I);
              this.ws[l].socket.write(
                w.createFrame(n.CLOSE),
                (f) => {
                  f || (this.ws[c] = !0);
                }
              );
            }
            this.ws[o] = s.CLOSING, this.ws[A] = !0, this.end();
            return;
          } else if (this.#t.opcode === n.PING) {
            const Q = this.consume(y);
            if (!this.ws[A]) {
              const I = new h(Q);
              this.ws[l].socket.write(I.createFrame(n.PONG)), m.ping.hasSubscribers && m.ping.publish({
                payload: Q
              });
            }
            if (this.#n = r.INFO, this.#r > 0)
              continue;
            E();
            return;
          } else if (this.#t.opcode === n.PONG) {
            const Q = this.consume(y);
            if (m.pong.hasSubscribers && m.pong.publish({
              payload: Q
            }), this.#r > 0)
              continue;
            E();
            return;
          }
        } else if (this.#n === r.PAYLOADLENGTH_16) {
          if (this.#r < 2)
            return E();
          const B = this.consume(2);
          this.#t.payloadLength = B.readUInt16BE(0), this.#n = r.READ_DATA;
        } else if (this.#n === r.PAYLOADLENGTH_64) {
          if (this.#r < 8)
            return E();
          const B = this.consume(8), y = B.readUInt32BE(0);
          if (y > 2 ** 31 - 1) {
            u(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const Q = B.readUInt32BE(4);
          this.#t.payloadLength = (y << 8) + Q, this.#n = r.READ_DATA;
        } else if (this.#n === r.READ_DATA) {
          if (this.#r < this.#t.payloadLength)
            return E();
          if (this.#r >= this.#t.payloadLength) {
            const B = this.consume(this.#t.payloadLength);
            if (this.#s.push(B), !this.#t.fragmented || this.#t.fin && this.#t.opcode === n.CONTINUATION) {
              const y = Buffer.concat(this.#s);
              g(this.ws, this.#t.originalOpcode, y), this.#t = {}, this.#s.length = 0;
            }
            this.#n = r.INFO;
          }
        }
        if (!(this.#r > 0)) {
          E();
          break;
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer|null}
     */
    consume(E) {
      if (E > this.#r)
        return null;
      if (E === 0)
        return i;
      if (this.#e[0].length === E)
        return this.#r -= this.#e[0].length, this.#e.shift();
      const B = Buffer.allocUnsafe(E);
      let y = 0;
      for (; y !== E; ) {
        const Q = this.#e[0], { length: I } = Q;
        if (I + y === E) {
          B.set(this.#e.shift(), y);
          break;
        } else if (I + y > E) {
          B.set(Q.subarray(0, E - y), y), this.#e[0] = Q.subarray(E - y);
          break;
        } else
          B.set(this.#e.shift(), y), y += Q.length;
      }
      return this.#r -= E, B;
    }
    parseCloseBody(E, B) {
      let y;
      if (B.length >= 2 && (y = B.readUInt16BE(0)), E)
        return a(y) ? { code: y } : null;
      let Q = B.subarray(2);
      if (Q[0] === 239 && Q[1] === 187 && Q[2] === 191 && (Q = Q.subarray(3)), y !== void 0 && !a(y))
        return null;
      try {
        Q = new TextDecoder("utf-8", { fatal: !0 }).decode(Q);
      } catch {
        return null;
      }
      return { code: y, reason: Q };
    }
    get closingInfo() {
      return this.#t.closeInfo;
    }
  }
  return hc = {
    ByteParser: d
  }, hc;
}
var pc, Sm;
function Hb() {
  if (Sm) return pc;
  Sm = 1;
  const { webidl: t } = br(), { DOMException: e } = ns(), { URLSerializer: r } = un(), { getGlobalOrigin: n } = ji(), { staticPropertyDescriptors: s, states: i, opcodes: o, emptyBuffer: c } = eo(), {
    kWebSocketURL: l,
    kReadyState: A,
    kController: a,
    kBinaryType: u,
    kResponse: g,
    kSentClose: h,
    kByteParser: m
  } = la(), { isEstablished: d, isClosing: p, isValidSubprotocol: E, failWebsocketConnection: B, fireEvent: y } = pu(), { establishWebSocketConnection: Q } = Gb(), { WebsocketFrameSend: I } = zf(), { ByteParser: w } = qb(), { kEnumerableProperty: f, isBlobLike: C } = rt(), { getGlobalDispatcher: b } = Zi(), { types: N } = Qr;
  let v = !1;
  class R extends EventTarget {
    #e = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #r = 0;
    #n = "";
    #t = "";
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(S, D = []) {
      super(), t.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), v || (v = !0, process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
        code: "UNDICI-WS"
      }));
      const T = t.converters["DOMString or sequence<DOMString> or WebSocketInit"](D);
      S = t.converters.USVString(S), D = T.protocols;
      const k = n();
      let L;
      try {
        L = new URL(S, k);
      } catch (W) {
        throw new e(W, "SyntaxError");
      }
      if (L.protocol === "http:" ? L.protocol = "ws:" : L.protocol === "https:" && (L.protocol = "wss:"), L.protocol !== "ws:" && L.protocol !== "wss:")
        throw new e(
          `Expected a ws: or wss: protocol, got ${L.protocol}`,
          "SyntaxError"
        );
      if (L.hash || L.href.endsWith("#"))
        throw new e("Got fragment", "SyntaxError");
      if (typeof D == "string" && (D = [D]), D.length !== new Set(D.map((W) => W.toLowerCase())).size)
        throw new e("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      if (D.length > 0 && !D.every((W) => E(W)))
        throw new e("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      this[l] = new URL(L.href), this[a] = Q(
        L,
        D,
        this,
        (W) => this.#s(W),
        T
      ), this[A] = R.CONNECTING, this[u] = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(S = void 0, D = void 0) {
      if (t.brandCheck(this, R), S !== void 0 && (S = t.converters["unsigned short"](S, { clamp: !0 })), D !== void 0 && (D = t.converters.USVString(D)), S !== void 0 && S !== 1e3 && (S < 3e3 || S > 4999))
        throw new e("invalid code", "InvalidAccessError");
      let T = 0;
      if (D !== void 0 && (T = Buffer.byteLength(D), T > 123))
        throw new e(
          `Reason must be less than 123 bytes; received ${T}`,
          "SyntaxError"
        );
      if (!(this[A] === R.CLOSING || this[A] === R.CLOSED)) if (!d(this))
        B(this, "Connection was closed before it was established."), this[A] = R.CLOSING;
      else if (p(this))
        this[A] = R.CLOSING;
      else {
        const k = new I();
        S !== void 0 && D === void 0 ? (k.frameData = Buffer.allocUnsafe(2), k.frameData.writeUInt16BE(S, 0)) : S !== void 0 && D !== void 0 ? (k.frameData = Buffer.allocUnsafe(2 + T), k.frameData.writeUInt16BE(S, 0), k.frameData.write(D, 2, "utf-8")) : k.frameData = c, this[g].socket.write(k.createFrame(o.CLOSE), (W) => {
          W || (this[h] = !0);
        }), this[A] = i.CLOSING;
      }
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(S) {
      if (t.brandCheck(this, R), t.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), S = t.converters.WebSocketSendData(S), this[A] === R.CONNECTING)
        throw new e("Sent before connected.", "InvalidStateError");
      if (!d(this) || p(this))
        return;
      const D = this[g].socket;
      if (typeof S == "string") {
        const T = Buffer.from(S), L = new I(T).createFrame(o.TEXT);
        this.#r += T.byteLength, D.write(L, () => {
          this.#r -= T.byteLength;
        });
      } else if (N.isArrayBuffer(S)) {
        const T = Buffer.from(S), L = new I(T).createFrame(o.BINARY);
        this.#r += T.byteLength, D.write(L, () => {
          this.#r -= T.byteLength;
        });
      } else if (ArrayBuffer.isView(S)) {
        const T = Buffer.from(S, S.byteOffset, S.byteLength), L = new I(T).createFrame(o.BINARY);
        this.#r += T.byteLength, D.write(L, () => {
          this.#r -= T.byteLength;
        });
      } else if (C(S)) {
        const T = new I();
        S.arrayBuffer().then((k) => {
          const L = Buffer.from(k);
          T.frameData = L;
          const W = T.createFrame(o.BINARY);
          this.#r += L.byteLength, D.write(W, () => {
            this.#r -= L.byteLength;
          });
        });
      }
    }
    get readyState() {
      return t.brandCheck(this, R), this[A];
    }
    get bufferedAmount() {
      return t.brandCheck(this, R), this.#r;
    }
    get url() {
      return t.brandCheck(this, R), r(this[l]);
    }
    get extensions() {
      return t.brandCheck(this, R), this.#t;
    }
    get protocol() {
      return t.brandCheck(this, R), this.#n;
    }
    get onopen() {
      return t.brandCheck(this, R), this.#e.open;
    }
    set onopen(S) {
      t.brandCheck(this, R), this.#e.open && this.removeEventListener("open", this.#e.open), typeof S == "function" ? (this.#e.open = S, this.addEventListener("open", S)) : this.#e.open = null;
    }
    get onerror() {
      return t.brandCheck(this, R), this.#e.error;
    }
    set onerror(S) {
      t.brandCheck(this, R), this.#e.error && this.removeEventListener("error", this.#e.error), typeof S == "function" ? (this.#e.error = S, this.addEventListener("error", S)) : this.#e.error = null;
    }
    get onclose() {
      return t.brandCheck(this, R), this.#e.close;
    }
    set onclose(S) {
      t.brandCheck(this, R), this.#e.close && this.removeEventListener("close", this.#e.close), typeof S == "function" ? (this.#e.close = S, this.addEventListener("close", S)) : this.#e.close = null;
    }
    get onmessage() {
      return t.brandCheck(this, R), this.#e.message;
    }
    set onmessage(S) {
      t.brandCheck(this, R), this.#e.message && this.removeEventListener("message", this.#e.message), typeof S == "function" ? (this.#e.message = S, this.addEventListener("message", S)) : this.#e.message = null;
    }
    get binaryType() {
      return t.brandCheck(this, R), this[u];
    }
    set binaryType(S) {
      t.brandCheck(this, R), S !== "blob" && S !== "arraybuffer" ? this[u] = "blob" : this[u] = S;
    }
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    #s(S) {
      this[g] = S;
      const D = new w(this);
      D.on("drain", function() {
        this.ws[g].socket.resume();
      }), S.socket.ws = this, this[m] = D, this[A] = i.OPEN;
      const T = S.headersList.get("sec-websocket-extensions");
      T !== null && (this.#t = T);
      const k = S.headersList.get("sec-websocket-protocol");
      k !== null && (this.#n = k), y("open", this);
    }
  }
  return R.CONNECTING = R.prototype.CONNECTING = i.CONNECTING, R.OPEN = R.prototype.OPEN = i.OPEN, R.CLOSING = R.prototype.CLOSING = i.CLOSING, R.CLOSED = R.prototype.CLOSED = i.CLOSED, Object.defineProperties(R.prototype, {
    CONNECTING: s,
    OPEN: s,
    CLOSING: s,
    CLOSED: s,
    url: f,
    readyState: f,
    bufferedAmount: f,
    onopen: f,
    onerror: f,
    onclose: f,
    close: f,
    onmessage: f,
    binaryType: f,
    send: f,
    extensions: f,
    protocol: f,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  }), Object.defineProperties(R, {
    CONNECTING: s,
    OPEN: s,
    CLOSING: s,
    CLOSED: s
  }), t.converters["sequence<DOMString>"] = t.sequenceConverter(
    t.converters.DOMString
  ), t.converters["DOMString or sequence<DOMString>"] = function(x) {
    return t.util.Type(x) === "Object" && Symbol.iterator in x ? t.converters["sequence<DOMString>"](x) : t.converters.DOMString(x);
  }, t.converters.WebSocketInit = t.dictionaryConverter([
    {
      key: "protocols",
      converter: t.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (x) => x,
      get defaultValue() {
        return b();
      }
    },
    {
      key: "headers",
      converter: t.nullableConverter(t.converters.HeadersInit)
    }
  ]), t.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(x) {
    return t.util.Type(x) === "Object" && !(Symbol.iterator in x) ? t.converters.WebSocketInit(x) : { protocols: t.converters["DOMString or sequence<DOMString>"](x) };
  }, t.converters.WebSocketSendData = function(x) {
    if (t.util.Type(x) === "Object") {
      if (C(x))
        return t.converters.Blob(x, { strict: !1 });
      if (ArrayBuffer.isView(x) || N.isAnyArrayBuffer(x))
        return t.converters.BufferSource(x);
    }
    return t.converters.USVString(x);
  }, pc = {
    WebSocket: R
  }, pc;
}
var vm;
function Yf() {
  if (vm) return Je;
  vm = 1;
  const t = oa(), e = uu(), r = ft(), n = $i(), s = fb(), i = aa(), o = rt(), { InvalidArgumentError: c } = r, l = bb(), A = ia(), a = Mf(), u = Rb(), g = Of(), h = Lf(), m = Sb(), d = vb(), { getGlobalDispatcher: p, setGlobalDispatcher: E } = Zi(), B = xb(), y = kf(), Q = du();
  let I;
  try {
    require("crypto"), I = !0;
  } catch {
    I = !1;
  }
  Object.assign(e.prototype, l), Je.Dispatcher = e, Je.Client = t, Je.Pool = n, Je.BalancedPool = s, Je.Agent = i, Je.ProxyAgent = m, Je.RetryHandler = d, Je.DecoratorHandler = B, Je.RedirectHandler = y, Je.createRedirectInterceptor = Q, Je.buildConnector = A, Je.errors = r;
  function w(f) {
    return (C, b, N) => {
      if (typeof b == "function" && (N = b, b = null), !C || typeof C != "string" && typeof C != "object" && !(C instanceof URL))
        throw new c("invalid url");
      if (b != null && typeof b != "object")
        throw new c("invalid opts");
      if (b && b.path != null) {
        if (typeof b.path != "string")
          throw new c("invalid opts.path");
        let x = b.path;
        b.path.startsWith("/") || (x = `/${x}`), C = new URL(o.parseOrigin(C).origin + x);
      } else
        b || (b = typeof C == "object" ? C : {}), C = o.parseURL(C);
      const { agent: v, dispatcher: R = p() } = b;
      if (v)
        throw new c("unsupported opts.agent. Did you mean opts.client?");
      return f.call(R, {
        ...b,
        origin: C.origin,
        path: C.search ? `${C.pathname}${C.search}` : C.pathname,
        method: b.method || (b.body ? "PUT" : "GET")
      }, N);
    };
  }
  if (Je.setGlobalDispatcher = E, Je.getGlobalDispatcher = p, o.nodeMajor > 16 || o.nodeMajor === 16 && o.nodeMinor >= 8) {
    let f = null;
    Je.fetch = async function(x) {
      f || (f = mu().fetch);
      try {
        return await f(...arguments);
      } catch (S) {
        throw typeof S == "object" && Error.captureStackTrace(S, this), S;
      }
    }, Je.Headers = Fs().Headers, Je.Response = gu().Response, Je.Request = ca().Request, Je.FormData = lu().FormData, Je.File = cu().File, Je.FileReader = Fb().FileReader;
    const { setGlobalOrigin: C, getGlobalOrigin: b } = ji();
    Je.setGlobalOrigin = C, Je.getGlobalOrigin = b;
    const { CacheStorage: N } = Lb(), { kConstruct: v } = hu();
    Je.caches = new N(v);
  }
  if (o.nodeMajor >= 16) {
    const { deleteCookie: f, getCookies: C, getSetCookies: b, setCookie: N } = Ob();
    Je.deleteCookie = f, Je.getCookies = C, Je.getSetCookies = b, Je.setCookie = N;
    const { parseMIMEType: v, serializeAMimeType: R } = un();
    Je.parseMIMEType = v, Je.serializeAMimeType = R;
  }
  if (o.nodeMajor >= 18 && I) {
    const { WebSocket: f } = Hb();
    Je.WebSocket = f;
  }
  return Je.request = w(l.request), Je.stream = w(l.stream), Je.pipeline = w(l.pipeline), Je.connect = w(l.connect), Je.upgrade = w(l.upgrade), Je.MockClient = a, Je.MockPool = g, Je.MockAgent = u, Je.mockErrors = h, Je;
}
var xm;
function kn() {
  if (xm) return dt;
  xm = 1;
  var t = dt && dt.__createBinding || (Object.create ? function(f, C, b, N) {
    N === void 0 && (N = b);
    var v = Object.getOwnPropertyDescriptor(C, b);
    (!v || ("get" in v ? !C.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return C[b];
    } }), Object.defineProperty(f, N, v);
  } : function(f, C, b, N) {
    N === void 0 && (N = b), f[N] = C[b];
  }), e = dt && dt.__setModuleDefault || (Object.create ? function(f, C) {
    Object.defineProperty(f, "default", { enumerable: !0, value: C });
  } : function(f, C) {
    f.default = C;
  }), r = dt && dt.__importStar || function(f) {
    if (f && f.__esModule) return f;
    var C = {};
    if (f != null) for (var b in f) b !== "default" && Object.prototype.hasOwnProperty.call(f, b) && t(C, f, b);
    return e(C, f), C;
  }, n = dt && dt.__awaiter || function(f, C, b, N) {
    function v(R) {
      return R instanceof b ? R : new b(function(x) {
        x(R);
      });
    }
    return new (b || (b = Promise))(function(R, x) {
      function S(k) {
        try {
          T(N.next(k));
        } catch (L) {
          x(L);
        }
      }
      function D(k) {
        try {
          T(N.throw(k));
        } catch (L) {
          x(L);
        }
      }
      function T(k) {
        k.done ? R(k.value) : v(k.value).then(S, D);
      }
      T((N = N.apply(f, C || [])).next());
    });
  };
  Object.defineProperty(dt, "__esModule", { value: !0 }), dt.HttpClient = dt.isHttps = dt.HttpClientResponse = dt.HttpClientError = dt.getProxyUrl = dt.MediaTypes = dt.Headers = dt.HttpCodes = void 0;
  const s = r(Ds), i = r(Ef), o = r(ZQ()), c = r(tb()), l = Yf();
  var A;
  (function(f) {
    f[f.OK = 200] = "OK", f[f.MultipleChoices = 300] = "MultipleChoices", f[f.MovedPermanently = 301] = "MovedPermanently", f[f.ResourceMoved = 302] = "ResourceMoved", f[f.SeeOther = 303] = "SeeOther", f[f.NotModified = 304] = "NotModified", f[f.UseProxy = 305] = "UseProxy", f[f.SwitchProxy = 306] = "SwitchProxy", f[f.TemporaryRedirect = 307] = "TemporaryRedirect", f[f.PermanentRedirect = 308] = "PermanentRedirect", f[f.BadRequest = 400] = "BadRequest", f[f.Unauthorized = 401] = "Unauthorized", f[f.PaymentRequired = 402] = "PaymentRequired", f[f.Forbidden = 403] = "Forbidden", f[f.NotFound = 404] = "NotFound", f[f.MethodNotAllowed = 405] = "MethodNotAllowed", f[f.NotAcceptable = 406] = "NotAcceptable", f[f.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", f[f.RequestTimeout = 408] = "RequestTimeout", f[f.Conflict = 409] = "Conflict", f[f.Gone = 410] = "Gone", f[f.TooManyRequests = 429] = "TooManyRequests", f[f.InternalServerError = 500] = "InternalServerError", f[f.NotImplemented = 501] = "NotImplemented", f[f.BadGateway = 502] = "BadGateway", f[f.ServiceUnavailable = 503] = "ServiceUnavailable", f[f.GatewayTimeout = 504] = "GatewayTimeout";
  })(A || (dt.HttpCodes = A = {}));
  var a;
  (function(f) {
    f.Accept = "accept", f.ContentType = "content-type";
  })(a || (dt.Headers = a = {}));
  var u;
  (function(f) {
    f.ApplicationJson = "application/json";
  })(u || (dt.MediaTypes = u = {}));
  function g(f) {
    const C = o.getProxyUrl(new URL(f));
    return C ? C.href : "";
  }
  dt.getProxyUrl = g;
  const h = [
    A.MovedPermanently,
    A.ResourceMoved,
    A.SeeOther,
    A.TemporaryRedirect,
    A.PermanentRedirect
  ], m = [
    A.BadGateway,
    A.ServiceUnavailable,
    A.GatewayTimeout
  ], d = ["OPTIONS", "GET", "DELETE", "HEAD"], p = 10, E = 5;
  class B extends Error {
    constructor(C, b) {
      super(C), this.name = "HttpClientError", this.statusCode = b, Object.setPrototypeOf(this, B.prototype);
    }
  }
  dt.HttpClientError = B;
  class y {
    constructor(C) {
      this.message = C;
    }
    readBody() {
      return n(this, void 0, void 0, function* () {
        return new Promise((C) => n(this, void 0, void 0, function* () {
          let b = Buffer.alloc(0);
          this.message.on("data", (N) => {
            b = Buffer.concat([b, N]);
          }), this.message.on("end", () => {
            C(b.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return n(this, void 0, void 0, function* () {
        return new Promise((C) => n(this, void 0, void 0, function* () {
          const b = [];
          this.message.on("data", (N) => {
            b.push(N);
          }), this.message.on("end", () => {
            C(Buffer.concat(b));
          });
        }));
      });
    }
  }
  dt.HttpClientResponse = y;
  function Q(f) {
    return new URL(f).protocol === "https:";
  }
  dt.isHttps = Q;
  class I {
    constructor(C, b, N) {
      this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = C, this.handlers = b || [], this.requestOptions = N, N && (N.ignoreSslError != null && (this._ignoreSslError = N.ignoreSslError), this._socketTimeout = N.socketTimeout, N.allowRedirects != null && (this._allowRedirects = N.allowRedirects), N.allowRedirectDowngrade != null && (this._allowRedirectDowngrade = N.allowRedirectDowngrade), N.maxRedirects != null && (this._maxRedirects = Math.max(N.maxRedirects, 0)), N.keepAlive != null && (this._keepAlive = N.keepAlive), N.allowRetries != null && (this._allowRetries = N.allowRetries), N.maxRetries != null && (this._maxRetries = N.maxRetries));
    }
    options(C, b) {
      return n(this, void 0, void 0, function* () {
        return this.request("OPTIONS", C, null, b || {});
      });
    }
    get(C, b) {
      return n(this, void 0, void 0, function* () {
        return this.request("GET", C, null, b || {});
      });
    }
    del(C, b) {
      return n(this, void 0, void 0, function* () {
        return this.request("DELETE", C, null, b || {});
      });
    }
    post(C, b, N) {
      return n(this, void 0, void 0, function* () {
        return this.request("POST", C, b, N || {});
      });
    }
    patch(C, b, N) {
      return n(this, void 0, void 0, function* () {
        return this.request("PATCH", C, b, N || {});
      });
    }
    put(C, b, N) {
      return n(this, void 0, void 0, function* () {
        return this.request("PUT", C, b, N || {});
      });
    }
    head(C, b) {
      return n(this, void 0, void 0, function* () {
        return this.request("HEAD", C, null, b || {});
      });
    }
    sendStream(C, b, N, v) {
      return n(this, void 0, void 0, function* () {
        return this.request(C, b, N, v);
      });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(C, b = {}) {
      return n(this, void 0, void 0, function* () {
        b[a.Accept] = this._getExistingOrDefaultHeader(b, a.Accept, u.ApplicationJson);
        const N = yield this.get(C, b);
        return this._processResponse(N, this.requestOptions);
      });
    }
    postJson(C, b, N = {}) {
      return n(this, void 0, void 0, function* () {
        const v = JSON.stringify(b, null, 2);
        N[a.Accept] = this._getExistingOrDefaultHeader(N, a.Accept, u.ApplicationJson), N[a.ContentType] = this._getExistingOrDefaultHeader(N, a.ContentType, u.ApplicationJson);
        const R = yield this.post(C, v, N);
        return this._processResponse(R, this.requestOptions);
      });
    }
    putJson(C, b, N = {}) {
      return n(this, void 0, void 0, function* () {
        const v = JSON.stringify(b, null, 2);
        N[a.Accept] = this._getExistingOrDefaultHeader(N, a.Accept, u.ApplicationJson), N[a.ContentType] = this._getExistingOrDefaultHeader(N, a.ContentType, u.ApplicationJson);
        const R = yield this.put(C, v, N);
        return this._processResponse(R, this.requestOptions);
      });
    }
    patchJson(C, b, N = {}) {
      return n(this, void 0, void 0, function* () {
        const v = JSON.stringify(b, null, 2);
        N[a.Accept] = this._getExistingOrDefaultHeader(N, a.Accept, u.ApplicationJson), N[a.ContentType] = this._getExistingOrDefaultHeader(N, a.ContentType, u.ApplicationJson);
        const R = yield this.patch(C, v, N);
        return this._processResponse(R, this.requestOptions);
      });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(C, b, N, v) {
      return n(this, void 0, void 0, function* () {
        if (this._disposed)
          throw new Error("Client has already been disposed.");
        const R = new URL(b);
        let x = this._prepareRequest(C, R, v);
        const S = this._allowRetries && d.includes(C) ? this._maxRetries + 1 : 1;
        let D = 0, T;
        do {
          if (T = yield this.requestRaw(x, N), T && T.message && T.message.statusCode === A.Unauthorized) {
            let L;
            for (const W of this.handlers)
              if (W.canHandleAuthentication(T)) {
                L = W;
                break;
              }
            return L ? L.handleAuthentication(this, x, N) : T;
          }
          let k = this._maxRedirects;
          for (; T.message.statusCode && h.includes(T.message.statusCode) && this._allowRedirects && k > 0; ) {
            const L = T.message.headers.location;
            if (!L)
              break;
            const W = new URL(L);
            if (R.protocol === "https:" && R.protocol !== W.protocol && !this._allowRedirectDowngrade)
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            if (yield T.readBody(), W.hostname !== R.hostname)
              for (const O in v)
                O.toLowerCase() === "authorization" && delete v[O];
            x = this._prepareRequest(C, W, v), T = yield this.requestRaw(x, N), k--;
          }
          if (!T.message.statusCode || !m.includes(T.message.statusCode))
            return T;
          D += 1, D < S && (yield T.readBody(), yield this._performExponentialBackoff(D));
        } while (D < S);
        return T;
      });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
      this._agent && this._agent.destroy(), this._disposed = !0;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(C, b) {
      return n(this, void 0, void 0, function* () {
        return new Promise((N, v) => {
          function R(x, S) {
            x ? v(x) : S ? N(S) : v(new Error("Unknown error"));
          }
          this.requestRawWithCallback(C, b, R);
        });
      });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(C, b, N) {
      typeof b == "string" && (C.options.headers || (C.options.headers = {}), C.options.headers["Content-Length"] = Buffer.byteLength(b, "utf8"));
      let v = !1;
      function R(D, T) {
        v || (v = !0, N(D, T));
      }
      const x = C.httpModule.request(C.options, (D) => {
        const T = new y(D);
        R(void 0, T);
      });
      let S;
      x.on("socket", (D) => {
        S = D;
      }), x.setTimeout(this._socketTimeout || 3 * 6e4, () => {
        S && S.end(), R(new Error(`Request timeout: ${C.options.path}`));
      }), x.on("error", function(D) {
        R(D);
      }), b && typeof b == "string" && x.write(b, "utf8"), b && typeof b != "string" ? (b.on("close", function() {
        x.end();
      }), b.pipe(x)) : x.end();
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(C) {
      const b = new URL(C);
      return this._getAgent(b);
    }
    getAgentDispatcher(C) {
      const b = new URL(C), N = o.getProxyUrl(b);
      if (N && N.hostname)
        return this._getProxyAgentDispatcher(b, N);
    }
    _prepareRequest(C, b, N) {
      const v = {};
      v.parsedUrl = b;
      const R = v.parsedUrl.protocol === "https:";
      v.httpModule = R ? i : s;
      const x = R ? 443 : 80;
      if (v.options = {}, v.options.host = v.parsedUrl.hostname, v.options.port = v.parsedUrl.port ? parseInt(v.parsedUrl.port) : x, v.options.path = (v.parsedUrl.pathname || "") + (v.parsedUrl.search || ""), v.options.method = C, v.options.headers = this._mergeHeaders(N), this.userAgent != null && (v.options.headers["user-agent"] = this.userAgent), v.options.agent = this._getAgent(v.parsedUrl), this.handlers)
        for (const S of this.handlers)
          S.prepareRequest(v.options);
      return v;
    }
    _mergeHeaders(C) {
      return this.requestOptions && this.requestOptions.headers ? Object.assign({}, w(this.requestOptions.headers), w(C || {})) : w(C || {});
    }
    _getExistingOrDefaultHeader(C, b, N) {
      let v;
      return this.requestOptions && this.requestOptions.headers && (v = w(this.requestOptions.headers)[b]), C[b] || v || N;
    }
    _getAgent(C) {
      let b;
      const N = o.getProxyUrl(C), v = N && N.hostname;
      if (this._keepAlive && v && (b = this._proxyAgent), v || (b = this._agent), b)
        return b;
      const R = C.protocol === "https:";
      let x = 100;
      if (this.requestOptions && (x = this.requestOptions.maxSockets || s.globalAgent.maxSockets), N && N.hostname) {
        const S = {
          maxSockets: x,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (N.username || N.password) && {
            proxyAuth: `${N.username}:${N.password}`
          }), { host: N.hostname, port: N.port })
        };
        let D;
        const T = N.protocol === "https:";
        R ? D = T ? c.httpsOverHttps : c.httpsOverHttp : D = T ? c.httpOverHttps : c.httpOverHttp, b = D(S), this._proxyAgent = b;
      }
      if (!b) {
        const S = { keepAlive: this._keepAlive, maxSockets: x };
        b = R ? new i.Agent(S) : new s.Agent(S), this._agent = b;
      }
      return R && this._ignoreSslError && (b.options = Object.assign(b.options || {}, {
        rejectUnauthorized: !1
      })), b;
    }
    _getProxyAgentDispatcher(C, b) {
      let N;
      if (this._keepAlive && (N = this._proxyAgentDispatcher), N)
        return N;
      const v = C.protocol === "https:";
      return N = new l.ProxyAgent(Object.assign({ uri: b.href, pipelining: this._keepAlive ? 1 : 0 }, (b.username || b.password) && {
        token: `Basic ${Buffer.from(`${b.username}:${b.password}`).toString("base64")}`
      })), this._proxyAgentDispatcher = N, v && this._ignoreSslError && (N.options = Object.assign(N.options.requestTls || {}, {
        rejectUnauthorized: !1
      })), N;
    }
    _performExponentialBackoff(C) {
      return n(this, void 0, void 0, function* () {
        C = Math.min(p, C);
        const b = E * Math.pow(2, C);
        return new Promise((N) => setTimeout(() => N(), b));
      });
    }
    _processResponse(C, b) {
      return n(this, void 0, void 0, function* () {
        return new Promise((N, v) => n(this, void 0, void 0, function* () {
          const R = C.message.statusCode || 0, x = {
            statusCode: R,
            result: null,
            headers: {}
          };
          R === A.NotFound && N(x);
          function S(k, L) {
            if (typeof L == "string") {
              const W = new Date(L);
              if (!isNaN(W.valueOf()))
                return W;
            }
            return L;
          }
          let D, T;
          try {
            T = yield C.readBody(), T && T.length > 0 && (b && b.deserializeDates ? D = JSON.parse(T, S) : D = JSON.parse(T), x.result = D), x.headers = C.message.headers;
          } catch {
          }
          if (R > 299) {
            let k;
            D && D.message ? k = D.message : T && T.length > 0 ? k = T : k = `Failed request: (${R})`;
            const L = new B(k, R);
            L.result = x.result, v(L);
          } else
            N(x);
        }));
      });
    }
  }
  dt.HttpClient = I;
  const w = (f) => Object.keys(f).reduce((C, b) => (C[b.toLowerCase()] = f[b], C), {});
  return dt;
}
var Vr = {}, Dm;
function fu() {
  if (Dm) return Vr;
  Dm = 1;
  var t = Vr && Vr.__awaiter || function(s, i, o, c) {
    function l(A) {
      return A instanceof o ? A : new o(function(a) {
        a(A);
      });
    }
    return new (o || (o = Promise))(function(A, a) {
      function u(m) {
        try {
          h(c.next(m));
        } catch (d) {
          a(d);
        }
      }
      function g(m) {
        try {
          h(c.throw(m));
        } catch (d) {
          a(d);
        }
      }
      function h(m) {
        m.done ? A(m.value) : l(m.value).then(u, g);
      }
      h((c = c.apply(s, i || [])).next());
    });
  };
  Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.PersonalAccessTokenCredentialHandler = Vr.BearerCredentialHandler = Vr.BasicCredentialHandler = void 0;
  class e {
    constructor(i, o) {
      this.username = i, this.password = o;
    }
    prepareRequest(i) {
      if (!i.headers)
        throw Error("The request has no headers");
      i.headers.Authorization = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return t(this, void 0, void 0, function* () {
        throw new Error("not implemented");
      });
    }
  }
  Vr.BasicCredentialHandler = e;
  class r {
    constructor(i) {
      this.token = i;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(i) {
      if (!i.headers)
        throw Error("The request has no headers");
      i.headers.Authorization = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return t(this, void 0, void 0, function* () {
        throw new Error("not implemented");
      });
    }
  }
  Vr.BearerCredentialHandler = r;
  class n {
    constructor(i) {
      this.token = i;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(i) {
      if (!i.headers)
        throw Error("The request has no headers");
      i.headers.Authorization = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return t(this, void 0, void 0, function* () {
        throw new Error("not implemented");
      });
    }
  }
  return Vr.PersonalAccessTokenCredentialHandler = n, Vr;
}
var Tm;
function zb() {
  if (Tm) return Gn;
  Tm = 1;
  var t = Gn && Gn.__awaiter || function(i, o, c, l) {
    function A(a) {
      return a instanceof c ? a : new c(function(u) {
        u(a);
      });
    }
    return new (c || (c = Promise))(function(a, u) {
      function g(d) {
        try {
          m(l.next(d));
        } catch (p) {
          u(p);
        }
      }
      function h(d) {
        try {
          m(l.throw(d));
        } catch (p) {
          u(p);
        }
      }
      function m(d) {
        d.done ? a(d.value) : A(d.value).then(g, h);
      }
      m((l = l.apply(i, o || [])).next());
    });
  };
  Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.OidcClient = void 0;
  const e = kn(), r = fu(), n = ir();
  class s {
    static createHttpClient(o = !0, c = 10) {
      const l = {
        allowRetries: o,
        maxRetries: c
      };
      return new e.HttpClient("actions/oidc-client", [new r.BearerCredentialHandler(s.getRequestToken())], l);
    }
    static getRequestToken() {
      const o = process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN;
      if (!o)
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      return o;
    }
    static getIDTokenUrl() {
      const o = process.env.ACTIONS_ID_TOKEN_REQUEST_URL;
      if (!o)
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      return o;
    }
    static getCall(o) {
      var c;
      return t(this, void 0, void 0, function* () {
        const a = (c = (yield s.createHttpClient().getJson(o).catch((u) => {
          throw new Error(`Failed to get ID Token. 
 
        Error Code : ${u.statusCode}
 
        Error Message: ${u.message}`);
        })).result) === null || c === void 0 ? void 0 : c.value;
        if (!a)
          throw new Error("Response json body do not have ID Token field");
        return a;
      });
    }
    static getIDToken(o) {
      return t(this, void 0, void 0, function* () {
        try {
          let c = s.getIDTokenUrl();
          if (o) {
            const A = encodeURIComponent(o);
            c = `${c}&audience=${A}`;
          }
          (0, n.debug)(`ID token url is ${c}`);
          const l = yield s.getCall(c);
          return (0, n.setSecret)(l), l;
        } catch (c) {
          throw new Error(`Error message: ${c.message}`);
        }
      });
    }
  }
  return Gn.OidcClient = s, Gn;
}
var pi = {}, km;
function Fm() {
  return km || (km = 1, function(t) {
    var e = pi && pi.__awaiter || function(A, a, u, g) {
      function h(m) {
        return m instanceof u ? m : new u(function(d) {
          d(m);
        });
      }
      return new (u || (u = Promise))(function(m, d) {
        function p(y) {
          try {
            B(g.next(y));
          } catch (Q) {
            d(Q);
          }
        }
        function E(y) {
          try {
            B(g.throw(y));
          } catch (Q) {
            d(Q);
          }
        }
        function B(y) {
          y.done ? m(y.value) : h(y.value).then(p, E);
        }
        B((g = g.apply(A, a || [])).next());
      });
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.summary = t.markdownSummary = t.SUMMARY_DOCS_URL = t.SUMMARY_ENV_VAR = void 0;
    const r = cn, n = Zr, { access: s, appendFile: i, writeFile: o } = n.promises;
    t.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY", t.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    class c {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return e(this, void 0, void 0, function* () {
          if (this._filePath)
            return this._filePath;
          const a = process.env[t.SUMMARY_ENV_VAR];
          if (!a)
            throw new Error(`Unable to find environment variable for $${t.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          try {
            yield s(a, n.constants.R_OK | n.constants.W_OK);
          } catch {
            throw new Error(`Unable to access summary file: '${a}'. Check if the file has correct read/write permissions.`);
          }
          return this._filePath = a, this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(a, u, g = {}) {
        const h = Object.entries(g).map(([m, d]) => ` ${m}="${d}"`).join("");
        return u ? `<${a}${h}>${u}</${a}>` : `<${a}${h}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(a) {
        return e(this, void 0, void 0, function* () {
          const u = !!a?.overwrite, g = yield this.filePath();
          return yield (u ? o : i)(g, this._buffer, { encoding: "utf8" }), this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return e(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: !0 });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        return this._buffer = "", this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(a, u = !1) {
        return this._buffer += a, u ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(r.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(a, u) {
        const g = Object.assign({}, u && { lang: u }), h = this.wrap("pre", this.wrap("code", a), g);
        return this.addRaw(h).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(a, u = !1) {
        const g = u ? "ol" : "ul", h = a.map((d) => this.wrap("li", d)).join(""), m = this.wrap(g, h);
        return this.addRaw(m).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(a) {
        const u = a.map((h) => {
          const m = h.map((d) => {
            if (typeof d == "string")
              return this.wrap("td", d);
            const { header: p, data: E, colspan: B, rowspan: y } = d, Q = p ? "th" : "td", I = Object.assign(Object.assign({}, B && { colspan: B }), y && { rowspan: y });
            return this.wrap(Q, E, I);
          }).join("");
          return this.wrap("tr", m);
        }).join(""), g = this.wrap("table", u);
        return this.addRaw(g).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(a, u) {
        const g = this.wrap("details", this.wrap("summary", a) + u);
        return this.addRaw(g).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(a, u, g) {
        const { width: h, height: m } = g || {}, d = Object.assign(Object.assign({}, h && { width: h }), m && { height: m }), p = this.wrap("img", null, Object.assign({ src: a, alt: u }, d));
        return this.addRaw(p).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(a, u) {
        const g = `h${u}`, h = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(g) ? g : "h1", m = this.wrap(h, a);
        return this.addRaw(m).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const a = this.wrap("hr", null);
        return this.addRaw(a).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const a = this.wrap("br", null);
        return this.addRaw(a).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(a, u) {
        const g = Object.assign({}, u && { cite: u }), h = this.wrap("blockquote", a, g);
        return this.addRaw(h).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(a, u) {
        const g = this.wrap("a", a, { href: u });
        return this.addRaw(g).addEOL();
      }
    }
    const l = new c();
    t.markdownSummary = l, t.summary = l;
  }(pi)), pi;
}
var lr = {}, Pm;
function Yb() {
  if (Pm) return lr;
  Pm = 1;
  var t = lr && lr.__createBinding || (Object.create ? function(c, l, A, a) {
    a === void 0 && (a = A);
    var u = Object.getOwnPropertyDescriptor(l, A);
    (!u || ("get" in u ? !l.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return l[A];
    } }), Object.defineProperty(c, a, u);
  } : function(c, l, A, a) {
    a === void 0 && (a = A), c[a] = l[A];
  }), e = lr && lr.__setModuleDefault || (Object.create ? function(c, l) {
    Object.defineProperty(c, "default", { enumerable: !0, value: l });
  } : function(c, l) {
    c.default = l;
  }), r = lr && lr.__importStar || function(c) {
    if (c && c.__esModule) return c;
    var l = {};
    if (c != null) for (var A in c) A !== "default" && Object.prototype.hasOwnProperty.call(c, A) && t(l, c, A);
    return e(l, c), l;
  };
  Object.defineProperty(lr, "__esModule", { value: !0 }), lr.toPlatformPath = lr.toWin32Path = lr.toPosixPath = void 0;
  const n = r(yr);
  function s(c) {
    return c.replace(/[\\]/g, "/");
  }
  lr.toPosixPath = s;
  function i(c) {
    return c.replace(/[/]/g, "\\");
  }
  lr.toWin32Path = i;
  function o(c) {
    return c.replace(/[/\\]/g, n.sep);
  }
  return lr.toPlatformPath = o, lr;
}
var Rr = {}, ur = {}, dr = {}, xt = {}, Wr = {}, Um;
function Jf() {
  return Um || (Um = 1, function(t) {
    var e = Wr && Wr.__createBinding || (Object.create ? function(d, p, E, B) {
      B === void 0 && (B = E), Object.defineProperty(d, B, { enumerable: !0, get: function() {
        return p[E];
      } });
    } : function(d, p, E, B) {
      B === void 0 && (B = E), d[B] = p[E];
    }), r = Wr && Wr.__setModuleDefault || (Object.create ? function(d, p) {
      Object.defineProperty(d, "default", { enumerable: !0, value: p });
    } : function(d, p) {
      d.default = p;
    }), n = Wr && Wr.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var p = {};
      if (d != null) for (var E in d) E !== "default" && Object.hasOwnProperty.call(d, E) && e(p, d, E);
      return r(p, d), p;
    }, s = Wr && Wr.__awaiter || function(d, p, E, B) {
      function y(Q) {
        return Q instanceof E ? Q : new E(function(I) {
          I(Q);
        });
      }
      return new (E || (E = Promise))(function(Q, I) {
        function w(b) {
          try {
            C(B.next(b));
          } catch (N) {
            I(N);
          }
        }
        function f(b) {
          try {
            C(B.throw(b));
          } catch (N) {
            I(N);
          }
        }
        function C(b) {
          b.done ? Q(b.value) : y(b.value).then(w, f);
        }
        C((B = B.apply(d, p || [])).next());
      });
    }, i;
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getCmdPath = t.tryGetExecutablePath = t.isRooted = t.isDirectory = t.exists = t.READONLY = t.UV_FS_O_EXLOCK = t.IS_WINDOWS = t.unlink = t.symlink = t.stat = t.rmdir = t.rm = t.rename = t.readlink = t.readdir = t.open = t.mkdir = t.lstat = t.copyFile = t.chmod = void 0;
    const o = n(Zr), c = n(yr);
    i = o.promises, t.chmod = i.chmod, t.copyFile = i.copyFile, t.lstat = i.lstat, t.mkdir = i.mkdir, t.open = i.open, t.readdir = i.readdir, t.readlink = i.readlink, t.rename = i.rename, t.rm = i.rm, t.rmdir = i.rmdir, t.stat = i.stat, t.symlink = i.symlink, t.unlink = i.unlink, t.IS_WINDOWS = process.platform === "win32", t.UV_FS_O_EXLOCK = 268435456, t.READONLY = o.constants.O_RDONLY;
    function l(d) {
      return s(this, void 0, void 0, function* () {
        try {
          yield t.stat(d);
        } catch (p) {
          if (p.code === "ENOENT")
            return !1;
          throw p;
        }
        return !0;
      });
    }
    t.exists = l;
    function A(d, p = !1) {
      return s(this, void 0, void 0, function* () {
        return (p ? yield t.stat(d) : yield t.lstat(d)).isDirectory();
      });
    }
    t.isDirectory = A;
    function a(d) {
      if (d = g(d), !d)
        throw new Error('isRooted() parameter "p" cannot be empty');
      return t.IS_WINDOWS ? d.startsWith("\\") || /^[A-Z]:/i.test(d) : d.startsWith("/");
    }
    t.isRooted = a;
    function u(d, p) {
      return s(this, void 0, void 0, function* () {
        let E;
        try {
          E = yield t.stat(d);
        } catch (y) {
          y.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${d}': ${y}`);
        }
        if (E && E.isFile()) {
          if (t.IS_WINDOWS) {
            const y = c.extname(d).toUpperCase();
            if (p.some((Q) => Q.toUpperCase() === y))
              return d;
          } else if (h(E))
            return d;
        }
        const B = d;
        for (const y of p) {
          d = B + y, E = void 0;
          try {
            E = yield t.stat(d);
          } catch (Q) {
            Q.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${d}': ${Q}`);
          }
          if (E && E.isFile()) {
            if (t.IS_WINDOWS) {
              try {
                const Q = c.dirname(d), I = c.basename(d).toUpperCase();
                for (const w of yield t.readdir(Q))
                  if (I === w.toUpperCase()) {
                    d = c.join(Q, w);
                    break;
                  }
              } catch (Q) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${d}': ${Q}`);
              }
              return d;
            } else if (h(E))
              return d;
          }
        }
        return "";
      });
    }
    t.tryGetExecutablePath = u;
    function g(d) {
      return d = d || "", t.IS_WINDOWS ? (d = d.replace(/\//g, "\\"), d.replace(/\\\\+/g, "\\")) : d.replace(/\/\/+/g, "/");
    }
    function h(d) {
      return (d.mode & 1) > 0 || (d.mode & 8) > 0 && d.gid === process.getgid() || (d.mode & 64) > 0 && d.uid === process.getuid();
    }
    function m() {
      var d;
      return (d = process.env.COMSPEC) !== null && d !== void 0 ? d : "cmd.exe";
    }
    t.getCmdPath = m;
  }(Wr)), Wr;
}
var Lm;
function to() {
  if (Lm) return xt;
  Lm = 1;
  var t = xt && xt.__createBinding || (Object.create ? function(p, E, B, y) {
    y === void 0 && (y = B), Object.defineProperty(p, y, { enumerable: !0, get: function() {
      return E[B];
    } });
  } : function(p, E, B, y) {
    y === void 0 && (y = B), p[y] = E[B];
  }), e = xt && xt.__setModuleDefault || (Object.create ? function(p, E) {
    Object.defineProperty(p, "default", { enumerable: !0, value: E });
  } : function(p, E) {
    p.default = E;
  }), r = xt && xt.__importStar || function(p) {
    if (p && p.__esModule) return p;
    var E = {};
    if (p != null) for (var B in p) B !== "default" && Object.hasOwnProperty.call(p, B) && t(E, p, B);
    return e(E, p), E;
  }, n = xt && xt.__awaiter || function(p, E, B, y) {
    function Q(I) {
      return I instanceof B ? I : new B(function(w) {
        w(I);
      });
    }
    return new (B || (B = Promise))(function(I, w) {
      function f(N) {
        try {
          b(y.next(N));
        } catch (v) {
          w(v);
        }
      }
      function C(N) {
        try {
          b(y.throw(N));
        } catch (v) {
          w(v);
        }
      }
      function b(N) {
        N.done ? I(N.value) : Q(N.value).then(f, C);
      }
      b((y = y.apply(p, E || [])).next());
    });
  };
  Object.defineProperty(xt, "__esModule", { value: !0 }), xt.findInPath = xt.which = xt.mkdirP = xt.rmRF = xt.mv = xt.cp = void 0;
  const s = bt, i = r(yr), o = r(Jf());
  function c(p, E, B = {}) {
    return n(this, void 0, void 0, function* () {
      const { force: y, recursive: Q, copySourceDirectory: I } = h(B), w = (yield o.exists(E)) ? yield o.stat(E) : null;
      if (w && w.isFile() && !y)
        return;
      const f = w && w.isDirectory() && I ? i.join(E, i.basename(p)) : E;
      if (!(yield o.exists(p)))
        throw new Error(`no such file or directory: ${p}`);
      if ((yield o.stat(p)).isDirectory())
        if (Q)
          yield m(p, f, 0, y);
        else
          throw new Error(`Failed to copy. ${p} is a directory, but tried to copy without recursive flag.`);
      else {
        if (i.relative(p, f) === "")
          throw new Error(`'${f}' and '${p}' are the same file`);
        yield d(p, f, y);
      }
    });
  }
  xt.cp = c;
  function l(p, E, B = {}) {
    return n(this, void 0, void 0, function* () {
      if (yield o.exists(E)) {
        let y = !0;
        if ((yield o.isDirectory(E)) && (E = i.join(E, i.basename(p)), y = yield o.exists(E)), y)
          if (B.force == null || B.force)
            yield A(E);
          else
            throw new Error("Destination already exists");
      }
      yield a(i.dirname(E)), yield o.rename(p, E);
    });
  }
  xt.mv = l;
  function A(p) {
    return n(this, void 0, void 0, function* () {
      if (o.IS_WINDOWS && /[*"<>|]/.test(p))
        throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
      try {
        yield o.rm(p, {
          force: !0,
          maxRetries: 3,
          recursive: !0,
          retryDelay: 300
        });
      } catch (E) {
        throw new Error(`File was unable to be removed ${E}`);
      }
    });
  }
  xt.rmRF = A;
  function a(p) {
    return n(this, void 0, void 0, function* () {
      s.ok(p, "a path argument must be provided"), yield o.mkdir(p, { recursive: !0 });
    });
  }
  xt.mkdirP = a;
  function u(p, E) {
    return n(this, void 0, void 0, function* () {
      if (!p)
        throw new Error("parameter 'tool' is required");
      if (E) {
        const y = yield u(p, !1);
        if (!y)
          throw o.IS_WINDOWS ? new Error(`Unable to locate executable file: ${p}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`) : new Error(`Unable to locate executable file: ${p}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
        return y;
      }
      const B = yield g(p);
      return B && B.length > 0 ? B[0] : "";
    });
  }
  xt.which = u;
  function g(p) {
    return n(this, void 0, void 0, function* () {
      if (!p)
        throw new Error("parameter 'tool' is required");
      const E = [];
      if (o.IS_WINDOWS && process.env.PATHEXT)
        for (const Q of process.env.PATHEXT.split(i.delimiter))
          Q && E.push(Q);
      if (o.isRooted(p)) {
        const Q = yield o.tryGetExecutablePath(p, E);
        return Q ? [Q] : [];
      }
      if (p.includes(i.sep))
        return [];
      const B = [];
      if (process.env.PATH)
        for (const Q of process.env.PATH.split(i.delimiter))
          Q && B.push(Q);
      const y = [];
      for (const Q of B) {
        const I = yield o.tryGetExecutablePath(i.join(Q, p), E);
        I && y.push(I);
      }
      return y;
    });
  }
  xt.findInPath = g;
  function h(p) {
    const E = p.force == null ? !0 : p.force, B = !!p.recursive, y = p.copySourceDirectory == null ? !0 : !!p.copySourceDirectory;
    return { force: E, recursive: B, copySourceDirectory: y };
  }
  function m(p, E, B, y) {
    return n(this, void 0, void 0, function* () {
      if (B >= 255)
        return;
      B++, yield a(E);
      const Q = yield o.readdir(p);
      for (const I of Q) {
        const w = `${p}/${I}`, f = `${E}/${I}`;
        (yield o.lstat(w)).isDirectory() ? yield m(w, f, B, y) : yield d(w, f, y);
      }
      yield o.chmod(E, (yield o.stat(p)).mode);
    });
  }
  function d(p, E, B) {
    return n(this, void 0, void 0, function* () {
      if ((yield o.lstat(p)).isSymbolicLink()) {
        try {
          yield o.lstat(E), yield o.unlink(E);
        } catch (Q) {
          Q.code === "EPERM" && (yield o.chmod(E, "0666"), yield o.unlink(E));
        }
        const y = yield o.readlink(p);
        yield o.symlink(y, E, o.IS_WINDOWS ? "junction" : null);
      } else (!(yield o.exists(E)) || B) && (yield o.copyFile(p, E));
    });
  }
  return xt;
}
var _m;
function Jb() {
  if (_m) return dr;
  _m = 1;
  var t = dr && dr.__createBinding || (Object.create ? function(d, p, E, B) {
    B === void 0 && (B = E), Object.defineProperty(d, B, { enumerable: !0, get: function() {
      return p[E];
    } });
  } : function(d, p, E, B) {
    B === void 0 && (B = E), d[B] = p[E];
  }), e = dr && dr.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), r = dr && dr.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var p = {};
    if (d != null) for (var E in d) E !== "default" && Object.hasOwnProperty.call(d, E) && t(p, d, E);
    return e(p, d), p;
  }, n = dr && dr.__awaiter || function(d, p, E, B) {
    function y(Q) {
      return Q instanceof E ? Q : new E(function(I) {
        I(Q);
      });
    }
    return new (E || (E = Promise))(function(Q, I) {
      function w(b) {
        try {
          C(B.next(b));
        } catch (N) {
          I(N);
        }
      }
      function f(b) {
        try {
          C(B.throw(b));
        } catch (N) {
          I(N);
        }
      }
      function C(b) {
        b.done ? Q(b.value) : y(b.value).then(w, f);
      }
      C((B = B.apply(d, p || [])).next());
    });
  };
  Object.defineProperty(dr, "__esModule", { value: !0 }), dr.argStringToArray = dr.ToolRunner = void 0;
  const s = r(cn), i = r(Ts), o = r(Nf), c = r(yr), l = r(to()), A = r(Jf()), a = LQ, u = process.platform === "win32";
  class g extends i.EventEmitter {
    constructor(p, E, B) {
      if (super(), !p)
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      this.toolPath = p, this.args = E || [], this.options = B || {};
    }
    _debug(p) {
      this.options.listeners && this.options.listeners.debug && this.options.listeners.debug(p);
    }
    _getCommandString(p, E) {
      const B = this._getSpawnFileName(), y = this._getSpawnArgs(p);
      let Q = E ? "" : "[command]";
      if (u)
        if (this._isCmdFile()) {
          Q += B;
          for (const I of y)
            Q += ` ${I}`;
        } else if (p.windowsVerbatimArguments) {
          Q += `"${B}"`;
          for (const I of y)
            Q += ` ${I}`;
        } else {
          Q += this._windowsQuoteCmdArg(B);
          for (const I of y)
            Q += ` ${this._windowsQuoteCmdArg(I)}`;
        }
      else {
        Q += B;
        for (const I of y)
          Q += ` ${I}`;
      }
      return Q;
    }
    _processLineBuffer(p, E, B) {
      try {
        let y = E + p.toString(), Q = y.indexOf(s.EOL);
        for (; Q > -1; ) {
          const I = y.substring(0, Q);
          B(I), y = y.substring(Q + s.EOL.length), Q = y.indexOf(s.EOL);
        }
        return y;
      } catch (y) {
        return this._debug(`error processing line. Failed with error ${y}`), "";
      }
    }
    _getSpawnFileName() {
      return u && this._isCmdFile() ? process.env.COMSPEC || "cmd.exe" : this.toolPath;
    }
    _getSpawnArgs(p) {
      if (u && this._isCmdFile()) {
        let E = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
        for (const B of this.args)
          E += " ", E += p.windowsVerbatimArguments ? B : this._windowsQuoteCmdArg(B);
        return E += '"', [E];
      }
      return this.args;
    }
    _endsWith(p, E) {
      return p.endsWith(E);
    }
    _isCmdFile() {
      const p = this.toolPath.toUpperCase();
      return this._endsWith(p, ".CMD") || this._endsWith(p, ".BAT");
    }
    _windowsQuoteCmdArg(p) {
      if (!this._isCmdFile())
        return this._uvQuoteCmdArg(p);
      if (!p)
        return '""';
      const E = [
        " ",
        "	",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let B = !1;
      for (const I of p)
        if (E.some((w) => w === I)) {
          B = !0;
          break;
        }
      if (!B)
        return p;
      let y = '"', Q = !0;
      for (let I = p.length; I > 0; I--)
        y += p[I - 1], Q && p[I - 1] === "\\" ? y += "\\" : p[I - 1] === '"' ? (Q = !0, y += '"') : Q = !1;
      return y += '"', y.split("").reverse().join("");
    }
    _uvQuoteCmdArg(p) {
      if (!p)
        return '""';
      if (!p.includes(" ") && !p.includes("	") && !p.includes('"'))
        return p;
      if (!p.includes('"') && !p.includes("\\"))
        return `"${p}"`;
      let E = '"', B = !0;
      for (let y = p.length; y > 0; y--)
        E += p[y - 1], B && p[y - 1] === "\\" ? E += "\\" : p[y - 1] === '"' ? (B = !0, E += "\\") : B = !1;
      return E += '"', E.split("").reverse().join("");
    }
    _cloneExecOptions(p) {
      p = p || {};
      const E = {
        cwd: p.cwd || process.cwd(),
        env: p.env || process.env,
        silent: p.silent || !1,
        windowsVerbatimArguments: p.windowsVerbatimArguments || !1,
        failOnStdErr: p.failOnStdErr || !1,
        ignoreReturnCode: p.ignoreReturnCode || !1,
        delay: p.delay || 1e4
      };
      return E.outStream = p.outStream || process.stdout, E.errStream = p.errStream || process.stderr, E;
    }
    _getSpawnOptions(p, E) {
      p = p || {};
      const B = {};
      return B.cwd = p.cwd, B.env = p.env, B.windowsVerbatimArguments = p.windowsVerbatimArguments || this._isCmdFile(), p.windowsVerbatimArguments && (B.argv0 = `"${E}"`), B;
    }
    /**
     * Exec a tool.
     * Output will be streamed to the live console.
     * Returns promise with return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See ExecOptions
     * @returns   number
     */
    exec() {
      return n(this, void 0, void 0, function* () {
        return !A.isRooted(this.toolPath) && (this.toolPath.includes("/") || u && this.toolPath.includes("\\")) && (this.toolPath = c.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath)), this.toolPath = yield l.which(this.toolPath, !0), new Promise((p, E) => n(this, void 0, void 0, function* () {
          this._debug(`exec tool: ${this.toolPath}`), this._debug("arguments:");
          for (const C of this.args)
            this._debug(`   ${C}`);
          const B = this._cloneExecOptions(this.options);
          !B.silent && B.outStream && B.outStream.write(this._getCommandString(B) + s.EOL);
          const y = new m(B, this.toolPath);
          if (y.on("debug", (C) => {
            this._debug(C);
          }), this.options.cwd && !(yield A.exists(this.options.cwd)))
            return E(new Error(`The cwd: ${this.options.cwd} does not exist!`));
          const Q = this._getSpawnFileName(), I = o.spawn(Q, this._getSpawnArgs(B), this._getSpawnOptions(this.options, Q));
          let w = "";
          I.stdout && I.stdout.on("data", (C) => {
            this.options.listeners && this.options.listeners.stdout && this.options.listeners.stdout(C), !B.silent && B.outStream && B.outStream.write(C), w = this._processLineBuffer(C, w, (b) => {
              this.options.listeners && this.options.listeners.stdline && this.options.listeners.stdline(b);
            });
          });
          let f = "";
          if (I.stderr && I.stderr.on("data", (C) => {
            y.processStderr = !0, this.options.listeners && this.options.listeners.stderr && this.options.listeners.stderr(C), !B.silent && B.errStream && B.outStream && (B.failOnStdErr ? B.errStream : B.outStream).write(C), f = this._processLineBuffer(C, f, (b) => {
              this.options.listeners && this.options.listeners.errline && this.options.listeners.errline(b);
            });
          }), I.on("error", (C) => {
            y.processError = C.message, y.processExited = !0, y.processClosed = !0, y.CheckComplete();
          }), I.on("exit", (C) => {
            y.processExitCode = C, y.processExited = !0, this._debug(`Exit code ${C} received from tool '${this.toolPath}'`), y.CheckComplete();
          }), I.on("close", (C) => {
            y.processExitCode = C, y.processExited = !0, y.processClosed = !0, this._debug(`STDIO streams have closed for tool '${this.toolPath}'`), y.CheckComplete();
          }), y.on("done", (C, b) => {
            w.length > 0 && this.emit("stdline", w), f.length > 0 && this.emit("errline", f), I.removeAllListeners(), C ? E(C) : p(b);
          }), this.options.input) {
            if (!I.stdin)
              throw new Error("child process missing stdin");
            I.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  dr.ToolRunner = g;
  function h(d) {
    const p = [];
    let E = !1, B = !1, y = "";
    function Q(I) {
      B && I !== '"' && (y += "\\"), y += I, B = !1;
    }
    for (let I = 0; I < d.length; I++) {
      const w = d.charAt(I);
      if (w === '"') {
        B ? Q(w) : E = !E;
        continue;
      }
      if (w === "\\" && B) {
        Q(w);
        continue;
      }
      if (w === "\\" && E) {
        B = !0;
        continue;
      }
      if (w === " " && !E) {
        y.length > 0 && (p.push(y), y = "");
        continue;
      }
      Q(w);
    }
    return y.length > 0 && p.push(y.trim()), p;
  }
  dr.argStringToArray = h;
  class m extends i.EventEmitter {
    constructor(p, E) {
      if (super(), this.processClosed = !1, this.processError = "", this.processExitCode = 0, this.processExited = !1, this.processStderr = !1, this.delay = 1e4, this.done = !1, this.timeout = null, !E)
        throw new Error("toolPath must not be empty");
      this.options = p, this.toolPath = E, p.delay && (this.delay = p.delay);
    }
    CheckComplete() {
      this.done || (this.processClosed ? this._setResult() : this.processExited && (this.timeout = a.setTimeout(m.HandleTimeout, this.delay, this)));
    }
    _debug(p) {
      this.emit("debug", p);
    }
    _setResult() {
      let p;
      this.processExited && (this.processError ? p = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`) : this.processExitCode !== 0 && !this.options.ignoreReturnCode ? p = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`) : this.processStderr && this.options.failOnStdErr && (p = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`))), this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.done = !0, this.emit("done", p, this.processExitCode);
    }
    static HandleTimeout(p) {
      if (!p.done) {
        if (!p.processClosed && p.processExited) {
          const E = `The STDIO streams did not close within ${p.delay / 1e3} seconds of the exit event from process '${p.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          p._debug(E);
        }
        p._setResult();
      }
    }
  }
  return dr;
}
var Mm;
function ro() {
  if (Mm) return ur;
  Mm = 1;
  var t = ur && ur.__createBinding || (Object.create ? function(l, A, a, u) {
    u === void 0 && (u = a), Object.defineProperty(l, u, { enumerable: !0, get: function() {
      return A[a];
    } });
  } : function(l, A, a, u) {
    u === void 0 && (u = a), l[u] = A[a];
  }), e = ur && ur.__setModuleDefault || (Object.create ? function(l, A) {
    Object.defineProperty(l, "default", { enumerable: !0, value: A });
  } : function(l, A) {
    l.default = A;
  }), r = ur && ur.__importStar || function(l) {
    if (l && l.__esModule) return l;
    var A = {};
    if (l != null) for (var a in l) a !== "default" && Object.hasOwnProperty.call(l, a) && t(A, l, a);
    return e(A, l), A;
  }, n = ur && ur.__awaiter || function(l, A, a, u) {
    function g(h) {
      return h instanceof a ? h : new a(function(m) {
        m(h);
      });
    }
    return new (a || (a = Promise))(function(h, m) {
      function d(B) {
        try {
          E(u.next(B));
        } catch (y) {
          m(y);
        }
      }
      function p(B) {
        try {
          E(u.throw(B));
        } catch (y) {
          m(y);
        }
      }
      function E(B) {
        B.done ? h(B.value) : g(B.value).then(d, p);
      }
      E((u = u.apply(l, A || [])).next());
    });
  };
  Object.defineProperty(ur, "__esModule", { value: !0 }), ur.getExecOutput = ur.exec = void 0;
  const s = bf, i = r(Jb());
  function o(l, A, a) {
    return n(this, void 0, void 0, function* () {
      const u = i.argStringToArray(l);
      if (u.length === 0)
        throw new Error("Parameter 'commandLine' cannot be null or empty.");
      const g = u[0];
      return A = u.slice(1).concat(A || []), new i.ToolRunner(g, A, a).exec();
    });
  }
  ur.exec = o;
  function c(l, A, a) {
    var u, g;
    return n(this, void 0, void 0, function* () {
      let h = "", m = "";
      const d = new s.StringDecoder("utf8"), p = new s.StringDecoder("utf8"), E = (u = a?.listeners) === null || u === void 0 ? void 0 : u.stdout, B = (g = a?.listeners) === null || g === void 0 ? void 0 : g.stderr, y = (f) => {
        m += p.write(f), B && B(f);
      }, Q = (f) => {
        h += d.write(f), E && E(f);
      }, I = Object.assign(Object.assign({}, a?.listeners), { stdout: Q, stderr: y }), w = yield o(l, A, Object.assign(Object.assign({}, a), { listeners: I }));
      return h += d.end(), m += p.end(), {
        exitCode: w,
        stdout: h,
        stderr: m
      };
    });
  }
  return ur.getExecOutput = c, ur;
}
var Om;
function Vb() {
  return Om || (Om = 1, function(t) {
    var e = Rr && Rr.__createBinding || (Object.create ? function(g, h, m, d) {
      d === void 0 && (d = m);
      var p = Object.getOwnPropertyDescriptor(h, m);
      (!p || ("get" in p ? !h.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
        return h[m];
      } }), Object.defineProperty(g, d, p);
    } : function(g, h, m, d) {
      d === void 0 && (d = m), g[d] = h[m];
    }), r = Rr && Rr.__setModuleDefault || (Object.create ? function(g, h) {
      Object.defineProperty(g, "default", { enumerable: !0, value: h });
    } : function(g, h) {
      g.default = h;
    }), n = Rr && Rr.__importStar || function(g) {
      if (g && g.__esModule) return g;
      var h = {};
      if (g != null) for (var m in g) m !== "default" && Object.prototype.hasOwnProperty.call(g, m) && e(h, g, m);
      return r(h, g), h;
    }, s = Rr && Rr.__awaiter || function(g, h, m, d) {
      function p(E) {
        return E instanceof m ? E : new m(function(B) {
          B(E);
        });
      }
      return new (m || (m = Promise))(function(E, B) {
        function y(w) {
          try {
            I(d.next(w));
          } catch (f) {
            B(f);
          }
        }
        function Q(w) {
          try {
            I(d.throw(w));
          } catch (f) {
            B(f);
          }
        }
        function I(w) {
          w.done ? E(w.value) : p(w.value).then(y, Q);
        }
        I((d = d.apply(g, h || [])).next());
      });
    }, i = Rr && Rr.__importDefault || function(g) {
      return g && g.__esModule ? g : { default: g };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getDetails = t.isLinux = t.isMacOS = t.isWindows = t.arch = t.platform = void 0;
    const o = i(cn), c = n(ro()), l = () => s(void 0, void 0, void 0, function* () {
      const { stdout: g } = yield c.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: !0
      }), { stdout: h } = yield c.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: !0
      });
      return {
        name: h.trim(),
        version: g.trim()
      };
    }), A = () => s(void 0, void 0, void 0, function* () {
      var g, h, m, d;
      const { stdout: p } = yield c.getExecOutput("sw_vers", void 0, {
        silent: !0
      }), E = (h = (g = p.match(/ProductVersion:\s*(.+)/)) === null || g === void 0 ? void 0 : g[1]) !== null && h !== void 0 ? h : "";
      return {
        name: (d = (m = p.match(/ProductName:\s*(.+)/)) === null || m === void 0 ? void 0 : m[1]) !== null && d !== void 0 ? d : "",
        version: E
      };
    }), a = () => s(void 0, void 0, void 0, function* () {
      const { stdout: g } = yield c.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: !0
      }), [h, m] = g.trim().split(`
`);
      return {
        name: h,
        version: m
      };
    });
    t.platform = o.default.platform(), t.arch = o.default.arch(), t.isWindows = t.platform === "win32", t.isMacOS = t.platform === "darwin", t.isLinux = t.platform === "linux";
    function u() {
      return s(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield t.isWindows ? l() : t.isMacOS ? A() : a()), {
          platform: t.platform,
          arch: t.arch,
          isWindows: t.isWindows,
          isMacOS: t.isMacOS,
          isLinux: t.isLinux
        });
      });
    }
    t.getDetails = u;
  }(Rr)), Rr;
}
var Gm;
function ir() {
  return Gm || (Gm = 1, function(t) {
    var e = Jr && Jr.__createBinding || (Object.create ? function(O, _, M, $) {
      $ === void 0 && ($ = M);
      var U = Object.getOwnPropertyDescriptor(_, M);
      (!U || ("get" in U ? !_.__esModule : U.writable || U.configurable)) && (U = { enumerable: !0, get: function() {
        return _[M];
      } }), Object.defineProperty(O, $, U);
    } : function(O, _, M, $) {
      $ === void 0 && ($ = M), O[$] = _[M];
    }), r = Jr && Jr.__setModuleDefault || (Object.create ? function(O, _) {
      Object.defineProperty(O, "default", { enumerable: !0, value: _ });
    } : function(O, _) {
      O.default = _;
    }), n = Jr && Jr.__importStar || function(O) {
      if (O && O.__esModule) return O;
      var _ = {};
      if (O != null) for (var M in O) M !== "default" && Object.prototype.hasOwnProperty.call(O, M) && e(_, O, M);
      return r(_, O), _;
    }, s = Jr && Jr.__awaiter || function(O, _, M, $) {
      function U(J) {
        return J instanceof M ? J : new M(function(j) {
          j(J);
        });
      }
      return new (M || (M = Promise))(function(J, j) {
        function te(q) {
          try {
            G($.next(q));
          } catch (Z) {
            j(Z);
          }
        }
        function ie(q) {
          try {
            G($.throw(q));
          } catch (Z) {
            j(Z);
          }
        }
        function G(q) {
          q.done ? J(q.value) : U(q.value).then(te, ie);
        }
        G(($ = $.apply(O, _ || [])).next());
      });
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.platform = t.toPlatformPath = t.toWin32Path = t.toPosixPath = t.markdownSummary = t.summary = t.getIDToken = t.getState = t.saveState = t.group = t.endGroup = t.startGroup = t.info = t.notice = t.warning = t.error = t.debug = t.isDebug = t.setFailed = t.setCommandEcho = t.setOutput = t.getBooleanInput = t.getMultilineInput = t.getInput = t.addPath = t.setSecret = t.exportVariable = t.ExitCode = void 0;
    const i = XQ(), o = KQ(), c = ou(), l = n(cn), A = n(yr), a = zb();
    var u;
    (function(O) {
      O[O.Success = 0] = "Success", O[O.Failure = 1] = "Failure";
    })(u || (t.ExitCode = u = {}));
    function g(O, _) {
      const M = (0, c.toCommandValue)(_);
      if (process.env[O] = M, process.env.GITHUB_ENV || "")
        return (0, o.issueFileCommand)("ENV", (0, o.prepareKeyValueMessage)(O, _));
      (0, i.issueCommand)("set-env", { name: O }, M);
    }
    t.exportVariable = g;
    function h(O) {
      (0, i.issueCommand)("add-mask", {}, O);
    }
    t.setSecret = h;
    function m(O) {
      process.env.GITHUB_PATH || "" ? (0, o.issueFileCommand)("PATH", O) : (0, i.issueCommand)("add-path", {}, O), process.env.PATH = `${O}${A.delimiter}${process.env.PATH}`;
    }
    t.addPath = m;
    function d(O, _) {
      const M = process.env[`INPUT_${O.replace(/ /g, "_").toUpperCase()}`] || "";
      if (_ && _.required && !M)
        throw new Error(`Input required and not supplied: ${O}`);
      return _ && _.trimWhitespace === !1 ? M : M.trim();
    }
    t.getInput = d;
    function p(O, _) {
      const M = d(O, _).split(`
`).filter(($) => $ !== "");
      return _ && _.trimWhitespace === !1 ? M : M.map(($) => $.trim());
    }
    t.getMultilineInput = p;
    function E(O, _) {
      const M = ["true", "True", "TRUE"], $ = ["false", "False", "FALSE"], U = d(O, _);
      if (M.includes(U))
        return !0;
      if ($.includes(U))
        return !1;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${O}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    t.getBooleanInput = E;
    function B(O, _) {
      if (process.env.GITHUB_OUTPUT || "")
        return (0, o.issueFileCommand)("OUTPUT", (0, o.prepareKeyValueMessage)(O, _));
      process.stdout.write(l.EOL), (0, i.issueCommand)("set-output", { name: O }, (0, c.toCommandValue)(_));
    }
    t.setOutput = B;
    function y(O) {
      (0, i.issue)("echo", O ? "on" : "off");
    }
    t.setCommandEcho = y;
    function Q(O) {
      process.exitCode = u.Failure, f(O);
    }
    t.setFailed = Q;
    function I() {
      return process.env.RUNNER_DEBUG === "1";
    }
    t.isDebug = I;
    function w(O) {
      (0, i.issueCommand)("debug", {}, O);
    }
    t.debug = w;
    function f(O, _ = {}) {
      (0, i.issueCommand)("error", (0, c.toCommandProperties)(_), O instanceof Error ? O.toString() : O);
    }
    t.error = f;
    function C(O, _ = {}) {
      (0, i.issueCommand)("warning", (0, c.toCommandProperties)(_), O instanceof Error ? O.toString() : O);
    }
    t.warning = C;
    function b(O, _ = {}) {
      (0, i.issueCommand)("notice", (0, c.toCommandProperties)(_), O instanceof Error ? O.toString() : O);
    }
    t.notice = b;
    function N(O) {
      process.stdout.write(O + l.EOL);
    }
    t.info = N;
    function v(O) {
      (0, i.issue)("group", O);
    }
    t.startGroup = v;
    function R() {
      (0, i.issue)("endgroup");
    }
    t.endGroup = R;
    function x(O, _) {
      return s(this, void 0, void 0, function* () {
        v(O);
        let M;
        try {
          M = yield _();
        } finally {
          R();
        }
        return M;
      });
    }
    t.group = x;
    function S(O, _) {
      if (process.env.GITHUB_STATE || "")
        return (0, o.issueFileCommand)("STATE", (0, o.prepareKeyValueMessage)(O, _));
      (0, i.issueCommand)("save-state", { name: O }, (0, c.toCommandValue)(_));
    }
    t.saveState = S;
    function D(O) {
      return process.env[`STATE_${O}`] || "";
    }
    t.getState = D;
    function T(O) {
      return s(this, void 0, void 0, function* () {
        return yield a.OidcClient.getIDToken(O);
      });
    }
    t.getIDToken = T;
    var k = Fm();
    Object.defineProperty(t, "summary", { enumerable: !0, get: function() {
      return k.summary;
    } });
    var L = Fm();
    Object.defineProperty(t, "markdownSummary", { enumerable: !0, get: function() {
      return L.markdownSummary;
    } });
    var W = Yb();
    Object.defineProperty(t, "toPosixPath", { enumerable: !0, get: function() {
      return W.toPosixPath;
    } }), Object.defineProperty(t, "toWin32Path", { enumerable: !0, get: function() {
      return W.toWin32Path;
    } }), Object.defineProperty(t, "toPlatformPath", { enumerable: !0, get: function() {
      return W.toPlatformPath;
    } }), t.platform = n(Vb());
  }(Jr)), Jr;
}
var mt = ir(), Vf = ro(), Sr = {}, fi = {}, qm;
function Wf() {
  if (qm) return fi;
  qm = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.Context = void 0;
  const t = Zr, e = cn;
  class r {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
      var s, i, o;
      if (this.payload = {}, process.env.GITHUB_EVENT_PATH)
        if ((0, t.existsSync)(process.env.GITHUB_EVENT_PATH))
          this.payload = JSON.parse((0, t.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
        else {
          const c = process.env.GITHUB_EVENT_PATH;
          process.stdout.write(`GITHUB_EVENT_PATH ${c} does not exist${e.EOL}`);
        }
      this.eventName = process.env.GITHUB_EVENT_NAME, this.sha = process.env.GITHUB_SHA, this.ref = process.env.GITHUB_REF, this.workflow = process.env.GITHUB_WORKFLOW, this.action = process.env.GITHUB_ACTION, this.actor = process.env.GITHUB_ACTOR, this.job = process.env.GITHUB_JOB, this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10), this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10), this.runId = parseInt(process.env.GITHUB_RUN_ID, 10), this.apiUrl = (s = process.env.GITHUB_API_URL) !== null && s !== void 0 ? s : "https://api.github.com", this.serverUrl = (i = process.env.GITHUB_SERVER_URL) !== null && i !== void 0 ? i : "https://github.com", this.graphqlUrl = (o = process.env.GITHUB_GRAPHQL_URL) !== null && o !== void 0 ? o : "https://api.github.com/graphql";
    }
    get issue() {
      const s = this.payload;
      return Object.assign(Object.assign({}, this.repo), { number: (s.issue || s.pull_request || s).number });
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        const [s, i] = process.env.GITHUB_REPOSITORY.split("/");
        return { owner: s, repo: i };
      }
      if (this.payload.repository)
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  }
  return fi.Context = r, fi;
}
var mn = {}, Lt = {}, Hm;
function Wb() {
  if (Hm) return Lt;
  Hm = 1;
  var t = Lt && Lt.__createBinding || (Object.create ? function(u, g, h, m) {
    m === void 0 && (m = h);
    var d = Object.getOwnPropertyDescriptor(g, h);
    (!d || ("get" in d ? !g.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return g[h];
    } }), Object.defineProperty(u, m, d);
  } : function(u, g, h, m) {
    m === void 0 && (m = h), u[m] = g[h];
  }), e = Lt && Lt.__setModuleDefault || (Object.create ? function(u, g) {
    Object.defineProperty(u, "default", { enumerable: !0, value: g });
  } : function(u, g) {
    u.default = g;
  }), r = Lt && Lt.__importStar || function(u) {
    if (u && u.__esModule) return u;
    var g = {};
    if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && t(g, u, h);
    return e(g, u), g;
  }, n = Lt && Lt.__awaiter || function(u, g, h, m) {
    function d(p) {
      return p instanceof h ? p : new h(function(E) {
        E(p);
      });
    }
    return new (h || (h = Promise))(function(p, E) {
      function B(I) {
        try {
          Q(m.next(I));
        } catch (w) {
          E(w);
        }
      }
      function y(I) {
        try {
          Q(m.throw(I));
        } catch (w) {
          E(w);
        }
      }
      function Q(I) {
        I.done ? p(I.value) : d(I.value).then(B, y);
      }
      Q((m = m.apply(u, g || [])).next());
    });
  };
  Object.defineProperty(Lt, "__esModule", { value: !0 }), Lt.getApiBaseUrl = Lt.getProxyFetch = Lt.getProxyAgentDispatcher = Lt.getProxyAgent = Lt.getAuthString = void 0;
  const s = r(kn()), i = Yf();
  function o(u, g) {
    if (!u && !g.auth)
      throw new Error("Parameter token or opts.auth is required");
    if (u && g.auth)
      throw new Error("Parameters token and opts.auth may not both be specified");
    return typeof g.auth == "string" ? g.auth : `token ${u}`;
  }
  Lt.getAuthString = o;
  function c(u) {
    return new s.HttpClient().getAgent(u);
  }
  Lt.getProxyAgent = c;
  function l(u) {
    return new s.HttpClient().getAgentDispatcher(u);
  }
  Lt.getProxyAgentDispatcher = l;
  function A(u) {
    const g = l(u);
    return (m, d) => n(this, void 0, void 0, function* () {
      return (0, i.fetch)(m, Object.assign(Object.assign({}, d), { dispatcher: g }));
    });
  }
  Lt.getProxyFetch = A;
  function a() {
    return process.env.GITHUB_API_URL || "https://api.github.com";
  }
  return Lt.getApiBaseUrl = a, Lt;
}
function ua() {
  return typeof navigator == "object" && "userAgent" in navigator ? navigator.userAgent : typeof process == "object" && process.version !== void 0 ? `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})` : "<environment undetectable>";
}
var ds = { exports: {} }, fc, zm;
function jb() {
  if (zm) return fc;
  zm = 1, fc = t;
  function t(e, r, n, s) {
    if (typeof n != "function")
      throw new Error("method for before hook must be a function");
    return s || (s = {}), Array.isArray(r) ? r.reverse().reduce(function(i, o) {
      return t.bind(null, e, o, i, s);
    }, n)() : Promise.resolve().then(function() {
      return e.registry[r] ? e.registry[r].reduce(function(i, o) {
        return o.hook.bind(null, i, s);
      }, n)() : n(s);
    });
  }
  return fc;
}
var Ec, Ym;
function $b() {
  if (Ym) return Ec;
  Ym = 1, Ec = t;
  function t(e, r, n, s) {
    var i = s;
    e.registry[n] || (e.registry[n] = []), r === "before" && (s = function(o, c) {
      return Promise.resolve().then(i.bind(null, c)).then(o.bind(null, c));
    }), r === "after" && (s = function(o, c) {
      var l;
      return Promise.resolve().then(o.bind(null, c)).then(function(A) {
        return l = A, i(l, c);
      }).then(function() {
        return l;
      });
    }), r === "error" && (s = function(o, c) {
      return Promise.resolve().then(o.bind(null, c)).catch(function(l) {
        return i(l, c);
      });
    }), e.registry[n].push({
      hook: s,
      orig: i
    });
  }
  return Ec;
}
var Cc, Jm;
function Xb() {
  if (Jm) return Cc;
  Jm = 1, Cc = t;
  function t(e, r, n) {
    if (e.registry[r]) {
      var s = e.registry[r].map(function(i) {
        return i.orig;
      }).indexOf(n);
      s !== -1 && e.registry[r].splice(s, 1);
    }
  }
  return Cc;
}
var Vm;
function Kb() {
  if (Vm) return ds.exports;
  Vm = 1;
  var t = jb(), e = $b(), r = Xb(), n = Function.bind, s = n.bind(n);
  function i(a, u, g) {
    var h = s(r, null).apply(
      null,
      g ? [u, g] : [u]
    );
    a.api = { remove: h }, a.remove = h, ["before", "error", "after", "wrap"].forEach(function(m) {
      var d = g ? [u, m, g] : [u, m];
      a[m] = a.api[m] = s(e, null).apply(null, d);
    });
  }
  function o() {
    var a = "h", u = {
      registry: {}
    }, g = t.bind(null, u, a);
    return i(g, u, a), g;
  }
  function c() {
    var a = {
      registry: {}
    }, u = t.bind(null, a);
    return i(u, a), u;
  }
  var l = !1;
  function A() {
    return l || (console.warn(
      '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
    ), l = !0), c();
  }
  return A.Singular = o.bind(), A.Collection = c.bind(), ds.exports = A, ds.exports.Hook = A, ds.exports.Singular = A.Singular, ds.exports.Collection = A.Collection, ds.exports;
}
var Zb = Kb(), ew = "9.0.6", tw = `octokit-endpoint.js/${ew} ${ua()}`, rw = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": tw
  },
  mediaType: {
    format: ""
  }
};
function nw(t) {
  return t ? Object.keys(t).reduce((e, r) => (e[r.toLowerCase()] = t[r], e), {}) : {};
}
function sw(t) {
  if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
    return !1;
  const e = Object.getPrototypeOf(t);
  if (e === null)
    return !0;
  const r = Object.prototype.hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && Function.prototype.call(r) === Function.prototype.call(t);
}
function jf(t, e) {
  const r = Object.assign({}, t);
  return Object.keys(e).forEach((n) => {
    sw(e[n]) ? n in t ? r[n] = jf(t[n], e[n]) : Object.assign(r, { [n]: e[n] }) : Object.assign(r, { [n]: e[n] });
  }), r;
}
function Wm(t) {
  for (const e in t)
    t[e] === void 0 && delete t[e];
  return t;
}
function kl(t, e, r) {
  if (typeof e == "string") {
    let [s, i] = e.split(" ");
    r = Object.assign(i ? { method: s, url: i } : { url: s }, r);
  } else
    r = Object.assign({}, e);
  r.headers = nw(r.headers), Wm(r), Wm(r.headers);
  const n = jf(t || {}, r);
  return r.url === "/graphql" && (t && t.mediaType.previews?.length && (n.mediaType.previews = t.mediaType.previews.filter(
    (s) => !n.mediaType.previews.includes(s)
  ).concat(n.mediaType.previews)), n.mediaType.previews = (n.mediaType.previews || []).map((s) => s.replace(/-preview/, ""))), n;
}
function iw(t, e) {
  const r = /\?/.test(t) ? "&" : "?", n = Object.keys(e);
  return n.length === 0 ? t : t + r + n.map((s) => s === "q" ? "q=" + e.q.split("+").map(encodeURIComponent).join("+") : `${s}=${encodeURIComponent(e[s])}`).join("&");
}
var ow = /\{[^{}}]+\}/g;
function aw(t) {
  return t.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function Aw(t) {
  const e = t.match(ow);
  return e ? e.map(aw).reduce((r, n) => r.concat(n), []) : [];
}
function jm(t, e) {
  const r = { __proto__: null };
  for (const n of Object.keys(t))
    e.indexOf(n) === -1 && (r[n] = t[n]);
  return r;
}
function $f(t) {
  return t.split(/(%[0-9A-Fa-f]{2})/g).map(function(e) {
    return /%[0-9A-Fa-f]/.test(e) || (e = encodeURI(e).replace(/%5B/g, "[").replace(/%5D/g, "]")), e;
  }).join("");
}
function Es(t) {
  return encodeURIComponent(t).replace(/[!'()*]/g, function(e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase();
  });
}
function Ei(t, e, r) {
  return e = t === "+" || t === "#" ? $f(e) : Es(e), r ? Es(r) + "=" + e : e;
}
function gs(t) {
  return t != null;
}
function Bc(t) {
  return t === ";" || t === "&" || t === "?";
}
function cw(t, e, r, n) {
  var s = t[r], i = [];
  if (gs(s) && s !== "")
    if (typeof s == "string" || typeof s == "number" || typeof s == "boolean")
      s = s.toString(), n && n !== "*" && (s = s.substring(0, parseInt(n, 10))), i.push(
        Ei(e, s, Bc(e) ? r : "")
      );
    else if (n === "*")
      Array.isArray(s) ? s.filter(gs).forEach(function(o) {
        i.push(
          Ei(e, o, Bc(e) ? r : "")
        );
      }) : Object.keys(s).forEach(function(o) {
        gs(s[o]) && i.push(Ei(e, s[o], o));
      });
    else {
      const o = [];
      Array.isArray(s) ? s.filter(gs).forEach(function(c) {
        o.push(Ei(e, c));
      }) : Object.keys(s).forEach(function(c) {
        gs(s[c]) && (o.push(Es(c)), o.push(Ei(e, s[c].toString())));
      }), Bc(e) ? i.push(Es(r) + "=" + o.join(",")) : o.length !== 0 && i.push(o.join(","));
    }
  else
    e === ";" ? gs(s) && i.push(Es(r)) : s === "" && (e === "&" || e === "?") ? i.push(Es(r) + "=") : s === "" && i.push("");
  return i;
}
function lw(t) {
  return {
    expand: uw.bind(null, t)
  };
}
function uw(t, e) {
  var r = ["+", "#", ".", "/", ";", "?", "&"];
  return t = t.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(n, s, i) {
      if (s) {
        let c = "";
        const l = [];
        if (r.indexOf(s.charAt(0)) !== -1 && (c = s.charAt(0), s = s.substr(1)), s.split(/,/g).forEach(function(A) {
          var a = /([^:\*]*)(?::(\d+)|(\*))?/.exec(A);
          l.push(cw(e, c, a[1], a[2] || a[3]));
        }), c && c !== "+") {
          var o = ",";
          return c === "?" ? o = "&" : c !== "#" && (o = c), (l.length !== 0 ? c : "") + l.join(o);
        } else
          return l.join(",");
      } else
        return $f(i);
    }
  ), t === "/" ? t : t.replace(/\/$/, "");
}
function Xf(t) {
  let e = t.method.toUpperCase(), r = (t.url || "/").replace(/:([a-z]\w+)/g, "{$1}"), n = Object.assign({}, t.headers), s, i = jm(t, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const o = Aw(r);
  r = lw(r).expand(i), /^http/.test(r) || (r = t.baseUrl + r);
  const c = Object.keys(t).filter((a) => o.includes(a)).concat("baseUrl"), l = jm(i, c);
  if (!/application\/octet-stream/i.test(n.accept) && (t.mediaType.format && (n.accept = n.accept.split(/,/).map(
    (a) => a.replace(
      /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
      `application/vnd$1$2.${t.mediaType.format}`
    )
  ).join(",")), r.endsWith("/graphql") && t.mediaType.previews?.length)) {
    const a = n.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
    n.accept = a.concat(t.mediaType.previews).map((u) => {
      const g = t.mediaType.format ? `.${t.mediaType.format}` : "+json";
      return `application/vnd.github.${u}-preview${g}`;
    }).join(",");
  }
  return ["GET", "HEAD"].includes(e) ? r = iw(r, l) : "data" in l ? s = l.data : Object.keys(l).length && (s = l), !n["content-type"] && typeof s < "u" && (n["content-type"] = "application/json; charset=utf-8"), ["PATCH", "PUT"].includes(e) && typeof s > "u" && (s = ""), Object.assign(
    { method: e, url: r, headers: n },
    typeof s < "u" ? { body: s } : null,
    t.request ? { request: t.request } : null
  );
}
function dw(t, e, r) {
  return Xf(kl(t, e, r));
}
function Kf(t, e) {
  const r = kl(t, e), n = dw.bind(null, r);
  return Object.assign(n, {
    DEFAULTS: r,
    defaults: Kf.bind(null, r),
    merge: kl.bind(null, r),
    parse: Xf
  });
}
var gw = Kf(null, rw);
class $m extends Error {
  constructor(e) {
    super(e), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "Deprecation";
  }
}
var bo = { exports: {} }, Ic, Xm;
function mw() {
  if (Xm) return Ic;
  Xm = 1, Ic = t;
  function t(e, r) {
    if (e && r) return t(e)(r);
    if (typeof e != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(e).forEach(function(s) {
      n[s] = e[s];
    }), n;
    function n() {
      for (var s = new Array(arguments.length), i = 0; i < s.length; i++)
        s[i] = arguments[i];
      var o = e.apply(this, s), c = s[s.length - 1];
      return typeof o == "function" && o !== c && Object.keys(c).forEach(function(l) {
        o[l] = c[l];
      }), o;
    }
  }
  return Ic;
}
var Km;
function hw() {
  if (Km) return bo.exports;
  Km = 1;
  var t = mw();
  bo.exports = t(e), bo.exports.strict = t(r), e.proto = e(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return e(this);
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return r(this);
      },
      configurable: !0
    });
  });
  function e(n) {
    var s = function() {
      return s.called ? s.value : (s.called = !0, s.value = n.apply(this, arguments));
    };
    return s.called = !1, s;
  }
  function r(n) {
    var s = function() {
      if (s.called)
        throw new Error(s.onceError);
      return s.called = !0, s.value = n.apply(this, arguments);
    }, i = n.name || "Function wrapped with `once`";
    return s.onceError = i + " shouldn't be called more than once", s.called = !1, s;
  }
  return bo.exports;
}
var pw = hw();
const Zf = /* @__PURE__ */ OQ(pw);
var fw = Zf((t) => console.warn(t)), Ew = Zf((t) => console.warn(t)), Ci = class extends Error {
  constructor(t, e, r) {
    super(t), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "HttpError", this.status = e;
    let n;
    "headers" in r && typeof r.headers < "u" && (n = r.headers), "response" in r && (this.response = r.response, n = r.response.headers);
    const s = Object.assign({}, r.request);
    r.request.headers.authorization && (s.headers = Object.assign({}, r.request.headers, {
      authorization: r.request.headers.authorization.replace(
        /(?<! ) .*$/,
        " [REDACTED]"
      )
    })), s.url = s.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]"), this.request = s, Object.defineProperty(this, "code", {
      get() {
        return fw(
          new $m(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        ), e;
      }
    }), Object.defineProperty(this, "headers", {
      get() {
        return Ew(
          new $m(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        ), n || {};
      }
    });
  }
}, Cw = "8.4.1";
function Bw(t) {
  if (typeof t != "object" || t === null || Object.prototype.toString.call(t) !== "[object Object]")
    return !1;
  const e = Object.getPrototypeOf(t);
  if (e === null)
    return !0;
  const r = Object.prototype.hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && Function.prototype.call(r) === Function.prototype.call(t);
}
function Iw(t) {
  return t.arrayBuffer();
}
function Zm(t) {
  const e = t.request && t.request.log ? t.request.log : console, r = t.request?.parseSuccessResponseBody !== !1;
  (Bw(t.body) || Array.isArray(t.body)) && (t.body = JSON.stringify(t.body));
  let n = {}, s, i, { fetch: o } = globalThis;
  if (t.request?.fetch && (o = t.request.fetch), !o)
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  return o(t.url, {
    method: t.method,
    body: t.body,
    redirect: t.request?.redirect,
    headers: t.headers,
    signal: t.request?.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...t.body && { duplex: "half" }
  }).then(async (c) => {
    i = c.url, s = c.status;
    for (const l of c.headers)
      n[l[0]] = l[1];
    if ("deprecation" in n) {
      const l = n.link && n.link.match(/<([^<>]+)>; rel="deprecation"/), A = l && l.pop();
      e.warn(
        `[@octokit/request] "${t.method} ${t.url}" is deprecated. It is scheduled to be removed on ${n.sunset}${A ? `. See ${A}` : ""}`
      );
    }
    if (!(s === 204 || s === 205)) {
      if (t.method === "HEAD") {
        if (s < 400)
          return;
        throw new Ci(c.statusText, s, {
          response: {
            url: i,
            status: s,
            headers: n,
            data: void 0
          },
          request: t
        });
      }
      if (s === 304)
        throw new Ci("Not modified", s, {
          response: {
            url: i,
            status: s,
            headers: n,
            data: await yc(c)
          },
          request: t
        });
      if (s >= 400) {
        const l = await yc(c);
        throw new Ci(yw(l), s, {
          response: {
            url: i,
            status: s,
            headers: n,
            data: l
          },
          request: t
        });
      }
      return r ? await yc(c) : c.body;
    }
  }).then((c) => ({
    status: s,
    url: i,
    headers: n,
    data: c
  })).catch((c) => {
    if (c instanceof Ci)
      throw c;
    if (c.name === "AbortError")
      throw c;
    let l = c.message;
    throw c.name === "TypeError" && "cause" in c && (c.cause instanceof Error ? l = c.cause.message : typeof c.cause == "string" && (l = c.cause)), new Ci(l, 500, {
      request: t
    });
  });
}
async function yc(t) {
  const e = t.headers.get("content-type");
  return /application\/json/.test(e) ? t.json().catch(() => t.text()).catch(() => "") : !e || /^text\/|charset=utf-8$/.test(e) ? t.text() : Iw(t);
}
function yw(t) {
  if (typeof t == "string")
    return t;
  let e;
  return "documentation_url" in t ? e = ` - ${t.documentation_url}` : e = "", "message" in t ? Array.isArray(t.errors) ? `${t.message}: ${t.errors.map(JSON.stringify).join(", ")}${e}` : `${t.message}${e}` : `Unknown error: ${JSON.stringify(t)}`;
}
function Fl(t, e) {
  const r = t.defaults(e);
  return Object.assign(function(s, i) {
    const o = r.merge(s, i);
    if (!o.request || !o.request.hook)
      return Zm(r.parse(o));
    const c = (l, A) => Zm(
      r.parse(r.merge(l, A))
    );
    return Object.assign(c, {
      endpoint: r,
      defaults: Fl.bind(null, r)
    }), o.request.hook(c, o);
  }, {
    endpoint: r,
    defaults: Fl.bind(null, r)
  });
}
var Pl = Fl(gw, {
  headers: {
    "user-agent": `octokit-request.js/${Cw} ${ua()}`
  }
}), Qw = "7.1.1";
function bw(t) {
  return `Request failed due to following response errors:
` + t.errors.map((e) => ` - ${e.message}`).join(`
`);
}
var ww = class extends Error {
  constructor(t, e, r) {
    super(bw(r)), this.request = t, this.headers = e, this.response = r, this.name = "GraphqlResponseError", this.errors = r.errors, this.data = r.data, Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}, Nw = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
], Rw = ["query", "method", "url"], eh = /\/api\/v3\/?$/;
function Sw(t, e, r) {
  if (r) {
    if (typeof e == "string" && "query" in r)
      return Promise.reject(
        new Error('[@octokit/graphql] "query" cannot be used as variable name')
      );
    for (const o in r)
      if (Rw.includes(o))
        return Promise.reject(
          new Error(
            `[@octokit/graphql] "${o}" cannot be used as variable name`
          )
        );
  }
  const n = typeof e == "string" ? Object.assign({ query: e }, r) : e, s = Object.keys(
    n
  ).reduce((o, c) => Nw.includes(c) ? (o[c] = n[c], o) : (o.variables || (o.variables = {}), o.variables[c] = n[c], o), {}), i = n.baseUrl || t.endpoint.DEFAULTS.baseUrl;
  return eh.test(i) && (s.url = i.replace(eh, "/api/graphql")), t(s).then((o) => {
    if (o.data.errors) {
      const c = {};
      for (const l of Object.keys(o.headers))
        c[l] = o.headers[l];
      throw new ww(
        s,
        c,
        o.data
      );
    }
    return o.data.data;
  });
}
function Eu(t, e) {
  const r = t.defaults(e);
  return Object.assign((s, i) => Sw(r, s, i), {
    defaults: Eu.bind(null, r),
    endpoint: r.endpoint
  });
}
Eu(Pl, {
  headers: {
    "user-agent": `octokit-graphql.js/${Qw} ${ua()}`
  },
  method: "POST",
  url: "/graphql"
});
function vw(t) {
  return Eu(t, {
    method: "POST",
    url: "/graphql"
  });
}
var xw = /^v1\./, Dw = /^ghs_/, Tw = /^ghu_/;
async function kw(t) {
  const e = t.split(/\./).length === 3, r = xw.test(t) || Dw.test(t), n = Tw.test(t);
  return {
    type: "token",
    token: t,
    tokenType: e ? "app" : r ? "installation" : n ? "user-to-server" : "oauth"
  };
}
function Fw(t) {
  return t.split(/\./).length === 3 ? `bearer ${t}` : `token ${t}`;
}
async function Pw(t, e, r, n) {
  const s = e.endpoint.merge(
    r,
    n
  );
  return s.headers.authorization = Fw(t), e(s);
}
var Uw = function(e) {
  if (!e)
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  if (typeof e != "string")
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  return e = e.replace(/^(token|bearer) +/i, ""), Object.assign(kw.bind(null, e), {
    hook: Pw.bind(null, e)
  });
}, eE = "5.2.1", th = () => {
}, Lw = console.warn.bind(console), _w = console.error.bind(console), rh = `octokit-core.js/${eE} ${ua()}`, Mw = class {
  static {
    this.VERSION = eE;
  }
  static defaults(t) {
    return class extends this {
      constructor(...r) {
        const n = r[0] || {};
        if (typeof t == "function") {
          super(t(n));
          return;
        }
        super(
          Object.assign(
            {},
            t,
            n,
            n.userAgent && t.userAgent ? {
              userAgent: `${n.userAgent} ${t.userAgent}`
            } : null
          )
        );
      }
    };
  }
  static {
    this.plugins = [];
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...t) {
    const e = this.plugins;
    return class extends this {
      static {
        this.plugins = e.concat(
          t.filter((n) => !e.includes(n))
        );
      }
    };
  }
  constructor(t = {}) {
    const e = new Zb.Collection(), r = {
      baseUrl: Pl.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, t.request, {
        // @ts-ignore internal usage only, no need to type
        hook: e.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    if (r.headers["user-agent"] = t.userAgent ? `${t.userAgent} ${rh}` : rh, t.baseUrl && (r.baseUrl = t.baseUrl), t.previews && (r.mediaType.previews = t.previews), t.timeZone && (r.headers["time-zone"] = t.timeZone), this.request = Pl.defaults(r), this.graphql = vw(this.request).defaults(r), this.log = Object.assign(
      {
        debug: th,
        info: th,
        warn: Lw,
        error: _w
      },
      t.log
    ), this.hook = e, t.authStrategy) {
      const { authStrategy: s, ...i } = t, o = s(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: i
          },
          t.auth
        )
      );
      e.wrap("request", o.hook), this.auth = o;
    } else if (!t.auth)
      this.auth = async () => ({
        type: "unauthenticated"
      });
    else {
      const s = Uw(t.auth);
      e.wrap("request", s.hook), this.auth = s;
    }
    const n = this.constructor;
    for (let s = 0; s < n.plugins.length; ++s)
      Object.assign(this, n.plugins[s](this, t));
  }
};
const Ow = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Octokit: Mw
}, Symbol.toStringTag, { value: "Module" })), Gw = /* @__PURE__ */ rs(Ow);
var tE = "10.4.1", qw = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: [
      "DELETE /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
      }
    ],
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getCommitAuthors: [
      "GET /repos/{owner}/{repo}/import/authors",
      {},
      {
        deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
      }
    ],
    getImportStatus: [
      "GET /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
      }
    ],
    getLargeFiles: [
      "GET /repos/{owner}/{repo}/import/large_files",
      {},
      {
        deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
      }
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    mapCommitAuthor: [
      "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
      {},
      {
        deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
      }
    ],
    setLfsPreference: [
      "PATCH /repos/{owner}/{repo}/import/lfs",
      {},
      {
        deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
      }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: [
      "PUT /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
      }
    ],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    updateImport: [
      "PATCH /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
      }
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteCustomOrganizationRole: [
      "DELETE /orgs/{org}/organization-roles/{role_id}"
    ],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    patchCustomOrganizationRole: [
      "PATCH /orgs/{org}/organization-roles/{role_id}"
    ],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
}, Hw = qw, Xn = /* @__PURE__ */ new Map();
for (const [t, e] of Object.entries(Hw))
  for (const [r, n] of Object.entries(e)) {
    const [s, i, o] = n, [c, l] = s.split(/ /), A = Object.assign(
      {
        method: c,
        url: l
      },
      i
    );
    Xn.has(t) || Xn.set(t, /* @__PURE__ */ new Map()), Xn.get(t).set(r, {
      scope: t,
      methodName: r,
      endpointDefaults: A,
      decorations: o
    });
  }
var zw = {
  has({ scope: t }, e) {
    return Xn.get(t).has(e);
  },
  getOwnPropertyDescriptor(t, e) {
    return {
      value: this.get(t, e),
      // ensures method is in the cache
      configurable: !0,
      writable: !0,
      enumerable: !0
    };
  },
  defineProperty(t, e, r) {
    return Object.defineProperty(t.cache, e, r), !0;
  },
  deleteProperty(t, e) {
    return delete t.cache[e], !0;
  },
  ownKeys({ scope: t }) {
    return [...Xn.get(t).keys()];
  },
  set(t, e, r) {
    return t.cache[e] = r;
  },
  get({ octokit: t, scope: e, cache: r }, n) {
    if (r[n])
      return r[n];
    const s = Xn.get(e).get(n);
    if (!s)
      return;
    const { endpointDefaults: i, decorations: o } = s;
    return o ? r[n] = Yw(
      t,
      e,
      n,
      i,
      o
    ) : r[n] = t.request.defaults(i), r[n];
  }
};
function rE(t) {
  const e = {};
  for (const r of Xn.keys())
    e[r] = new Proxy({ octokit: t, scope: r, cache: {} }, zw);
  return e;
}
function Yw(t, e, r, n, s) {
  const i = t.request.defaults(n);
  function o(...c) {
    let l = i.endpoint.merge(...c);
    if (s.mapToData)
      return l = Object.assign({}, l, {
        data: l[s.mapToData],
        [s.mapToData]: void 0
      }), i(l);
    if (s.renamed) {
      const [A, a] = s.renamed;
      t.log.warn(
        `octokit.${e}.${r}() has been renamed to octokit.${A}.${a}()`
      );
    }
    if (s.deprecated && t.log.warn(s.deprecated), s.renamedParameters) {
      const A = i.endpoint.merge(...c);
      for (const [a, u] of Object.entries(
        s.renamedParameters
      ))
        a in A && (t.log.warn(
          `"${a}" parameter is deprecated for "octokit.${e}.${r}()". Use "${u}" instead`
        ), u in A || (A[u] = A[a]), delete A[a]);
      return i(A);
    }
    return i(...c);
  }
  return Object.assign(o, i);
}
function nE(t) {
  return {
    rest: rE(t)
  };
}
nE.VERSION = tE;
function sE(t) {
  const e = rE(t);
  return {
    ...e,
    rest: e
  };
}
sE.VERSION = tE;
const Jw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  legacyRestEndpointMethods: sE,
  restEndpointMethods: nE
}, Symbol.toStringTag, { value: "Module" })), Vw = /* @__PURE__ */ rs(Jw);
var Ww = "9.2.2";
function jw(t) {
  if (!t.data)
    return {
      ...t,
      data: []
    };
  if (!("total_count" in t.data && !("url" in t.data)))
    return t;
  const r = t.data.incomplete_results, n = t.data.repository_selection, s = t.data.total_count;
  delete t.data.incomplete_results, delete t.data.repository_selection, delete t.data.total_count;
  const i = Object.keys(t.data)[0], o = t.data[i];
  return t.data = o, typeof r < "u" && (t.data.incomplete_results = r), typeof n < "u" && (t.data.repository_selection = n), t.data.total_count = s, t;
}
function Cu(t, e, r) {
  const n = typeof e == "function" ? e.endpoint(r) : t.request.endpoint(e, r), s = typeof e == "function" ? e : t.request, i = n.method, o = n.headers;
  let c = n.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!c)
          return { done: !0 };
        try {
          const l = await s({ method: i, url: c, headers: o }), A = jw(l);
          return c = ((A.headers.link || "").match(
            /<([^<>]+)>;\s*rel="next"/
          ) || [])[1], { value: A };
        } catch (l) {
          if (l.status !== 409)
            throw l;
          return c = "", {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function iE(t, e, r, n) {
  return typeof r == "function" && (n = r, r = void 0), oE(
    t,
    [],
    Cu(t, e, r)[Symbol.asyncIterator](),
    n
  );
}
function oE(t, e, r, n) {
  return r.next().then((s) => {
    if (s.done)
      return e;
    let i = !1;
    function o() {
      i = !0;
    }
    return e = e.concat(
      n ? n(s.value, o) : s.value.data
    ), i ? e : oE(t, e, r, n);
  });
}
var $w = Object.assign(iE, {
  iterator: Cu
}), aE = [
  "GET /advisories",
  "GET /app/hook/deliveries",
  "GET /app/installation-requests",
  "GET /app/installations",
  "GET /assignments/{assignment_id}/accepted_assignments",
  "GET /classrooms",
  "GET /classrooms/{classroom_id}/assignments",
  "GET /enterprises/{enterprise}/dependabot/alerts",
  "GET /enterprises/{enterprise}/secret-scanning/alerts",
  "GET /events",
  "GET /gists",
  "GET /gists/public",
  "GET /gists/starred",
  "GET /gists/{gist_id}/comments",
  "GET /gists/{gist_id}/commits",
  "GET /gists/{gist_id}/forks",
  "GET /installation/repositories",
  "GET /issues",
  "GET /licenses",
  "GET /marketplace_listing/plans",
  "GET /marketplace_listing/plans/{plan_id}/accounts",
  "GET /marketplace_listing/stubbed/plans",
  "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
  "GET /networks/{owner}/{repo}/events",
  "GET /notifications",
  "GET /organizations",
  "GET /orgs/{org}/actions/cache/usage-by-repository",
  "GET /orgs/{org}/actions/permissions/repositories",
  "GET /orgs/{org}/actions/runners",
  "GET /orgs/{org}/actions/secrets",
  "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/actions/variables",
  "GET /orgs/{org}/actions/variables/{name}/repositories",
  "GET /orgs/{org}/blocks",
  "GET /orgs/{org}/code-scanning/alerts",
  "GET /orgs/{org}/codespaces",
  "GET /orgs/{org}/codespaces/secrets",
  "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/copilot/billing/seats",
  "GET /orgs/{org}/dependabot/alerts",
  "GET /orgs/{org}/dependabot/secrets",
  "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/events",
  "GET /orgs/{org}/failed_invitations",
  "GET /orgs/{org}/hooks",
  "GET /orgs/{org}/hooks/{hook_id}/deliveries",
  "GET /orgs/{org}/installations",
  "GET /orgs/{org}/invitations",
  "GET /orgs/{org}/invitations/{invitation_id}/teams",
  "GET /orgs/{org}/issues",
  "GET /orgs/{org}/members",
  "GET /orgs/{org}/members/{username}/codespaces",
  "GET /orgs/{org}/migrations",
  "GET /orgs/{org}/migrations/{migration_id}/repositories",
  "GET /orgs/{org}/organization-roles/{role_id}/teams",
  "GET /orgs/{org}/organization-roles/{role_id}/users",
  "GET /orgs/{org}/outside_collaborators",
  "GET /orgs/{org}/packages",
  "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
  "GET /orgs/{org}/personal-access-token-requests",
  "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
  "GET /orgs/{org}/personal-access-tokens",
  "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
  "GET /orgs/{org}/projects",
  "GET /orgs/{org}/properties/values",
  "GET /orgs/{org}/public_members",
  "GET /orgs/{org}/repos",
  "GET /orgs/{org}/rulesets",
  "GET /orgs/{org}/rulesets/rule-suites",
  "GET /orgs/{org}/secret-scanning/alerts",
  "GET /orgs/{org}/security-advisories",
  "GET /orgs/{org}/teams",
  "GET /orgs/{org}/teams/{team_slug}/discussions",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
  "GET /orgs/{org}/teams/{team_slug}/invitations",
  "GET /orgs/{org}/teams/{team_slug}/members",
  "GET /orgs/{org}/teams/{team_slug}/projects",
  "GET /orgs/{org}/teams/{team_slug}/repos",
  "GET /orgs/{org}/teams/{team_slug}/teams",
  "GET /projects/columns/{column_id}/cards",
  "GET /projects/{project_id}/collaborators",
  "GET /projects/{project_id}/columns",
  "GET /repos/{owner}/{repo}/actions/artifacts",
  "GET /repos/{owner}/{repo}/actions/caches",
  "GET /repos/{owner}/{repo}/actions/organization-secrets",
  "GET /repos/{owner}/{repo}/actions/organization-variables",
  "GET /repos/{owner}/{repo}/actions/runners",
  "GET /repos/{owner}/{repo}/actions/runs",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
  "GET /repos/{owner}/{repo}/actions/secrets",
  "GET /repos/{owner}/{repo}/actions/variables",
  "GET /repos/{owner}/{repo}/actions/workflows",
  "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
  "GET /repos/{owner}/{repo}/activity",
  "GET /repos/{owner}/{repo}/assignees",
  "GET /repos/{owner}/{repo}/branches",
  "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
  "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
  "GET /repos/{owner}/{repo}/code-scanning/alerts",
  "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
  "GET /repos/{owner}/{repo}/code-scanning/analyses",
  "GET /repos/{owner}/{repo}/codespaces",
  "GET /repos/{owner}/{repo}/codespaces/devcontainers",
  "GET /repos/{owner}/{repo}/codespaces/secrets",
  "GET /repos/{owner}/{repo}/collaborators",
  "GET /repos/{owner}/{repo}/comments",
  "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/commits",
  "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
  "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
  "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
  "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
  "GET /repos/{owner}/{repo}/commits/{ref}/status",
  "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
  "GET /repos/{owner}/{repo}/contributors",
  "GET /repos/{owner}/{repo}/dependabot/alerts",
  "GET /repos/{owner}/{repo}/dependabot/secrets",
  "GET /repos/{owner}/{repo}/deployments",
  "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
  "GET /repos/{owner}/{repo}/environments",
  "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
  "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
  "GET /repos/{owner}/{repo}/events",
  "GET /repos/{owner}/{repo}/forks",
  "GET /repos/{owner}/{repo}/hooks",
  "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
  "GET /repos/{owner}/{repo}/invitations",
  "GET /repos/{owner}/{repo}/issues",
  "GET /repos/{owner}/{repo}/issues/comments",
  "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/issues/events",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
  "GET /repos/{owner}/{repo}/keys",
  "GET /repos/{owner}/{repo}/labels",
  "GET /repos/{owner}/{repo}/milestones",
  "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
  "GET /repos/{owner}/{repo}/notifications",
  "GET /repos/{owner}/{repo}/pages/builds",
  "GET /repos/{owner}/{repo}/projects",
  "GET /repos/{owner}/{repo}/pulls",
  "GET /repos/{owner}/{repo}/pulls/comments",
  "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
  "GET /repos/{owner}/{repo}/releases",
  "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
  "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
  "GET /repos/{owner}/{repo}/rules/branches/{branch}",
  "GET /repos/{owner}/{repo}/rulesets",
  "GET /repos/{owner}/{repo}/rulesets/rule-suites",
  "GET /repos/{owner}/{repo}/secret-scanning/alerts",
  "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
  "GET /repos/{owner}/{repo}/security-advisories",
  "GET /repos/{owner}/{repo}/stargazers",
  "GET /repos/{owner}/{repo}/subscribers",
  "GET /repos/{owner}/{repo}/tags",
  "GET /repos/{owner}/{repo}/teams",
  "GET /repos/{owner}/{repo}/topics",
  "GET /repositories",
  "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
  "GET /repositories/{repository_id}/environments/{environment_name}/variables",
  "GET /search/code",
  "GET /search/commits",
  "GET /search/issues",
  "GET /search/labels",
  "GET /search/repositories",
  "GET /search/topics",
  "GET /search/users",
  "GET /teams/{team_id}/discussions",
  "GET /teams/{team_id}/discussions/{discussion_number}/comments",
  "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
  "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
  "GET /teams/{team_id}/invitations",
  "GET /teams/{team_id}/members",
  "GET /teams/{team_id}/projects",
  "GET /teams/{team_id}/repos",
  "GET /teams/{team_id}/teams",
  "GET /user/blocks",
  "GET /user/codespaces",
  "GET /user/codespaces/secrets",
  "GET /user/emails",
  "GET /user/followers",
  "GET /user/following",
  "GET /user/gpg_keys",
  "GET /user/installations",
  "GET /user/installations/{installation_id}/repositories",
  "GET /user/issues",
  "GET /user/keys",
  "GET /user/marketplace_purchases",
  "GET /user/marketplace_purchases/stubbed",
  "GET /user/memberships/orgs",
  "GET /user/migrations",
  "GET /user/migrations/{migration_id}/repositories",
  "GET /user/orgs",
  "GET /user/packages",
  "GET /user/packages/{package_type}/{package_name}/versions",
  "GET /user/public_emails",
  "GET /user/repos",
  "GET /user/repository_invitations",
  "GET /user/social_accounts",
  "GET /user/ssh_signing_keys",
  "GET /user/starred",
  "GET /user/subscriptions",
  "GET /user/teams",
  "GET /users",
  "GET /users/{username}/events",
  "GET /users/{username}/events/orgs/{org}",
  "GET /users/{username}/events/public",
  "GET /users/{username}/followers",
  "GET /users/{username}/following",
  "GET /users/{username}/gists",
  "GET /users/{username}/gpg_keys",
  "GET /users/{username}/keys",
  "GET /users/{username}/orgs",
  "GET /users/{username}/packages",
  "GET /users/{username}/projects",
  "GET /users/{username}/received_events",
  "GET /users/{username}/received_events/public",
  "GET /users/{username}/repos",
  "GET /users/{username}/social_accounts",
  "GET /users/{username}/ssh_signing_keys",
  "GET /users/{username}/starred",
  "GET /users/{username}/subscriptions"
];
function Xw(t) {
  return typeof t == "string" ? aE.includes(t) : !1;
}
function AE(t) {
  return {
    paginate: Object.assign(iE.bind(null, t), {
      iterator: Cu.bind(null, t)
    })
  };
}
AE.VERSION = Ww;
const Kw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  composePaginateRest: $w,
  isPaginatingEndpoint: Xw,
  paginateRest: AE,
  paginatingEndpoints: aE
}, Symbol.toStringTag, { value: "Module" })), Zw = /* @__PURE__ */ rs(Kw);
var nh;
function eN() {
  return nh || (nh = 1, function(t) {
    var e = mn && mn.__createBinding || (Object.create ? function(u, g, h, m) {
      m === void 0 && (m = h);
      var d = Object.getOwnPropertyDescriptor(g, h);
      (!d || ("get" in d ? !g.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return g[h];
      } }), Object.defineProperty(u, m, d);
    } : function(u, g, h, m) {
      m === void 0 && (m = h), u[m] = g[h];
    }), r = mn && mn.__setModuleDefault || (Object.create ? function(u, g) {
      Object.defineProperty(u, "default", { enumerable: !0, value: g });
    } : function(u, g) {
      u.default = g;
    }), n = mn && mn.__importStar || function(u) {
      if (u && u.__esModule) return u;
      var g = {};
      if (u != null) for (var h in u) h !== "default" && Object.prototype.hasOwnProperty.call(u, h) && e(g, u, h);
      return r(g, u), g;
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.getOctokitOptions = t.GitHub = t.defaults = t.context = void 0;
    const s = n(Wf()), i = n(Wb()), o = Gw, c = Vw, l = Zw;
    t.context = new s.Context();
    const A = i.getApiBaseUrl();
    t.defaults = {
      baseUrl: A,
      request: {
        agent: i.getProxyAgent(A),
        fetch: i.getProxyFetch(A)
      }
    }, t.GitHub = o.Octokit.plugin(c.restEndpointMethods, l.paginateRest).defaults(t.defaults);
    function a(u, g) {
      const h = Object.assign({}, g || {}), m = i.getAuthString(u, h);
      return m && (h.auth = m), h;
    }
    t.getOctokitOptions = a;
  }(mn)), mn;
}
var sh;
function tN() {
  if (sh) return Sr;
  sh = 1;
  var t = Sr && Sr.__createBinding || (Object.create ? function(o, c, l, A) {
    A === void 0 && (A = l);
    var a = Object.getOwnPropertyDescriptor(c, l);
    (!a || ("get" in a ? !c.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return c[l];
    } }), Object.defineProperty(o, A, a);
  } : function(o, c, l, A) {
    A === void 0 && (A = l), o[A] = c[l];
  }), e = Sr && Sr.__setModuleDefault || (Object.create ? function(o, c) {
    Object.defineProperty(o, "default", { enumerable: !0, value: c });
  } : function(o, c) {
    o.default = c;
  }), r = Sr && Sr.__importStar || function(o) {
    if (o && o.__esModule) return o;
    var c = {};
    if (o != null) for (var l in o) l !== "default" && Object.prototype.hasOwnProperty.call(o, l) && t(c, o, l);
    return e(c, o), c;
  };
  Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.getOctokit = Sr.context = void 0;
  const n = r(Wf()), s = eN();
  Sr.context = new n.Context();
  function i(o, c, ...l) {
    const A = s.GitHub.plugin(...l);
    return new A((0, s.getOctokitOptions)(o, c));
  }
  return Sr.getOctokit = i, Sr;
}
tN();
var rN = Object.defineProperty, nN = (t, e, r) => e in t ? rN(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, sN = (t, e, r) => nN(t, e + "", r);
class cE {
  constructor(e) {
    sN(this, "path"), this.path = e;
  }
  call(e, r) {
    return Vf.exec(this.path, e, r);
  }
}
var _t = {}, tt = {}, Yn = {}, Ht = {}, jr = {}, ih;
function iN() {
  if (ih) return jr;
  ih = 1;
  var t = jr && jr.__createBinding || (Object.create ? function(i, o, c, l) {
    l === void 0 && (l = c), Object.defineProperty(i, l, { enumerable: !0, get: function() {
      return o[c];
    } });
  } : function(i, o, c, l) {
    l === void 0 && (l = c), i[l] = o[c];
  }), e = jr && jr.__setModuleDefault || (Object.create ? function(i, o) {
    Object.defineProperty(i, "default", { enumerable: !0, value: o });
  } : function(i, o) {
    i.default = o;
  }), r = jr && jr.__importStar || function(i) {
    if (i && i.__esModule) return i;
    var o = {};
    if (i != null) for (var c in i) c !== "default" && Object.hasOwnProperty.call(i, c) && t(o, i, c);
    return e(o, i), o;
  };
  Object.defineProperty(jr, "__esModule", { value: !0 }), jr.getOptions = void 0;
  const n = r(ir());
  function s(i) {
    const o = {
      followSymbolicLinks: !0,
      implicitDescendants: !0,
      omitBrokenSymbolicLinks: !0
    };
    return i && (typeof i.followSymbolicLinks == "boolean" && (o.followSymbolicLinks = i.followSymbolicLinks, n.debug(`followSymbolicLinks '${o.followSymbolicLinks}'`)), typeof i.implicitDescendants == "boolean" && (o.implicitDescendants = i.implicitDescendants, n.debug(`implicitDescendants '${o.implicitDescendants}'`)), typeof i.omitBrokenSymbolicLinks == "boolean" && (o.omitBrokenSymbolicLinks = i.omitBrokenSymbolicLinks, n.debug(`omitBrokenSymbolicLinks '${o.omitBrokenSymbolicLinks}'`))), o;
  }
  return jr.getOptions = s, jr;
}
var gr = {}, Dt = {}, oh;
function Bu() {
  if (oh) return Dt;
  oh = 1;
  var t = Dt && Dt.__createBinding || (Object.create ? function(h, m, d, p) {
    p === void 0 && (p = d), Object.defineProperty(h, p, { enumerable: !0, get: function() {
      return m[d];
    } });
  } : function(h, m, d, p) {
    p === void 0 && (p = d), h[p] = m[d];
  }), e = Dt && Dt.__setModuleDefault || (Object.create ? function(h, m) {
    Object.defineProperty(h, "default", { enumerable: !0, value: m });
  } : function(h, m) {
    h.default = m;
  }), r = Dt && Dt.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var m = {};
    if (h != null) for (var d in h) d !== "default" && Object.hasOwnProperty.call(h, d) && t(m, h, d);
    return e(m, h), m;
  }, n = Dt && Dt.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.safeTrimTrailingSeparator = Dt.normalizeSeparators = Dt.hasRoot = Dt.hasAbsoluteRoot = Dt.ensureAbsoluteRoot = Dt.dirname = void 0;
  const s = r(yr), i = n(bt), o = process.platform === "win32";
  function c(h) {
    if (h = g(h), o && /^\\\\[^\\]+(\\[^\\]+)?$/.test(h))
      return h;
    let m = s.dirname(h);
    return o && /^\\\\[^\\]+\\[^\\]+\\$/.test(m) && (m = g(m)), m;
  }
  Dt.dirname = c;
  function l(h, m) {
    if (i.default(h, "ensureAbsoluteRoot parameter 'root' must not be empty"), i.default(m, "ensureAbsoluteRoot parameter 'itemPath' must not be empty"), A(m))
      return m;
    if (o) {
      if (m.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let d = process.cwd();
        return i.default(d.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${d}'`), m[0].toUpperCase() === d[0].toUpperCase() ? m.length === 2 ? `${m[0]}:\\${d.substr(3)}` : (d.endsWith("\\") || (d += "\\"), `${m[0]}:\\${d.substr(3)}${m.substr(2)}`) : `${m[0]}:\\${m.substr(2)}`;
      } else if (u(m).match(/^\\$|^\\[^\\]/)) {
        const d = process.cwd();
        return i.default(d.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${d}'`), `${d[0]}:\\${m.substr(1)}`;
      }
    }
    return i.default(A(h), "ensureAbsoluteRoot parameter 'root' must have an absolute root"), h.endsWith("/") || o && h.endsWith("\\") || (h += s.sep), h + m;
  }
  Dt.ensureAbsoluteRoot = l;
  function A(h) {
    return i.default(h, "hasAbsoluteRoot parameter 'itemPath' must not be empty"), h = u(h), o ? h.startsWith("\\\\") || /^[A-Z]:\\/i.test(h) : h.startsWith("/");
  }
  Dt.hasAbsoluteRoot = A;
  function a(h) {
    return i.default(h, "isRooted parameter 'itemPath' must not be empty"), h = u(h), o ? h.startsWith("\\") || /^[A-Z]:/i.test(h) : h.startsWith("/");
  }
  Dt.hasRoot = a;
  function u(h) {
    return h = h || "", o ? (h = h.replace(/\//g, "\\"), (/^\\\\+[^\\]/.test(h) ? "\\" : "") + h.replace(/\\\\+/g, "\\")) : h.replace(/\/\/+/g, "/");
  }
  Dt.normalizeSeparators = u;
  function g(h) {
    return h ? (h = u(h), !h.endsWith(s.sep) || h === s.sep || o && /^[A-Z]:\\$/i.test(h) ? h : h.substr(0, h.length - 1)) : "";
  }
  return Dt.safeTrimTrailingSeparator = g, Dt;
}
var Qc = {}, ah;
function Iu() {
  return ah || (ah = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MatchKind = void 0, function(e) {
      e[e.None = 0] = "None", e[e.Directory = 1] = "Directory", e[e.File = 2] = "File", e[e.All = 3] = "All";
    }(t.MatchKind || (t.MatchKind = {}));
  }(Qc)), Qc;
}
var Ah;
function oN() {
  if (Ah) return gr;
  Ah = 1;
  var t = gr && gr.__createBinding || (Object.create ? function(A, a, u, g) {
    g === void 0 && (g = u), Object.defineProperty(A, g, { enumerable: !0, get: function() {
      return a[u];
    } });
  } : function(A, a, u, g) {
    g === void 0 && (g = u), A[g] = a[u];
  }), e = gr && gr.__setModuleDefault || (Object.create ? function(A, a) {
    Object.defineProperty(A, "default", { enumerable: !0, value: a });
  } : function(A, a) {
    A.default = a;
  }), r = gr && gr.__importStar || function(A) {
    if (A && A.__esModule) return A;
    var a = {};
    if (A != null) for (var u in A) u !== "default" && Object.hasOwnProperty.call(A, u) && t(a, A, u);
    return e(a, A), a;
  };
  Object.defineProperty(gr, "__esModule", { value: !0 }), gr.partialMatch = gr.match = gr.getSearchPaths = void 0;
  const n = r(Bu()), s = Iu(), i = process.platform === "win32";
  function o(A) {
    A = A.filter((g) => !g.negate);
    const a = {};
    for (const g of A) {
      const h = i ? g.searchPath.toUpperCase() : g.searchPath;
      a[h] = "candidate";
    }
    const u = [];
    for (const g of A) {
      const h = i ? g.searchPath.toUpperCase() : g.searchPath;
      if (a[h] === "included")
        continue;
      let m = !1, d = h, p = n.dirname(d);
      for (; p !== d; ) {
        if (a[p]) {
          m = !0;
          break;
        }
        d = p, p = n.dirname(d);
      }
      m || (u.push(g.searchPath), a[h] = "included");
    }
    return u;
  }
  gr.getSearchPaths = o;
  function c(A, a) {
    let u = s.MatchKind.None;
    for (const g of A)
      g.negate ? u &= ~g.match(a) : u |= g.match(a);
    return u;
  }
  gr.match = c;
  function l(A, a) {
    return A.some((u) => !u.negate && u.partialMatch(a));
  }
  return gr.partialMatch = l, gr;
}
var vr = {}, bc, ch;
function aN() {
  if (ch) return bc;
  ch = 1, bc = function(e, r) {
    for (var n = [], s = 0; s < e.length; s++) {
      var i = r(e[s], s);
      t(i) ? n.push.apply(n, i) : n.push(i);
    }
    return n;
  };
  var t = Array.isArray || function(e) {
    return Object.prototype.toString.call(e) === "[object Array]";
  };
  return bc;
}
var wc, lh;
function AN() {
  if (lh) return wc;
  lh = 1, wc = t;
  function t(n, s, i) {
    n instanceof RegExp && (n = e(n, i)), s instanceof RegExp && (s = e(s, i));
    var o = r(n, s, i);
    return o && {
      start: o[0],
      end: o[1],
      pre: i.slice(0, o[0]),
      body: i.slice(o[0] + n.length, o[1]),
      post: i.slice(o[1] + s.length)
    };
  }
  function e(n, s) {
    var i = s.match(n);
    return i ? i[0] : null;
  }
  t.range = r;
  function r(n, s, i) {
    var o, c, l, A, a, u = i.indexOf(n), g = i.indexOf(s, u + 1), h = u;
    if (u >= 0 && g > 0) {
      if (n === s)
        return [u, g];
      for (o = [], l = i.length; h >= 0 && !a; )
        h == u ? (o.push(h), u = i.indexOf(n, h + 1)) : o.length == 1 ? a = [o.pop(), g] : (c = o.pop(), c < l && (l = c, A = g), g = i.indexOf(s, h + 1)), h = u < g && u >= 0 ? u : g;
      o.length && (a = [l, A]);
    }
    return a;
  }
  return wc;
}
var Nc, uh;
function cN() {
  if (uh) return Nc;
  uh = 1;
  var t = aN(), e = AN();
  Nc = u;
  var r = "\0SLASH" + Math.random() + "\0", n = "\0OPEN" + Math.random() + "\0", s = "\0CLOSE" + Math.random() + "\0", i = "\0COMMA" + Math.random() + "\0", o = "\0PERIOD" + Math.random() + "\0";
  function c(E) {
    return parseInt(E, 10) == E ? parseInt(E, 10) : E.charCodeAt(0);
  }
  function l(E) {
    return E.split("\\\\").join(r).split("\\{").join(n).split("\\}").join(s).split("\\,").join(i).split("\\.").join(o);
  }
  function A(E) {
    return E.split(r).join("\\").split(n).join("{").split(s).join("}").split(i).join(",").split(o).join(".");
  }
  function a(E) {
    if (!E)
      return [""];
    var B = [], y = e("{", "}", E);
    if (!y)
      return E.split(",");
    var Q = y.pre, I = y.body, w = y.post, f = Q.split(",");
    f[f.length - 1] += "{" + I + "}";
    var C = a(w);
    return w.length && (f[f.length - 1] += C.shift(), f.push.apply(f, C)), B.push.apply(B, f), B;
  }
  function u(E) {
    return E ? (E.substr(0, 2) === "{}" && (E = "\\{\\}" + E.substr(2)), p(l(E), !0).map(A)) : [];
  }
  function g(E) {
    return "{" + E + "}";
  }
  function h(E) {
    return /^-?0\d/.test(E);
  }
  function m(E, B) {
    return E <= B;
  }
  function d(E, B) {
    return E >= B;
  }
  function p(E, B) {
    var y = [], Q = e("{", "}", E);
    if (!Q || /\$$/.test(Q.pre)) return [E];
    var I = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(Q.body), w = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(Q.body), f = I || w, C = Q.body.indexOf(",") >= 0;
    if (!f && !C)
      return Q.post.match(/,(?!,).*\}/) ? (E = Q.pre + "{" + Q.body + s + Q.post, p(E)) : [E];
    var b;
    if (f)
      b = Q.body.split(/\.\./);
    else if (b = a(Q.body), b.length === 1 && (b = p(b[0], !1).map(g), b.length === 1)) {
      var v = Q.post.length ? p(Q.post, !1) : [""];
      return v.map(function(ie) {
        return Q.pre + b[0] + ie;
      });
    }
    var N = Q.pre, v = Q.post.length ? p(Q.post, !1) : [""], R;
    if (f) {
      var x = c(b[0]), S = c(b[1]), D = Math.max(b[0].length, b[1].length), T = b.length == 3 ? Math.abs(c(b[2])) : 1, k = m, L = S < x;
      L && (T *= -1, k = d);
      var W = b.some(h);
      R = [];
      for (var O = x; k(O, S); O += T) {
        var _;
        if (w)
          _ = String.fromCharCode(O), _ === "\\" && (_ = "");
        else if (_ = String(O), W) {
          var M = D - _.length;
          if (M > 0) {
            var $ = new Array(M + 1).join("0");
            O < 0 ? _ = "-" + $ + _.slice(1) : _ = $ + _;
          }
        }
        R.push(_);
      }
    } else
      R = t(b, function(te) {
        return p(te, !1);
      });
    for (var U = 0; U < R.length; U++)
      for (var J = 0; J < v.length; J++) {
        var j = N + R[U] + v[J];
        (!B || f || j) && y.push(j);
      }
    return y;
  }
  return Nc;
}
var Rc, dh;
function lN() {
  if (dh) return Rc;
  dh = 1, Rc = h, h.Minimatch = m;
  var t = function() {
    try {
      return require("path");
    } catch {
    }
  }() || {
    sep: "/"
  };
  h.sep = t.sep;
  var e = h.GLOBSTAR = m.GLOBSTAR = {}, r = cN(), n = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, s = "[^/]", i = s + "*?", o = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", c = "(?:(?!(?:\\/|^)\\.).)*?", l = A("().*{}+?[]^$\\!");
  function A(b) {
    return b.split("").reduce(function(N, v) {
      return N[v] = !0, N;
    }, {});
  }
  var a = /\/+/;
  h.filter = u;
  function u(b, N) {
    return N = N || {}, function(v, R, x) {
      return h(v, b, N);
    };
  }
  function g(b, N) {
    N = N || {};
    var v = {};
    return Object.keys(b).forEach(function(R) {
      v[R] = b[R];
    }), Object.keys(N).forEach(function(R) {
      v[R] = N[R];
    }), v;
  }
  h.defaults = function(b) {
    if (!b || typeof b != "object" || !Object.keys(b).length)
      return h;
    var N = h, v = function(x, S, D) {
      return N(x, S, g(b, D));
    };
    return v.Minimatch = function(x, S) {
      return new N.Minimatch(x, g(b, S));
    }, v.Minimatch.defaults = function(x) {
      return N.defaults(g(b, x)).Minimatch;
    }, v.filter = function(x, S) {
      return N.filter(x, g(b, S));
    }, v.defaults = function(x) {
      return N.defaults(g(b, x));
    }, v.makeRe = function(x, S) {
      return N.makeRe(x, g(b, S));
    }, v.braceExpand = function(x, S) {
      return N.braceExpand(x, g(b, S));
    }, v.match = function(R, x, S) {
      return N.match(R, x, g(b, S));
    }, v;
  }, m.defaults = function(b) {
    return h.defaults(b).Minimatch;
  };
  function h(b, N, v) {
    return y(N), v || (v = {}), !v.nocomment && N.charAt(0) === "#" ? !1 : new m(N, v).match(b);
  }
  function m(b, N) {
    if (!(this instanceof m))
      return new m(b, N);
    y(b), N || (N = {}), b = b.trim(), !N.allowWindowsEscape && t.sep !== "/" && (b = b.split(t.sep).join("/")), this.options = N, this.set = [], this.pattern = b, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!N.partial, this.make();
  }
  m.prototype.debug = function() {
  }, m.prototype.make = d;
  function d() {
    var b = this.pattern, N = this.options;
    if (!N.nocomment && b.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!b) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var v = this.globSet = this.braceExpand();
    N.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, v), v = this.globParts = v.map(function(R) {
      return R.split(a);
    }), this.debug(this.pattern, v), v = v.map(function(R, x, S) {
      return R.map(this.parse, this);
    }, this), this.debug(this.pattern, v), v = v.filter(function(R) {
      return R.indexOf(!1) === -1;
    }), this.debug(this.pattern, v), this.set = v;
  }
  m.prototype.parseNegate = p;
  function p() {
    var b = this.pattern, N = !1, v = this.options, R = 0;
    if (!v.nonegate) {
      for (var x = 0, S = b.length; x < S && b.charAt(x) === "!"; x++)
        N = !N, R++;
      R && (this.pattern = b.substr(R)), this.negate = N;
    }
  }
  h.braceExpand = function(b, N) {
    return E(b, N);
  }, m.prototype.braceExpand = E;
  function E(b, N) {
    return N || (this instanceof m ? N = this.options : N = {}), b = typeof b > "u" ? this.pattern : b, y(b), N.nobrace || !/\{(?:(?!\{).)*\}/.test(b) ? [b] : r(b);
  }
  var B = 1024 * 64, y = function(b) {
    if (typeof b != "string")
      throw new TypeError("invalid pattern");
    if (b.length > B)
      throw new TypeError("pattern is too long");
  };
  m.prototype.parse = I;
  var Q = {};
  function I(b, N) {
    y(b);
    var v = this.options;
    if (b === "**")
      if (v.noglobstar)
        b = "*";
      else
        return e;
    if (b === "") return "";
    var R = "", x = !!v.nocase, S = !1, D = [], T = [], k, L = !1, W = -1, O = -1, _ = b.charAt(0) === "." ? "" : v.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", M = this;
    function $() {
      if (k) {
        switch (k) {
          case "*":
            R += i, x = !0;
            break;
          case "?":
            R += s, x = !0;
            break;
          default:
            R += "\\" + k;
            break;
        }
        M.debug("clearStateChar %j %j", k, R), k = !1;
      }
    }
    for (var U = 0, J = b.length, j; U < J && (j = b.charAt(U)); U++) {
      if (this.debug("%s	%s %s %j", b, U, R, j), S && l[j]) {
        R += "\\" + j, S = !1;
        continue;
      }
      switch (j) {
        /* istanbul ignore next */
        case "/":
          return !1;
        case "\\":
          $(), S = !0;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", b, U, R, j), L) {
            this.debug("  in class"), j === "!" && U === O + 1 && (j = "^"), R += j;
            continue;
          }
          M.debug("call clearStateChar %j", k), $(), k = j, v.noext && $();
          continue;
        case "(":
          if (L) {
            R += "(";
            continue;
          }
          if (!k) {
            R += "\\(";
            continue;
          }
          D.push({
            type: k,
            start: U - 1,
            reStart: R.length,
            open: n[k].open,
            close: n[k].close
          }), R += k === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", k, R), k = !1;
          continue;
        case ")":
          if (L || !D.length) {
            R += "\\)";
            continue;
          }
          $(), x = !0;
          var te = D.pop();
          R += te.close, te.type === "!" && T.push(te), te.reEnd = R.length;
          continue;
        case "|":
          if (L || !D.length || S) {
            R += "\\|", S = !1;
            continue;
          }
          $(), R += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          if ($(), L) {
            R += "\\" + j;
            continue;
          }
          L = !0, O = U, W = R.length, R += j;
          continue;
        case "]":
          if (U === O + 1 || !L) {
            R += "\\" + j, S = !1;
            continue;
          }
          var ie = b.substring(O + 1, U);
          try {
            RegExp("[" + ie + "]");
          } catch {
            var G = this.parse(ie, Q);
            R = R.substr(0, W) + "\\[" + G[0] + "\\]", x = x || G[1], L = !1;
            continue;
          }
          x = !0, L = !1, R += j;
          continue;
        default:
          $(), S ? S = !1 : l[j] && !(j === "^" && L) && (R += "\\"), R += j;
      }
    }
    for (L && (ie = b.substr(O + 1), G = this.parse(ie, Q), R = R.substr(0, W) + "\\[" + G[0], x = x || G[1]), te = D.pop(); te; te = D.pop()) {
      var q = R.slice(te.reStart + te.open.length);
      this.debug("setting tail", R, te), q = q.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(pt, Er, Ot) {
        return Ot || (Ot = "\\"), Er + Er + Ot + "|";
      }), this.debug(`tail=%j
   %s`, q, q, te, R);
      var Z = te.type === "*" ? i : te.type === "?" ? s : "\\" + te.type;
      x = !0, R = R.slice(0, te.reStart) + Z + "\\(" + q;
    }
    $(), S && (R += "\\\\");
    var se = !1;
    switch (R.charAt(0)) {
      case "[":
      case ".":
      case "(":
        se = !0;
    }
    for (var F = T.length - 1; F > -1; F--) {
      var ne = T[F], de = R.slice(0, ne.reStart), ve = R.slice(ne.reStart, ne.reEnd - 8), Ce = R.slice(ne.reEnd - 8, ne.reEnd), Qe = R.slice(ne.reEnd);
      Ce += Qe;
      var xe = de.split("(").length - 1, _e = Qe;
      for (U = 0; U < xe; U++)
        _e = _e.replace(/\)[+*?]?/, "");
      Qe = _e;
      var Et = "";
      Qe === "" && N !== Q && (Et = "$");
      var Jt = de + ve + Qe + Et + Ce;
      R = Jt;
    }
    if (R !== "" && x && (R = "(?=.)" + R), se && (R = _ + R), N === Q)
      return [R, x];
    if (!x)
      return f(b);
    var je = v.nocase ? "i" : "";
    try {
      var st = new RegExp("^" + R + "$", je);
    } catch {
      return new RegExp("$.");
    }
    return st._glob = b, st._src = R, st;
  }
  h.makeRe = function(b, N) {
    return new m(b, N || {}).makeRe();
  }, m.prototype.makeRe = w;
  function w() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    var b = this.set;
    if (!b.length)
      return this.regexp = !1, this.regexp;
    var N = this.options, v = N.noglobstar ? i : N.dot ? o : c, R = N.nocase ? "i" : "", x = b.map(function(S) {
      return S.map(function(D) {
        return D === e ? v : typeof D == "string" ? C(D) : D._src;
      }).join("\\/");
    }).join("|");
    x = "^(?:" + x + ")$", this.negate && (x = "^(?!" + x + ").*$");
    try {
      this.regexp = new RegExp(x, R);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  h.match = function(b, N, v) {
    v = v || {};
    var R = new m(N, v);
    return b = b.filter(function(x) {
      return R.match(x);
    }), R.options.nonull && !b.length && b.push(N), b;
  }, m.prototype.match = function(N, v) {
    if (typeof v > "u" && (v = this.partial), this.debug("match", N, this.pattern), this.comment) return !1;
    if (this.empty) return N === "";
    if (N === "/" && v) return !0;
    var R = this.options;
    t.sep !== "/" && (N = N.split(t.sep).join("/")), N = N.split(a), this.debug(this.pattern, "split", N);
    var x = this.set;
    this.debug(this.pattern, "set", x);
    var S, D;
    for (D = N.length - 1; D >= 0 && (S = N[D], !S); D--)
      ;
    for (D = 0; D < x.length; D++) {
      var T = x[D], k = N;
      R.matchBase && T.length === 1 && (k = [S]);
      var L = this.matchOne(k, T, v);
      if (L)
        return R.flipNegate ? !0 : !this.negate;
    }
    return R.flipNegate ? !1 : this.negate;
  }, m.prototype.matchOne = function(b, N, v) {
    var R = this.options;
    this.debug(
      "matchOne",
      { this: this, file: b, pattern: N }
    ), this.debug("matchOne", b.length, N.length);
    for (var x = 0, S = 0, D = b.length, T = N.length; x < D && S < T; x++, S++) {
      this.debug("matchOne loop");
      var k = N[S], L = b[x];
      if (this.debug(N, k, L), k === !1) return !1;
      if (k === e) {
        this.debug("GLOBSTAR", [N, k, L]);
        var W = x, O = S + 1;
        if (O === T) {
          for (this.debug("** at the end"); x < D; x++)
            if (b[x] === "." || b[x] === ".." || !R.dot && b[x].charAt(0) === ".") return !1;
          return !0;
        }
        for (; W < D; ) {
          var _ = b[W];
          if (this.debug(`
globstar while`, b, W, N, O, _), this.matchOne(b.slice(W), N.slice(O), v))
            return this.debug("globstar found match!", W, D, _), !0;
          if (_ === "." || _ === ".." || !R.dot && _.charAt(0) === ".") {
            this.debug("dot detected!", b, W, N, O);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), W++;
        }
        return !!(v && (this.debug(`
>>> no match, partial?`, b, W, N, O), W === D));
      }
      var M;
      if (typeof k == "string" ? (M = L === k, this.debug("string match", k, L, M)) : (M = L.match(k), this.debug("pattern match", k, L, M)), !M) return !1;
    }
    if (x === D && S === T)
      return !0;
    if (x === D)
      return v;
    if (S === T)
      return x === D - 1 && b[x] === "";
    throw new Error("wtf?");
  };
  function f(b) {
    return b.replace(/\\(.)/g, "$1");
  }
  function C(b) {
    return b.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return Rc;
}
var xr = {}, gh;
function uN() {
  if (gh) return xr;
  gh = 1;
  var t = xr && xr.__createBinding || (Object.create ? function(A, a, u, g) {
    g === void 0 && (g = u), Object.defineProperty(A, g, { enumerable: !0, get: function() {
      return a[u];
    } });
  } : function(A, a, u, g) {
    g === void 0 && (g = u), A[g] = a[u];
  }), e = xr && xr.__setModuleDefault || (Object.create ? function(A, a) {
    Object.defineProperty(A, "default", { enumerable: !0, value: a });
  } : function(A, a) {
    A.default = a;
  }), r = xr && xr.__importStar || function(A) {
    if (A && A.__esModule) return A;
    var a = {};
    if (A != null) for (var u in A) u !== "default" && Object.hasOwnProperty.call(A, u) && t(a, A, u);
    return e(a, A), a;
  }, n = xr && xr.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(xr, "__esModule", { value: !0 }), xr.Path = void 0;
  const s = r(yr), i = r(Bu()), o = n(bt), c = process.platform === "win32";
  class l {
    /**
     * Constructs a Path
     * @param itemPath Path or array of segments
     */
    constructor(a) {
      if (this.segments = [], typeof a == "string")
        if (o.default(a, "Parameter 'itemPath' must not be empty"), a = i.safeTrimTrailingSeparator(a), !i.hasRoot(a))
          this.segments = a.split(s.sep);
        else {
          let u = a, g = i.dirname(u);
          for (; g !== u; ) {
            const h = s.basename(u);
            this.segments.unshift(h), u = g, g = i.dirname(u);
          }
          this.segments.unshift(u);
        }
      else {
        o.default(a.length > 0, "Parameter 'itemPath' must not be an empty array");
        for (let u = 0; u < a.length; u++) {
          let g = a[u];
          o.default(g, "Parameter 'itemPath' must not contain any empty segments"), g = i.normalizeSeparators(a[u]), u === 0 && i.hasRoot(g) ? (g = i.safeTrimTrailingSeparator(g), o.default(g === i.dirname(g), "Parameter 'itemPath' root segment contains information for multiple segments"), this.segments.push(g)) : (o.default(!g.includes(s.sep), "Parameter 'itemPath' contains unexpected path separators"), this.segments.push(g));
        }
      }
    }
    /**
     * Converts the path to it's string representation
     */
    toString() {
      let a = this.segments[0], u = a.endsWith(s.sep) || c && /^[A-Z]:$/i.test(a);
      for (let g = 1; g < this.segments.length; g++)
        u ? u = !1 : a += s.sep, a += this.segments[g];
      return a;
    }
  }
  return xr.Path = l, xr;
}
var mh;
function dN() {
  if (mh) return vr;
  mh = 1;
  var t = vr && vr.__createBinding || (Object.create ? function(h, m, d, p) {
    p === void 0 && (p = d), Object.defineProperty(h, p, { enumerable: !0, get: function() {
      return m[d];
    } });
  } : function(h, m, d, p) {
    p === void 0 && (p = d), h[p] = m[d];
  }), e = vr && vr.__setModuleDefault || (Object.create ? function(h, m) {
    Object.defineProperty(h, "default", { enumerable: !0, value: m });
  } : function(h, m) {
    h.default = m;
  }), r = vr && vr.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var m = {};
    if (h != null) for (var d in h) d !== "default" && Object.hasOwnProperty.call(h, d) && t(m, h, d);
    return e(m, h), m;
  }, n = vr && vr.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(vr, "__esModule", { value: !0 }), vr.Pattern = void 0;
  const s = r(cn), i = r(yr), o = r(Bu()), c = n(bt), l = lN(), A = Iu(), a = uN(), u = process.platform === "win32";
  class g {
    constructor(m, d = !1, p, E) {
      this.negate = !1;
      let B;
      if (typeof m == "string")
        B = m.trim();
      else {
        p = p || [], c.default(p.length, "Parameter 'segments' must not empty");
        const w = g.getLiteral(p[0]);
        c.default(w && o.hasAbsoluteRoot(w), "Parameter 'segments' first element must be a root path"), B = new a.Path(p).toString().trim(), m && (B = `!${B}`);
      }
      for (; B.startsWith("!"); )
        this.negate = !this.negate, B = B.substr(1).trim();
      B = g.fixupPattern(B, E), this.segments = new a.Path(B).segments, this.trailingSeparator = o.normalizeSeparators(B).endsWith(i.sep), B = o.safeTrimTrailingSeparator(B);
      let y = !1;
      const Q = this.segments.map((w) => g.getLiteral(w)).filter((w) => !y && !(y = w === ""));
      this.searchPath = new a.Path(Q).toString(), this.rootRegExp = new RegExp(g.regExpEscape(Q[0]), u ? "i" : ""), this.isImplicitPattern = d;
      const I = {
        dot: !0,
        nobrace: !0,
        nocase: u,
        nocomment: !0,
        noext: !0,
        nonegate: !0
      };
      B = u ? B.replace(/\\/g, "/") : B, this.minimatch = new l.Minimatch(B, I);
    }
    /**
     * Matches the pattern against the specified path
     */
    match(m) {
      return this.segments[this.segments.length - 1] === "**" ? (m = o.normalizeSeparators(m), !m.endsWith(i.sep) && this.isImplicitPattern === !1 && (m = `${m}${i.sep}`)) : m = o.safeTrimTrailingSeparator(m), this.minimatch.match(m) ? this.trailingSeparator ? A.MatchKind.Directory : A.MatchKind.All : A.MatchKind.None;
    }
    /**
     * Indicates whether the pattern may match descendants of the specified path
     */
    partialMatch(m) {
      return m = o.safeTrimTrailingSeparator(m), o.dirname(m) === m ? this.rootRegExp.test(m) : this.minimatch.matchOne(m.split(u ? /\\+/ : /\/+/), this.minimatch.set[0], !0);
    }
    /**
     * Escapes glob patterns within a path
     */
    static globEscape(m) {
      return (u ? m : m.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
    }
    /**
     * Normalizes slashes and ensures absolute root
     */
    static fixupPattern(m, d) {
      c.default(m, "pattern cannot be empty");
      const p = new a.Path(m).segments.map((E) => g.getLiteral(E));
      if (c.default(p.every((E, B) => (E !== "." || B === 0) && E !== ".."), `Invalid pattern '${m}'. Relative pathing '.' and '..' is not allowed.`), c.default(!o.hasRoot(m) || p[0], `Invalid pattern '${m}'. Root segment must not contain globs.`), m = o.normalizeSeparators(m), m === "." || m.startsWith(`.${i.sep}`))
        m = g.globEscape(process.cwd()) + m.substr(1);
      else if (m === "~" || m.startsWith(`~${i.sep}`))
        d = d || s.homedir(), c.default(d, "Unable to determine HOME directory"), c.default(o.hasAbsoluteRoot(d), `Expected HOME directory to be a rooted path. Actual '${d}'`), m = g.globEscape(d) + m.substr(1);
      else if (u && (m.match(/^[A-Z]:$/i) || m.match(/^[A-Z]:[^\\]/i))) {
        let E = o.ensureAbsoluteRoot("C:\\dummy-root", m.substr(0, 2));
        m.length > 2 && !E.endsWith("\\") && (E += "\\"), m = g.globEscape(E) + m.substr(2);
      } else if (u && (m === "\\" || m.match(/^\\[^\\]/))) {
        let E = o.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        E.endsWith("\\") || (E += "\\"), m = g.globEscape(E) + m.substr(1);
      } else
        m = o.ensureAbsoluteRoot(g.globEscape(process.cwd()), m);
      return o.normalizeSeparators(m);
    }
    /**
     * Attempts to unescape a pattern segment to create a literal path segment.
     * Otherwise returns empty string.
     */
    static getLiteral(m) {
      let d = "";
      for (let p = 0; p < m.length; p++) {
        const E = m[p];
        if (E === "\\" && !u && p + 1 < m.length) {
          d += m[++p];
          continue;
        } else {
          if (E === "*" || E === "?")
            return "";
          if (E === "[" && p + 1 < m.length) {
            let B = "", y = -1;
            for (let Q = p + 1; Q < m.length; Q++) {
              const I = m[Q];
              if (I === "\\" && !u && Q + 1 < m.length) {
                B += m[++Q];
                continue;
              } else if (I === "]") {
                y = Q;
                break;
              } else
                B += I;
            }
            if (y >= 0) {
              if (B.length > 1)
                return "";
              if (B) {
                d += B, p = y;
                continue;
              }
            }
          }
        }
        d += E;
      }
      return d;
    }
    /**
     * Escapes regexp special characters
     * https://javascript.info/regexp-escaping
     */
    static regExpEscape(m) {
      return m.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  }
  return vr.Pattern = g, vr;
}
var Bi = {}, hh;
function gN() {
  if (hh) return Bi;
  hh = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.SearchState = void 0;
  class t {
    constructor(r, n) {
      this.path = r, this.level = n;
    }
  }
  return Bi.SearchState = t, Bi;
}
var ph;
function mN() {
  if (ph) return Ht;
  ph = 1;
  var t = Ht && Ht.__createBinding || (Object.create ? function(E, B, y, Q) {
    Q === void 0 && (Q = y), Object.defineProperty(E, Q, { enumerable: !0, get: function() {
      return B[y];
    } });
  } : function(E, B, y, Q) {
    Q === void 0 && (Q = y), E[Q] = B[y];
  }), e = Ht && Ht.__setModuleDefault || (Object.create ? function(E, B) {
    Object.defineProperty(E, "default", { enumerable: !0, value: B });
  } : function(E, B) {
    E.default = B;
  }), r = Ht && Ht.__importStar || function(E) {
    if (E && E.__esModule) return E;
    var B = {};
    if (E != null) for (var y in E) y !== "default" && Object.hasOwnProperty.call(E, y) && t(B, E, y);
    return e(B, E), B;
  }, n = Ht && Ht.__awaiter || function(E, B, y, Q) {
    function I(w) {
      return w instanceof y ? w : new y(function(f) {
        f(w);
      });
    }
    return new (y || (y = Promise))(function(w, f) {
      function C(v) {
        try {
          N(Q.next(v));
        } catch (R) {
          f(R);
        }
      }
      function b(v) {
        try {
          N(Q.throw(v));
        } catch (R) {
          f(R);
        }
      }
      function N(v) {
        v.done ? w(v.value) : I(v.value).then(C, b);
      }
      N((Q = Q.apply(E, B || [])).next());
    });
  }, s = Ht && Ht.__asyncValues || function(E) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var B = E[Symbol.asyncIterator], y;
    return B ? B.call(E) : (E = typeof __values == "function" ? __values(E) : E[Symbol.iterator](), y = {}, Q("next"), Q("throw"), Q("return"), y[Symbol.asyncIterator] = function() {
      return this;
    }, y);
    function Q(w) {
      y[w] = E[w] && function(f) {
        return new Promise(function(C, b) {
          f = E[w](f), I(C, b, f.done, f.value);
        });
      };
    }
    function I(w, f, C, b) {
      Promise.resolve(b).then(function(N) {
        w({ value: N, done: C });
      }, f);
    }
  }, i = Ht && Ht.__await || function(E) {
    return this instanceof i ? (this.v = E, this) : new i(E);
  }, o = Ht && Ht.__asyncGenerator || function(E, B, y) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var Q = y.apply(E, B || []), I, w = [];
    return I = {}, f("next"), f("throw"), f("return"), I[Symbol.asyncIterator] = function() {
      return this;
    }, I;
    function f(x) {
      Q[x] && (I[x] = function(S) {
        return new Promise(function(D, T) {
          w.push([x, S, D, T]) > 1 || C(x, S);
        });
      });
    }
    function C(x, S) {
      try {
        b(Q[x](S));
      } catch (D) {
        R(w[0][3], D);
      }
    }
    function b(x) {
      x.value instanceof i ? Promise.resolve(x.value.v).then(N, v) : R(w[0][2], x);
    }
    function N(x) {
      C("next", x);
    }
    function v(x) {
      C("throw", x);
    }
    function R(x, S) {
      x(S), w.shift(), w.length && C(w[0][0], w[0][1]);
    }
  };
  Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.DefaultGlobber = void 0;
  const c = r(ir()), l = r(Zr), A = r(iN()), a = r(yr), u = r(oN()), g = Iu(), h = dN(), m = gN(), d = process.platform === "win32";
  class p {
    constructor(B) {
      this.patterns = [], this.searchPaths = [], this.options = A.getOptions(B);
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var B, y;
      return n(this, void 0, void 0, function* () {
        const Q = [];
        try {
          for (var I = s(this.globGenerator()), w; w = yield I.next(), !w.done; ) {
            const f = w.value;
            Q.push(f);
          }
        } catch (f) {
          B = { error: f };
        } finally {
          try {
            w && !w.done && (y = I.return) && (yield y.call(I));
          } finally {
            if (B) throw B.error;
          }
        }
        return Q;
      });
    }
    globGenerator() {
      return o(this, arguments, function* () {
        const y = A.getOptions(this.options), Q = [];
        for (const f of this.patterns)
          Q.push(f), y.implicitDescendants && (f.trailingSeparator || f.segments[f.segments.length - 1] !== "**") && Q.push(new h.Pattern(f.negate, !0, f.segments.concat("**")));
        const I = [];
        for (const f of u.getSearchPaths(Q)) {
          c.debug(`Search path '${f}'`);
          try {
            yield i(l.promises.lstat(f));
          } catch (C) {
            if (C.code === "ENOENT")
              continue;
            throw C;
          }
          I.unshift(new m.SearchState(f, 1));
        }
        const w = [];
        for (; I.length; ) {
          const f = I.pop(), C = u.match(Q, f.path), b = !!C || u.partialMatch(Q, f.path);
          if (!C && !b)
            continue;
          const N = yield i(
            p.stat(f, y, w)
            // Broken symlink, or symlink cycle detected, or no longer exists
          );
          if (N)
            if (N.isDirectory()) {
              if (C & g.MatchKind.Directory)
                yield yield i(f.path);
              else if (!b)
                continue;
              const v = f.level + 1, R = (yield i(l.promises.readdir(f.path))).map((x) => new m.SearchState(a.join(f.path, x), v));
              I.push(...R.reverse());
            } else C & g.MatchKind.File && (yield yield i(f.path));
        }
      });
    }
    /**
     * Constructs a DefaultGlobber
     */
    static create(B, y) {
      return n(this, void 0, void 0, function* () {
        const Q = new p(y);
        d && (B = B.replace(/\r\n/g, `
`), B = B.replace(/\r/g, `
`));
        const I = B.split(`
`).map((w) => w.trim());
        for (const w of I)
          !w || w.startsWith("#") || Q.patterns.push(new h.Pattern(w));
        return Q.searchPaths.push(...u.getSearchPaths(Q.patterns)), Q;
      });
    }
    static stat(B, y, Q) {
      return n(this, void 0, void 0, function* () {
        let I;
        if (y.followSymbolicLinks)
          try {
            I = yield l.promises.stat(B.path);
          } catch (w) {
            if (w.code === "ENOENT") {
              if (y.omitBrokenSymbolicLinks) {
                c.debug(`Broken symlink '${B.path}'`);
                return;
              }
              throw new Error(`No information found for the path '${B.path}'. This may indicate a broken symbolic link.`);
            }
            throw w;
          }
        else
          I = yield l.promises.lstat(B.path);
        if (I.isDirectory() && y.followSymbolicLinks) {
          const w = yield l.promises.realpath(B.path);
          for (; Q.length >= B.level; )
            Q.pop();
          if (Q.some((f) => f === w)) {
            c.debug(`Symlink cycle detected for path '${B.path}' and realpath '${w}'`);
            return;
          }
          Q.push(w);
        }
        return I;
      });
    }
  }
  return Ht.DefaultGlobber = p, Ht;
}
var fh;
function hN() {
  if (fh) return Yn;
  fh = 1;
  var t = Yn && Yn.__awaiter || function(n, s, i, o) {
    function c(l) {
      return l instanceof i ? l : new i(function(A) {
        A(l);
      });
    }
    return new (i || (i = Promise))(function(l, A) {
      function a(h) {
        try {
          g(o.next(h));
        } catch (m) {
          A(m);
        }
      }
      function u(h) {
        try {
          g(o.throw(h));
        } catch (m) {
          A(m);
        }
      }
      function g(h) {
        h.done ? l(h.value) : c(h.value).then(a, u);
      }
      g((o = o.apply(n, s || [])).next());
    });
  };
  Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.create = void 0;
  const e = mN();
  function r(n, s) {
    return t(this, void 0, void 0, function* () {
      return yield e.DefaultGlobber.create(n, s);
    });
  }
  return Yn.create = r, Yn;
}
var wo = { exports: {} }, Eh;
function yu() {
  return Eh || (Eh = 1, function(t, e) {
    e = t.exports = f;
    var r;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? r = function() {
      var P = Array.prototype.slice.call(arguments, 0);
      P.unshift("SEMVER"), console.log.apply(console, P);
    } : r = function() {
    }, e.SEMVER_SPEC_VERSION = "2.0.0";
    var n = 256, s = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991, i = 16, o = n - 6, c = e.re = [], l = e.safeRe = [], A = e.src = [], a = e.tokens = {}, u = 0;
    function g(P) {
      a[P] = u++;
    }
    var h = "[a-zA-Z0-9-]", m = [
      ["\\s", 1],
      ["\\d", n],
      [h, o]
    ];
    function d(P) {
      for (var z = 0; z < m.length; z++) {
        var X = m[z][0], ae = m[z][1];
        P = P.split(X + "*").join(X + "{0," + ae + "}").split(X + "+").join(X + "{1," + ae + "}");
      }
      return P;
    }
    g("NUMERICIDENTIFIER"), A[a.NUMERICIDENTIFIER] = "0|[1-9]\\d*", g("NUMERICIDENTIFIERLOOSE"), A[a.NUMERICIDENTIFIERLOOSE] = "\\d+", g("NONNUMERICIDENTIFIER"), A[a.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + h + "*", g("MAINVERSION"), A[a.MAINVERSION] = "(" + A[a.NUMERICIDENTIFIER] + ")\\.(" + A[a.NUMERICIDENTIFIER] + ")\\.(" + A[a.NUMERICIDENTIFIER] + ")", g("MAINVERSIONLOOSE"), A[a.MAINVERSIONLOOSE] = "(" + A[a.NUMERICIDENTIFIERLOOSE] + ")\\.(" + A[a.NUMERICIDENTIFIERLOOSE] + ")\\.(" + A[a.NUMERICIDENTIFIERLOOSE] + ")", g("PRERELEASEIDENTIFIER"), A[a.PRERELEASEIDENTIFIER] = "(?:" + A[a.NUMERICIDENTIFIER] + "|" + A[a.NONNUMERICIDENTIFIER] + ")", g("PRERELEASEIDENTIFIERLOOSE"), A[a.PRERELEASEIDENTIFIERLOOSE] = "(?:" + A[a.NUMERICIDENTIFIERLOOSE] + "|" + A[a.NONNUMERICIDENTIFIER] + ")", g("PRERELEASE"), A[a.PRERELEASE] = "(?:-(" + A[a.PRERELEASEIDENTIFIER] + "(?:\\." + A[a.PRERELEASEIDENTIFIER] + ")*))", g("PRERELEASELOOSE"), A[a.PRERELEASELOOSE] = "(?:-?(" + A[a.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + A[a.PRERELEASEIDENTIFIERLOOSE] + ")*))", g("BUILDIDENTIFIER"), A[a.BUILDIDENTIFIER] = h + "+", g("BUILD"), A[a.BUILD] = "(?:\\+(" + A[a.BUILDIDENTIFIER] + "(?:\\." + A[a.BUILDIDENTIFIER] + ")*))", g("FULL"), g("FULLPLAIN"), A[a.FULLPLAIN] = "v?" + A[a.MAINVERSION] + A[a.PRERELEASE] + "?" + A[a.BUILD] + "?", A[a.FULL] = "^" + A[a.FULLPLAIN] + "$", g("LOOSEPLAIN"), A[a.LOOSEPLAIN] = "[v=\\s]*" + A[a.MAINVERSIONLOOSE] + A[a.PRERELEASELOOSE] + "?" + A[a.BUILD] + "?", g("LOOSE"), A[a.LOOSE] = "^" + A[a.LOOSEPLAIN] + "$", g("GTLT"), A[a.GTLT] = "((?:<|>)?=?)", g("XRANGEIDENTIFIERLOOSE"), A[a.XRANGEIDENTIFIERLOOSE] = A[a.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", g("XRANGEIDENTIFIER"), A[a.XRANGEIDENTIFIER] = A[a.NUMERICIDENTIFIER] + "|x|X|\\*", g("XRANGEPLAIN"), A[a.XRANGEPLAIN] = "[v=\\s]*(" + A[a.XRANGEIDENTIFIER] + ")(?:\\.(" + A[a.XRANGEIDENTIFIER] + ")(?:\\.(" + A[a.XRANGEIDENTIFIER] + ")(?:" + A[a.PRERELEASE] + ")?" + A[a.BUILD] + "?)?)?", g("XRANGEPLAINLOOSE"), A[a.XRANGEPLAINLOOSE] = "[v=\\s]*(" + A[a.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + A[a.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + A[a.XRANGEIDENTIFIERLOOSE] + ")(?:" + A[a.PRERELEASELOOSE] + ")?" + A[a.BUILD] + "?)?)?", g("XRANGE"), A[a.XRANGE] = "^" + A[a.GTLT] + "\\s*" + A[a.XRANGEPLAIN] + "$", g("XRANGELOOSE"), A[a.XRANGELOOSE] = "^" + A[a.GTLT] + "\\s*" + A[a.XRANGEPLAINLOOSE] + "$", g("COERCE"), A[a.COERCE] = "(^|[^\\d])(\\d{1," + i + "})(?:\\.(\\d{1," + i + "}))?(?:\\.(\\d{1," + i + "}))?(?:$|[^\\d])", g("COERCERTL"), c[a.COERCERTL] = new RegExp(A[a.COERCE], "g"), l[a.COERCERTL] = new RegExp(d(A[a.COERCE]), "g"), g("LONETILDE"), A[a.LONETILDE] = "(?:~>?)", g("TILDETRIM"), A[a.TILDETRIM] = "(\\s*)" + A[a.LONETILDE] + "\\s+", c[a.TILDETRIM] = new RegExp(A[a.TILDETRIM], "g"), l[a.TILDETRIM] = new RegExp(d(A[a.TILDETRIM]), "g");
    var p = "$1~";
    g("TILDE"), A[a.TILDE] = "^" + A[a.LONETILDE] + A[a.XRANGEPLAIN] + "$", g("TILDELOOSE"), A[a.TILDELOOSE] = "^" + A[a.LONETILDE] + A[a.XRANGEPLAINLOOSE] + "$", g("LONECARET"), A[a.LONECARET] = "(?:\\^)", g("CARETTRIM"), A[a.CARETTRIM] = "(\\s*)" + A[a.LONECARET] + "\\s+", c[a.CARETTRIM] = new RegExp(A[a.CARETTRIM], "g"), l[a.CARETTRIM] = new RegExp(d(A[a.CARETTRIM]), "g");
    var E = "$1^";
    g("CARET"), A[a.CARET] = "^" + A[a.LONECARET] + A[a.XRANGEPLAIN] + "$", g("CARETLOOSE"), A[a.CARETLOOSE] = "^" + A[a.LONECARET] + A[a.XRANGEPLAINLOOSE] + "$", g("COMPARATORLOOSE"), A[a.COMPARATORLOOSE] = "^" + A[a.GTLT] + "\\s*(" + A[a.LOOSEPLAIN] + ")$|^$", g("COMPARATOR"), A[a.COMPARATOR] = "^" + A[a.GTLT] + "\\s*(" + A[a.FULLPLAIN] + ")$|^$", g("COMPARATORTRIM"), A[a.COMPARATORTRIM] = "(\\s*)" + A[a.GTLT] + "\\s*(" + A[a.LOOSEPLAIN] + "|" + A[a.XRANGEPLAIN] + ")", c[a.COMPARATORTRIM] = new RegExp(A[a.COMPARATORTRIM], "g"), l[a.COMPARATORTRIM] = new RegExp(d(A[a.COMPARATORTRIM]), "g");
    var B = "$1$2$3";
    g("HYPHENRANGE"), A[a.HYPHENRANGE] = "^\\s*(" + A[a.XRANGEPLAIN] + ")\\s+-\\s+(" + A[a.XRANGEPLAIN] + ")\\s*$", g("HYPHENRANGELOOSE"), A[a.HYPHENRANGELOOSE] = "^\\s*(" + A[a.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + A[a.XRANGEPLAINLOOSE] + ")\\s*$", g("STAR"), A[a.STAR] = "(<|>)?=?\\s*\\*";
    for (var y = 0; y < u; y++)
      r(y, A[y]), c[y] || (c[y] = new RegExp(A[y]), l[y] = new RegExp(d(A[y])));
    e.parse = Q;
    function Q(P, z) {
      if ((!z || typeof z != "object") && (z = {
        loose: !!z,
        includePrerelease: !1
      }), P instanceof f)
        return P;
      if (typeof P != "string" || P.length > n)
        return null;
      var X = z.loose ? l[a.LOOSE] : l[a.FULL];
      if (!X.test(P))
        return null;
      try {
        return new f(P, z);
      } catch {
        return null;
      }
    }
    e.valid = I;
    function I(P, z) {
      var X = Q(P, z);
      return X ? X.version : null;
    }
    e.clean = w;
    function w(P, z) {
      var X = Q(P.trim().replace(/^[=v]+/, ""), z);
      return X ? X.version : null;
    }
    e.SemVer = f;
    function f(P, z) {
      if ((!z || typeof z != "object") && (z = {
        loose: !!z,
        includePrerelease: !1
      }), P instanceof f) {
        if (P.loose === z.loose)
          return P;
        P = P.version;
      } else if (typeof P != "string")
        throw new TypeError("Invalid Version: " + P);
      if (P.length > n)
        throw new TypeError("version is longer than " + n + " characters");
      if (!(this instanceof f))
        return new f(P, z);
      r("SemVer", P, z), this.options = z, this.loose = !!z.loose;
      var X = P.trim().match(z.loose ? l[a.LOOSE] : l[a.FULL]);
      if (!X)
        throw new TypeError("Invalid Version: " + P);
      if (this.raw = P, this.major = +X[1], this.minor = +X[2], this.patch = +X[3], this.major > s || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > s || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > s || this.patch < 0)
        throw new TypeError("Invalid patch version");
      X[4] ? this.prerelease = X[4].split(".").map(function(ae) {
        if (/^[0-9]+$/.test(ae)) {
          var ge = +ae;
          if (ge >= 0 && ge < s)
            return ge;
        }
        return ae;
      }) : this.prerelease = [], this.build = X[5] ? X[5].split(".") : [], this.format();
    }
    f.prototype.format = function() {
      return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    }, f.prototype.toString = function() {
      return this.version;
    }, f.prototype.compare = function(P) {
      return r("SemVer.compare", this.version, this.options, P), P instanceof f || (P = new f(P, this.options)), this.compareMain(P) || this.comparePre(P);
    }, f.prototype.compareMain = function(P) {
      return P instanceof f || (P = new f(P, this.options)), v(this.major, P.major) || v(this.minor, P.minor) || v(this.patch, P.patch);
    }, f.prototype.comparePre = function(P) {
      if (P instanceof f || (P = new f(P, this.options)), this.prerelease.length && !P.prerelease.length)
        return -1;
      if (!this.prerelease.length && P.prerelease.length)
        return 1;
      if (!this.prerelease.length && !P.prerelease.length)
        return 0;
      var z = 0;
      do {
        var X = this.prerelease[z], ae = P.prerelease[z];
        if (r("prerelease compare", z, X, ae), X === void 0 && ae === void 0)
          return 0;
        if (ae === void 0)
          return 1;
        if (X === void 0)
          return -1;
        if (X === ae)
          continue;
        return v(X, ae);
      } while (++z);
    }, f.prototype.compareBuild = function(P) {
      P instanceof f || (P = new f(P, this.options));
      var z = 0;
      do {
        var X = this.build[z], ae = P.build[z];
        if (r("prerelease compare", z, X, ae), X === void 0 && ae === void 0)
          return 0;
        if (ae === void 0)
          return 1;
        if (X === void 0)
          return -1;
        if (X === ae)
          continue;
        return v(X, ae);
      } while (++z);
    }, f.prototype.inc = function(P, z) {
      switch (P) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", z);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", z);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", z), this.inc("pre", z);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", z), this.inc("pre", z);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            for (var X = this.prerelease.length; --X >= 0; )
              typeof this.prerelease[X] == "number" && (this.prerelease[X]++, X = -2);
            X === -1 && this.prerelease.push(0);
          }
          z && (this.prerelease[0] === z ? isNaN(this.prerelease[1]) && (this.prerelease = [z, 0]) : this.prerelease = [z, 0]);
          break;
        default:
          throw new Error("invalid increment argument: " + P);
      }
      return this.format(), this.raw = this.version, this;
    }, e.inc = C;
    function C(P, z, X, ae) {
      typeof X == "string" && (ae = X, X = void 0);
      try {
        return new f(P, X).inc(z, ae).version;
      } catch {
        return null;
      }
    }
    e.diff = b;
    function b(P, z) {
      if (U(P, z))
        return null;
      var X = Q(P), ae = Q(z), ge = "";
      if (X.prerelease.length || ae.prerelease.length) {
        ge = "pre";
        var Ie = "prerelease";
      }
      for (var De in X)
        if ((De === "major" || De === "minor" || De === "patch") && X[De] !== ae[De])
          return ge + De;
      return Ie;
    }
    e.compareIdentifiers = v;
    var N = /^[0-9]+$/;
    function v(P, z) {
      var X = N.test(P), ae = N.test(z);
      return X && ae && (P = +P, z = +z), P === z ? 0 : X && !ae ? -1 : ae && !X ? 1 : P < z ? -1 : 1;
    }
    e.rcompareIdentifiers = R;
    function R(P, z) {
      return v(z, P);
    }
    e.major = x;
    function x(P, z) {
      return new f(P, z).major;
    }
    e.minor = S;
    function S(P, z) {
      return new f(P, z).minor;
    }
    e.patch = D;
    function D(P, z) {
      return new f(P, z).patch;
    }
    e.compare = T;
    function T(P, z, X) {
      return new f(P, X).compare(new f(z, X));
    }
    e.compareLoose = k;
    function k(P, z) {
      return T(P, z, !0);
    }
    e.compareBuild = L;
    function L(P, z, X) {
      var ae = new f(P, X), ge = new f(z, X);
      return ae.compare(ge) || ae.compareBuild(ge);
    }
    e.rcompare = W;
    function W(P, z, X) {
      return T(z, P, X);
    }
    e.sort = O;
    function O(P, z) {
      return P.sort(function(X, ae) {
        return e.compareBuild(X, ae, z);
      });
    }
    e.rsort = _;
    function _(P, z) {
      return P.sort(function(X, ae) {
        return e.compareBuild(ae, X, z);
      });
    }
    e.gt = M;
    function M(P, z, X) {
      return T(P, z, X) > 0;
    }
    e.lt = $;
    function $(P, z, X) {
      return T(P, z, X) < 0;
    }
    e.eq = U;
    function U(P, z, X) {
      return T(P, z, X) === 0;
    }
    e.neq = J;
    function J(P, z, X) {
      return T(P, z, X) !== 0;
    }
    e.gte = j;
    function j(P, z, X) {
      return T(P, z, X) >= 0;
    }
    e.lte = te;
    function te(P, z, X) {
      return T(P, z, X) <= 0;
    }
    e.cmp = ie;
    function ie(P, z, X, ae) {
      switch (z) {
        case "===":
          return typeof P == "object" && (P = P.version), typeof X == "object" && (X = X.version), P === X;
        case "!==":
          return typeof P == "object" && (P = P.version), typeof X == "object" && (X = X.version), P !== X;
        case "":
        case "=":
        case "==":
          return U(P, X, ae);
        case "!=":
          return J(P, X, ae);
        case ">":
          return M(P, X, ae);
        case ">=":
          return j(P, X, ae);
        case "<":
          return $(P, X, ae);
        case "<=":
          return te(P, X, ae);
        default:
          throw new TypeError("Invalid operator: " + z);
      }
    }
    e.Comparator = G;
    function G(P, z) {
      if ((!z || typeof z != "object") && (z = {
        loose: !!z,
        includePrerelease: !1
      }), P instanceof G) {
        if (P.loose === !!z.loose)
          return P;
        P = P.value;
      }
      if (!(this instanceof G))
        return new G(P, z);
      P = P.trim().split(/\s+/).join(" "), r("comparator", P, z), this.options = z, this.loose = !!z.loose, this.parse(P), this.semver === q ? this.value = "" : this.value = this.operator + this.semver.version, r("comp", this);
    }
    var q = {};
    G.prototype.parse = function(P) {
      var z = this.options.loose ? l[a.COMPARATORLOOSE] : l[a.COMPARATOR], X = P.match(z);
      if (!X)
        throw new TypeError("Invalid comparator: " + P);
      this.operator = X[1] !== void 0 ? X[1] : "", this.operator === "=" && (this.operator = ""), X[2] ? this.semver = new f(X[2], this.options.loose) : this.semver = q;
    }, G.prototype.toString = function() {
      return this.value;
    }, G.prototype.test = function(P) {
      if (r("Comparator.test", P, this.options.loose), this.semver === q || P === q)
        return !0;
      if (typeof P == "string")
        try {
          P = new f(P, this.options);
        } catch {
          return !1;
        }
      return ie(P, this.operator, this.semver, this.options);
    }, G.prototype.intersects = function(P, z) {
      if (!(P instanceof G))
        throw new TypeError("a Comparator is required");
      (!z || typeof z != "object") && (z = {
        loose: !!z,
        includePrerelease: !1
      });
      var X;
      if (this.operator === "")
        return this.value === "" ? !0 : (X = new Z(P.value, z), pt(this.value, X, z));
      if (P.operator === "")
        return P.value === "" ? !0 : (X = new Z(this.value, z), pt(P.semver, X, z));
      var ae = (this.operator === ">=" || this.operator === ">") && (P.operator === ">=" || P.operator === ">"), ge = (this.operator === "<=" || this.operator === "<") && (P.operator === "<=" || P.operator === "<"), Ie = this.semver.version === P.semver.version, De = (this.operator === ">=" || this.operator === "<=") && (P.operator === ">=" || P.operator === "<="), Ve = ie(this.semver, "<", P.semver, z) && (this.operator === ">=" || this.operator === ">") && (P.operator === "<=" || P.operator === "<"), Pe = ie(this.semver, ">", P.semver, z) && (this.operator === "<=" || this.operator === "<") && (P.operator === ">=" || P.operator === ">");
      return ae || ge || Ie && De || Ve || Pe;
    }, e.Range = Z;
    function Z(P, z) {
      if ((!z || typeof z != "object") && (z = {
        loose: !!z,
        includePrerelease: !1
      }), P instanceof Z)
        return P.loose === !!z.loose && P.includePrerelease === !!z.includePrerelease ? P : new Z(P.raw, z);
      if (P instanceof G)
        return new Z(P.value, z);
      if (!(this instanceof Z))
        return new Z(P, z);
      if (this.options = z, this.loose = !!z.loose, this.includePrerelease = !!z.includePrerelease, this.raw = P.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function(X) {
        return this.parseRange(X.trim());
      }, this).filter(function(X) {
        return X.length;
      }), !this.set.length)
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      this.format();
    }
    Z.prototype.format = function() {
      return this.range = this.set.map(function(P) {
        return P.join(" ").trim();
      }).join("||").trim(), this.range;
    }, Z.prototype.toString = function() {
      return this.range;
    }, Z.prototype.parseRange = function(P) {
      var z = this.options.loose, X = z ? l[a.HYPHENRANGELOOSE] : l[a.HYPHENRANGE];
      P = P.replace(X, je), r("hyphen replace", P), P = P.replace(l[a.COMPARATORTRIM], B), r("comparator trim", P, l[a.COMPARATORTRIM]), P = P.replace(l[a.TILDETRIM], p), P = P.replace(l[a.CARETTRIM], E), P = P.split(/\s+/).join(" ");
      var ae = z ? l[a.COMPARATORLOOSE] : l[a.COMPARATOR], ge = P.split(" ").map(function(Ie) {
        return ne(Ie, this.options);
      }, this).join(" ").split(/\s+/);
      return this.options.loose && (ge = ge.filter(function(Ie) {
        return !!Ie.match(ae);
      })), ge = ge.map(function(Ie) {
        return new G(Ie, this.options);
      }, this), ge;
    }, Z.prototype.intersects = function(P, z) {
      if (!(P instanceof Z))
        throw new TypeError("a Range is required");
      return this.set.some(function(X) {
        return se(X, z) && P.set.some(function(ae) {
          return se(ae, z) && X.every(function(ge) {
            return ae.every(function(Ie) {
              return ge.intersects(Ie, z);
            });
          });
        });
      });
    };
    function se(P, z) {
      for (var X = !0, ae = P.slice(), ge = ae.pop(); X && ae.length; )
        X = ae.every(function(Ie) {
          return ge.intersects(Ie, z);
        }), ge = ae.pop();
      return X;
    }
    e.toComparators = F;
    function F(P, z) {
      return new Z(P, z).set.map(function(X) {
        return X.map(function(ae) {
          return ae.value;
        }).join(" ").trim().split(" ");
      });
    }
    function ne(P, z) {
      return r("comp", P, z), P = Qe(P, z), r("caret", P), P = ve(P, z), r("tildes", P), P = _e(P, z), r("xrange", P), P = Jt(P, z), r("stars", P), P;
    }
    function de(P) {
      return !P || P.toLowerCase() === "x" || P === "*";
    }
    function ve(P, z) {
      return P.trim().split(/\s+/).map(function(X) {
        return Ce(X, z);
      }).join(" ");
    }
    function Ce(P, z) {
      var X = z.loose ? l[a.TILDELOOSE] : l[a.TILDE];
      return P.replace(X, function(ae, ge, Ie, De, Ve) {
        r("tilde", P, ae, ge, Ie, De, Ve);
        var Pe;
        return de(ge) ? Pe = "" : de(Ie) ? Pe = ">=" + ge + ".0.0 <" + (+ge + 1) + ".0.0" : de(De) ? Pe = ">=" + ge + "." + Ie + ".0 <" + ge + "." + (+Ie + 1) + ".0" : Ve ? (r("replaceTilde pr", Ve), Pe = ">=" + ge + "." + Ie + "." + De + "-" + Ve + " <" + ge + "." + (+Ie + 1) + ".0") : Pe = ">=" + ge + "." + Ie + "." + De + " <" + ge + "." + (+Ie + 1) + ".0", r("tilde return", Pe), Pe;
      });
    }
    function Qe(P, z) {
      return P.trim().split(/\s+/).map(function(X) {
        return xe(X, z);
      }).join(" ");
    }
    function xe(P, z) {
      r("caret", P, z);
      var X = z.loose ? l[a.CARETLOOSE] : l[a.CARET];
      return P.replace(X, function(ae, ge, Ie, De, Ve) {
        r("caret", P, ae, ge, Ie, De, Ve);
        var Pe;
        return de(ge) ? Pe = "" : de(Ie) ? Pe = ">=" + ge + ".0.0 <" + (+ge + 1) + ".0.0" : de(De) ? ge === "0" ? Pe = ">=" + ge + "." + Ie + ".0 <" + ge + "." + (+Ie + 1) + ".0" : Pe = ">=" + ge + "." + Ie + ".0 <" + (+ge + 1) + ".0.0" : Ve ? (r("replaceCaret pr", Ve), ge === "0" ? Ie === "0" ? Pe = ">=" + ge + "." + Ie + "." + De + "-" + Ve + " <" + ge + "." + Ie + "." + (+De + 1) : Pe = ">=" + ge + "." + Ie + "." + De + "-" + Ve + " <" + ge + "." + (+Ie + 1) + ".0" : Pe = ">=" + ge + "." + Ie + "." + De + "-" + Ve + " <" + (+ge + 1) + ".0.0") : (r("no pr"), ge === "0" ? Ie === "0" ? Pe = ">=" + ge + "." + Ie + "." + De + " <" + ge + "." + Ie + "." + (+De + 1) : Pe = ">=" + ge + "." + Ie + "." + De + " <" + ge + "." + (+Ie + 1) + ".0" : Pe = ">=" + ge + "." + Ie + "." + De + " <" + (+ge + 1) + ".0.0"), r("caret return", Pe), Pe;
      });
    }
    function _e(P, z) {
      return r("replaceXRanges", P, z), P.split(/\s+/).map(function(X) {
        return Et(X, z);
      }).join(" ");
    }
    function Et(P, z) {
      P = P.trim();
      var X = z.loose ? l[a.XRANGELOOSE] : l[a.XRANGE];
      return P.replace(X, function(ae, ge, Ie, De, Ve, Pe) {
        r("xRange", P, ae, ge, Ie, De, Ve, Pe);
        var ee = de(Ie), fe = ee || de(De), le = fe || de(Ve), Ae = le;
        return ge === "=" && Ae && (ge = ""), Pe = z.includePrerelease ? "-0" : "", ee ? ge === ">" || ge === "<" ? ae = "<0.0.0-0" : ae = "*" : ge && Ae ? (fe && (De = 0), Ve = 0, ge === ">" ? (ge = ">=", fe ? (Ie = +Ie + 1, De = 0, Ve = 0) : (De = +De + 1, Ve = 0)) : ge === "<=" && (ge = "<", fe ? Ie = +Ie + 1 : De = +De + 1), ae = ge + Ie + "." + De + "." + Ve + Pe) : fe ? ae = ">=" + Ie + ".0.0" + Pe + " <" + (+Ie + 1) + ".0.0" + Pe : le && (ae = ">=" + Ie + "." + De + ".0" + Pe + " <" + Ie + "." + (+De + 1) + ".0" + Pe), r("xRange return", ae), ae;
      });
    }
    function Jt(P, z) {
      return r("replaceStars", P, z), P.trim().replace(l[a.STAR], "");
    }
    function je(P, z, X, ae, ge, Ie, De, Ve, Pe, ee, fe, le, Ae) {
      return de(X) ? z = "" : de(ae) ? z = ">=" + X + ".0.0" : de(ge) ? z = ">=" + X + "." + ae + ".0" : z = ">=" + z, de(Pe) ? Ve = "" : de(ee) ? Ve = "<" + (+Pe + 1) + ".0.0" : de(fe) ? Ve = "<" + Pe + "." + (+ee + 1) + ".0" : le ? Ve = "<=" + Pe + "." + ee + "." + fe + "-" + le : Ve = "<=" + Ve, (z + " " + Ve).trim();
    }
    Z.prototype.test = function(P) {
      if (!P)
        return !1;
      if (typeof P == "string")
        try {
          P = new f(P, this.options);
        } catch {
          return !1;
        }
      for (var z = 0; z < this.set.length; z++)
        if (st(this.set[z], P, this.options))
          return !0;
      return !1;
    };
    function st(P, z, X) {
      for (var ae = 0; ae < P.length; ae++)
        if (!P[ae].test(z))
          return !1;
      if (z.prerelease.length && !X.includePrerelease) {
        for (ae = 0; ae < P.length; ae++)
          if (r(P[ae].semver), P[ae].semver !== q && P[ae].semver.prerelease.length > 0) {
            var ge = P[ae].semver;
            if (ge.major === z.major && ge.minor === z.minor && ge.patch === z.patch)
              return !0;
          }
        return !1;
      }
      return !0;
    }
    e.satisfies = pt;
    function pt(P, z, X) {
      try {
        z = new Z(z, X);
      } catch {
        return !1;
      }
      return z.test(P);
    }
    e.maxSatisfying = Er;
    function Er(P, z, X) {
      var ae = null, ge = null;
      try {
        var Ie = new Z(z, X);
      } catch {
        return null;
      }
      return P.forEach(function(De) {
        Ie.test(De) && (!ae || ge.compare(De) === -1) && (ae = De, ge = new f(ae, X));
      }), ae;
    }
    e.minSatisfying = Ot;
    function Ot(P, z, X) {
      var ae = null, ge = null;
      try {
        var Ie = new Z(z, X);
      } catch {
        return null;
      }
      return P.forEach(function(De) {
        Ie.test(De) && (!ae || ge.compare(De) === 1) && (ae = De, ge = new f(ae, X));
      }), ae;
    }
    e.minVersion = K;
    function K(P, z) {
      P = new Z(P, z);
      var X = new f("0.0.0");
      if (P.test(X) || (X = new f("0.0.0-0"), P.test(X)))
        return X;
      X = null;
      for (var ae = 0; ae < P.set.length; ++ae) {
        var ge = P.set[ae];
        ge.forEach(function(Ie) {
          var De = new f(Ie.semver.version);
          switch (Ie.operator) {
            case ">":
              De.prerelease.length === 0 ? De.patch++ : De.prerelease.push(0), De.raw = De.format();
            /* fallthrough */
            case "":
            case ">=":
              (!X || M(X, De)) && (X = De);
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + Ie.operator);
          }
        });
      }
      return X && P.test(X) ? X : null;
    }
    e.validRange = ce;
    function ce(P, z) {
      try {
        return new Z(P, z).range || "*";
      } catch {
        return null;
      }
    }
    e.ltr = Ee;
    function Ee(P, z, X) {
      return $e(P, z, "<", X);
    }
    e.gtr = Ue;
    function Ue(P, z, X) {
      return $e(P, z, ">", X);
    }
    e.outside = $e;
    function $e(P, z, X, ae) {
      P = new f(P, ae), z = new Z(z, ae);
      var ge, Ie, De, Ve, Pe;
      switch (X) {
        case ">":
          ge = M, Ie = te, De = $, Ve = ">", Pe = ">=";
          break;
        case "<":
          ge = $, Ie = j, De = M, Ve = "<", Pe = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (pt(P, z, ae))
        return !1;
      for (var ee = 0; ee < z.set.length; ++ee) {
        var fe = z.set[ee], le = null, Ae = null;
        if (fe.forEach(function(Be) {
          Be.semver === q && (Be = new G(">=0.0.0")), le = le || Be, Ae = Ae || Be, ge(Be.semver, le.semver, ae) ? le = Be : De(Be.semver, Ae.semver, ae) && (Ae = Be);
        }), le.operator === Ve || le.operator === Pe || (!Ae.operator || Ae.operator === Ve) && Ie(P, Ae.semver))
          return !1;
        if (Ae.operator === Pe && De(P, Ae.semver))
          return !1;
      }
      return !0;
    }
    e.prerelease = Ct;
    function Ct(P, z) {
      var X = Q(P, z);
      return X && X.prerelease.length ? X.prerelease : null;
    }
    e.intersects = St;
    function St(P, z, X) {
      return P = new Z(P, X), z = new Z(z, X), P.intersects(z);
    }
    e.coerce = Vt;
    function Vt(P, z) {
      if (P instanceof f)
        return P;
      if (typeof P == "number" && (P = String(P)), typeof P != "string")
        return null;
      z = z || {};
      var X = null;
      if (!z.rtl)
        X = P.match(l[a.COERCE]);
      else {
        for (var ae; (ae = l[a.COERCERTL].exec(P)) && (!X || X.index + X[0].length !== P.length); )
          (!X || ae.index + ae[0].length !== X.index + X[0].length) && (X = ae), l[a.COERCERTL].lastIndex = ae.index + ae[1].length + ae[2].length;
        l[a.COERCERTL].lastIndex = -1;
      }
      return X === null ? null : Q(X[2] + "." + (X[3] || "0") + "." + (X[4] || "0"), z);
    }
  }(wo, wo.exports)), wo.exports;
}
var yt = {}, Ch;
function no() {
  if (Ch) return yt;
  Ch = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.CacheFileSizeLimit = yt.ManifestFilename = yt.TarFilename = yt.SystemTarPathOnWindows = yt.GnuTarPathOnWindows = yt.SocketTimeout = yt.DefaultRetryDelay = yt.DefaultRetryAttempts = yt.ArchiveToolType = yt.CompressionMethod = yt.CacheFilename = void 0;
  var t;
  (function(n) {
    n.Gzip = "cache.tgz", n.Zstd = "cache.tzst";
  })(t || (yt.CacheFilename = t = {}));
  var e;
  (function(n) {
    n.Gzip = "gzip", n.ZstdWithoutLong = "zstd-without-long", n.Zstd = "zstd";
  })(e || (yt.CompressionMethod = e = {}));
  var r;
  return function(n) {
    n.GNU = "gnu", n.BSD = "bsd";
  }(r || (yt.ArchiveToolType = r = {})), yt.DefaultRetryAttempts = 2, yt.DefaultRetryDelay = 5e3, yt.SocketTimeout = 5e3, yt.GnuTarPathOnWindows = `${process.env.PROGRAMFILES}\\Git\\usr\\bin\\tar.exe`, yt.SystemTarPathOnWindows = `${process.env.SYSTEMDRIVE}\\Windows\\System32\\tar.exe`, yt.TarFilename = "cache.tar", yt.ManifestFilename = "manifest.txt", yt.CacheFileSizeLimit = 10 * Math.pow(1024, 3), yt;
}
var Bh;
function so() {
  if (Bh) return tt;
  Bh = 1;
  var t = tt && tt.__createBinding || (Object.create ? function(v, R, x, S) {
    S === void 0 && (S = x);
    var D = Object.getOwnPropertyDescriptor(R, x);
    (!D || ("get" in D ? !R.__esModule : D.writable || D.configurable)) && (D = { enumerable: !0, get: function() {
      return R[x];
    } }), Object.defineProperty(v, S, D);
  } : function(v, R, x, S) {
    S === void 0 && (S = x), v[S] = R[x];
  }), e = tt && tt.__setModuleDefault || (Object.create ? function(v, R) {
    Object.defineProperty(v, "default", { enumerable: !0, value: R });
  } : function(v, R) {
    v.default = R;
  }), r = tt && tt.__importStar || function(v) {
    if (v && v.__esModule) return v;
    var R = {};
    if (v != null) for (var x in v) x !== "default" && Object.prototype.hasOwnProperty.call(v, x) && t(R, v, x);
    return e(R, v), R;
  }, n = tt && tt.__awaiter || function(v, R, x, S) {
    function D(T) {
      return T instanceof x ? T : new x(function(k) {
        k(T);
      });
    }
    return new (x || (x = Promise))(function(T, k) {
      function L(_) {
        try {
          O(S.next(_));
        } catch (M) {
          k(M);
        }
      }
      function W(_) {
        try {
          O(S.throw(_));
        } catch (M) {
          k(M);
        }
      }
      function O(_) {
        _.done ? T(_.value) : D(_.value).then(L, W);
      }
      O((S = S.apply(v, R || [])).next());
    });
  }, s = tt && tt.__asyncValues || function(v) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var R = v[Symbol.asyncIterator], x;
    return R ? R.call(v) : (v = typeof __values == "function" ? __values(v) : v[Symbol.iterator](), x = {}, S("next"), S("throw"), S("return"), x[Symbol.asyncIterator] = function() {
      return this;
    }, x);
    function S(T) {
      x[T] = v[T] && function(k) {
        return new Promise(function(L, W) {
          k = v[T](k), D(L, W, k.done, k.value);
        });
      };
    }
    function D(T, k, L, W) {
      Promise.resolve(W).then(function(O) {
        T({ value: O, done: L });
      }, k);
    }
  };
  Object.defineProperty(tt, "__esModule", { value: !0 }), tt.getRuntimeToken = tt.getCacheVersion = tt.assertDefined = tt.getGnuTarPathOnWindows = tt.getCacheFileName = tt.getCompressionMethod = tt.unlinkFile = tt.resolvePaths = tt.getArchiveFileSizeInBytes = tt.createTempDirectory = void 0;
  const i = r(ir()), o = r(ro()), c = r(hN()), l = r(to()), A = r(su), a = r(Zr), u = r(yr), g = r(yu()), h = r(Qr), m = no(), d = "1.0";
  function p() {
    return n(this, void 0, void 0, function* () {
      const v = process.platform === "win32";
      let R = process.env.RUNNER_TEMP || "";
      if (!R) {
        let S;
        v ? S = process.env.USERPROFILE || "C:\\" : process.platform === "darwin" ? S = "/Users" : S = "/home", R = u.join(S, "actions", "temp");
      }
      const x = u.join(R, A.randomUUID());
      return yield l.mkdirP(x), x;
    });
  }
  tt.createTempDirectory = p;
  function E(v) {
    return a.statSync(v).size;
  }
  tt.getArchiveFileSizeInBytes = E;
  function B(v) {
    var R, x, S, D, T;
    return n(this, void 0, void 0, function* () {
      const k = [], L = (T = process.env.GITHUB_WORKSPACE) !== null && T !== void 0 ? T : process.cwd(), W = yield c.create(v.join(`
`), {
        implicitDescendants: !1
      });
      try {
        for (var O = !0, _ = s(W.globGenerator()), M; M = yield _.next(), R = M.done, !R; O = !0) {
          D = M.value, O = !1;
          const $ = D, U = u.relative(L, $).replace(new RegExp(`\\${u.sep}`, "g"), "/");
          i.debug(`Matched: ${U}`), U === "" ? k.push(".") : k.push(`${U}`);
        }
      } catch ($) {
        x = { error: $ };
      } finally {
        try {
          !O && !R && (S = _.return) && (yield S.call(_));
        } finally {
          if (x) throw x.error;
        }
      }
      return k;
    });
  }
  tt.resolvePaths = B;
  function y(v) {
    return n(this, void 0, void 0, function* () {
      return h.promisify(a.unlink)(v);
    });
  }
  tt.unlinkFile = y;
  function Q(v, R = []) {
    return n(this, void 0, void 0, function* () {
      let x = "";
      R.push("--version"), i.debug(`Checking ${v} ${R.join(" ")}`);
      try {
        yield o.exec(`${v}`, R, {
          ignoreReturnCode: !0,
          silent: !0,
          listeners: {
            stdout: (S) => x += S.toString(),
            stderr: (S) => x += S.toString()
          }
        });
      } catch (S) {
        i.debug(S.message);
      }
      return x = x.trim(), i.debug(x), x;
    });
  }
  function I() {
    return n(this, void 0, void 0, function* () {
      const v = yield Q("zstd", ["--quiet"]), R = g.clean(v);
      return i.debug(`zstd version: ${R}`), v === "" ? m.CompressionMethod.Gzip : m.CompressionMethod.ZstdWithoutLong;
    });
  }
  tt.getCompressionMethod = I;
  function w(v) {
    return v === m.CompressionMethod.Gzip ? m.CacheFilename.Gzip : m.CacheFilename.Zstd;
  }
  tt.getCacheFileName = w;
  function f() {
    return n(this, void 0, void 0, function* () {
      return a.existsSync(m.GnuTarPathOnWindows) ? m.GnuTarPathOnWindows : (yield Q("tar")).toLowerCase().includes("gnu tar") ? l.which("tar") : "";
    });
  }
  tt.getGnuTarPathOnWindows = f;
  function C(v, R) {
    if (R === void 0)
      throw Error(`Expected ${v} but value was undefiend`);
    return R;
  }
  tt.assertDefined = C;
  function b(v, R, x = !1) {
    const S = v.slice();
    return R && S.push(R), process.platform === "win32" && !x && S.push("windows-only"), S.push(d), A.createHash("sha256").update(S.join("|")).digest("hex");
  }
  tt.getCacheVersion = b;
  function N() {
    const v = process.env.ACTIONS_RUNTIME_TOKEN;
    if (!v)
      throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
    return v;
  }
  return tt.getRuntimeToken = N, tt;
}
var zt = {}, mr = {};
let Qu = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function pN(...t) {
  if (t.length > 0) {
    const e = String(t[0]);
    e.includes(":error") ? console.error(...t) : e.includes(":warning") ? console.warn(...t) : e.includes(":info") ? console.info(...t) : e.includes(":verbose") ? console.debug(...t) : console.debug(...t);
  }
}
const Ih = typeof process < "u" && process.env && process.env.DEBUG || void 0;
let lE, Ul = [], Ll = [];
const zo = [];
Ih && bu(Ih);
const hs = Object.assign((t) => uE(t), {
  enable: bu,
  enabled: wu,
  disable: fN,
  log: pN
});
function bu(t) {
  lE = t, Ul = [], Ll = [];
  const e = /\*/g, r = t.split(",").map((n) => n.trim().replace(e, ".*?"));
  for (const n of r)
    n.startsWith("-") ? Ll.push(new RegExp(`^${n.substr(1)}$`)) : Ul.push(new RegExp(`^${n}$`));
  for (const n of zo)
    n.enabled = wu(n.namespace);
}
function wu(t) {
  if (t.endsWith("*"))
    return !0;
  for (const e of Ll)
    if (e.test(t))
      return !1;
  for (const e of Ul)
    if (e.test(t))
      return !0;
  return !1;
}
function fN() {
  const t = lE || "";
  return bu(""), t;
}
function uE(t) {
  const e = Object.assign(r, {
    enabled: wu(t),
    destroy: EN,
    log: hs.log,
    namespace: t,
    extend: CN
  });
  function r(...n) {
    e.enabled && (n.length > 0 && (n[0] = `${t} ${n[0]}`), e.log(...n));
  }
  return zo.push(e), e;
}
function EN() {
  const t = zo.indexOf(this);
  return t >= 0 ? (zo.splice(t, 1), !0) : !1;
}
function CN(t) {
  const e = uE(`${this.namespace}:${t}`);
  return e.log = this.log, e;
}
const _l = ["verbose", "info", "warning", "error"], yh = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function Qh(t, e) {
  e.log = (...r) => {
    t.log(...r);
  };
}
function bh(t) {
  return _l.includes(t);
}
function BN(t) {
  const e = /* @__PURE__ */ new Set(), r = typeof process < "u" && process.env && process.env[t.logLevelEnvVarName] || void 0;
  let n;
  const s = hs(t.namespace);
  s.log = (...a) => {
    hs.log(...a);
  };
  function i(a) {
    if (a && !bh(a))
      throw new Error(`Unknown log level '${a}'. Acceptable values: ${_l.join(",")}`);
    n = a;
    const u = [];
    for (const g of e)
      o(g) && u.push(g.namespace);
    hs.enable(u.join(","));
  }
  r && (bh(r) ? i(r) : console.error(`${t.logLevelEnvVarName} set to unknown log level '${r}'; logging is not enabled. Acceptable values: ${_l.join(", ")}.`));
  function o(a) {
    return !!(n && yh[a.level] <= yh[n]);
  }
  function c(a, u) {
    const g = Object.assign(a.extend(u), {
      level: u
    });
    if (Qh(a, g), o(g)) {
      const h = hs.disable();
      hs.enable(h + "," + g.namespace);
    }
    return e.add(g), g;
  }
  function l() {
    return n;
  }
  function A(a) {
    const u = s.extend(a);
    return Qh(s, u), {
      error: c(u, "error"),
      warning: c(u, "warning"),
      info: c(u, "info"),
      verbose: c(u, "verbose")
    };
  }
  return {
    setLogLevel: i,
    getLogLevel: l,
    createClientLogger: A,
    logger: s
  };
}
const IN = BN({
  logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
  namespace: "typeSpecRuntime"
});
function dE(t) {
  return IN.createClientLogger(t);
}
function No(t) {
  return t.toLowerCase();
}
function* yN(t) {
  for (const e of t.values())
    yield [e.name, e.value];
}
class QN {
  constructor(e) {
    if (this._headersMap = /* @__PURE__ */ new Map(), e)
      for (const r of Object.keys(e))
        this.set(r, e[r]);
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param name - The name of the header to set. This value is case-insensitive.
   * @param value - The value of the header to set.
   */
  set(e, r) {
    this._headersMap.set(No(e), { name: e, value: String(r).trim() });
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param name - The name of the header. This value is case-insensitive.
   */
  get(e) {
    var r;
    return (r = this._headersMap.get(No(e))) === null || r === void 0 ? void 0 : r.value;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   * @param name - The name of the header to set. This value is case-insensitive.
   */
  has(e) {
    return this._headersMap.has(No(e));
  }
  /**
   * Remove the header with the provided headerName.
   * @param name - The name of the header to remove.
   */
  delete(e) {
    this._headersMap.delete(No(e));
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJSON(e = {}) {
    const r = {};
    if (e.preserveCase)
      for (const n of this._headersMap.values())
        r[n.name] = n.value;
    else
      for (const [n, s] of this._headersMap)
        r[n] = s.value;
    return r;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJSON({ preserveCase: !0 }));
  }
  /**
   * Iterate over tuples of header [name, value] pairs.
   */
  [Symbol.iterator]() {
    return yN(this._headersMap);
  }
}
function Li(t) {
  return new QN(t);
}
function bN() {
  let t = "";
  for (let e = 0; e < 32; e++) {
    const r = Math.floor(Math.random() * 16);
    e === 12 ? t += "4" : e === 16 ? t += r & 3 | 8 : t += r.toString(16), (e === 7 || e === 11 || e === 15 || e === 19) && (t += "-");
  }
  return t;
}
var Sc;
const wN = typeof ((Sc = globalThis?.crypto) === null || Sc === void 0 ? void 0 : Sc.randomUUID) == "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : bN;
function Nu() {
  return wN();
}
class NN {
  constructor(e) {
    var r, n, s, i, o, c, l;
    this.url = e.url, this.body = e.body, this.headers = (r = e.headers) !== null && r !== void 0 ? r : Li(), this.method = (n = e.method) !== null && n !== void 0 ? n : "GET", this.timeout = (s = e.timeout) !== null && s !== void 0 ? s : 0, this.multipartBody = e.multipartBody, this.formData = e.formData, this.disableKeepAlive = (i = e.disableKeepAlive) !== null && i !== void 0 ? i : !1, this.proxySettings = e.proxySettings, this.streamResponseStatusCodes = e.streamResponseStatusCodes, this.withCredentials = (o = e.withCredentials) !== null && o !== void 0 ? o : !1, this.abortSignal = e.abortSignal, this.onUploadProgress = e.onUploadProgress, this.onDownloadProgress = e.onDownloadProgress, this.requestId = e.requestId || Nu(), this.allowInsecureConnection = (c = e.allowInsecureConnection) !== null && c !== void 0 ? c : !1, this.enableBrowserStreams = (l = e.enableBrowserStreams) !== null && l !== void 0 ? l : !1, this.requestOverrides = e.requestOverrides, this.authSchemes = e.authSchemes;
  }
}
function RN(t) {
  return new NN(t);
}
const wh = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
class Yo {
  constructor(e) {
    var r;
    this._policies = [], this._policies = (r = e?.slice(0)) !== null && r !== void 0 ? r : [], this._orderedPolicies = void 0;
  }
  addPolicy(e, r = {}) {
    if (r.phase && r.afterPhase)
      throw new Error("Policies inside a phase cannot specify afterPhase.");
    if (r.phase && !wh.has(r.phase))
      throw new Error(`Invalid phase name: ${r.phase}`);
    if (r.afterPhase && !wh.has(r.afterPhase))
      throw new Error(`Invalid afterPhase name: ${r.afterPhase}`);
    this._policies.push({
      policy: e,
      options: r
    }), this._orderedPolicies = void 0;
  }
  removePolicy(e) {
    const r = [];
    return this._policies = this._policies.filter((n) => e.name && n.policy.name === e.name || e.phase && n.options.phase === e.phase ? (r.push(n.policy), !1) : !0), this._orderedPolicies = void 0, r;
  }
  sendRequest(e, r) {
    return this.getOrderedPolicies().reduceRight((i, o) => (c) => o.sendRequest(c, i), (i) => e.sendRequest(i))(r);
  }
  getOrderedPolicies() {
    return this._orderedPolicies || (this._orderedPolicies = this.orderPolicies()), this._orderedPolicies;
  }
  clone() {
    return new Yo(this._policies);
  }
  static create() {
    return new Yo();
  }
  orderPolicies() {
    const e = [], r = /* @__PURE__ */ new Map();
    function n(m) {
      return {
        name: m,
        policies: /* @__PURE__ */ new Set(),
        hasRun: !1,
        hasAfterPolicies: !1
      };
    }
    const s = n("Serialize"), i = n("None"), o = n("Deserialize"), c = n("Retry"), l = n("Sign"), A = [s, i, o, c, l];
    function a(m) {
      return m === "Retry" ? c : m === "Serialize" ? s : m === "Deserialize" ? o : m === "Sign" ? l : i;
    }
    for (const m of this._policies) {
      const d = m.policy, p = m.options, E = d.name;
      if (r.has(E))
        throw new Error("Duplicate policy names not allowed in pipeline");
      const B = {
        policy: d,
        dependsOn: /* @__PURE__ */ new Set(),
        dependants: /* @__PURE__ */ new Set()
      };
      p.afterPhase && (B.afterPhase = a(p.afterPhase), B.afterPhase.hasAfterPolicies = !0), r.set(E, B), a(p.phase).policies.add(B);
    }
    for (const m of this._policies) {
      const { policy: d, options: p } = m, E = d.name, B = r.get(E);
      if (!B)
        throw new Error(`Missing node for policy ${E}`);
      if (p.afterPolicies)
        for (const y of p.afterPolicies) {
          const Q = r.get(y);
          Q && (B.dependsOn.add(Q), Q.dependants.add(B));
        }
      if (p.beforePolicies)
        for (const y of p.beforePolicies) {
          const Q = r.get(y);
          Q && (Q.dependsOn.add(B), B.dependants.add(Q));
        }
    }
    function u(m) {
      m.hasRun = !0;
      for (const d of m.policies)
        if (!(d.afterPhase && (!d.afterPhase.hasRun || d.afterPhase.policies.size)) && d.dependsOn.size === 0) {
          e.push(d.policy);
          for (const p of d.dependants)
            p.dependsOn.delete(d);
          r.delete(d.policy.name), m.policies.delete(d);
        }
    }
    function g() {
      for (const m of A) {
        if (u(m), m.policies.size > 0 && m !== i) {
          i.hasRun || u(i);
          return;
        }
        m.hasAfterPolicies && u(i);
      }
    }
    let h = 0;
    for (; r.size > 0; ) {
      h++;
      const m = e.length;
      if (g(), e.length <= m && h > 1)
        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
    }
    return e;
  }
}
function SN() {
  return Yo.create();
}
function gE(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date);
}
function Ru(t) {
  if (gE(t)) {
    const e = typeof t.name == "string", r = typeof t.message == "string";
    return e && r;
  }
  return !1;
}
const vN = Symbol(), vc = "REDACTED", xN = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "ms-cv",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Accept-Encoding",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent",
  "WWW-Authenticate"
], DN = ["api-version"];
class Su {
  constructor({ additionalAllowedHeaderNames: e = [], additionalAllowedQueryParameters: r = [] } = {}) {
    e = xN.concat(e), r = DN.concat(r), this.allowedHeaderNames = new Set(e.map((n) => n.toLowerCase())), this.allowedQueryParameters = new Set(r.map((n) => n.toLowerCase()));
  }
  /**
   * Sanitizes an object for logging.
   * @param obj - The object to sanitize
   * @returns - The sanitized object as a string
   */
  sanitize(e) {
    const r = /* @__PURE__ */ new Set();
    return JSON.stringify(e, (n, s) => {
      if (s instanceof Error)
        return Object.assign(Object.assign({}, s), { name: s.name, message: s.message });
      if (n === "headers")
        return this.sanitizeHeaders(s);
      if (n === "url")
        return this.sanitizeUrl(s);
      if (n === "query")
        return this.sanitizeQuery(s);
      if (n === "body")
        return;
      if (n === "response")
        return;
      if (n === "operationSpec")
        return;
      if (Array.isArray(s) || gE(s)) {
        if (r.has(s))
          return "[Circular]";
        r.add(s);
      }
      return s;
    }, 2);
  }
  /**
   * Sanitizes a URL for logging.
   * @param value - The URL to sanitize
   * @returns - The sanitized URL as a string
   */
  sanitizeUrl(e) {
    if (typeof e != "string" || e === null || e === "")
      return e;
    const r = new URL(e);
    if (!r.search)
      return e;
    for (const [n] of r.searchParams)
      this.allowedQueryParameters.has(n.toLowerCase()) || r.searchParams.set(n, vc);
    return r.toString();
  }
  sanitizeHeaders(e) {
    const r = {};
    for (const n of Object.keys(e))
      this.allowedHeaderNames.has(n.toLowerCase()) ? r[n] = e[n] : r[n] = vc;
    return r;
  }
  sanitizeQuery(e) {
    if (typeof e != "object" || e === null)
      return e;
    const r = {};
    for (const n of Object.keys(e))
      this.allowedQueryParameters.has(n.toLowerCase()) ? r[n] = e[n] : r[n] = vc;
    return r;
  }
}
const TN = new Su();
let ws = class mE extends Error {
  constructor(e, r = {}) {
    super(e), this.name = "RestError", this.code = r.code, this.statusCode = r.statusCode, Object.defineProperty(this, "request", { value: r.request, enumerable: !1 }), Object.defineProperty(this, "response", { value: r.response, enumerable: !1 }), Object.defineProperty(this, vN, {
      value: () => `RestError: ${this.message} 
 ${TN.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`,
      enumerable: !1
    }), Object.setPrototypeOf(this, mE.prototype);
  }
};
ws.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
ws.PARSE_ERROR = "PARSE_ERROR";
function kN(t) {
  return t instanceof ws ? !0 : Ru(t) && t.name === "RestError";
}
function $n(t, e) {
  switch (e) {
    case "utf-8":
      return FN(t);
    case "base64":
      return hE(t);
    case "base64url":
      return PN(t);
    case "hex":
      return UN(t);
  }
}
function FN(t) {
  return new TextEncoder().encode(t);
}
function hE(t) {
  return new Uint8Array([...atob(t)].map((e) => e.charCodeAt(0)));
}
function PN(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/");
  return hE(e);
}
const Nh = new Set("0123456789abcdefABCDEF");
function UN(t) {
  const e = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length / 2; ++r) {
    const n = t[2 * r], s = t[2 * r + 1];
    if (!Nh.has(n) || !Nh.has(s))
      return e.slice(0, r);
    e[r] = parseInt(`${n}${s}`, 16);
  }
  return e;
}
function LN(t) {
  return !!(t && typeof t.pipe == "function");
}
function vu(t) {
  return !!(t && typeof t.getReader == "function" && typeof t.tee == "function");
}
function _N(t) {
  return typeof t.stream == "function";
}
function MN(t) {
  return (typeof Blob == "function" || typeof Blob == "object") && t instanceof Blob;
}
class ON {
  /**
   * Makes a request over an underlying transport layer and returns the response.
   * @param request - The request to be made.
   */
  async sendRequest(e) {
    if (new URL(e.url).protocol !== "https:" && !e.allowInsecureConnection)
      throw new Error(`Cannot connect to ${e.url} while allowInsecureConnection is false.`);
    if (e.proxySettings)
      throw new Error("HTTP proxy is not supported in browser environment");
    try {
      return await GN(e);
    } catch (s) {
      throw zN(s, e);
    }
  }
}
async function GN(t) {
  const { abortController: e, abortControllerCleanup: r } = HN(t);
  try {
    const n = YN(t.headers), { streaming: s, body: i } = VN(t), o = Object.assign(Object.assign({ body: i, method: t.method, headers: n, signal: e.signal }, "credentials" in Request.prototype ? { credentials: t.withCredentials ? "include" : "same-origin" } : {}), "cache" in Request.prototype ? { cache: "no-store" } : {});
    s && (o.duplex = "half");
    const c = await fetch(t.url, Object.assign(Object.assign({}, o), t.requestOverrides));
    return MN(t.body) && t.onUploadProgress && t.onUploadProgress({ loadedBytes: t.body.size }), qN(c, t, r);
  } catch (n) {
    throw r?.(), n;
  }
}
async function qN(t, e, r) {
  var n, s;
  const i = JN(t), o = {
    request: e,
    headers: i,
    status: t.status
  }, c = vu(t.body) ? pE(t.body, {
    onProgress: e.onDownloadProgress,
    onEnd: r
  }) : t.body;
  if (
    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    !((n = e.streamResponseStatusCodes) === null || n === void 0) && n.has(Number.POSITIVE_INFINITY) || !((s = e.streamResponseStatusCodes) === null || s === void 0) && s.has(o.status)
  )
    if (e.enableBrowserStreams)
      o.browserStreamBody = c ?? void 0;
    else {
      const l = new Response(c);
      o.blobBody = l.blob(), r?.();
    }
  else {
    const l = new Response(c);
    o.bodyAsText = await l.text(), r?.();
  }
  return o;
}
function HN(t) {
  const e = new AbortController();
  let r, n;
  if (t.abortSignal) {
    if (t.abortSignal.aborted)
      throw new Qu("The operation was aborted. Request has already been canceled.");
    n = (s) => {
      s.type === "abort" && e.abort();
    }, t.abortSignal.addEventListener("abort", n), r = () => {
      var s;
      n && ((s = t.abortSignal) === null || s === void 0 || s.removeEventListener("abort", n));
    };
  }
  return t.timeout > 0 && setTimeout(() => {
    e.abort();
  }, t.timeout), { abortController: e, abortControllerCleanup: r };
}
function zN(t, e) {
  var r;
  return t && t?.name === "AbortError" ? t : new ws(`Error sending request: ${t.message}`, {
    code: (r = t?.code) !== null && r !== void 0 ? r : ws.REQUEST_SEND_ERROR,
    request: e
  });
}
function YN(t) {
  const e = new Headers();
  for (const [r, n] of t)
    e.append(r, n);
  return e;
}
function JN(t) {
  const e = Li();
  for (const [r, n] of t.headers)
    e.set(r, n);
  return e;
}
function VN(t) {
  const e = typeof t.body == "function" ? t.body() : t.body;
  if (LN(e))
    throw new Error("Node streams are not supported in browser environment.");
  return vu(e) ? { streaming: !0, body: pE(e, { onProgress: t.onUploadProgress }) } : { streaming: !1, body: e };
}
function pE(t, e = {}) {
  let r = 0;
  const { onProgress: n, onEnd: s } = e;
  if (jN(t))
    return t.pipeThrough(new TransformStream({
      transform(i, o) {
        if (i === null) {
          o.terminate();
          return;
        }
        o.enqueue(i), r += i.length, n && n({ loadedBytes: r });
      },
      flush() {
        s?.();
      }
    }));
  {
    const i = t.getReader();
    return new ReadableStream({
      async pull(o) {
        var c;
        const { done: l, value: A } = await i.read();
        if (l || !A) {
          s?.(), o.close(), i.releaseLock();
          return;
        }
        r += (c = A?.length) !== null && c !== void 0 ? c : 0, o.enqueue(A), n && n({ loadedBytes: r });
      },
      cancel(o) {
        return s?.(), i.cancel(o);
      }
    });
  }
}
function WN() {
  return new ON();
}
function jN(t) {
  return t.pipeThrough !== void 0 && self.TransformStream !== void 0;
}
function $N() {
  return WN();
}
const XN = dE("ts-http-runtime"), KN = "logPolicy";
function ZN(t = {}) {
  var e;
  const r = (e = t.logger) !== null && e !== void 0 ? e : XN.info, n = new Su({
    additionalAllowedHeaderNames: t.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: t.additionalAllowedQueryParameters
  });
  return {
    name: KN,
    async sendRequest(s, i) {
      if (!r.enabled)
        return i(s);
      r(`Request: ${n.sanitize(s)}`);
      const o = await i(s);
      return r(`Response status code: ${o.status}`), r(`Headers: ${n.sanitize(o.headers)}`), o;
    }
  };
}
const fE = "redirectPolicy", Rh = ["GET", "HEAD"];
function eR(t = {}) {
  const { maxRetries: e = 20 } = t;
  return {
    name: fE,
    async sendRequest(r, n) {
      const s = await n(r);
      return EE(n, s, e);
    }
  };
}
async function EE(t, e, r, n = 0) {
  const { request: s, status: i, headers: o } = e, c = o.get("location");
  if (c && (i === 300 || i === 301 && Rh.includes(s.method) || i === 302 && Rh.includes(s.method) || i === 303 && s.method === "POST" || i === 307) && n < r) {
    const l = new URL(c, s.url);
    s.url = l.toString(), i === 303 && (s.method = "GET", s.headers.delete("Content-Length"), delete s.body), s.headers.delete("Authorization");
    const A = await t(s);
    return EE(t, A, r, n + 1);
  }
  return e;
}
const Ml = 3, tR = "decompressResponsePolicy";
function rR() {
  throw new Error("decompressResponsePolicy is not supported in browser environment");
}
function nR(t, e) {
  return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t;
}
function sR(t, e) {
  const r = e.retryDelayInMs * Math.pow(2, t), n = Math.min(e.maxRetryDelayInMs, r);
  return { retryAfterInMs: n / 2 + nR(0, n / 2) };
}
const iR = "The operation was aborted.";
function oR(t, e, r) {
  return new Promise((n, s) => {
    let i, o;
    const c = () => s(new Qu(r?.abortErrorMsg ? r?.abortErrorMsg : iR)), l = () => {
      r?.abortSignal && o && r.abortSignal.removeEventListener("abort", o);
    };
    if (o = () => (i && clearTimeout(i), l(), c()), r?.abortSignal && r.abortSignal.aborted)
      return c();
    i = setTimeout(() => {
      l(), n(e);
    }, t), r?.abortSignal && r.abortSignal.addEventListener("abort", o);
  });
}
function aR(t, e) {
  const r = t.headers.get(e);
  if (!r)
    return;
  const n = Number(r);
  if (!Number.isNaN(n))
    return n;
}
const Ol = "Retry-After", AR = ["retry-after-ms", "x-ms-retry-after-ms", Ol];
function CE(t) {
  if (t && [429, 503].includes(t.status))
    try {
      for (const s of AR) {
        const i = aR(t, s);
        if (i === 0 || i)
          return i * (s === Ol ? 1e3 : 1);
      }
      const e = t.headers.get(Ol);
      if (!e)
        return;
      const n = Date.parse(e) - Date.now();
      return Number.isFinite(n) ? Math.max(0, n) : void 0;
    } catch {
      return;
    }
}
function cR(t) {
  return Number.isFinite(CE(t));
}
function lR() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response: t }) {
      const e = CE(t);
      return Number.isFinite(e) ? {
        retryAfterInMs: e
      } : { skipStrategy: !0 };
    }
  };
}
const uR = 1e3, dR = 1e3 * 64;
function gR(t = {}) {
  var e, r;
  const n = (e = t.retryDelayInMs) !== null && e !== void 0 ? e : uR, s = (r = t.maxRetryDelayInMs) !== null && r !== void 0 ? r : dR;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount: i, response: o, responseError: c }) {
      const l = hR(c), A = l && t.ignoreSystemErrors, a = mR(o), u = a && t.ignoreHttpStatusCodes;
      return o && (cR(o) || !a) || u || A ? { skipStrategy: !0 } : c && !l && !a ? { errorToThrow: c } : sR(i, {
        retryDelayInMs: n,
        maxRetryDelayInMs: s
      });
    }
  };
}
function mR(t) {
  return !!(t && t.status !== void 0 && (t.status >= 500 || t.status === 408) && t.status !== 501 && t.status !== 505);
}
function hR(t) {
  return t ? t.code === "ETIMEDOUT" || t.code === "ESOCKETTIMEDOUT" || t.code === "ECONNREFUSED" || t.code === "ECONNRESET" || t.code === "ENOENT" || t.code === "ENOTFOUND" : !1;
}
const pR = dE("ts-http-runtime retryPolicy"), fR = "retryPolicy";
function ER(t, e = { maxRetries: Ml }) {
  const r = e.logger || pR;
  return {
    name: fR,
    async sendRequest(n, s) {
      var i, o;
      let c, l, A = -1;
      e: for (; ; ) {
        A += 1, c = void 0, l = void 0;
        try {
          r.info(`Retry ${A}: Attempting to send request`, n.requestId), c = await s(n), r.info(`Retry ${A}: Received a response from request`, n.requestId);
        } catch (a) {
          if (r.error(`Retry ${A}: Received an error from request`, n.requestId), l = a, !a || l.name !== "RestError")
            throw a;
          c = l.response;
        }
        if (!((i = n.abortSignal) === null || i === void 0) && i.aborted)
          throw r.error(`Retry ${A}: Request aborted.`), new Qu();
        if (A >= ((o = e.maxRetries) !== null && o !== void 0 ? o : Ml)) {
          if (r.info(`Retry ${A}: Maximum retries reached. Returning the last received response, or throwing the last received error.`), l)
            throw l;
          if (c)
            return c;
          throw new Error("Maximum retries reached with no response or error to throw");
        }
        r.info(`Retry ${A}: Processing ${t.length} retry strategies.`);
        t: for (const a of t) {
          const u = a.logger || r;
          u.info(`Retry ${A}: Processing retry strategy ${a.name}.`);
          const g = a.retry({
            retryCount: A,
            response: c,
            responseError: l
          });
          if (g.skipStrategy) {
            u.info(`Retry ${A}: Skipped.`);
            continue t;
          }
          const { errorToThrow: h, retryAfterInMs: m, redirectTo: d } = g;
          if (h)
            throw u.error(`Retry ${A}: Retry strategy ${a.name} throws error:`, h), h;
          if (m || m === 0) {
            u.info(`Retry ${A}: Retry strategy ${a.name} retries after ${m}`), await oR(m, void 0, { abortSignal: n.abortSignal });
            continue e;
          }
          if (d) {
            u.info(`Retry ${A}: Retry strategy ${a.name} redirects to ${d}`), n.url = d;
            continue e;
          }
        }
        if (l)
          throw r.info("None of the retry strategies could work with the received error. Throwing it."), l;
        if (c)
          return r.info("None of the retry strategies could work with the received response. Returning it."), c;
      }
    }
  };
}
const CR = "defaultRetryPolicy";
function BR(t = {}) {
  var e;
  return {
    name: CR,
    sendRequest: ER([lR(), gR(t)], {
      maxRetries: (e = t.maxRetries) !== null && e !== void 0 ? e : Ml
    }).sendRequest
  };
}
var xc, Dc, Tc, kc;
typeof self == "object" && typeof self?.importScripts == "function" && (((xc = self.constructor) === null || xc === void 0 ? void 0 : xc.name) === "DedicatedWorkerGlobalScope" || ((Dc = self.constructor) === null || Dc === void 0 ? void 0 : Dc.name) === "ServiceWorkerGlobalScope" || ((Tc = self.constructor) === null || Tc === void 0 || Tc.name));
typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u";
typeof Bun < "u" && typeof Bun.version < "u";
const xu = typeof globalThis.process < "u" && !!globalThis.process.version && !!(!((kc = globalThis.process.versions) === null || kc === void 0) && kc.node), IR = "formDataPolicy";
function yR(t) {
  var e;
  const r = {};
  for (const [n, s] of t.entries())
    (e = r[n]) !== null && e !== void 0 || (r[n] = []), r[n].push(s);
  return r;
}
function QR() {
  return {
    name: IR,
    async sendRequest(t, e) {
      if (xu && typeof FormData < "u" && t.body instanceof FormData && (t.formData = yR(t.body), t.body = void 0), t.formData) {
        const r = t.headers.get("Content-Type");
        r && r.indexOf("application/x-www-form-urlencoded") !== -1 ? t.body = bR(t.formData) : await wR(t.formData, t), t.formData = void 0;
      }
      return e(t);
    }
  };
}
function bR(t) {
  const e = new URLSearchParams();
  for (const [r, n] of Object.entries(t))
    if (Array.isArray(n))
      for (const s of n)
        e.append(r, s.toString());
    else
      e.append(r, n.toString());
  return e.toString();
}
async function wR(t, e) {
  const r = e.headers.get("Content-Type");
  if (r && !r.startsWith("multipart/form-data"))
    return;
  e.headers.set("Content-Type", r ?? "multipart/form-data");
  const n = [];
  for (const [s, i] of Object.entries(t))
    for (const o of Array.isArray(i) ? i : [i])
      if (typeof o == "string")
        n.push({
          headers: Li({
            "Content-Disposition": `form-data; name="${s}"`
          }),
          body: $n(o, "utf-8")
        });
      else {
        if (o == null || typeof o != "object")
          throw new Error(`Unexpected value for key ${s}: ${o}. Value should be serialized to string first.`);
        {
          const c = o.name || "blob", l = Li();
          l.set("Content-Disposition", `form-data; name="${s}"; filename="${c}"`), l.set("Content-Type", o.type || "application/octet-stream"), n.push({
            headers: l,
            body: o
          });
        }
      }
  e.multipartBody = { parts: n };
}
const BE = "proxyPolicy is not supported in browser environment";
function NR() {
  throw new Error(BE);
}
function RR() {
  throw new Error(BE);
}
const SR = "agentPolicy";
function vR(t) {
  return {
    name: SR,
    sendRequest: async (e, r) => (e.agent || (e.agent = t), r(e))
  };
}
const xR = "tlsPolicy";
function DR(t) {
  return {
    name: xR,
    sendRequest: async (e, r) => (e.tlsSettings || (e.tlsSettings = t), r(e))
  };
}
function TR(t) {
  return new Response(t).blob();
}
async function kR(t) {
  if (t instanceof Blob || t instanceof Uint8Array)
    return t;
  if (vu(t))
    return TR(t);
  throw new Error("Unsupported source type. Only Blob, Uint8Array, and ReadableStream are supported in browser.");
}
async function FR(t) {
  const e = [];
  for (const r of t)
    e.push(await kR(typeof r == "function" ? r() : r));
  return new Blob(e);
}
function PR() {
  return `----AzSDKFormBoundary${Nu()}`;
}
function UR(t) {
  let e = "";
  for (const [r, n] of t)
    e += `${r}: ${n}\r
`;
  return e;
}
function LR(t) {
  return t instanceof Uint8Array ? t.byteLength : _N(t) ? t.size === -1 ? void 0 : t.size : void 0;
}
function _R(t) {
  let e = 0;
  for (const r of t) {
    const n = LR(r);
    if (n === void 0)
      return;
    e += n;
  }
  return e;
}
async function MR(t, e, r) {
  const n = [
    $n(`--${r}`, "utf-8"),
    ...e.flatMap((i) => [
      $n(`\r
`, "utf-8"),
      $n(UR(i.headers), "utf-8"),
      $n(`\r
`, "utf-8"),
      i.body,
      $n(`\r
--${r}`, "utf-8")
    ]),
    $n(`--\r
\r
`, "utf-8")
  ], s = _R(n);
  s && t.headers.set("Content-Length", s), t.body = await FR(n);
}
const IE = "multipartPolicy", OR = 70, GR = new Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?");
function qR(t) {
  if (t.length > OR)
    throw new Error(`Multipart boundary "${t}" exceeds maximum length of 70 characters`);
  if (Array.from(t).some((e) => !GR.has(e)))
    throw new Error(`Multipart boundary "${t}" contains invalid characters`);
}
function HR() {
  return {
    name: IE,
    async sendRequest(t, e) {
      var r;
      if (!t.multipartBody)
        return e(t);
      if (t.body)
        throw new Error("multipartBody and regular body cannot be set at the same time");
      let n = t.multipartBody.boundary;
      const s = (r = t.headers.get("Content-Type")) !== null && r !== void 0 ? r : "multipart/mixed", i = s.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!i)
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${s}`);
      const [, o, c] = i;
      if (c && n && c !== n)
        throw new Error(`Multipart boundary was specified as ${c} in the header, but got ${n} in the request body`);
      return n ?? (n = c), n ? qR(n) : n = PR(), t.headers.set("Content-Type", `${o}; boundary=${n}`), await MR(t, t.multipartBody.parts, n), t.multipartBody = void 0, e(t);
    }
  };
}
function yE() {
  return SN();
}
function zR(...t) {
  if (t.length > 0) {
    const e = String(t[0]);
    e.includes(":error") ? console.error(...t) : e.includes(":warning") ? console.warn(...t) : e.includes(":info") ? console.info(...t) : e.includes(":verbose") ? console.debug(...t) : console.debug(...t);
  }
}
const Sh = typeof process < "u" && process.env && process.env.DEBUG || void 0;
let QE, Gl = [], ql = [];
const Jo = [];
Sh && Du(Sh);
const ps = Object.assign((t) => bE(t), {
  enable: Du,
  enabled: Tu,
  disable: YR,
  log: zR
});
function Du(t) {
  QE = t, Gl = [], ql = [];
  const e = /\*/g, r = t.split(",").map((n) => n.trim().replace(e, ".*?"));
  for (const n of r)
    n.startsWith("-") ? ql.push(new RegExp(`^${n.substr(1)}$`)) : Gl.push(new RegExp(`^${n}$`));
  for (const n of Jo)
    n.enabled = Tu(n.namespace);
}
function Tu(t) {
  if (t.endsWith("*"))
    return !0;
  for (const e of ql)
    if (e.test(t))
      return !1;
  for (const e of Gl)
    if (e.test(t))
      return !0;
  return !1;
}
function YR() {
  const t = QE || "";
  return Du(""), t;
}
function bE(t) {
  const e = Object.assign(r, {
    enabled: Tu(t),
    destroy: JR,
    log: ps.log,
    namespace: t,
    extend: VR
  });
  function r(...n) {
    e.enabled && (n.length > 0 && (n[0] = `${t} ${n[0]}`), e.log(...n));
  }
  return Jo.push(e), e;
}
function JR() {
  const t = Jo.indexOf(this);
  return t >= 0 ? (Jo.splice(t, 1), !0) : !1;
}
function VR(t) {
  const e = bE(`${this.namespace}:${t}`);
  return e.log = this.log, e;
}
const Hl = ["verbose", "info", "warning", "error"], vh = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function xh(t, e) {
  e.log = (...r) => {
    t.log(...r);
  };
}
function Dh(t) {
  return Hl.includes(t);
}
function wE(t) {
  const e = /* @__PURE__ */ new Set(), r = typeof process < "u" && process.env && process.env[t.logLevelEnvVarName] || void 0;
  let n;
  const s = ps(t.namespace);
  s.log = (...a) => {
    ps.log(...a);
  };
  function i(a) {
    if (a && !Dh(a))
      throw new Error(`Unknown log level '${a}'. Acceptable values: ${Hl.join(",")}`);
    n = a;
    const u = [];
    for (const g of e)
      o(g) && u.push(g.namespace);
    ps.enable(u.join(","));
  }
  r && (Dh(r) ? i(r) : console.error(`${t.logLevelEnvVarName} set to unknown log level '${r}'; logging is not enabled. Acceptable values: ${Hl.join(", ")}.`));
  function o(a) {
    return !!(n && vh[a.level] <= vh[n]);
  }
  function c(a, u) {
    const g = Object.assign(a.extend(u), {
      level: u
    });
    if (xh(a, g), o(g)) {
      const h = ps.disable();
      ps.enable(h + "," + g.namespace);
    }
    return e.add(g), g;
  }
  function l() {
    return n;
  }
  function A(a) {
    const u = s.extend(a);
    return xh(s, u), {
      error: c(u, "error"),
      warning: c(u, "warning"),
      info: c(u, "info"),
      verbose: c(u, "verbose")
    };
  }
  return {
    setLogLevel: i,
    getLogLevel: l,
    createClientLogger: A,
    logger: s
  };
}
wE({
  logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
  namespace: "typeSpecRuntime"
});
const WR = wE({
  logLevelEnvVarName: "AZURE_LOG_LEVEL",
  namespace: "azure"
});
function ku(t) {
  return WR.createClientLogger(t);
}
const Ps = ku("core-rest-pipeline");
function jR(t = {}) {
  return ZN(Object.assign({ logger: Ps.info }, t));
}
const $R = fE;
function XR(t = {}) {
  return eR(t);
}
function KR() {
  return "x-ms-useragent";
}
function ZR(t) {
  const e = [
    { name: "Firefox", regex: /Firefox\/([\d.]+)/ },
    { name: "Safari", regex: /Version\/([\d.]+).*Safari/ }
  ];
  for (const r of e) {
    const n = t.match(r.regex);
    if (n)
      return { brand: r.name, version: n[1] };
  }
}
function e0(t) {
  const e = ["Google Chrome", "Microsoft Edge", "Opera", "Brave", "Chromium"];
  for (const r of e) {
    const n = t.find((s) => s.brand === r);
    if (n)
      return n;
  }
}
async function t0(t) {
  const e = globalThis.navigator;
  let r = "unknown";
  if (e?.userAgentData) {
    const n = await e.userAgentData.getHighEntropyValues([
      "architecture",
      "platformVersion"
    ]);
    r = `${n.architecture}-${n.platform}-${n.platformVersion}`;
    const s = e0(e.userAgentData.brands);
    s && t.set(s.brand, s.version);
  } else if (e?.platform) {
    r = e.platform;
    const n = ZR(e.userAgent);
    n && t.set(n.brand, n.version);
  } else typeof globalThis.EdgeRuntime == "string" && t.set("EdgeRuntime", globalThis.EdgeRuntime);
  t.set("OS", r);
}
const NE = "1.21.0";
function r0(t) {
  const e = [];
  for (const [r, n] of t) {
    const s = n ? `${r}/${n}` : r;
    e.push(s);
  }
  return e.join(" ");
}
function n0() {
  return KR();
}
async function RE(t) {
  const e = /* @__PURE__ */ new Map();
  e.set("core-rest-pipeline", NE), await t0(e);
  const r = r0(e);
  return t ? `${t} ${r}` : r;
}
const Th = n0(), s0 = "userAgentPolicy";
function i0(t = {}) {
  const e = RE(t.userAgentPrefix);
  return {
    name: s0,
    async sendRequest(r, n) {
      return r.headers.has(Th) || r.headers.set(Th, await e), n(r);
    }
  };
}
let Fu = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function o0(t, e) {
  const { cleanupBeforeAbort: r, abortSignal: n, abortErrorMsg: s } = e ?? {};
  return new Promise((i, o) => {
    function c() {
      o(new Fu(s ?? "The operation was aborted."));
    }
    function l() {
      n?.removeEventListener("abort", A);
    }
    function A() {
      r?.(), l(), c();
    }
    if (n?.aborted)
      return c();
    try {
      t((a) => {
        l(), i(a);
      }, (a) => {
        l(), o(a);
      });
    } catch (a) {
      o(a);
    }
    n?.addEventListener("abort", A);
  });
}
const a0 = "The delay was aborted.";
function SE(t, e) {
  let r;
  const { abortSignal: n, abortErrorMsg: s } = {};
  return o0((i) => {
    r = setTimeout(i, t);
  }, {
    cleanupBeforeAbort: () => clearTimeout(r),
    abortSignal: n,
    abortErrorMsg: s ?? a0
  });
}
function io(t) {
  if (Ru(t))
    return t.message;
  {
    let e;
    try {
      typeof t == "object" && t ? e = JSON.stringify(t) : e = String(t);
    } catch {
      e = "[unable to stringify input]";
    }
    return `Unknown error ${e}`;
  }
}
function A0(t) {
  return Ru(t);
}
function Vo() {
  return Nu();
}
const Mt = xu, kh = xu, vE = Symbol("rawContent");
function xE(t) {
  return typeof t[vE] == "function";
}
function c0(t) {
  return xE(t) ? t[vE]() : t;
}
const DE = IE;
function l0() {
  const t = HR();
  return {
    name: DE,
    sendRequest: async (e, r) => {
      if (e.multipartBody)
        for (const n of e.multipartBody.parts)
          xE(n.body) && (n.body = c0(n.body));
      return t.sendRequest(e, r);
    }
  };
}
const u0 = tR;
function d0() {
  return rR();
}
function g0(t = {}) {
  return BR(t);
}
function m0() {
  return QR();
}
function Us(t) {
  return NR();
}
function h0(t, e) {
  return RR();
}
const p0 = "setClientRequestIdPolicy";
function f0(t = "x-ms-client-request-id") {
  return {
    name: p0,
    async sendRequest(e, r) {
      return e.headers.has(t) || e.headers.set(t, e.requestId), r(e);
    }
  };
}
function E0(t) {
  return vR(t);
}
function C0(t) {
  return DR(t);
}
const vi = {
  span: Symbol.for("@azure/core-tracing span"),
  namespace: Symbol.for("@azure/core-tracing namespace")
};
function B0(t = {}) {
  let e = new xi(t.parentContext);
  return t.span && (e = e.setValue(vi.span, t.span)), t.namespace && (e = e.setValue(vi.namespace, t.namespace)), e;
}
class xi {
  constructor(e) {
    this._contextMap = e instanceof xi ? new Map(e._contextMap) : /* @__PURE__ */ new Map();
  }
  setValue(e, r) {
    const n = new xi(this);
    return n._contextMap.set(e, r), n;
  }
  getValue(e) {
    return this._contextMap.get(e);
  }
  deleteValue(e) {
    const r = new xi(this);
    return r._contextMap.delete(e), r;
  }
}
const Fc = {
  instrumenterImplementation: void 0
};
function I0() {
  return {
    end: () => {
    },
    isRecording: () => !1,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    },
    addEvent: () => {
    }
  };
}
function y0() {
  return {
    createRequestHeaders: () => ({}),
    parseTraceparentHeader: () => {
    },
    startSpan: (t, e) => ({
      span: I0(),
      tracingContext: B0({ parentContext: e.tracingContext })
    }),
    withContext(t, e, ...r) {
      return e(...r);
    }
  };
}
function Ro() {
  return Fc.instrumenterImplementation || (Fc.instrumenterImplementation = y0()), Fc.instrumenterImplementation;
}
function TE(t) {
  const { namespace: e, packageName: r, packageVersion: n } = t;
  function s(A, a, u) {
    var g;
    const h = Ro().startSpan(A, Object.assign(Object.assign({}, u), { packageName: r, packageVersion: n, tracingContext: (g = a?.tracingOptions) === null || g === void 0 ? void 0 : g.tracingContext }));
    let m = h.tracingContext;
    const d = h.span;
    m.getValue(vi.namespace) || (m = m.setValue(vi.namespace, e)), d.setAttribute("az.namespace", m.getValue(vi.namespace));
    const p = Object.assign({}, a, {
      tracingOptions: Object.assign(Object.assign({}, a?.tracingOptions), { tracingContext: m })
    });
    return {
      span: d,
      updatedOptions: p
    };
  }
  async function i(A, a, u, g) {
    const { span: h, updatedOptions: m } = s(A, a, g);
    try {
      const d = await o(m.tracingOptions.tracingContext, () => Promise.resolve(u(m, h)));
      return h.setStatus({ status: "success" }), d;
    } catch (d) {
      throw h.setStatus({ status: "error", error: d }), d;
    } finally {
      h.end();
    }
  }
  function o(A, a, ...u) {
    return Ro().withContext(A, a, ...u);
  }
  function c(A) {
    return Ro().parseTraceparentHeader(A);
  }
  function l(A) {
    return Ro().createRequestHeaders(A);
  }
  return {
    startSpan: s,
    withSpan: i,
    withContext: o,
    parseTraceparentHeader: c,
    createRequestHeaders: l
  };
}
const Ns = ws;
function Pu(t) {
  return kN(t);
}
const Q0 = "tracingPolicy";
function b0(t = {}) {
  const e = RE(t.userAgentPrefix), r = new Su({
    additionalAllowedQueryParameters: t.additionalAllowedQueryParameters
  }), n = w0();
  return {
    name: Q0,
    async sendRequest(s, i) {
      var o;
      if (!n)
        return i(s);
      const c = await e, l = {
        "http.url": r.sanitizeUrl(s.url),
        "http.method": s.method,
        "http.user_agent": c,
        requestId: s.requestId
      };
      c && (l["http.user_agent"] = c);
      const { span: A, tracingContext: a } = (o = N0(n, s, l)) !== null && o !== void 0 ? o : {};
      if (!A || !a)
        return i(s);
      try {
        const u = await n.withContext(a, i, s);
        return S0(A, u), u;
      } catch (u) {
        throw R0(A, u), u;
      }
    }
  };
}
function w0() {
  try {
    return TE({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: NE
    });
  } catch (t) {
    Ps.warning(`Error when creating the TracingClient: ${io(t)}`);
    return;
  }
}
function N0(t, e, r) {
  try {
    const { span: n, updatedOptions: s } = t.startSpan(`HTTP ${e.method}`, { tracingOptions: e.tracingOptions }, {
      spanKind: "client",
      spanAttributes: r
    });
    if (!n.isRecording()) {
      n.end();
      return;
    }
    const i = t.createRequestHeaders(s.tracingOptions.tracingContext);
    for (const [o, c] of Object.entries(i))
      e.headers.set(o, c);
    return { span: n, tracingContext: s.tracingOptions.tracingContext };
  } catch (n) {
    Ps.warning(`Skipping creating a tracing span due to an error: ${io(n)}`);
    return;
  }
}
function R0(t, e) {
  try {
    t.setStatus({
      status: "error",
      error: A0(e) ? e : void 0
    }), Pu(e) && e.statusCode && t.setAttribute("http.status_code", e.statusCode), t.end();
  } catch (r) {
    Ps.warning(`Skipping tracing span processing due to an error: ${io(r)}`);
  }
}
function S0(t, e) {
  try {
    t.setAttribute("http.status_code", e.status);
    const r = e.headers.get("x-ms-request-id");
    r && t.setAttribute("serviceRequestId", r), e.status >= 400 && t.setStatus({
      status: "error"
    }), t.end();
  } catch (r) {
    Ps.warning(`Skipping tracing span processing due to an error: ${io(r)}`);
  }
}
function kE(t) {
  if (t instanceof AbortSignal)
    return { abortSignal: t };
  if (t.aborted)
    return { abortSignal: AbortSignal.abort(t.reason) };
  const e = new AbortController();
  let r = !0;
  function n() {
    r && (t.removeEventListener("abort", s), r = !1);
  }
  function s() {
    e.abort(t.reason), n();
  }
  return t.addEventListener("abort", s), { abortSignal: e.signal, cleanup: n };
}
const v0 = "wrapAbortSignalLikePolicy";
function x0() {
  return {
    name: v0,
    sendRequest: async (t, e) => {
      if (!t.abortSignal)
        return e(t);
      const { abortSignal: r, cleanup: n } = kE(t.abortSignal);
      t.abortSignal = r;
      try {
        return await e(t);
      } finally {
        n?.();
      }
    }
  };
}
function D0(t) {
  var e;
  const r = yE();
  return kh && (t.agent && r.addPolicy(E0(t.agent)), t.tlsOptions && r.addPolicy(C0(t.tlsOptions)), r.addPolicy(h0(t.proxyOptions)), r.addPolicy(d0())), r.addPolicy(x0()), r.addPolicy(m0(), { beforePolicies: [DE] }), r.addPolicy(i0(t.userAgentOptions)), r.addPolicy(f0((e = t.telemetryOptions) === null || e === void 0 ? void 0 : e.clientRequestIdHeaderName)), r.addPolicy(l0(), { afterPhase: "Deserialize" }), r.addPolicy(g0(t.retryOptions), { phase: "Retry" }), r.addPolicy(b0(Object.assign(Object.assign({}, t.userAgentOptions), t.loggingOptions)), {
    afterPhase: "Retry"
  }), kh && r.addPolicy(XR(t.redirectOptions), { afterPhase: "Retry" }), r.addPolicy(jR(t.loggingOptions), { afterPhase: "Sign" }), r;
}
function FE() {
  const t = $N();
  return {
    async sendRequest(e) {
      const { abortSignal: r, cleanup: n } = e.abortSignal ? kE(e.abortSignal) : {};
      try {
        return e.abortSignal = r, await t.sendRequest(e);
      } finally {
        n?.();
      }
    }
  };
}
function da(t) {
  return Li(t);
}
function PE(t) {
  return RN(t);
}
const T0 = {
  forcedRefreshWindowInMs: 1e3,
  // Force waiting for a refresh 1s before the token expires
  retryIntervalInMs: 3e3,
  // Allow refresh attempts every 3s
  refreshWindowInMs: 1e3 * 60 * 2
  // Start refreshing 2m before expiry
};
async function k0(t, e, r) {
  async function n() {
    if (Date.now() < r)
      try {
        return await t();
      } catch {
        return null;
      }
    else {
      const i = await t();
      if (i === null)
        throw new Error("Failed to refresh access token.");
      return i;
    }
  }
  let s = await n();
  for (; s === null; )
    await SE(e), s = await n();
  return s;
}
function F0(t, e) {
  let r = null, n = null, s;
  const i = Object.assign(Object.assign({}, T0), e), o = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return r !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var l;
      return o.isRefreshing ? !1 : n?.refreshAfterTimestamp && n.refreshAfterTimestamp < Date.now() ? !0 : ((l = n?.expiresOnTimestamp) !== null && l !== void 0 ? l : 0) - i.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return n === null || n.expiresOnTimestamp - i.forcedRefreshWindowInMs < Date.now();
    }
  };
  function c(l, A) {
    var a;
    return o.isRefreshing || (r = k0(
      () => t.getToken(l, A),
      i.retryIntervalInMs,
      // If we don't have a token, then we should timeout immediately
      (a = n?.expiresOnTimestamp) !== null && a !== void 0 ? a : Date.now()
    ).then((g) => (r = null, n = g, s = A.tenantId, n)).catch((g) => {
      throw r = null, n = null, s = void 0, g;
    })), r;
  }
  return async (l, A) => {
    const a = !!A.claims, u = s !== A.tenantId;
    return a && (n = null), u || a || o.mustRefresh ? c(l, A) : (o.shouldRefresh && c(l, A), n);
  };
}
const P0 = "bearerTokenAuthenticationPolicy";
async function So(t, e) {
  try {
    return [await e(t), void 0];
  } catch (r) {
    if (Pu(r) && r.response)
      return [r.response, r];
    throw r;
  }
}
async function U0(t) {
  const { scopes: e, getAccessToken: r, request: n } = t, s = {
    abortSignal: n.abortSignal,
    tracingOptions: n.tracingOptions,
    enableCae: !0
  }, i = await r(e, s);
  i && t.request.headers.set("Authorization", `Bearer ${i.token}`);
}
function Fh(t) {
  return t.status === 401 && t.headers.has("WWW-Authenticate");
}
async function Ph(t, e) {
  var r;
  const { scopes: n } = t, s = await t.getAccessToken(n, {
    enableCae: !0,
    claims: e
  });
  return s ? (t.request.headers.set("Authorization", `${(r = s.tokenType) !== null && r !== void 0 ? r : "Bearer"} ${s.token}`), !0) : !1;
}
function Uu(t) {
  var e, r, n;
  const { credential: s, scopes: i, challengeCallbacks: o } = t, c = t.logger || Ps, l = {
    authorizeRequest: (r = (e = o?.authorizeRequest) === null || e === void 0 ? void 0 : e.bind(o)) !== null && r !== void 0 ? r : U0,
    authorizeRequestOnChallenge: (n = o?.authorizeRequestOnChallenge) === null || n === void 0 ? void 0 : n.bind(o)
  }, A = s ? F0(
    s
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: P0,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(a, u) {
      if (!a.url.toLowerCase().startsWith("https://"))
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      await l.authorizeRequest({
        scopes: Array.isArray(i) ? i : [i],
        request: a,
        getAccessToken: A,
        logger: c
      });
      let g, h, m;
      if ([g, h] = await So(a, u), Fh(g)) {
        let d = Uh(g.headers.get("WWW-Authenticate"));
        if (d) {
          let p;
          try {
            p = atob(d);
          } catch {
            return c.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${d}`), g;
          }
          m = await Ph({
            scopes: Array.isArray(i) ? i : [i],
            response: g,
            request: a,
            getAccessToken: A,
            logger: c
          }, p), m && ([g, h] = await So(a, u));
        } else if (l.authorizeRequestOnChallenge && (m = await l.authorizeRequestOnChallenge({
          scopes: Array.isArray(i) ? i : [i],
          request: a,
          response: g,
          getAccessToken: A,
          logger: c
        }), m && ([g, h] = await So(a, u)), Fh(g) && (d = Uh(g.headers.get("WWW-Authenticate")), d))) {
          let p;
          try {
            p = atob(d);
          } catch {
            return c.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${d}`), g;
          }
          m = await Ph({
            scopes: Array.isArray(i) ? i : [i],
            response: g,
            request: a,
            getAccessToken: A,
            logger: c
          }, p), m && ([g, h] = await So(a, u));
        }
      }
      if (h)
        throw h;
      return g;
    }
  };
}
function L0(t) {
  const e = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g, r = /(\w+)="([^"]*)"/g, n = [];
  let s;
  for (; (s = e.exec(t)) !== null; ) {
    const i = s[1], o = s[2], c = {};
    let l;
    for (; (l = r.exec(o)) !== null; )
      c[l[1]] = l[2];
    n.push({ scheme: i, params: c });
  }
  return n;
}
function Uh(t) {
  var e;
  return t ? (e = L0(t).find((n) => n.scheme === "Bearer" && n.params.claims && n.params.error === "insufficient_claims")) === null || e === void 0 ? void 0 : e.params.claims : void 0;
}
function _0(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(t); s < n.length; s++)
      e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);
  return r;
}
function Lh(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function qe(t) {
  return this instanceof qe ? (this.v = t, this) : new qe(t);
}
function Ir(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), s, i = [];
  return s = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), c("next"), c("throw"), c("return", o), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(h) {
    return function(m) {
      return Promise.resolve(m).then(h, u);
    };
  }
  function c(h, m) {
    n[h] && (s[h] = function(d) {
      return new Promise(function(p, E) {
        i.push([h, d, p, E]) > 1 || l(h, d);
      });
    }, m && (s[h] = m(s[h])));
  }
  function l(h, m) {
    try {
      A(n[h](m));
    } catch (d) {
      g(i[0][3], d);
    }
  }
  function A(h) {
    h.value instanceof qe ? Promise.resolve(h.value.v).then(a, u) : g(i[0][2], h);
  }
  function a(h) {
    l("next", h);
  }
  function u(h) {
    l("throw", h);
  }
  function g(h, m) {
    h(m), i.shift(), i.length && l(i[0][0], i[0][1]);
  }
}
function Rs(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(s) {
    throw s;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(s, i) {
    e[s] = t[s] ? function(o) {
      return (r = !r) ? { value: qe(t[s](o)), done: !1 } : i ? i(o) : o;
    } : i;
  }
}
function Ur(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof Lh == "function" ? Lh(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(i) {
    r[i] = t[i] && function(o) {
      return new Promise(function(c, l) {
        o = t[i](o), s(c, l, o.done, o.value);
      });
    };
  }
  function s(i, o, c, l) {
    Promise.resolve(l).then(function(A) {
      i({ value: A, done: c });
    }, o);
  }
}
function Or(t) {
  const e = t;
  return e && typeof e.getToken == "function" && (e.signRequest === void 0 || e.getToken.length > 0);
}
const UE = "DisableKeepAlivePolicy";
function M0() {
  return {
    name: UE,
    async sendRequest(t, e) {
      return t.disableKeepAlive = !0, e(t);
    }
  };
}
function O0(t) {
  return t.getOrderedPolicies().some((e) => e.name === UE);
}
function LE(t) {
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return btoa(e);
}
function _E(t) {
  const e = atob(t), r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e.charCodeAt(n);
  return r;
}
const rr = "$", _i = "_";
function G0(t, e) {
  return e !== "Composite" && e !== "Dictionary" && (typeof t == "string" || typeof t == "number" || typeof t == "boolean" || e?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || t === void 0 || t === null);
}
const q0 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function H0(t) {
  return q0.test(t);
}
const z0 = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
function Y0(t) {
  return z0.test(t);
}
function J0(t) {
  const e = Object.assign(Object.assign({}, t.headers), t.body);
  return t.hasNullableType && Object.getOwnPropertyNames(e).length === 0 ? t.shouldWrapBody ? { body: null } : null : t.shouldWrapBody ? Object.assign(Object.assign({}, t.headers), { body: t.body }) : e;
}
function _h(t, e) {
  var r, n;
  const s = t.parsedHeaders;
  if (t.request.method === "HEAD")
    return Object.assign(Object.assign({}, s), { body: t.parsedBody });
  const i = e && e.bodyMapper, o = !!i?.nullable, c = i?.type.name;
  if (c === "Stream")
    return Object.assign(Object.assign({}, s), { blobBody: t.blobBody, readableStreamBody: t.readableStreamBody });
  const l = c === "Composite" && i.type.modelProperties || {}, A = Object.keys(l).some((a) => l[a].serializedName === "");
  if (c === "Sequence" || A) {
    const a = (r = t.parsedBody) !== null && r !== void 0 ? r : [];
    for (const u of Object.keys(l))
      l[u].serializedName && (a[u] = (n = t.parsedBody) === null || n === void 0 ? void 0 : n[u]);
    if (s)
      for (const u of Object.keys(s))
        a[u] = s[u];
    return o && !t.parsedBody && !s && Object.getOwnPropertyNames(l).length === 0 ? null : a;
  }
  return J0({
    body: t.parsedBody,
    headers: s,
    hasNullableType: o,
    shouldWrapBody: G0(t.parsedBody, c)
  });
}
class V0 {
  constructor(e = {}, r = !1) {
    this.modelMappers = e, this.isXML = r;
  }
  /**
   * @deprecated Removing the constraints validation on client side.
   */
  validateConstraints(e, r, n) {
    const s = (i, o) => {
      throw new Error(`"${n}" with value "${r}" should satisfy the constraint "${i}": ${o}.`);
    };
    if (e.constraints && r !== void 0 && r !== null) {
      const { ExclusiveMaximum: i, ExclusiveMinimum: o, InclusiveMaximum: c, InclusiveMinimum: l, MaxItems: A, MaxLength: a, MinItems: u, MinLength: g, MultipleOf: h, Pattern: m, UniqueItems: d } = e.constraints;
      if (i !== void 0 && r >= i && s("ExclusiveMaximum", i), o !== void 0 && r <= o && s("ExclusiveMinimum", o), c !== void 0 && r > c && s("InclusiveMaximum", c), l !== void 0 && r < l && s("InclusiveMinimum", l), A !== void 0 && r.length > A && s("MaxItems", A), a !== void 0 && r.length > a && s("MaxLength", a), u !== void 0 && r.length < u && s("MinItems", u), g !== void 0 && r.length < g && s("MinLength", g), h !== void 0 && r % h !== 0 && s("MultipleOf", h), m) {
        const p = typeof m == "string" ? new RegExp(m) : m;
        (typeof r != "string" || r.match(p) === null) && s("Pattern", m);
      }
      d && r.some((p, E, B) => B.indexOf(p) !== E) && s("UniqueItems", d);
    }
  }
  /**
   * Serialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param object - A valid Javascript object to be serialized
   *
   * @param objectName - Name of the serialized object
   *
   * @param options - additional options to serialization
   *
   * @returns A valid serialized Javascript object
   */
  serialize(e, r, n, s = { xml: {} }) {
    var i, o, c;
    const l = {
      xml: {
        rootName: (i = s.xml.rootName) !== null && i !== void 0 ? i : "",
        includeRoot: (o = s.xml.includeRoot) !== null && o !== void 0 ? o : !1,
        xmlCharKey: (c = s.xml.xmlCharKey) !== null && c !== void 0 ? c : _i
      }
    };
    let A = {};
    const a = e.type.name;
    n || (n = e.serializedName), a.match(/^Sequence$/i) !== null && (A = []), e.isConstant && (r = e.defaultValue);
    const { required: u, nullable: g } = e;
    if (u && g && r === void 0)
      throw new Error(`${n} cannot be undefined.`);
    if (u && !g && r == null)
      throw new Error(`${n} cannot be null or undefined.`);
    if (!u && g === !1 && r === null)
      throw new Error(`${n} cannot be null.`);
    return r == null || a.match(/^any$/i) !== null ? A = r : a.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null ? A = Z0(a, n, r) : a.match(/^Enum$/i) !== null ? A = eS(n, e.type.allowedValues, r) : a.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null ? A = nS(a, r, n) : a.match(/^ByteArray$/i) !== null ? A = tS(n, r) : a.match(/^Base64Url$/i) !== null ? A = rS(n, r) : a.match(/^Sequence$/i) !== null ? A = sS(this, e, r, n, !!this.isXML, l) : a.match(/^Dictionary$/i) !== null ? A = iS(this, e, r, n, !!this.isXML, l) : a.match(/^Composite$/i) !== null && (A = aS(this, e, r, n, !!this.isXML, l)), A;
  }
  /**
   * Deserialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param responseBody - A valid Javascript entity to be deserialized
   *
   * @param objectName - Name of the deserialized object
   *
   * @param options - Controls behavior of XML parser and builder.
   *
   * @returns A valid deserialized Javascript object
   */
  deserialize(e, r, n, s = { xml: {} }) {
    var i, o, c, l;
    const A = {
      xml: {
        rootName: (i = s.xml.rootName) !== null && i !== void 0 ? i : "",
        includeRoot: (o = s.xml.includeRoot) !== null && o !== void 0 ? o : !1,
        xmlCharKey: (c = s.xml.xmlCharKey) !== null && c !== void 0 ? c : _i
      },
      ignoreUnknownProperties: (l = s.ignoreUnknownProperties) !== null && l !== void 0 ? l : !1
    };
    if (r == null)
      return this.isXML && e.type.name === "Sequence" && !e.xmlIsWrapped && (r = []), e.defaultValue !== void 0 && (r = e.defaultValue), r;
    let a;
    const u = e.type.name;
    if (n || (n = e.serializedName), u.match(/^Composite$/i) !== null)
      a = cS(this, e, r, n, A);
    else {
      if (this.isXML) {
        const g = A.xml.xmlCharKey;
        r[rr] !== void 0 && r[g] !== void 0 && (r = r[g]);
      }
      u.match(/^Number$/i) !== null ? (a = parseFloat(r), isNaN(a) && (a = r)) : u.match(/^Boolean$/i) !== null ? r === "true" ? a = !0 : r === "false" ? a = !1 : a = r : u.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null ? a = r : u.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null ? a = new Date(r) : u.match(/^UnixTime$/i) !== null ? a = K0(r) : u.match(/^ByteArray$/i) !== null ? a = _E(r) : u.match(/^Base64Url$/i) !== null ? a = $0(r) : u.match(/^Sequence$/i) !== null ? a = uS(this, e, r, n, A) : u.match(/^Dictionary$/i) !== null && (a = lS(this, e, r, n, A));
    }
    return e.isConstant && (a = e.defaultValue), a;
  }
}
function Ls(t = {}, e = !1) {
  return new V0(t, e);
}
function W0(t, e) {
  let r = t.length;
  for (; r - 1 >= 0 && t[r - 1] === e; )
    --r;
  return t.substr(0, r);
}
function j0(t) {
  if (!t)
    return;
  if (!(t instanceof Uint8Array))
    throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
  const e = LE(t);
  return W0(e, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function $0(t) {
  if (t) {
    if (t && typeof t.valueOf() != "string")
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    return t = t.replace(/-/g, "+").replace(/_/g, "/"), _E(t);
  }
}
function zl(t) {
  const e = [];
  let r = "";
  if (t) {
    const n = t.split(".");
    for (const s of n)
      s.charAt(s.length - 1) === "\\" ? r += s.substr(0, s.length - 1) + "." : (r += s, e.push(r), r = "");
  }
  return e;
}
function X0(t) {
  if (t)
    return typeof t.valueOf() == "string" && (t = new Date(t)), Math.floor(t.getTime() / 1e3);
}
function K0(t) {
  if (t)
    return new Date(t * 1e3);
}
function Z0(t, e, r) {
  if (r != null) {
    if (t.match(/^Number$/i) !== null) {
      if (typeof r != "number")
        throw new Error(`${e} with value ${r} must be of type number.`);
    } else if (t.match(/^String$/i) !== null) {
      if (typeof r.valueOf() != "string")
        throw new Error(`${e} with value "${r}" must be of type string.`);
    } else if (t.match(/^Uuid$/i) !== null) {
      if (!(typeof r.valueOf() == "string" && Y0(r)))
        throw new Error(`${e} with value "${r}" must be of type string and a valid uuid.`);
    } else if (t.match(/^Boolean$/i) !== null) {
      if (typeof r != "boolean")
        throw new Error(`${e} with value ${r} must be of type boolean.`);
    } else if (t.match(/^Stream$/i) !== null) {
      const n = typeof r;
      if (n !== "string" && typeof r.pipe != "function" && // NodeJS.ReadableStream
      typeof r.tee != "function" && // browser ReadableStream
      !(r instanceof ArrayBuffer) && !ArrayBuffer.isView(r) && // File objects count as a type of Blob, so we want to use instanceof explicitly
      !((typeof Blob == "function" || typeof Blob == "object") && r instanceof Blob) && n !== "function")
        throw new Error(`${e} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
    }
  }
  return r;
}
function eS(t, e, r) {
  if (!e)
    throw new Error(`Please provide a set of allowedValues to validate ${t} as an Enum Type.`);
  if (!e.some((s) => typeof s.valueOf() == "string" ? s.toLowerCase() === r.toLowerCase() : s === r))
    throw new Error(`${r} is not a valid value for ${t}. The valid values are: ${JSON.stringify(e)}.`);
  return r;
}
function tS(t, e) {
  if (e != null) {
    if (!(e instanceof Uint8Array))
      throw new Error(`${t} must be of type Uint8Array.`);
    e = LE(e);
  }
  return e;
}
function rS(t, e) {
  if (e != null) {
    if (!(e instanceof Uint8Array))
      throw new Error(`${t} must be of type Uint8Array.`);
    e = j0(e);
  }
  return e;
}
function nS(t, e, r) {
  if (e != null) {
    if (t.match(/^Date$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in ISO8601 format.`);
      e = e instanceof Date ? e.toISOString().substring(0, 10) : new Date(e).toISOString().substring(0, 10);
    } else if (t.match(/^DateTime$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in ISO8601 format.`);
      e = e instanceof Date ? e.toISOString() : new Date(e).toISOString();
    } else if (t.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in RFC-1123 format.`);
      e = e instanceof Date ? e.toUTCString() : new Date(e).toUTCString();
    } else if (t.match(/^UnixTime$/i) !== null) {
      if (!(e instanceof Date || typeof e.valueOf() == "string" && !isNaN(Date.parse(e))))
        throw new Error(`${r} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      e = X0(e);
    } else if (t.match(/^TimeSpan$/i) !== null && !H0(e))
      throw new Error(`${r} must be a string in ISO 8601 format. Instead was "${e}".`);
  }
  return e;
}
function sS(t, e, r, n, s, i) {
  var o;
  if (!Array.isArray(r))
    throw new Error(`${n} must be of type Array.`);
  let c = e.type.element;
  if (!c || typeof c != "object")
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}.`);
  c.type.name === "Composite" && c.type.className && (c = (o = t.modelMappers[c.type.className]) !== null && o !== void 0 ? o : c);
  const l = [];
  for (let A = 0; A < r.length; A++) {
    const a = t.serialize(c, r[A], n, i);
    if (s && c.xmlNamespace) {
      const u = c.xmlNamespacePrefix ? `xmlns:${c.xmlNamespacePrefix}` : "xmlns";
      c.type.name === "Composite" ? (l[A] = Object.assign({}, a), l[A][rr] = { [u]: c.xmlNamespace }) : (l[A] = {}, l[A][i.xml.xmlCharKey] = a, l[A][rr] = { [u]: c.xmlNamespace });
    } else
      l[A] = a;
  }
  return l;
}
function iS(t, e, r, n, s, i) {
  if (typeof r != "object")
    throw new Error(`${n} must be of type object.`);
  const o = e.type.value;
  if (!o || typeof o != "object")
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}.`);
  const c = {};
  for (const l of Object.keys(r)) {
    const A = t.serialize(o, r[l], n, i);
    c[l] = GE(o, A, s, i);
  }
  if (s && e.xmlNamespace) {
    const l = e.xmlNamespacePrefix ? `xmlns:${e.xmlNamespacePrefix}` : "xmlns", A = c;
    return A[rr] = { [l]: e.xmlNamespace }, A;
  }
  return c;
}
function oS(t, e, r) {
  const n = e.type.additionalProperties;
  if (!n && e.type.className) {
    const s = ME(t, e, r);
    return s?.type.additionalProperties;
  }
  return n;
}
function ME(t, e, r) {
  const n = e.type.className;
  if (!n)
    throw new Error(`Class name for model "${r}" is not provided in the mapper "${JSON.stringify(e, void 0, 2)}".`);
  return t.modelMappers[n];
}
function OE(t, e, r) {
  let n = e.type.modelProperties;
  if (!n) {
    const s = ME(t, e, r);
    if (!s)
      throw new Error(`mapper() cannot be null or undefined for model "${e.type.className}".`);
    if (n = s?.type.modelProperties, !n)
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(s)}" of type "${e.type.className}" for object "${r}".`);
  }
  return n;
}
function aS(t, e, r, n, s, i) {
  if (Wo(t, e) && (e = qE(t, e, r, "clientName")), r != null) {
    const o = {}, c = OE(t, e, n);
    for (const A of Object.keys(c)) {
      const a = c[A];
      if (a.readOnly)
        continue;
      let u, g = o;
      if (t.isXML)
        a.xmlIsWrapped ? u = a.xmlName : u = a.xmlElementName || a.xmlName;
      else {
        const h = zl(a.serializedName);
        u = h.pop();
        for (const m of h) {
          const d = g[m];
          d == null && (r[A] !== void 0 && r[A] !== null || a.defaultValue !== void 0) && (g[m] = {}), g = g[m];
        }
      }
      if (g != null) {
        if (s && e.xmlNamespace) {
          const E = e.xmlNamespacePrefix ? `xmlns:${e.xmlNamespacePrefix}` : "xmlns";
          g[rr] = Object.assign(Object.assign({}, g[rr]), { [E]: e.xmlNamespace });
        }
        const h = a.serializedName !== "" ? n + "." + a.serializedName : n;
        let m = r[A];
        const d = Wo(t, e);
        d && d.clientName === A && m == null && (m = e.serializedName);
        const p = t.serialize(a, m, h, i);
        if (p !== void 0 && u !== void 0 && u !== null) {
          const E = GE(a, p, s, i);
          s && a.xmlIsAttribute ? (g[rr] = g[rr] || {}, g[rr][u] = p) : s && a.xmlIsWrapped ? g[u] = { [a.xmlElementName]: E } : g[u] = E;
        }
      }
    }
    const l = oS(t, e, n);
    if (l) {
      const A = Object.keys(c);
      for (const a in r)
        A.every((g) => g !== a) && (o[a] = t.serialize(l, r[a], n + '["' + a + '"]', i));
    }
    return o;
  }
  return r;
}
function GE(t, e, r, n) {
  if (!r || !t.xmlNamespace)
    return e;
  const i = { [t.xmlNamespacePrefix ? `xmlns:${t.xmlNamespacePrefix}` : "xmlns"]: t.xmlNamespace };
  if (["Composite"].includes(t.type.name)) {
    if (e[rr])
      return e;
    {
      const c = Object.assign({}, e);
      return c[rr] = i, c;
    }
  }
  const o = {};
  return o[n.xml.xmlCharKey] = e, o[rr] = i, o;
}
function AS(t, e) {
  return [rr, e.xml.xmlCharKey].includes(t);
}
function cS(t, e, r, n, s) {
  var i, o;
  const c = (i = s.xml.xmlCharKey) !== null && i !== void 0 ? i : _i;
  Wo(t, e) && (e = qE(t, e, r, "serializedName"));
  const l = OE(t, e, n);
  let A = {};
  const a = [];
  for (const g of Object.keys(l)) {
    const h = l[g], m = zl(l[g].serializedName);
    a.push(m[0]);
    const { serializedName: d, xmlName: p, xmlElementName: E } = h;
    let B = n;
    d !== "" && d !== void 0 && (B = n + "." + d);
    const y = h.headerCollectionPrefix;
    if (y) {
      const Q = {};
      for (const I of Object.keys(r))
        I.startsWith(y) && (Q[I.substring(y.length)] = t.deserialize(h.type.value, r[I], B, s)), a.push(I);
      A[g] = Q;
    } else if (t.isXML)
      if (h.xmlIsAttribute && r[rr])
        A[g] = t.deserialize(h, r[rr][p], B, s);
      else if (h.xmlIsMsText)
        r[c] !== void 0 ? A[g] = r[c] : typeof r == "string" && (A[g] = r);
      else {
        const Q = E || p || d;
        if (h.xmlIsWrapped) {
          const I = r[p], w = (o = I?.[E]) !== null && o !== void 0 ? o : [];
          A[g] = t.deserialize(h, w, B, s), a.push(p);
        } else {
          const I = r[Q];
          A[g] = t.deserialize(h, I, B, s), a.push(Q);
        }
      }
    else {
      let Q, I = r, w = 0;
      for (const b of m) {
        if (!I)
          break;
        w++, I = I[b];
      }
      I === null && w < m.length && (I = void 0), Q = I;
      const f = e.type.polymorphicDiscriminator;
      f && g === f.clientName && Q == null && (Q = e.serializedName);
      let C;
      if (Array.isArray(r[g]) && l[g].serializedName === "") {
        Q = r[g];
        const b = t.deserialize(h, Q, B, s);
        for (const [N, v] of Object.entries(A))
          Object.prototype.hasOwnProperty.call(b, N) || (b[N] = v);
        A = b;
      } else (Q !== void 0 || h.defaultValue !== void 0) && (C = t.deserialize(h, Q, B, s), A[g] = C);
    }
  }
  const u = e.type.additionalProperties;
  if (u) {
    const g = (h) => {
      for (const m in l)
        if (zl(l[m].serializedName)[0] === h)
          return !1;
      return !0;
    };
    for (const h in r)
      g(h) && (A[h] = t.deserialize(u, r[h], n + '["' + h + '"]', s));
  } else if (r && !s.ignoreUnknownProperties)
    for (const g of Object.keys(r))
      A[g] === void 0 && !a.includes(g) && !AS(g, s) && (A[g] = r[g]);
  return A;
}
function lS(t, e, r, n, s) {
  const i = e.type.value;
  if (!i || typeof i != "object")
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}`);
  if (r) {
    const o = {};
    for (const c of Object.keys(r))
      o[c] = t.deserialize(i, r[c], n, s);
    return o;
  }
  return r;
}
function uS(t, e, r, n, s) {
  var i;
  let o = e.type.element;
  if (!o || typeof o != "object")
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}`);
  if (r) {
    Array.isArray(r) || (r = [r]), o.type.name === "Composite" && o.type.className && (o = (i = t.modelMappers[o.type.className]) !== null && i !== void 0 ? i : o);
    const c = [];
    for (let l = 0; l < r.length; l++)
      c[l] = t.deserialize(o, r[l], `${n}[${l}]`, s);
    return c;
  }
  return r;
}
function dS(t, e, r) {
  const n = [r];
  for (; n.length; ) {
    const s = n.shift(), i = e === s ? e : s + "." + e;
    if (Object.prototype.hasOwnProperty.call(t, i))
      return t[i];
    for (const [o, c] of Object.entries(t))
      o.startsWith(s + ".") && c.type.uberParent === s && c.type.className && n.push(c.type.className);
  }
}
function qE(t, e, r, n) {
  var s;
  const i = Wo(t, e);
  if (i) {
    let o = i[n];
    if (o) {
      n === "serializedName" && (o = o.replace(/\\/gi, ""));
      const c = r[o], l = (s = e.type.uberParent) !== null && s !== void 0 ? s : e.type.className;
      if (typeof c == "string" && l) {
        const A = dS(t.modelMappers.discriminators, c, l);
        A && (e = A);
      }
    }
  }
  return e;
}
function Wo(t, e) {
  return e.type.polymorphicDiscriminator || Mh(t, e.type.uberParent) || Mh(t, e.type.className);
}
function Mh(t, e) {
  return e && t.modelMappers[e] && t.modelMappers[e].type.polymorphicDiscriminator;
}
const ys = {
  Base64Url: "Base64Url",
  Boolean: "Boolean",
  ByteArray: "ByteArray",
  Composite: "Composite",
  Date: "Date",
  DateTime: "DateTime",
  DateTimeRfc1123: "DateTimeRfc1123",
  Dictionary: "Dictionary",
  Enum: "Enum",
  Number: "Number",
  Object: "Object",
  Sequence: "Sequence",
  String: "String",
  Stream: "Stream",
  TimeSpan: "TimeSpan",
  UnixTime: "UnixTime"
}, Oh = {
  operationRequestMap: /* @__PURE__ */ new WeakMap()
};
function Ss(t, e, r) {
  let n = e.parameterPath;
  const s = e.mapper;
  let i;
  if (typeof n == "string" && (n = [n]), Array.isArray(n)) {
    if (n.length > 0)
      if (s.isConstant)
        i = s.defaultValue;
      else {
        let o = Gh(t, n);
        !o.propertyFound && r && (o = Gh(r, n));
        let c = !1;
        o.propertyFound || (c = s.required || n[0] === "options" && n.length === 2), i = c ? s.defaultValue : o.propertyValue;
      }
  } else {
    s.required && (i = {});
    for (const o in n) {
      const c = s.type.modelProperties[o], l = n[o], A = Ss(t, {
        parameterPath: l,
        mapper: c
      }, r);
      A !== void 0 && (i || (i = {}), i[o] = A);
    }
  }
  return i;
}
function Gh(t, e) {
  const r = { propertyFound: !1 };
  let n = 0;
  for (; n < e.length; ++n) {
    const s = e[n];
    if (t && s in t)
      t = t[s];
    else
      break;
  }
  return n === e.length && (r.propertyValue = t, r.propertyFound = !0), r;
}
const HE = Symbol.for("@azure/core-client original request");
function gS(t) {
  return HE in t;
}
function _s(t) {
  if (gS(t))
    return _s(t[HE]);
  let e = Oh.operationRequestMap.get(t);
  return e || (e = {}, Oh.operationRequestMap.set(t, e)), e;
}
const mS = ["application/json", "text/json"], hS = ["application/xml", "application/atom+xml"], pS = "deserializationPolicy";
function fS(t = {}) {
  var e, r, n, s, i, o, c;
  const l = (r = (e = t.expectedContentTypes) === null || e === void 0 ? void 0 : e.json) !== null && r !== void 0 ? r : mS, A = (s = (n = t.expectedContentTypes) === null || n === void 0 ? void 0 : n.xml) !== null && s !== void 0 ? s : hS, a = t.parseXML, u = t.serializerOptions, g = {
    xml: {
      rootName: (i = u?.xml.rootName) !== null && i !== void 0 ? i : "",
      includeRoot: (o = u?.xml.includeRoot) !== null && o !== void 0 ? o : !1,
      xmlCharKey: (c = u?.xml.xmlCharKey) !== null && c !== void 0 ? c : _i
    }
  };
  return {
    name: pS,
    async sendRequest(h, m) {
      const d = await m(h);
      return BS(l, A, d, g, a);
    }
  };
}
function ES(t) {
  let e;
  const r = t.request, n = _s(r), s = n?.operationSpec;
  return s && (n?.operationResponseGetter ? e = n?.operationResponseGetter(s, t) : e = s.responses[t.status]), e;
}
function CS(t) {
  const e = t.request, r = _s(e), n = r?.shouldDeserialize;
  let s;
  return n === void 0 ? s = !0 : typeof n == "boolean" ? s = n : s = n(t), s;
}
async function BS(t, e, r, n, s) {
  const i = await QS(t, e, r, n, s);
  if (!CS(i))
    return i;
  const o = _s(i.request), c = o?.operationSpec;
  if (!c || !c.responses)
    return i;
  const l = ES(i), { error: A, shouldReturnResponse: a } = yS(i, c, l, n);
  if (A)
    throw A;
  if (a)
    return i;
  if (l) {
    if (l.bodyMapper) {
      let u = i.parsedBody;
      c.isXML && l.bodyMapper.type.name === ys.Sequence && (u = typeof u == "object" ? u[l.bodyMapper.xmlElementName] : []);
      try {
        i.parsedBody = c.serializer.deserialize(l.bodyMapper, u, "operationRes.parsedBody", n);
      } catch (g) {
        throw new Ns(`Error ${g} occurred in deserializing the responseBody - ${i.bodyAsText}`, {
          statusCode: i.status,
          request: i.request,
          response: i
        });
      }
    } else c.httpMethod === "HEAD" && (i.parsedBody = r.status >= 200 && r.status < 300);
    l.headersMapper && (i.parsedHeaders = c.serializer.deserialize(l.headersMapper, i.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: !0 }));
  }
  return i;
}
function IS(t) {
  const e = Object.keys(t.responses);
  return e.length === 0 || e.length === 1 && e[0] === "default";
}
function yS(t, e, r, n) {
  var s, i, o, c, l;
  const A = 200 <= t.status && t.status < 300;
  if (IS(e) ? A : !!r)
    if (r) {
      if (!r.isError)
        return { error: null, shouldReturnResponse: !1 };
    } else
      return { error: null, shouldReturnResponse: !1 };
  const u = r ?? e.responses.default, g = !((s = t.request.streamResponseStatusCodes) === null || s === void 0) && s.has(t.status) ? `Unexpected status code: ${t.status}` : t.bodyAsText, h = new Ns(g, {
    statusCode: t.status,
    request: t.request,
    response: t
  });
  if (!u && !(!((o = (i = t.parsedBody) === null || i === void 0 ? void 0 : i.error) === null || o === void 0) && o.code && (!((l = (c = t.parsedBody) === null || c === void 0 ? void 0 : c.error) === null || l === void 0) && l.message)))
    throw h;
  const m = u?.bodyMapper, d = u?.headersMapper;
  try {
    if (t.parsedBody) {
      const p = t.parsedBody;
      let E;
      if (m) {
        let y = p;
        if (e.isXML && m.type.name === ys.Sequence) {
          y = [];
          const Q = m.xmlElementName;
          typeof p == "object" && Q && (y = p[Q]);
        }
        E = e.serializer.deserialize(m, y, "error.response.parsedBody", n);
      }
      const B = p.error || E || p;
      h.code = B.code, B.message && (h.message = B.message), m && (h.response.parsedBody = E);
    }
    t.headers && d && (h.response.parsedHeaders = e.serializer.deserialize(d, t.headers.toJSON(), "operationRes.parsedHeaders"));
  } catch (p) {
    h.message = `Error "${p.message}" occurred in deserializing the responseBody - "${t.bodyAsText}" for the default response.`;
  }
  return { error: h, shouldReturnResponse: !1 };
}
async function QS(t, e, r, n, s) {
  var i;
  if (!(!((i = r.request.streamResponseStatusCodes) === null || i === void 0) && i.has(r.status)) && r.bodyAsText) {
    const o = r.bodyAsText, c = r.headers.get("Content-Type") || "", l = c ? c.split(";").map((A) => A.toLowerCase()) : [];
    try {
      if (l.length === 0 || l.some((A) => t.indexOf(A) !== -1))
        return r.parsedBody = JSON.parse(o), r;
      if (l.some((A) => e.indexOf(A) !== -1)) {
        if (!s)
          throw new Error("Parsing XML not supported.");
        const A = await s(o, n.xml);
        return r.parsedBody = A, r;
      }
    } catch (A) {
      const a = `Error "${A}" occurred while parsing the response body - ${r.bodyAsText}.`, u = A.code || Ns.PARSE_ERROR;
      throw new Ns(a, {
        code: u,
        statusCode: r.status,
        request: r.request,
        response: r
      });
    }
  }
  return r;
}
function bS(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r in t.responses) {
    const n = t.responses[r];
    n.bodyMapper && n.bodyMapper.type.name === ys.Stream && e.add(Number(r));
  }
  return e;
}
function Sn(t) {
  const { parameterPath: e, mapper: r } = t;
  let n;
  return typeof e == "string" ? n = e : Array.isArray(e) ? n = e.join(".") : n = r.serializedName, n;
}
const wS = "serializationPolicy";
function zE(t = {}) {
  const e = t.stringifyXML;
  return {
    name: wS,
    async sendRequest(r, n) {
      const s = _s(r), i = s?.operationSpec, o = s?.operationArguments;
      return i && o && (NS(r, o, i), RS(r, o, i, e)), n(r);
    }
  };
}
function NS(t, e, r) {
  var n, s;
  if (r.headerParameters)
    for (const o of r.headerParameters) {
      let c = Ss(e, o);
      if (c != null || o.mapper.required) {
        c = r.serializer.serialize(o.mapper, c, Sn(o));
        const l = o.mapper.headerCollectionPrefix;
        if (l)
          for (const A of Object.keys(c))
            t.headers.set(l + A, c[A]);
        else
          t.headers.set(o.mapper.serializedName || Sn(o), c);
      }
    }
  const i = (s = (n = e.options) === null || n === void 0 ? void 0 : n.requestOptions) === null || s === void 0 ? void 0 : s.customHeaders;
  if (i)
    for (const o of Object.keys(i))
      t.headers.set(o, i[o]);
}
function RS(t, e, r, n = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var s, i, o, c, l;
  const A = (s = e.options) === null || s === void 0 ? void 0 : s.serializerOptions, a = {
    xml: {
      rootName: (i = A?.xml.rootName) !== null && i !== void 0 ? i : "",
      includeRoot: (o = A?.xml.includeRoot) !== null && o !== void 0 ? o : !1,
      xmlCharKey: (c = A?.xml.xmlCharKey) !== null && c !== void 0 ? c : _i
    }
  }, u = a.xml.xmlCharKey;
  if (r.requestBody && r.requestBody.mapper) {
    t.body = Ss(e, r.requestBody);
    const g = r.requestBody.mapper, { required: h, serializedName: m, xmlName: d, xmlElementName: p, xmlNamespace: E, xmlNamespacePrefix: B, nullable: y } = g, Q = g.type.name;
    try {
      if (t.body !== void 0 && t.body !== null || y && t.body === null || h) {
        const I = Sn(r.requestBody);
        t.body = r.serializer.serialize(g, t.body, I, a);
        const w = Q === ys.Stream;
        if (r.isXML) {
          const f = B ? `xmlns:${B}` : "xmlns", C = SS(E, f, Q, t.body, a);
          Q === ys.Sequence ? t.body = n(vS(C, p || d || m, f, E), { rootName: d || m, xmlCharKey: u }) : w || (t.body = n(C, {
            rootName: d || m,
            xmlCharKey: u
          }));
        } else {
          if (Q === ys.String && (!((l = r.contentType) === null || l === void 0) && l.match("text/plain") || r.mediaType === "text"))
            return;
          w || (t.body = JSON.stringify(t.body));
        }
      }
    } catch (I) {
      throw new Error(`Error "${I.message}" occurred in serializing the payload - ${JSON.stringify(m, void 0, "  ")}.`);
    }
  } else if (r.formDataParameters && r.formDataParameters.length > 0) {
    t.formData = {};
    for (const g of r.formDataParameters) {
      const h = Ss(e, g);
      if (h != null) {
        const m = g.mapper.serializedName || Sn(g);
        t.formData[m] = r.serializer.serialize(g.mapper, h, Sn(g), a);
      }
    }
  }
}
function SS(t, e, r, n, s) {
  if (t && !["Composite", "Sequence", "Dictionary"].includes(r)) {
    const i = {};
    return i[s.xml.xmlCharKey] = n, i[rr] = { [e]: t }, i;
  }
  return n;
}
function vS(t, e, r, n) {
  if (Array.isArray(t) || (t = [t]), !r || !n)
    return { [e]: t };
  const s = { [e]: t };
  return s[rr] = { [r]: n }, s;
}
function YE(t = {}) {
  const e = D0(t ?? {});
  return t.credentialOptions && e.addPolicy(Uu({
    credential: t.credentialOptions.credential,
    scopes: t.credentialOptions.credentialScopes
  })), e.addPolicy(zE(t.serializationOptions), { phase: "Serialize" }), e.addPolicy(fS(t.deserializationOptions), {
    phase: "Deserialize"
  }), e;
}
let Pc;
function xS() {
  return Pc || (Pc = FE()), Pc;
}
const DS = {
  CSV: ",",
  SSV: " ",
  Multi: "Multi",
  TSV: "	",
  Pipes: "|"
};
function TS(t, e, r, n) {
  const s = kS(e, r, n);
  let i = !1, o = qh(t, s);
  if (e.path) {
    let A = qh(e.path, s);
    e.path === "/{nextLink}" && A.startsWith("/") && (A = A.substring(1)), FS(A) ? (o = A, i = !0) : o = PS(o, A);
  }
  const { queryParams: c, sequenceParams: l } = US(e, r, n);
  return o = _S(o, c, l, i), o;
}
function qh(t, e) {
  let r = t;
  for (const [n, s] of e)
    r = r.split(n).join(s);
  return r;
}
function kS(t, e, r) {
  var n;
  const s = /* @__PURE__ */ new Map();
  if (!((n = t.urlParameters) === null || n === void 0) && n.length)
    for (const i of t.urlParameters) {
      let o = Ss(e, i, r);
      const c = Sn(i);
      o = t.serializer.serialize(i.mapper, o, c), i.skipEncoding || (o = encodeURIComponent(o)), s.set(`{${i.mapper.serializedName || c}}`, o);
    }
  return s;
}
function FS(t) {
  return t.includes("://");
}
function PS(t, e) {
  if (!e)
    return t;
  const r = new URL(t);
  let n = r.pathname;
  n.endsWith("/") || (n = `${n}/`), e.startsWith("/") && (e = e.substring(1));
  const s = e.indexOf("?");
  if (s !== -1) {
    const i = e.substring(0, s), o = e.substring(s + 1);
    n = n + i, o && (r.search = r.search ? `${r.search}&${o}` : o);
  } else
    n = n + e;
  return r.pathname = n, r.toString();
}
function US(t, e, r) {
  var n;
  const s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
  if (!((n = t.queryParameters) === null || n === void 0) && n.length)
    for (const o of t.queryParameters) {
      o.mapper.type.name === "Sequence" && o.mapper.serializedName && i.add(o.mapper.serializedName);
      let c = Ss(e, o, r);
      if (c != null || o.mapper.required) {
        c = t.serializer.serialize(o.mapper, c, Sn(o));
        const l = o.collectionFormat ? DS[o.collectionFormat] : "";
        if (Array.isArray(c) && (c = c.map((A) => A ?? "")), o.collectionFormat === "Multi" && c.length === 0)
          continue;
        Array.isArray(c) && (o.collectionFormat === "SSV" || o.collectionFormat === "TSV") && (c = c.join(l)), o.skipEncoding || (Array.isArray(c) ? c = c.map((A) => encodeURIComponent(A)) : c = encodeURIComponent(c)), Array.isArray(c) && (o.collectionFormat === "CSV" || o.collectionFormat === "Pipes") && (c = c.join(l)), s.set(o.mapper.serializedName || Sn(o), c);
      }
    }
  return {
    queryParams: s,
    sequenceParams: i
  };
}
function LS(t) {
  const e = /* @__PURE__ */ new Map();
  if (!t || t[0] !== "?")
    return e;
  t = t.slice(1);
  const r = t.split("&");
  for (const n of r) {
    const [s, i] = n.split("=", 2), o = e.get(s);
    o ? Array.isArray(o) ? o.push(i) : e.set(s, [o, i]) : e.set(s, i);
  }
  return e;
}
function _S(t, e, r, n = !1) {
  if (e.size === 0)
    return t;
  const s = new URL(t), i = LS(s.search);
  for (const [c, l] of e) {
    const A = i.get(c);
    if (Array.isArray(A))
      if (Array.isArray(l)) {
        A.push(...l);
        const a = new Set(A);
        i.set(c, Array.from(a));
      } else
        A.push(l);
    else A ? (Array.isArray(l) ? l.unshift(A) : r.has(c) && i.set(c, [A, l]), n || i.set(c, l)) : i.set(c, l);
  }
  const o = [];
  for (const [c, l] of i)
    if (typeof l == "string")
      o.push(`${c}=${l}`);
    else if (Array.isArray(l))
      for (const A of l)
        o.push(`${c}=${A}`);
    else
      o.push(`${c}=${l}`);
  return s.search = o.length ? `?${o.join("&")}` : "", s.toString();
}
const MS = ku("core-client");
class OS {
  /**
   * The ServiceClient constructor
   * @param options - The service client options that govern the behavior of the client.
   */
  constructor(e = {}) {
    var r, n;
    if (this._requestContentType = e.requestContentType, this._endpoint = (r = e.endpoint) !== null && r !== void 0 ? r : e.baseUri, e.baseUri && MS.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead."), this._allowInsecureConnection = e.allowInsecureConnection, this._httpClient = e.httpClient || xS(), this.pipeline = e.pipeline || GS(e), !((n = e.additionalPolicies) === null || n === void 0) && n.length)
      for (const { policy: s, position: i } of e.additionalPolicies) {
        const o = i === "perRetry" ? "Sign" : void 0;
        this.pipeline.addPolicy(s, {
          afterPhase: o
        });
      }
  }
  /**
   * Send the provided httpRequest.
   */
  async sendRequest(e) {
    return this.pipeline.sendRequest(this._httpClient, e);
  }
  /**
   * Send an HTTP request that is populated using the provided OperationSpec.
   * @typeParam T - The typed result of the request, based on the OperationSpec.
   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
   * @param operationSpec - The OperationSpec to use to populate the httpRequest.
   */
  async sendOperationRequest(e, r) {
    const n = r.baseUrl || this._endpoint;
    if (!n)
      throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
    const s = TS(n, r, e, this), i = PE({
      url: s
    });
    i.method = r.httpMethod;
    const o = _s(i);
    o.operationSpec = r, o.operationArguments = e;
    const c = r.contentType || this._requestContentType;
    c && r.requestBody && i.headers.set("Content-Type", c);
    const l = e.options;
    if (l) {
      const A = l.requestOptions;
      A && (A.timeout && (i.timeout = A.timeout), A.onUploadProgress && (i.onUploadProgress = A.onUploadProgress), A.onDownloadProgress && (i.onDownloadProgress = A.onDownloadProgress), A.shouldDeserialize !== void 0 && (o.shouldDeserialize = A.shouldDeserialize), A.allowInsecureConnection && (i.allowInsecureConnection = !0)), l.abortSignal && (i.abortSignal = l.abortSignal), l.tracingOptions && (i.tracingOptions = l.tracingOptions);
    }
    this._allowInsecureConnection && (i.allowInsecureConnection = !0), i.streamResponseStatusCodes === void 0 && (i.streamResponseStatusCodes = bS(r));
    try {
      const A = await this.sendRequest(i), a = _h(A, r.responses[A.status]);
      return l?.onResponse && l.onResponse(A, a), a;
    } catch (A) {
      if (typeof A == "object" && A?.response) {
        const a = A.response, u = _h(a, r.responses[A.statusCode] || r.responses.default);
        A.details = u, l?.onResponse && l.onResponse(a, u, A);
      }
      throw A;
    }
  }
}
function GS(t) {
  const e = qS(t), r = t.credential && e ? { credentialScopes: e, credential: t.credential } : void 0;
  return YE(Object.assign(Object.assign({}, t), { credentialOptions: r }));
}
function qS(t) {
  if (t.credentialScopes)
    return t.credentialScopes;
  if (t.endpoint)
    return `${t.endpoint}/.default`;
  if (t.baseUri)
    return `${t.baseUri}/.default`;
  if (t.credential && !t.credentialScopes)
    throw new Error("When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy");
}
const JE = {
  DefaultScope: "/.default",
  /**
   * Defines constants for use with HTTP headers.
   */
  HeaderConstants: {
    /**
     * The Authorization header.
     */
    AUTHORIZATION: "authorization"
  }
};
function HS(t) {
  return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(t);
}
const VE = async (t) => {
  var e;
  const r = WS(t.request), n = JS(t.response);
  if (n) {
    const s = VS(n), i = YS(t, s), o = zS(s);
    if (!o)
      return !1;
    const c = await t.getAccessToken(i, Object.assign(Object.assign({}, r), { tenantId: o }));
    return c ? (t.request.headers.set(JE.HeaderConstants.AUTHORIZATION, `${(e = c.tokenType) !== null && e !== void 0 ? e : "Bearer"} ${c.token}`), !0) : !1;
  }
  return !1;
};
function zS(t) {
  const n = new URL(t.authorization_uri).pathname.split("/")[1];
  if (n && HS(n))
    return n;
}
function YS(t, e) {
  if (!e.resource_id)
    return t.scopes;
  const r = new URL(e.resource_id);
  r.pathname = JE.DefaultScope;
  let n = r.toString();
  return n === "https://disk.azure.com/.default" && (n = "https://disk.azure.com//.default"), [n];
}
function JS(t) {
  const e = t.headers.get("WWW-Authenticate");
  if (t.status === 401 && e)
    return e;
}
function VS(t) {
  return `${t.slice(7).trim()} `.split(" ").filter((s) => s).map((s) => (([i, o]) => ({ [i]: o }))(s.trim().split("="))).reduce((s, i) => Object.assign(Object.assign({}, s), i), {});
}
function WS(t) {
  return {
    abortSignal: t.abortSignal,
    requestOptions: {
      timeout: t.timeout
    },
    tracingOptions: t.tracingOptions
  };
}
const WE = Symbol("Original PipelineRequest"), jS = Symbol.for("@azure/core-client original request");
function Lu(t, e = {}) {
  const n = t[WE], s = da(t.headers.toJson({ preserveCase: !0 }));
  if (n)
    return n.headers = s, n;
  {
    const i = PE({
      url: t.url,
      method: t.method,
      headers: s,
      withCredentials: t.withCredentials,
      timeout: t.timeout,
      requestId: t.requestId,
      abortSignal: t.abortSignal,
      body: t.body,
      formData: t.formData,
      disableKeepAlive: !!t.keepAlive,
      onDownloadProgress: t.onDownloadProgress,
      onUploadProgress: t.onUploadProgress,
      proxySettings: t.proxySettings,
      streamResponseStatusCodes: t.streamResponseStatusCodes,
      agent: t.agent,
      requestOverrides: t.requestOverrides
    });
    return e.originalRequest && (i[jS] = e.originalRequest), i;
  }
}
function ga(t, e) {
  var r;
  const n = (r = e?.originalRequest) !== null && r !== void 0 ? r : t, s = {
    url: t.url,
    method: t.method,
    headers: _u(t.headers),
    withCredentials: t.withCredentials,
    timeout: t.timeout,
    requestId: t.headers.get("x-ms-client-request-id") || t.requestId,
    abortSignal: t.abortSignal,
    body: t.body,
    formData: t.formData,
    keepAlive: !!t.disableKeepAlive,
    onDownloadProgress: t.onDownloadProgress,
    onUploadProgress: t.onUploadProgress,
    proxySettings: t.proxySettings,
    streamResponseStatusCodes: t.streamResponseStatusCodes,
    agent: t.agent,
    requestOverrides: t.requestOverrides,
    clone() {
      throw new Error("Cannot clone a non-proxied WebResourceLike");
    },
    prepare() {
      throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
    },
    validateRequestProperties() {
    }
  };
  return e?.createProxy ? new Proxy(s, {
    get(i, o, c) {
      return o === WE ? t : o === "clone" ? () => ga(Lu(s, { originalRequest: n }), {
        createProxy: !0,
        originalRequest: n
      }) : Reflect.get(i, o, c);
    },
    set(i, o, c, l) {
      return o === "keepAlive" && (t.disableKeepAlive = !c), typeof o == "string" && [
        "url",
        "method",
        "withCredentials",
        "timeout",
        "requestId",
        "abortSignal",
        "body",
        "formData",
        "onDownloadProgress",
        "onUploadProgress",
        "proxySettings",
        "streamResponseStatusCodes",
        "agent",
        "requestOverrides"
      ].includes(o) && (t[o] = c), Reflect.set(i, o, c, l);
    }
  }) : s;
}
function _u(t) {
  return new Mu(t.toJSON({ preserveCase: !0 }));
}
function Ii(t) {
  return t.toLowerCase();
}
class Mu {
  constructor(e) {
    if (this._headersMap = {}, e)
      for (const r in e)
        this.set(r, e[r]);
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param headerName - The name of the header to set. This value is case-insensitive.
   * @param headerValue - The value of the header to set.
   */
  set(e, r) {
    this._headersMap[Ii(e)] = {
      name: e,
      value: r.toString()
    };
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param headerName - The name of the header.
   */
  get(e) {
    const r = this._headersMap[Ii(e)];
    return r ? r.value : void 0;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   */
  contains(e) {
    return !!this._headersMap[Ii(e)];
  }
  /**
   * Remove the header with the provided headerName. Return whether or not the header existed and
   * was removed.
   * @param headerName - The name of the header to remove.
   */
  remove(e) {
    const r = this.contains(e);
    return delete this._headersMap[Ii(e)], r;
  }
  /**
   * Get the headers that are contained this collection as an object.
   */
  rawHeaders() {
    return this.toJson({ preserveCase: !0 });
  }
  /**
   * Get the headers that are contained in this collection as an array.
   */
  headersArray() {
    const e = [];
    for (const r in this._headersMap)
      e.push(this._headersMap[r]);
    return e;
  }
  /**
   * Get the header names that are contained in this collection.
   */
  headerNames() {
    const e = [], r = this.headersArray();
    for (let n = 0; n < r.length; ++n)
      e.push(r[n].name);
    return e;
  }
  /**
   * Get the header values that are contained in this collection.
   */
  headerValues() {
    const e = [], r = this.headersArray();
    for (let n = 0; n < r.length; ++n)
      e.push(r[n].value);
    return e;
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJson(e = {}) {
    const r = {};
    if (e.preserveCase)
      for (const n in this._headersMap) {
        const s = this._headersMap[n];
        r[s.name] = s.value;
      }
    else
      for (const n in this._headersMap) {
        const s = this._headersMap[n];
        r[Ii(s.name)] = s.value;
      }
    return r;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJson({ preserveCase: !0 }));
  }
  /**
   * Create a deep clone/copy of this HttpHeaders collection.
   */
  clone() {
    const e = {};
    for (const r in this._headersMap) {
      const n = this._headersMap[r];
      e[n.name] = n.value;
    }
    return new Mu(e);
  }
}
const jE = Symbol("Original FullOperationResponse");
function $E(t, e) {
  let r = ga(t.request), n = _u(t.headers);
  return e?.createProxy ? new Proxy(t, {
    get(s, i, o) {
      return i === "headers" ? n : i === "request" ? r : i === jE ? t : Reflect.get(s, i, o);
    },
    set(s, i, o, c) {
      return i === "headers" ? n = o : i === "request" && (r = o), Reflect.set(s, i, o, c);
    }
  }) : Object.assign(Object.assign({}, t), {
    request: r,
    headers: n
  });
}
function XE(t) {
  const r = t[jE], n = da(t.headers.toJson({ preserveCase: !0 }));
  return r ? (r.headers = n, r) : Object.assign(Object.assign({}, t), { headers: n, request: Lu(t.request) });
}
class $S extends OS {
  constructor(e) {
    var r, n;
    super(e), ((r = e.keepAliveOptions) === null || r === void 0 ? void 0 : r.enable) === !1 && !O0(this.pipeline) && this.pipeline.addPolicy(M0()), ((n = e.redirectOptions) === null || n === void 0 ? void 0 : n.handleRedirects) === !1 && this.pipeline.removePolicy({
      name: $R
    });
  }
  /**
   * Compatible send operation request function.
   *
   * @param operationArguments - Operation arguments
   * @param operationSpec - Operation Spec
   * @returns
   */
  async sendOperationRequest(e, r) {
    var n;
    const s = (n = e?.options) === null || n === void 0 ? void 0 : n.onResponse;
    let i;
    function o(l, A, a) {
      i = l, s && s(l, A, a);
    }
    e.options = Object.assign(Object.assign({}, e.options), { onResponse: o });
    const c = await super.sendOperationRequest(e, r);
    return i && Object.defineProperty(c, "_response", {
      value: $E(i)
    }), c;
  }
}
var Hh;
(function(t) {
  t[t.ERROR = 1] = "ERROR", t[t.INFO = 3] = "INFO", t[t.OFF = 0] = "OFF", t[t.WARNING = 2] = "WARNING";
})(Hh || (Hh = {}));
const XS = {
  log(t, e) {
  },
  shouldLog(t) {
    return !1;
  }
}, KS = "RequestPolicyFactoryPolicy";
function ZS(t) {
  const e = t.slice().reverse();
  return {
    name: KS,
    async sendRequest(r, n) {
      let s = {
        async sendRequest(c) {
          const l = await n(Lu(c));
          return $E(l, { createProxy: !0 });
        }
      };
      for (const c of e)
        s = c.create(s, XS);
      const i = ga(r, { createProxy: !0 }), o = await s.sendRequest(i);
      return XE(o);
    }
  };
}
function ev(t) {
  return {
    sendRequest: async (e) => {
      const r = await t.sendRequest(ga(e, { createProxy: !0 }));
      return XE(r);
    }
  };
}
const Di = "$", KE = "_";
if (!document || !DOMParser || !Node || !XMLSerializer)
  throw new Error('This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. ');
let Kn;
try {
  typeof self.trustedTypes < "u" && (Kn = self.trustedTypes.createPolicy("@azure/core-xml#xml.browser", {
    createHTML: (t) => t
  }));
} catch {
  console.warn('Could not create trusted types policy "@azure/core-xml#xml.browser"');
}
const Ni = document.implementation.createDocument(null, null, null), ZE = new DOMParser();
function tv(t, e = {}) {
  var r, n, s, i, o, c;
  try {
    const l = {
      rootName: (r = e.rootName) !== null && r !== void 0 ? r : "",
      includeRoot: (n = e.includeRoot) !== null && n !== void 0 ? n : !1,
      xmlCharKey: (s = e.xmlCharKey) !== null && s !== void 0 ? s : KE,
      cdataPropName: (i = e.cdataPropName) !== null && i !== void 0 ? i : "__cdata",
      stopNodes: (o = e.stopNodes) !== null && o !== void 0 ? o : []
    }, A = ZE.parseFromString((c = Kn?.createHTML(t)) !== null && c !== void 0 ? c : t, "application/xml");
    nv(A);
    let a;
    return l.includeRoot ? a = Yl(A, l) : a = Yl(A.childNodes[0], l), Promise.resolve(a);
  } catch (l) {
    return Promise.reject(l);
  }
}
let Ri;
function rv() {
  var t, e;
  if (Ri === void 0)
    try {
      const r = (t = Kn?.createHTML("INVALID")) !== null && t !== void 0 ? t : "INVALID";
      Ri = (e = ZE.parseFromString(r, "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) !== null && e !== void 0 ? e : "";
    } catch {
      Ri = "";
    }
  return Ri;
}
function nv(t) {
  const e = t.getElementsByTagName("parsererror");
  if (e.length > 0 && rv()) {
    for (let r = 0; r < e.length; r++)
      if (e[r].namespaceURI === Ri)
        throw new Error(e[r].innerHTML);
  }
}
function sv(t) {
  return !!t.attributes;
}
function iv(t) {
  return sv(t) && t.hasAttributes() ? t : void 0;
}
function Yl(t, e) {
  var r;
  let n = {};
  const s = t.childNodes.length, i = t.childNodes[0], o = i && s === 1 && i.nodeType === Node.TEXT_NODE && i.nodeValue || void 0, c = iv(t);
  if (c) {
    n[Di] = {};
    for (let l = 0; l < c.attributes.length; l++) {
      const A = c.attributes[l];
      n[Di][A.nodeName] = A.nodeValue;
    }
    o && (n[e.xmlCharKey] = o);
  } else s === 0 ? n = "" : o && (n = o);
  if (!o)
    for (let l = 0; l < s; l++) {
      const A = t.childNodes[l];
      if (A?.nodeType === Node.CDATA_SECTION_NODE)
        n = A.textContent;
      else if (((r = A?.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === Node.CDATA_SECTION_NODE)
        n[A.nodeName] = A.textContent;
      else if (A.nodeType !== Node.TEXT_NODE) {
        const a = Yl(A, e);
        n[A.nodeName] ? Array.isArray(n[A.nodeName]) ? n[A.nodeName].push(a) : n[A.nodeName] = [n[A.nodeName], a] : n[A.nodeName] = a;
      }
    }
  return n;
}
const ov = new XMLSerializer();
function eC(t, e = {}) {
  var r, n, s, i, o;
  const c = {
    rootName: (r = e.rootName) !== null && r !== void 0 ? r : "root",
    includeRoot: (n = e.includeRoot) !== null && n !== void 0 ? n : !1,
    xmlCharKey: (s = e.xmlCharKey) !== null && s !== void 0 ? s : KE,
    cdataPropName: (i = e.cdataPropName) !== null && i !== void 0 ? i : "__cdata",
    stopNodes: (o = e.stopNodes) !== null && o !== void 0 ? o : []
  }, l = Jl(t, c.rootName, c)[0];
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + ov.serializeToString(l).replace(/ xmlns=""/g, "");
}
function av(t) {
  const e = [];
  for (const r of Object.keys(t)) {
    const n = Ni.createAttribute(r);
    n.value = t[r].toString(), e.push(n);
  }
  return e;
}
function Jl(t, e, r) {
  var n;
  if (t == null || typeof t == "string" || typeof t == "number" || typeof t == "boolean") {
    const s = Ni.createElement(e);
    return s.textContent = t == null ? "" : t.toString(), [s];
  } else if (Array.isArray(t)) {
    const s = [];
    for (const i of t)
      for (const o of Jl(i, e, r))
        s.push(o);
    return s;
  } else if (typeof t == "object") {
    let s;
    !((n = t[Di]) === null || n === void 0) && n.xmlns ? s = Ni.createElementNS(t[Di].xmlns, e) : s = Ni.createElement(e);
    for (const i of Object.keys(t))
      if (i === Di)
        for (const o of av(t[i]))
          s.attributes.setNamedItem(o);
      else if (i === r.xmlCharKey)
        s.textContent = t[i].toString();
      else if (i === r.cdataPropName) {
        const o = Ni.createCDATASection(t[i].toString());
        s.appendChild(o);
      } else
        for (const o of Jl(t[i], i, r))
          s.appendChild(o);
    return [s];
  } else
    throw new Error(`Illegal value passed to buildObject: ${t}`);
}
const qt = ku("storage-blob");
class ma {
  /**
   * The main method to implement that manipulates a request/response.
   */
  constructor(e, r) {
    this._nextPolicy = e, this._options = r;
  }
  /**
   * Get whether or not a log with the provided log level should be logged.
   * @param logLevel - The log level of the log that will be logged.
   * @returns Whether or not a log with the provided log level should be logged.
   */
  shouldLog(e) {
    return this._options.shouldLog(e);
  }
  /**
   * Attempt to log the provided message to the provided logger. If no logger was provided or if
   * the log level does not meat the logger's threshold, then nothing will be logged.
   * @param logLevel - The log level of this log.
   * @param message - The message of this log.
   */
  log(e, r) {
    this._options.log(e, r);
  }
}
const tC = "12.27.0", Ou = "2025-05-05", Uc = 256 * 1024 * 1024, Lc = 4e3 * 1024 * 1024, vo = 5e4, Av = 8 * 1024 * 1024, Vl = 4 * 1024 * 1024, cv = 5, Gu = "https://storage.azure.com/.default", Xr = {
  Parameters: {
    FORCE_BROWSER_NO_CACHE: "_",
    SNAPSHOT: "snapshot",
    VERSIONID: "versionid",
    TIMEOUT: "timeout"
  }
}, lv = {
  HTTP_ACCEPTED: 202
}, An = {
  CONTENT_ID: "Content-ID",
  CONTENT_LENGTH: "Content-Length",
  CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
  CONTENT_TYPE: "Content-Type",
  COOKIE: "Cookie",
  X_MS_ERROR_CODE: "x-ms-error-code",
  X_MS_VERSION: "x-ms-version"
}, an = "", rC = "*", zh = 256, pn = `\r
`, nC = "HTTP/1.1", uv = "AES256", dv = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;", gv = [
  "Access-Control-Allow-Origin",
  "Cache-Control",
  "Content-Length",
  "Content-Type",
  "Date",
  "Request-Id",
  "traceparent",
  "Transfer-Encoding",
  "User-Agent",
  "x-ms-client-request-id",
  "x-ms-date",
  "x-ms-error-code",
  "x-ms-request-id",
  "x-ms-return-client-request-id",
  "x-ms-version",
  "Accept-Ranges",
  "Content-Disposition",
  "Content-Encoding",
  "Content-Language",
  "Content-MD5",
  "Content-Range",
  "ETag",
  "Last-Modified",
  "Server",
  "Vary",
  "x-ms-content-crc64",
  "x-ms-copy-action",
  "x-ms-copy-completion-time",
  "x-ms-copy-id",
  "x-ms-copy-progress",
  "x-ms-copy-status",
  "x-ms-has-immutability-policy",
  "x-ms-has-legal-hold",
  "x-ms-lease-state",
  "x-ms-lease-status",
  "x-ms-range",
  "x-ms-request-server-encrypted",
  "x-ms-server-encrypted",
  "x-ms-snapshot",
  "x-ms-source-range",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "x-ms-access-tier",
  "x-ms-access-tier-change-time",
  "x-ms-access-tier-inferred",
  "x-ms-account-kind",
  "x-ms-archive-status",
  "x-ms-blob-append-offset",
  "x-ms-blob-cache-control",
  "x-ms-blob-committed-block-count",
  "x-ms-blob-condition-appendpos",
  "x-ms-blob-condition-maxsize",
  "x-ms-blob-content-disposition",
  "x-ms-blob-content-encoding",
  "x-ms-blob-content-language",
  "x-ms-blob-content-length",
  "x-ms-blob-content-md5",
  "x-ms-blob-content-type",
  "x-ms-blob-public-access",
  "x-ms-blob-sequence-number",
  "x-ms-blob-type",
  "x-ms-copy-destination-snapshot",
  "x-ms-creation-time",
  "x-ms-default-encryption-scope",
  "x-ms-delete-snapshots",
  "x-ms-delete-type-permanent",
  "x-ms-deny-encryption-scope-override",
  "x-ms-encryption-algorithm",
  "x-ms-if-sequence-number-eq",
  "x-ms-if-sequence-number-le",
  "x-ms-if-sequence-number-lt",
  "x-ms-incremental-copy",
  "x-ms-lease-action",
  "x-ms-lease-break-period",
  "x-ms-lease-duration",
  "x-ms-lease-id",
  "x-ms-lease-time",
  "x-ms-page-write",
  "x-ms-proposed-lease-id",
  "x-ms-range-get-content-md5",
  "x-ms-rehydrate-priority",
  "x-ms-sequence-number-action",
  "x-ms-sku-name",
  "x-ms-source-content-md5",
  "x-ms-source-if-match",
  "x-ms-source-if-modified-since",
  "x-ms-source-if-none-match",
  "x-ms-source-if-unmodified-since",
  "x-ms-tag-count",
  "x-ms-encryption-key-sha256",
  "x-ms-copy-source-error-code",
  "x-ms-copy-source-status-code",
  "x-ms-if-tags",
  "x-ms-source-if-tags"
], mv = [
  "comp",
  "maxresults",
  "rscc",
  "rscd",
  "rsce",
  "rscl",
  "rsct",
  "se",
  "si",
  "sip",
  "sp",
  "spr",
  "sr",
  "srt",
  "ss",
  "st",
  "sv",
  "include",
  "marker",
  "prefix",
  "copyid",
  "restype",
  "blockid",
  "blocklisttype",
  "delimiter",
  "prevsnapshot",
  "ske",
  "skoid",
  "sks",
  "skt",
  "sktid",
  "skv",
  "snapshot"
], hv = "BlobUsesCustomerSpecifiedEncryption", pv = "BlobDoesNotUseCustomerSpecifiedEncryption", fv = [
  "10000",
  "10001",
  "10002",
  "10003",
  "10004",
  "10100",
  "10101",
  "10102",
  "10103",
  "10104",
  "11000",
  "11001",
  "11002",
  "11003",
  "11004",
  "11100",
  "11101",
  "11102",
  "11103",
  "11104"
];
function Ev(t) {
  const e = new URL(t);
  let r = e.pathname;
  return r = r || "/", r = Bv(r), e.pathname = r, e.toString();
}
function Cv(t) {
  let e = "";
  if (t.search("DevelopmentStorageProxyUri=") !== -1) {
    const r = t.split(";");
    for (const n of r)
      n.trim().startsWith("DevelopmentStorageProxyUri=") && (e = n.trim().match("DevelopmentStorageProxyUri=(.*)")[1]);
  }
  return e;
}
function Jn(t, e) {
  const r = t.split(";");
  for (const n of r)
    if (n.trim().startsWith(e))
      return n.trim().match(e + "=(.*)")[1];
  return "";
}
function Ms(t) {
  let e = "";
  t.startsWith("UseDevelopmentStorage=true") && (e = Cv(t), t = dv);
  let r = Jn(t, "BlobEndpoint");
  if (r = r.endsWith("/") ? r.slice(0, -1) : r, t.search("DefaultEndpointsProtocol=") !== -1 && t.search("AccountKey=") !== -1) {
    let n = "", s = "", i = Buffer.from("accountKey", "base64"), o = "";
    if (s = Jn(t, "AccountName"), i = Buffer.from(Jn(t, "AccountKey"), "base64"), !r) {
      n = Jn(t, "DefaultEndpointsProtocol");
      const c = n.toLowerCase();
      if (c !== "https" && c !== "http")
        throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
      if (o = Jn(t, "EndpointSuffix"), !o)
        throw new Error("Invalid EndpointSuffix in the provided Connection String");
      r = `${n}://${s}.blob.${o}`;
    }
    if (s) {
      if (i.length === 0)
        throw new Error("Invalid AccountKey in the provided Connection String");
    } else throw new Error("Invalid AccountName in the provided Connection String");
    return {
      kind: "AccountConnString",
      url: r,
      accountName: s,
      accountKey: i,
      proxyUri: e
    };
  } else {
    let n = Jn(t, "SharedAccessSignature"), s = Jn(t, "AccountName");
    if (s || (s = AC(r)), r) {
      if (!n)
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
    } else throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
    return n.startsWith("?") && (n = n.substring(1)), { kind: "SASConnString", url: r, accountName: s, accountSas: n };
  }
}
function Bv(t) {
  return encodeURIComponent(t).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
}
function kt(t, e) {
  const r = new URL(t);
  let n = r.pathname;
  return n = n ? n.endsWith("/") ? `${n}${e}` : `${n}/${e}` : e, r.pathname = n, r.toString();
}
function En(t, e, r) {
  const n = new URL(t), s = encodeURIComponent(e), i = r ? encodeURIComponent(r) : void 0, o = n.search === "" ? "?" : n.search, c = [];
  for (const l of o.slice(1).split("&"))
    if (l) {
      const [A] = l.split("=", 2);
      A !== s && c.push(l);
    }
  return i && c.push(`${s}=${i}`), n.search = c.length ? `?${c.join("&")}` : "", n.toString();
}
function Yh(t, e) {
  var r;
  return (r = new URL(t).searchParams.get(e)) !== null && r !== void 0 ? r : void 0;
}
function sC(t, e) {
  const r = new URL(t);
  return r.hostname = e, r.toString();
}
function iC(t) {
  try {
    return new URL(t).pathname;
  } catch {
    return;
  }
}
function Iv(t) {
  try {
    const e = new URL(t);
    return e.protocol.endsWith(":") ? e.protocol.slice(0, -1) : e.protocol;
  } catch {
    return;
  }
}
function yv(t) {
  const e = new URL(t), r = e.pathname;
  if (!r)
    throw new RangeError("Invalid url without valid path.");
  let n = e.search || "";
  return n = n.trim(), n !== "" && (n = n.startsWith("?") ? n : `?${n}`), `${r}${n}`;
}
function Mi(t, e) {
  const r = new URL(t);
  let n = r.search;
  return n ? n += "&" + e : n = e, r.search = n, r.toString();
}
function ot(t, e = !0) {
  const r = t.toISOString();
  return e ? r.substring(0, r.length - 1) + "0000Z" : r.substring(0, r.length - 5) + "Z";
}
function Qv(t) {
  return Mt ? Buffer.from(t).toString("base64") : btoa(t);
}
function Jh(t, e) {
  t.length > 42 && (t = t.slice(0, 42));
  const i = t + bv(e.toString(), 48 - t.length, "0");
  return Qv(i);
}
async function oC(t, e, r) {
  return new Promise((n, s) => {
    let i;
    const o = () => {
      i !== void 0 && clearTimeout(i), s(r);
    };
    i = setTimeout(() => {
      e !== void 0 && e.removeEventListener("abort", o), n();
    }, t), e !== void 0 && e.addEventListener("abort", o);
  });
}
function bv(t, e, r = " ") {
  return String.prototype.padStart ? t.padStart(e, r) : (r = r || " ", t.length > e ? t : (e = e - t.length, e > r.length && (r += r.repeat(e / r.length)), r.slice(0, e) + t));
}
function aC(t, e) {
  return t.toLocaleLowerCase() === e.toLocaleLowerCase();
}
function AC(t) {
  const e = new URL(t);
  let r;
  try {
    return e.hostname.split(".")[1] === "blob" ? r = e.hostname.split(".")[0] : qu(e) ? r = e.pathname.split("/")[1] : r = "", r;
  } catch {
    throw new Error("Unable to extract accountName with provided information.");
  }
}
function qu(t) {
  const e = t.host;
  return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(e) || !!t.port && fv.includes(t.port);
}
function Zn(t) {
  if (t === void 0)
    return;
  const e = [];
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const n = t[r];
      e.push(`${encodeURIComponent(r)}=${encodeURIComponent(n)}`);
    }
  return e.join("&");
}
function wv(t) {
  if (t === void 0)
    return;
  const e = {
    blobTagSet: []
  };
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const n = t[r];
      e.blobTagSet.push({
        key: r,
        value: n
      });
    }
  return e;
}
function Ti(t) {
  if (t === void 0)
    return;
  const e = {};
  for (const r of t.blobTagSet)
    e[r.key] = r.value;
  return e;
}
function Vh(t) {
  if (t !== void 0)
    switch (t.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: t.columnSeparator || ",",
              fieldQuote: t.fieldQuote || "",
              recordSeparator: t.recordSeparator,
              escapeChar: t.escapeCharacter || "",
              headersPresent: t.hasHeaders || !1
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: t.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: t.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
}
function jo(t) {
  if (!t || "policy-id" in t)
    return;
  const e = [];
  for (const r in t) {
    const n = r.split("_"), s = "or-";
    n[0].startsWith(s) && (n[0] = n[0].substring(s.length));
    const i = {
      ruleId: n[1],
      replicationStatus: t[r]
    }, o = e.findIndex((c) => c.policyId === n[0]);
    o > -1 ? e[o].rules.push(i) : e.push({
      policyId: n[0],
      rules: [i]
    });
  }
  return e;
}
function Oi(t) {
  return t ? t.scheme + " " + t.value : void 0;
}
function Qs(t) {
  return t.encoded ? decodeURIComponent(t.content) : t.content;
}
function Nv(t) {
  return Object.assign(Object.assign({}, t), { segment: {
    blobItems: t.segment.blobItems.map((e) => Object.assign(Object.assign({}, e), { name: Qs(e.name) }))
  } });
}
function Rv(t) {
  var e;
  return Object.assign(Object.assign({}, t), { segment: {
    blobPrefixes: (e = t.segment.blobPrefixes) === null || e === void 0 ? void 0 : e.map((r) => Object.assign(Object.assign({}, r), { name: Qs(r.name) })),
    blobItems: t.segment.blobItems.map((r) => Object.assign(Object.assign({}, r), { name: Qs(r.name) }))
  } });
}
function* Wh(t) {
  let e = [], r = [];
  t.pageRange && (e = t.pageRange), t.clearRange && (r = t.clearRange);
  let n = 0, s = 0;
  for (; n < e.length && s < r.length; )
    e[n].start < r[s].start ? (yield {
      start: e[n].start,
      end: e[n].end,
      isClear: !1
    }, ++n) : (yield {
      start: r[s].start,
      end: r[s].end,
      isClear: !0
    }, ++s);
  for (; n < e.length; ++n)
    yield {
      start: e[n].start,
      end: e[n].end,
      isClear: !1
    };
  for (; s < r.length; ++s)
    yield {
      start: r[s].start,
      end: r[s].end,
      isClear: !0
    };
}
function xo(t) {
  const e = t.split("/");
  for (let r = 0; r < e.length; r++)
    e[r] = encodeURIComponent(e[r]);
  return e.join("/");
}
function be(t) {
  if ("_response" in t)
    return t;
  throw new TypeError(`Unexpected response object ${t}`);
}
var vs;
(function(t) {
  t[t.EXPONENTIAL = 0] = "EXPONENTIAL", t[t.FIXED = 1] = "FIXED";
})(vs || (vs = {}));
const Nn = {
  maxRetryDelayInMs: 120 * 1e3,
  maxTries: 4,
  retryDelayInMs: 4 * 1e3,
  retryPolicyType: vs.EXPONENTIAL,
  secondaryHost: "",
  tryTimeoutInMs: void 0
  // Use server side default timeout strategy
}, Sv = new Fu("The operation was aborted.");
class cC extends ma {
  /**
   * Creates an instance of RetryPolicy.
   *
   * @param nextPolicy -
   * @param options -
   * @param retryOptions -
   */
  constructor(e, r, n = Nn) {
    super(e, r), this.retryOptions = {
      retryPolicyType: n.retryPolicyType ? n.retryPolicyType : Nn.retryPolicyType,
      maxTries: n.maxTries && n.maxTries >= 1 ? Math.floor(n.maxTries) : Nn.maxTries,
      tryTimeoutInMs: n.tryTimeoutInMs && n.tryTimeoutInMs >= 0 ? n.tryTimeoutInMs : Nn.tryTimeoutInMs,
      retryDelayInMs: n.retryDelayInMs && n.retryDelayInMs >= 0 ? Math.min(n.retryDelayInMs, n.maxRetryDelayInMs ? n.maxRetryDelayInMs : Nn.maxRetryDelayInMs) : Nn.retryDelayInMs,
      maxRetryDelayInMs: n.maxRetryDelayInMs && n.maxRetryDelayInMs >= 0 ? n.maxRetryDelayInMs : Nn.maxRetryDelayInMs,
      secondaryHost: n.secondaryHost ? n.secondaryHost : Nn.secondaryHost
    };
  }
  /**
   * Sends request.
   *
   * @param request -
   */
  async sendRequest(e) {
    return this.attemptSendRequest(e, !1, 1);
  }
  /**
   * Decide and perform next retry. Won't mutate request parameter.
   *
   * @param request -
   * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
   *                                   the resource was not found. This may be due to replication delay. So, in this
   *                                   case, we'll never try the secondary again for this operation.
   * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
   *                                   the attempt will be performed by this method call.
   */
  async attemptSendRequest(e, r, n) {
    const s = e.clone(), i = r || !this.retryOptions.secondaryHost || !(e.method === "GET" || e.method === "HEAD" || e.method === "OPTIONS") || n % 2 === 1;
    i || (s.url = sC(s.url, this.retryOptions.secondaryHost)), this.retryOptions.tryTimeoutInMs && (s.url = En(s.url, Xr.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString()));
    let o;
    try {
      if (qt.info(`RetryPolicy: =====> Try=${n} ${i ? "Primary" : "Secondary"}`), o = await this._nextPolicy.sendRequest(s), !this.shouldRetry(i, n, o))
        return o;
      r = r || !i && o.status === 404;
    } catch (c) {
      if (qt.error(`RetryPolicy: Caught error, message: ${c.message}, code: ${c.code}`), !this.shouldRetry(i, n, o, c))
        throw c;
    }
    return await this.delay(i, n, e.abortSignal), this.attemptSendRequest(e, r, ++n);
  }
  /**
   * Decide whether to retry according to last HTTP response and retry counters.
   *
   * @param isPrimaryRetry -
   * @param attempt -
   * @param response -
   * @param err -
   */
  shouldRetry(e, r, n, s) {
    if (r >= this.retryOptions.maxTries)
      return qt.info(`RetryPolicy: Attempt(s) ${r} >= maxTries ${this.retryOptions.maxTries}, no further try.`), !1;
    const i = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
      // For default xhr based http client provided in ms-rest-js
    ];
    if (s) {
      for (const o of i)
        if (s.name.toUpperCase().includes(o) || s.message.toUpperCase().includes(o) || s.code && s.code.toString().toUpperCase() === o)
          return qt.info(`RetryPolicy: Network error ${o} found, will retry.`), !0;
    }
    if (n || s) {
      const o = n ? n.status : s ? s.statusCode : 0;
      if (!e && o === 404)
        return qt.info("RetryPolicy: Secondary access with 404, will retry."), !0;
      if (o === 503 || o === 500)
        return qt.info(`RetryPolicy: Will retry for status code ${o}.`), !0;
    }
    return s?.code === "PARSE_ERROR" && s?.message.startsWith('Error "Error: Unclosed root tag') ? (qt.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0) : !1;
  }
  /**
   * Delay a calculated time between retries.
   *
   * @param isPrimaryRetry -
   * @param attempt -
   * @param abortSignal -
   */
  async delay(e, r, n) {
    let s = 0;
    if (e)
      switch (this.retryOptions.retryPolicyType) {
        case vs.EXPONENTIAL:
          s = Math.min((Math.pow(2, r - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
          break;
        case vs.FIXED:
          s = this.retryOptions.retryDelayInMs;
          break;
      }
    else
      s = Math.random() * 1e3;
    return qt.info(`RetryPolicy: Delay for ${s}ms`), oC(s, n, Sv);
  }
}
class lC {
  /**
   * Creates an instance of StorageRetryPolicyFactory.
   * @param retryOptions -
   */
  constructor(e) {
    this.retryOptions = e;
  }
  /**
   * Creates a StorageRetryPolicy object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new cC(e, r, this.retryOptions);
  }
}
class wt {
}
class uC extends ma {
  /**
   * Sends out request.
   *
   * @param request -
   */
  sendRequest(e) {
    return this._nextPolicy.sendRequest(this.signRequest(e));
  }
  /**
   * Child classes must implement this method with request signing. This method
   * will be executed in {@link sendRequest}.
   *
   * @param request -
   */
  signRequest(e) {
    return e;
  }
}
class dC extends uC {
  /**
   * Creates an instance of AnonymousCredentialPolicy.
   * @param nextPolicy -
   * @param options -
   */
  // The base class has a protected constructor. Adding a public one to enable constructing of this class.
  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
  constructor(e, r) {
    super(e, r);
  }
}
class gC {
  /**
   * Creates a RequestPolicy object.
   *
   * @param _nextPolicy -
   * @param _options -
   */
  create(e, r) {
    throw new Error("Method should be implemented in children classes.");
  }
}
class Qt extends gC {
  /**
   * Creates an {@link AnonymousCredentialPolicy} object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new dC(e, r);
  }
}
let _c;
function vv() {
  return _c || (_c = FE()), _c;
}
const xv = "storageBrowserPolicy";
function Dv() {
  return {
    name: xv,
    async sendRequest(t, e) {
      return Mt || ((t.method === "GET" || t.method === "HEAD") && (t.url = En(t.url, Xr.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString())), t.headers.delete(An.COOKIE), t.headers.delete(An.CONTENT_LENGTH)), e(t);
    }
  };
}
const Tv = "storageRetryPolicy";
var Gi;
(function(t) {
  t[t.EXPONENTIAL = 0] = "EXPONENTIAL", t[t.FIXED = 1] = "FIXED";
})(Gi || (Gi = {}));
const ms = {
  maxRetryDelayInMs: 120 * 1e3,
  maxTries: 4,
  retryDelayInMs: 4 * 1e3,
  retryPolicyType: Gi.EXPONENTIAL,
  secondaryHost: "",
  tryTimeoutInMs: void 0
  // Use server side default timeout strategy
}, kv = [
  "ETIMEDOUT",
  "ESOCKETTIMEDOUT",
  "ECONNREFUSED",
  "ECONNRESET",
  "ENOENT",
  "ENOTFOUND",
  "TIMEOUT",
  "EPIPE",
  "REQUEST_SEND_ERROR"
], Fv = new Fu("The operation was aborted.");
function Pv(t = {}) {
  var e, r, n, s, i, o;
  const c = (e = t.retryPolicyType) !== null && e !== void 0 ? e : ms.retryPolicyType, l = (r = t.maxTries) !== null && r !== void 0 ? r : ms.maxTries, A = (n = t.retryDelayInMs) !== null && n !== void 0 ? n : ms.retryDelayInMs, a = (s = t.maxRetryDelayInMs) !== null && s !== void 0 ? s : ms.maxRetryDelayInMs, u = (i = t.secondaryHost) !== null && i !== void 0 ? i : ms.secondaryHost, g = (o = t.tryTimeoutInMs) !== null && o !== void 0 ? o : ms.tryTimeoutInMs;
  function h({ isPrimaryRetry: d, attempt: p, response: E, error: B }) {
    var y, Q;
    if (p >= l)
      return qt.info(`RetryPolicy: Attempt(s) ${p} >= maxTries ${l}, no further try.`), !1;
    if (B) {
      for (const I of kv)
        if (B.name.toUpperCase().includes(I) || B.message.toUpperCase().includes(I) || B.code && B.code.toString().toUpperCase() === I)
          return qt.info(`RetryPolicy: Network error ${I} found, will retry.`), !0;
      if (B?.code === "PARSE_ERROR" && B?.message.startsWith('Error "Error: Unclosed root tag'))
        return qt.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0;
    }
    if (E || B) {
      const I = (Q = (y = E?.status) !== null && y !== void 0 ? y : B?.statusCode) !== null && Q !== void 0 ? Q : 0;
      if (!d && I === 404)
        return qt.info("RetryPolicy: Secondary access with 404, will retry."), !0;
      if (I === 503 || I === 500)
        return qt.info(`RetryPolicy: Will retry for status code ${I}.`), !0;
    }
    return !1;
  }
  function m(d, p) {
    let E = 0;
    if (d)
      switch (c) {
        case Gi.EXPONENTIAL:
          E = Math.min((Math.pow(2, p - 1) - 1) * A, a);
          break;
        case Gi.FIXED:
          E = A;
          break;
      }
    else
      E = Math.random() * 1e3;
    return qt.info(`RetryPolicy: Delay for ${E}ms`), E;
  }
  return {
    name: Tv,
    async sendRequest(d, p) {
      g && (d.url = En(d.url, Xr.Parameters.TIMEOUT, String(Math.floor(g / 1e3))));
      const E = d.url, B = u ? sC(d.url, u) : void 0;
      let y = !1, Q = 1, I = !0, w, f;
      for (; I; ) {
        const C = y || !B || !["GET", "HEAD", "OPTIONS"].includes(d.method) || Q % 2 === 1;
        d.url = C ? E : B, w = void 0, f = void 0;
        try {
          qt.info(`RetryPolicy: =====> Try=${Q} ${C ? "Primary" : "Secondary"}`), w = await p(d), y = y || !C && w.status === 404;
        } catch (b) {
          if (Pu(b))
            qt.error(`RetryPolicy: Caught error, message: ${b.message}, code: ${b.code}`), f = b;
          else
            throw qt.error(`RetryPolicy: Caught error, message: ${io(b)}`), b;
        }
        I = h({ isPrimaryRetry: C, attempt: Q, response: w, error: f }), I && await oC(m(C, Q), d.abortSignal, Fv), Q++;
      }
      if (w)
        return w;
      throw f ?? new Ns("RetryPolicy failed without known error.");
    }
  };
}
const Uv = "storageSharedKeyCredentialPolicy";
function mC(t) {
  return {
    name: Uv,
    async sendRequest(e, r) {
      return r(e);
    }
  };
}
class hC extends ma {
  /**
   * Creates an instance of StorageBrowserPolicy.
   * @param nextPolicy -
   * @param options -
   */
  // The base class has a protected constructor. Adding a public one to enable constructing of this class.
  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
  constructor(e, r) {
    super(e, r);
  }
  /**
   * Sends out request.
   *
   * @param request -
   */
  async sendRequest(e) {
    return Mt ? this._nextPolicy.sendRequest(e) : ((e.method.toUpperCase() === "GET" || e.method.toUpperCase() === "HEAD") && (e.url = En(e.url, Xr.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString())), e.headers.remove(An.COOKIE), e.headers.remove(An.CONTENT_LENGTH), this._nextPolicy.sendRequest(e));
  }
}
class pC {
  /**
   * Creates a StorageBrowserPolicyFactory object.
   *
   * @param nextPolicy -
   * @param options -
   */
  create(e, r) {
    return new hC(e, r);
  }
}
const Lv = "StorageCorrectContentLengthPolicy";
function _v() {
  return {
    name: Lv,
    async sendRequest(t, e) {
      return e(t);
    }
  };
}
function Fn(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = t;
  return Array.isArray(e.factories) && typeof e.options == "object" && typeof e.toServiceClientOptions == "function";
}
class Hu {
  /**
   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
   *
   * @param factories -
   * @param options -
   */
  constructor(e, r = {}) {
    this.factories = e, this.options = r;
  }
  /**
   * Transfer Pipeline object to ServiceClientOptions object which is required by
   * ServiceClient constructor.
   *
   * @returns The ServiceClientOptions object from this Pipeline.
   */
  toServiceClientOptions() {
    return {
      httpClient: this.options.httpClient,
      requestPolicyFactories: this.factories
    };
  }
}
function ht(t, e = {}) {
  t || (t = new Qt());
  const r = new Hu([], e);
  return r._credential = t, r;
}
function Mv(t) {
  const e = [
    Ov,
    CC,
    Gv,
    qv,
    Hv,
    zv,
    Jv
  ];
  if (t.factories.length) {
    const r = t.factories.filter((n) => !e.some((s) => s(n)));
    if (r.length) {
      const n = r.some((s) => Yv(s));
      return {
        wrappedPolicies: ZS(r),
        afterRetry: n
      };
    }
  }
}
function fC(t) {
  var e;
  const r = t.options, { httpClient: n } = r, s = _0(r, ["httpClient"]);
  let i = t._coreHttpClient;
  i || (i = n ? ev(n) : vv(), t._coreHttpClient = i);
  let o = t._corePipeline;
  if (!o) {
    const c = `azsdk-js-azure-storage-blob/${tC}`, l = s.userAgentOptions && s.userAgentOptions.userAgentPrefix ? `${s.userAgentOptions.userAgentPrefix} ${c}` : `${c}`;
    o = YE(Object.assign(Object.assign({}, s), { loggingOptions: {
      additionalAllowedHeaderNames: gv,
      additionalAllowedQueryParameters: mv,
      logger: qt.info
    }, userAgentOptions: {
      userAgentPrefix: l
    }, serializationOptions: {
      stringifyXML: eC,
      serializerOptions: {
        xml: {
          // Use customized XML char key of "#" so we can deserialize metadata
          // with "_" key
          xmlCharKey: "#"
        }
      }
    }, deserializationOptions: {
      parseXML: tv,
      serializerOptions: {
        xml: {
          // Use customized XML char key of "#" so we can deserialize metadata
          // with "_" key
          xmlCharKey: "#"
        }
      }
    } })), o.removePolicy({ phase: "Retry" }), o.removePolicy({ name: u0 }), o.addPolicy(_v()), o.addPolicy(Pv(s.retryOptions), { phase: "Retry" }), o.addPolicy(Dv());
    const A = Mv(t);
    A && o.addPolicy(A.wrappedPolicies, A.afterRetry ? { afterPhase: "Retry" } : void 0);
    const a = EC(t);
    Or(a) ? o.addPolicy(Uu({
      credential: a,
      scopes: (e = s.audience) !== null && e !== void 0 ? e : Gu,
      challengeCallbacks: { authorizeRequestOnChallenge: VE }
    }), { phase: "Sign" }) : a instanceof wt && o.addPolicy(mC({
      accountName: a.accountName,
      accountKey: a.accountKey
    }), { phase: "Sign" }), t._corePipeline = o;
  }
  return Object.assign(Object.assign({}, s), { allowInsecureConnection: !0, httpClient: i, pipeline: o });
}
function EC(t) {
  if (t._credential)
    return t._credential;
  let e = new Qt();
  for (const r of t.factories)
    if (Or(r.credential))
      e = r.credential;
    else if (CC(r))
      return r;
  return e;
}
function CC(t) {
  return t instanceof wt ? !0 : t.constructor.name === "StorageSharedKeyCredential";
}
function Ov(t) {
  return t instanceof Qt ? !0 : t.constructor.name === "AnonymousCredential";
}
function Gv(t) {
  return Or(t.credential);
}
function qv(t) {
  return t instanceof pC ? !0 : t.constructor.name === "StorageBrowserPolicyFactory";
}
function Hv(t) {
  return t instanceof lC ? !0 : t.constructor.name === "StorageRetryPolicyFactory";
}
function zv(t) {
  return t.constructor.name === "TelemetryPolicyFactory";
}
function Yv(t) {
  return t.constructor.name === "InjectorPolicyFactory";
}
function Jv(t) {
  const e = [
    "GenerateClientRequestIdPolicy",
    "TracingPolicy",
    "LogPolicy",
    "ProxyPolicy",
    "DisableResponseDecompressionPolicy",
    "KeepAlivePolicy",
    "DeserializationPolicy"
  ], r = {
    sendRequest: async (o) => ({
      request: o,
      headers: o.headers.clone(),
      status: 500
    })
  }, n = {
    log(o, c) {
    },
    shouldLog(o) {
      return !1;
    }
  }, i = t.create(r, n).constructor.name;
  return e.some((o) => i.startsWith(o));
}
const zu = {
  serializedName: "BlobServiceProperties",
  xmlName: "StorageServiceProperties",
  type: {
    name: "Composite",
    className: "BlobServiceProperties",
    modelProperties: {
      blobAnalyticsLogging: {
        serializedName: "Logging",
        xmlName: "Logging",
        type: {
          name: "Composite",
          className: "Logging"
        }
      },
      hourMetrics: {
        serializedName: "HourMetrics",
        xmlName: "HourMetrics",
        type: {
          name: "Composite",
          className: "Metrics"
        }
      },
      minuteMetrics: {
        serializedName: "MinuteMetrics",
        xmlName: "MinuteMetrics",
        type: {
          name: "Composite",
          className: "Metrics"
        }
      },
      cors: {
        serializedName: "Cors",
        xmlName: "Cors",
        xmlIsWrapped: !0,
        xmlElementName: "CorsRule",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CorsRule"
            }
          }
        }
      },
      defaultServiceVersion: {
        serializedName: "DefaultServiceVersion",
        xmlName: "DefaultServiceVersion",
        type: {
          name: "String"
        }
      },
      deleteRetentionPolicy: {
        serializedName: "DeleteRetentionPolicy",
        xmlName: "DeleteRetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      },
      staticWebsite: {
        serializedName: "StaticWebsite",
        xmlName: "StaticWebsite",
        type: {
          name: "Composite",
          className: "StaticWebsite"
        }
      }
    }
  }
}, Vv = {
  serializedName: "Logging",
  type: {
    name: "Composite",
    className: "Logging",
    modelProperties: {
      version: {
        serializedName: "Version",
        required: !0,
        xmlName: "Version",
        type: {
          name: "String"
        }
      },
      deleteProperty: {
        serializedName: "Delete",
        required: !0,
        xmlName: "Delete",
        type: {
          name: "Boolean"
        }
      },
      read: {
        serializedName: "Read",
        required: !0,
        xmlName: "Read",
        type: {
          name: "Boolean"
        }
      },
      write: {
        serializedName: "Write",
        required: !0,
        xmlName: "Write",
        type: {
          name: "Boolean"
        }
      },
      retentionPolicy: {
        serializedName: "RetentionPolicy",
        xmlName: "RetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      }
    }
  }
}, Wv = {
  serializedName: "RetentionPolicy",
  type: {
    name: "Composite",
    className: "RetentionPolicy",
    modelProperties: {
      enabled: {
        serializedName: "Enabled",
        required: !0,
        xmlName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      days: {
        constraints: {
          InclusiveMinimum: 1
        },
        serializedName: "Days",
        xmlName: "Days",
        type: {
          name: "Number"
        }
      }
    }
  }
}, jv = {
  serializedName: "Metrics",
  type: {
    name: "Composite",
    className: "Metrics",
    modelProperties: {
      version: {
        serializedName: "Version",
        xmlName: "Version",
        type: {
          name: "String"
        }
      },
      enabled: {
        serializedName: "Enabled",
        required: !0,
        xmlName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      includeAPIs: {
        serializedName: "IncludeAPIs",
        xmlName: "IncludeAPIs",
        type: {
          name: "Boolean"
        }
      },
      retentionPolicy: {
        serializedName: "RetentionPolicy",
        xmlName: "RetentionPolicy",
        type: {
          name: "Composite",
          className: "RetentionPolicy"
        }
      }
    }
  }
}, $v = {
  serializedName: "CorsRule",
  type: {
    name: "Composite",
    className: "CorsRule",
    modelProperties: {
      allowedOrigins: {
        serializedName: "AllowedOrigins",
        required: !0,
        xmlName: "AllowedOrigins",
        type: {
          name: "String"
        }
      },
      allowedMethods: {
        serializedName: "AllowedMethods",
        required: !0,
        xmlName: "AllowedMethods",
        type: {
          name: "String"
        }
      },
      allowedHeaders: {
        serializedName: "AllowedHeaders",
        required: !0,
        xmlName: "AllowedHeaders",
        type: {
          name: "String"
        }
      },
      exposedHeaders: {
        serializedName: "ExposedHeaders",
        required: !0,
        xmlName: "ExposedHeaders",
        type: {
          name: "String"
        }
      },
      maxAgeInSeconds: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "MaxAgeInSeconds",
        required: !0,
        xmlName: "MaxAgeInSeconds",
        type: {
          name: "Number"
        }
      }
    }
  }
}, Xv = {
  serializedName: "StaticWebsite",
  type: {
    name: "Composite",
    className: "StaticWebsite",
    modelProperties: {
      enabled: {
        serializedName: "Enabled",
        required: !0,
        xmlName: "Enabled",
        type: {
          name: "Boolean"
        }
      },
      indexDocument: {
        serializedName: "IndexDocument",
        xmlName: "IndexDocument",
        type: {
          name: "String"
        }
      },
      errorDocument404Path: {
        serializedName: "ErrorDocument404Path",
        xmlName: "ErrorDocument404Path",
        type: {
          name: "String"
        }
      },
      defaultIndexDocumentPath: {
        serializedName: "DefaultIndexDocumentPath",
        xmlName: "DefaultIndexDocumentPath",
        type: {
          name: "String"
        }
      }
    }
  }
}, ye = {
  serializedName: "StorageError",
  type: {
    name: "Composite",
    className: "StorageError",
    modelProperties: {
      message: {
        serializedName: "Message",
        xmlName: "Message",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "Code",
        xmlName: "Code",
        type: {
          name: "String"
        }
      },
      authenticationErrorDetail: {
        serializedName: "AuthenticationErrorDetail",
        xmlName: "AuthenticationErrorDetail",
        type: {
          name: "String"
        }
      }
    }
  }
}, BC = {
  serializedName: "BlobServiceStatistics",
  xmlName: "StorageServiceStats",
  type: {
    name: "Composite",
    className: "BlobServiceStatistics",
    modelProperties: {
      geoReplication: {
        serializedName: "GeoReplication",
        xmlName: "GeoReplication",
        type: {
          name: "Composite",
          className: "GeoReplication"
        }
      }
    }
  }
}, Kv = {
  serializedName: "GeoReplication",
  type: {
    name: "Composite",
    className: "GeoReplication",
    modelProperties: {
      status: {
        serializedName: "Status",
        required: !0,
        xmlName: "Status",
        type: {
          name: "Enum",
          allowedValues: ["live", "bootstrap", "unavailable"]
        }
      },
      lastSyncOn: {
        serializedName: "LastSyncTime",
        required: !0,
        xmlName: "LastSyncTime",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, IC = {
  serializedName: "ListContainersSegmentResponse",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "ListContainersSegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      prefix: {
        serializedName: "Prefix",
        xmlName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        serializedName: "Marker",
        xmlName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        serializedName: "MaxResults",
        xmlName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      containerItems: {
        serializedName: "ContainerItems",
        required: !0,
        xmlName: "Containers",
        xmlIsWrapped: !0,
        xmlElementName: "Container",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContainerItem"
            }
          }
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, Zv = {
  serializedName: "ContainerItem",
  xmlName: "Container",
  type: {
    name: "Composite",
    className: "ContainerItem",
    modelProperties: {
      name: {
        serializedName: "Name",
        required: !0,
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      deleted: {
        serializedName: "Deleted",
        xmlName: "Deleted",
        type: {
          name: "Boolean"
        }
      },
      version: {
        serializedName: "Version",
        xmlName: "Version",
        type: {
          name: "String"
        }
      },
      properties: {
        serializedName: "Properties",
        xmlName: "Properties",
        type: {
          name: "Composite",
          className: "ContainerProperties"
        }
      },
      metadata: {
        serializedName: "Metadata",
        xmlName: "Metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      }
    }
  }
}, ex = {
  serializedName: "ContainerProperties",
  type: {
    name: "Composite",
    className: "ContainerProperties",
    modelProperties: {
      lastModified: {
        serializedName: "Last-Modified",
        required: !0,
        xmlName: "Last-Modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "Etag",
        required: !0,
        xmlName: "Etag",
        type: {
          name: "String"
        }
      },
      leaseStatus: {
        serializedName: "LeaseStatus",
        xmlName: "LeaseStatus",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      leaseState: {
        serializedName: "LeaseState",
        xmlName: "LeaseState",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseDuration: {
        serializedName: "LeaseDuration",
        xmlName: "LeaseDuration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      publicAccess: {
        serializedName: "PublicAccess",
        xmlName: "PublicAccess",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      },
      hasImmutabilityPolicy: {
        serializedName: "HasImmutabilityPolicy",
        xmlName: "HasImmutabilityPolicy",
        type: {
          name: "Boolean"
        }
      },
      hasLegalHold: {
        serializedName: "HasLegalHold",
        xmlName: "HasLegalHold",
        type: {
          name: "Boolean"
        }
      },
      defaultEncryptionScope: {
        serializedName: "DefaultEncryptionScope",
        xmlName: "DefaultEncryptionScope",
        type: {
          name: "String"
        }
      },
      preventEncryptionScopeOverride: {
        serializedName: "DenyEncryptionScopeOverride",
        xmlName: "DenyEncryptionScopeOverride",
        type: {
          name: "Boolean"
        }
      },
      deletedOn: {
        serializedName: "DeletedTime",
        xmlName: "DeletedTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      remainingRetentionDays: {
        serializedName: "RemainingRetentionDays",
        xmlName: "RemainingRetentionDays",
        type: {
          name: "Number"
        }
      },
      isImmutableStorageWithVersioningEnabled: {
        serializedName: "ImmutableStorageWithVersioningEnabled",
        xmlName: "ImmutableStorageWithVersioningEnabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, yC = {
  serializedName: "KeyInfo",
  type: {
    name: "Composite",
    className: "KeyInfo",
    modelProperties: {
      startsOn: {
        serializedName: "Start",
        required: !0,
        xmlName: "Start",
        type: {
          name: "String"
        }
      },
      expiresOn: {
        serializedName: "Expiry",
        required: !0,
        xmlName: "Expiry",
        type: {
          name: "String"
        }
      }
    }
  }
}, QC = {
  serializedName: "UserDelegationKey",
  type: {
    name: "Composite",
    className: "UserDelegationKey",
    modelProperties: {
      signedObjectId: {
        serializedName: "SignedOid",
        required: !0,
        xmlName: "SignedOid",
        type: {
          name: "String"
        }
      },
      signedTenantId: {
        serializedName: "SignedTid",
        required: !0,
        xmlName: "SignedTid",
        type: {
          name: "String"
        }
      },
      signedStartsOn: {
        serializedName: "SignedStart",
        required: !0,
        xmlName: "SignedStart",
        type: {
          name: "String"
        }
      },
      signedExpiresOn: {
        serializedName: "SignedExpiry",
        required: !0,
        xmlName: "SignedExpiry",
        type: {
          name: "String"
        }
      },
      signedService: {
        serializedName: "SignedService",
        required: !0,
        xmlName: "SignedService",
        type: {
          name: "String"
        }
      },
      signedVersion: {
        serializedName: "SignedVersion",
        required: !0,
        xmlName: "SignedVersion",
        type: {
          name: "String"
        }
      },
      value: {
        serializedName: "Value",
        required: !0,
        xmlName: "Value",
        type: {
          name: "String"
        }
      }
    }
  }
}, Yu = {
  serializedName: "FilterBlobSegment",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "FilterBlobSegment",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      where: {
        serializedName: "Where",
        required: !0,
        xmlName: "Where",
        type: {
          name: "String"
        }
      },
      blobs: {
        serializedName: "Blobs",
        required: !0,
        xmlName: "Blobs",
        xmlIsWrapped: !0,
        xmlElementName: "Blob",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "FilterBlobItem"
            }
          }
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, tx = {
  serializedName: "FilterBlobItem",
  xmlName: "Blob",
  type: {
    name: "Composite",
    className: "FilterBlobItem",
    modelProperties: {
      name: {
        serializedName: "Name",
        required: !0,
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      containerName: {
        serializedName: "ContainerName",
        required: !0,
        xmlName: "ContainerName",
        type: {
          name: "String"
        }
      },
      tags: {
        serializedName: "Tags",
        xmlName: "Tags",
        type: {
          name: "Composite",
          className: "BlobTags"
        }
      }
    }
  }
}, Ju = {
  serializedName: "BlobTags",
  xmlName: "Tags",
  type: {
    name: "Composite",
    className: "BlobTags",
    modelProperties: {
      blobTagSet: {
        serializedName: "BlobTagSet",
        required: !0,
        xmlName: "TagSet",
        xmlIsWrapped: !0,
        xmlElementName: "Tag",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobTag"
            }
          }
        }
      }
    }
  }
}, rx = {
  serializedName: "BlobTag",
  xmlName: "Tag",
  type: {
    name: "Composite",
    className: "BlobTag",
    modelProperties: {
      key: {
        serializedName: "Key",
        required: !0,
        xmlName: "Key",
        type: {
          name: "String"
        }
      },
      value: {
        serializedName: "Value",
        required: !0,
        xmlName: "Value",
        type: {
          name: "String"
        }
      }
    }
  }
}, nx = {
  serializedName: "SignedIdentifier",
  xmlName: "SignedIdentifier",
  type: {
    name: "Composite",
    className: "SignedIdentifier",
    modelProperties: {
      id: {
        serializedName: "Id",
        required: !0,
        xmlName: "Id",
        type: {
          name: "String"
        }
      },
      accessPolicy: {
        serializedName: "AccessPolicy",
        xmlName: "AccessPolicy",
        type: {
          name: "Composite",
          className: "AccessPolicy"
        }
      }
    }
  }
}, sx = {
  serializedName: "AccessPolicy",
  type: {
    name: "Composite",
    className: "AccessPolicy",
    modelProperties: {
      startsOn: {
        serializedName: "Start",
        xmlName: "Start",
        type: {
          name: "String"
        }
      },
      expiresOn: {
        serializedName: "Expiry",
        xmlName: "Expiry",
        type: {
          name: "String"
        }
      },
      permissions: {
        serializedName: "Permission",
        xmlName: "Permission",
        type: {
          name: "String"
        }
      }
    }
  }
}, bC = {
  serializedName: "ListBlobsFlatSegmentResponse",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "ListBlobsFlatSegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      containerName: {
        serializedName: "ContainerName",
        required: !0,
        xmlName: "ContainerName",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      prefix: {
        serializedName: "Prefix",
        xmlName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        serializedName: "Marker",
        xmlName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        serializedName: "MaxResults",
        xmlName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      segment: {
        serializedName: "Segment",
        xmlName: "Blobs",
        type: {
          name: "Composite",
          className: "BlobFlatListSegment"
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, ix = {
  serializedName: "BlobFlatListSegment",
  xmlName: "Blobs",
  type: {
    name: "Composite",
    className: "BlobFlatListSegment",
    modelProperties: {
      blobItems: {
        serializedName: "BlobItems",
        required: !0,
        xmlName: "BlobItems",
        xmlElementName: "Blob",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobItemInternal"
            }
          }
        }
      }
    }
  }
}, ox = {
  serializedName: "BlobItemInternal",
  xmlName: "Blob",
  type: {
    name: "Composite",
    className: "BlobItemInternal",
    modelProperties: {
      name: {
        serializedName: "Name",
        xmlName: "Name",
        type: {
          name: "Composite",
          className: "BlobName"
        }
      },
      deleted: {
        serializedName: "Deleted",
        required: !0,
        xmlName: "Deleted",
        type: {
          name: "Boolean"
        }
      },
      snapshot: {
        serializedName: "Snapshot",
        required: !0,
        xmlName: "Snapshot",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "VersionId",
        xmlName: "VersionId",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "IsCurrentVersion",
        xmlName: "IsCurrentVersion",
        type: {
          name: "Boolean"
        }
      },
      properties: {
        serializedName: "Properties",
        xmlName: "Properties",
        type: {
          name: "Composite",
          className: "BlobPropertiesInternal"
        }
      },
      metadata: {
        serializedName: "Metadata",
        xmlName: "Metadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      blobTags: {
        serializedName: "BlobTags",
        xmlName: "Tags",
        type: {
          name: "Composite",
          className: "BlobTags"
        }
      },
      objectReplicationMetadata: {
        serializedName: "ObjectReplicationMetadata",
        xmlName: "OrMetadata",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      hasVersionsOnly: {
        serializedName: "HasVersionsOnly",
        xmlName: "HasVersionsOnly",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, ax = {
  serializedName: "BlobName",
  type: {
    name: "Composite",
    className: "BlobName",
    modelProperties: {
      encoded: {
        serializedName: "Encoded",
        xmlName: "Encoded",
        xmlIsAttribute: !0,
        type: {
          name: "Boolean"
        }
      },
      content: {
        serializedName: "content",
        xmlName: "content",
        xmlIsMsText: !0,
        type: {
          name: "String"
        }
      }
    }
  }
}, Ax = {
  serializedName: "BlobPropertiesInternal",
  xmlName: "Properties",
  type: {
    name: "Composite",
    className: "BlobPropertiesInternal",
    modelProperties: {
      createdOn: {
        serializedName: "Creation-Time",
        xmlName: "Creation-Time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      lastModified: {
        serializedName: "Last-Modified",
        required: !0,
        xmlName: "Last-Modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "Etag",
        required: !0,
        xmlName: "Etag",
        type: {
          name: "String"
        }
      },
      contentLength: {
        serializedName: "Content-Length",
        xmlName: "Content-Length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "Content-Type",
        xmlName: "Content-Type",
        type: {
          name: "String"
        }
      },
      contentEncoding: {
        serializedName: "Content-Encoding",
        xmlName: "Content-Encoding",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "Content-Language",
        xmlName: "Content-Language",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "Content-MD5",
        xmlName: "Content-MD5",
        type: {
          name: "ByteArray"
        }
      },
      contentDisposition: {
        serializedName: "Content-Disposition",
        xmlName: "Content-Disposition",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "Cache-Control",
        xmlName: "Cache-Control",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "BlobType",
        xmlName: "BlobType",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      leaseStatus: {
        serializedName: "LeaseStatus",
        xmlName: "LeaseStatus",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      leaseState: {
        serializedName: "LeaseState",
        xmlName: "LeaseState",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseDuration: {
        serializedName: "LeaseDuration",
        xmlName: "LeaseDuration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      copyId: {
        serializedName: "CopyId",
        xmlName: "CopyId",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "CopyStatus",
        xmlName: "CopyStatus",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      copySource: {
        serializedName: "CopySource",
        xmlName: "CopySource",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "CopyProgress",
        xmlName: "CopyProgress",
        type: {
          name: "String"
        }
      },
      copyCompletedOn: {
        serializedName: "CopyCompletionTime",
        xmlName: "CopyCompletionTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "CopyStatusDescription",
        xmlName: "CopyStatusDescription",
        type: {
          name: "String"
        }
      },
      serverEncrypted: {
        serializedName: "ServerEncrypted",
        xmlName: "ServerEncrypted",
        type: {
          name: "Boolean"
        }
      },
      incrementalCopy: {
        serializedName: "IncrementalCopy",
        xmlName: "IncrementalCopy",
        type: {
          name: "Boolean"
        }
      },
      destinationSnapshot: {
        serializedName: "DestinationSnapshot",
        xmlName: "DestinationSnapshot",
        type: {
          name: "String"
        }
      },
      deletedOn: {
        serializedName: "DeletedTime",
        xmlName: "DeletedTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      remainingRetentionDays: {
        serializedName: "RemainingRetentionDays",
        xmlName: "RemainingRetentionDays",
        type: {
          name: "Number"
        }
      },
      accessTier: {
        serializedName: "AccessTier",
        xmlName: "AccessTier",
        type: {
          name: "Enum",
          allowedValues: [
            "P4",
            "P6",
            "P10",
            "P15",
            "P20",
            "P30",
            "P40",
            "P50",
            "P60",
            "P70",
            "P80",
            "Hot",
            "Cool",
            "Archive",
            "Cold"
          ]
        }
      },
      accessTierInferred: {
        serializedName: "AccessTierInferred",
        xmlName: "AccessTierInferred",
        type: {
          name: "Boolean"
        }
      },
      archiveStatus: {
        serializedName: "ArchiveStatus",
        xmlName: "ArchiveStatus",
        type: {
          name: "Enum",
          allowedValues: [
            "rehydrate-pending-to-hot",
            "rehydrate-pending-to-cool",
            "rehydrate-pending-to-cold"
          ]
        }
      },
      customerProvidedKeySha256: {
        serializedName: "CustomerProvidedKeySha256",
        xmlName: "CustomerProvidedKeySha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "EncryptionScope",
        xmlName: "EncryptionScope",
        type: {
          name: "String"
        }
      },
      accessTierChangedOn: {
        serializedName: "AccessTierChangeTime",
        xmlName: "AccessTierChangeTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      tagCount: {
        serializedName: "TagCount",
        xmlName: "TagCount",
        type: {
          name: "Number"
        }
      },
      expiresOn: {
        serializedName: "Expiry-Time",
        xmlName: "Expiry-Time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "Sealed",
        xmlName: "Sealed",
        type: {
          name: "Boolean"
        }
      },
      rehydratePriority: {
        serializedName: "RehydratePriority",
        xmlName: "RehydratePriority",
        type: {
          name: "Enum",
          allowedValues: ["High", "Standard"]
        }
      },
      lastAccessedOn: {
        serializedName: "LastAccessTime",
        xmlName: "LastAccessTime",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiresOn: {
        serializedName: "ImmutabilityPolicyUntilDate",
        xmlName: "ImmutabilityPolicyUntilDate",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "ImmutabilityPolicyMode",
        xmlName: "ImmutabilityPolicyMode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      },
      legalHold: {
        serializedName: "LegalHold",
        xmlName: "LegalHold",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, wC = {
  serializedName: "ListBlobsHierarchySegmentResponse",
  xmlName: "EnumerationResults",
  type: {
    name: "Composite",
    className: "ListBlobsHierarchySegmentResponse",
    modelProperties: {
      serviceEndpoint: {
        serializedName: "ServiceEndpoint",
        required: !0,
        xmlName: "ServiceEndpoint",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      containerName: {
        serializedName: "ContainerName",
        required: !0,
        xmlName: "ContainerName",
        xmlIsAttribute: !0,
        type: {
          name: "String"
        }
      },
      prefix: {
        serializedName: "Prefix",
        xmlName: "Prefix",
        type: {
          name: "String"
        }
      },
      marker: {
        serializedName: "Marker",
        xmlName: "Marker",
        type: {
          name: "String"
        }
      },
      maxPageSize: {
        serializedName: "MaxResults",
        xmlName: "MaxResults",
        type: {
          name: "Number"
        }
      },
      delimiter: {
        serializedName: "Delimiter",
        xmlName: "Delimiter",
        type: {
          name: "String"
        }
      },
      segment: {
        serializedName: "Segment",
        xmlName: "Blobs",
        type: {
          name: "Composite",
          className: "BlobHierarchyListSegment"
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, cx = {
  serializedName: "BlobHierarchyListSegment",
  xmlName: "Blobs",
  type: {
    name: "Composite",
    className: "BlobHierarchyListSegment",
    modelProperties: {
      blobPrefixes: {
        serializedName: "BlobPrefixes",
        xmlName: "BlobPrefixes",
        xmlElementName: "BlobPrefix",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobPrefix"
            }
          }
        }
      },
      blobItems: {
        serializedName: "BlobItems",
        required: !0,
        xmlName: "BlobItems",
        xmlElementName: "Blob",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BlobItemInternal"
            }
          }
        }
      }
    }
  }
}, lx = {
  serializedName: "BlobPrefix",
  type: {
    name: "Composite",
    className: "BlobPrefix",
    modelProperties: {
      name: {
        serializedName: "Name",
        xmlName: "Name",
        type: {
          name: "Composite",
          className: "BlobName"
        }
      }
    }
  }
}, NC = {
  serializedName: "BlockLookupList",
  xmlName: "BlockList",
  type: {
    name: "Composite",
    className: "BlockLookupList",
    modelProperties: {
      committed: {
        serializedName: "Committed",
        xmlName: "Committed",
        xmlElementName: "Committed",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      uncommitted: {
        serializedName: "Uncommitted",
        xmlName: "Uncommitted",
        xmlElementName: "Uncommitted",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      latest: {
        serializedName: "Latest",
        xmlName: "Latest",
        xmlElementName: "Latest",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
}, RC = {
  serializedName: "BlockList",
  type: {
    name: "Composite",
    className: "BlockList",
    modelProperties: {
      committedBlocks: {
        serializedName: "CommittedBlocks",
        xmlName: "CommittedBlocks",
        xmlIsWrapped: !0,
        xmlElementName: "Block",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      },
      uncommittedBlocks: {
        serializedName: "UncommittedBlocks",
        xmlName: "UncommittedBlocks",
        xmlIsWrapped: !0,
        xmlElementName: "Block",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      }
    }
  }
}, ux = {
  serializedName: "Block",
  type: {
    name: "Composite",
    className: "Block",
    modelProperties: {
      name: {
        serializedName: "Name",
        required: !0,
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      size: {
        serializedName: "Size",
        required: !0,
        xmlName: "Size",
        type: {
          name: "Number"
        }
      }
    }
  }
}, Vu = {
  serializedName: "PageList",
  type: {
    name: "Composite",
    className: "PageList",
    modelProperties: {
      pageRange: {
        serializedName: "PageRange",
        xmlName: "PageRange",
        xmlElementName: "PageRange",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "PageRange"
            }
          }
        }
      },
      clearRange: {
        serializedName: "ClearRange",
        xmlName: "ClearRange",
        xmlElementName: "ClearRange",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ClearRange"
            }
          }
        }
      },
      continuationToken: {
        serializedName: "NextMarker",
        xmlName: "NextMarker",
        type: {
          name: "String"
        }
      }
    }
  }
}, dx = {
  serializedName: "PageRange",
  xmlName: "PageRange",
  type: {
    name: "Composite",
    className: "PageRange",
    modelProperties: {
      start: {
        serializedName: "Start",
        required: !0,
        xmlName: "Start",
        type: {
          name: "Number"
        }
      },
      end: {
        serializedName: "End",
        required: !0,
        xmlName: "End",
        type: {
          name: "Number"
        }
      }
    }
  }
}, gx = {
  serializedName: "ClearRange",
  xmlName: "ClearRange",
  type: {
    name: "Composite",
    className: "ClearRange",
    modelProperties: {
      start: {
        serializedName: "Start",
        required: !0,
        xmlName: "Start",
        type: {
          name: "Number"
        }
      },
      end: {
        serializedName: "End",
        required: !0,
        xmlName: "End",
        type: {
          name: "Number"
        }
      }
    }
  }
}, SC = {
  serializedName: "QueryRequest",
  xmlName: "QueryRequest",
  type: {
    name: "Composite",
    className: "QueryRequest",
    modelProperties: {
      queryType: {
        serializedName: "QueryType",
        required: !0,
        xmlName: "QueryType",
        type: {
          name: "String"
        }
      },
      expression: {
        serializedName: "Expression",
        required: !0,
        xmlName: "Expression",
        type: {
          name: "String"
        }
      },
      inputSerialization: {
        serializedName: "InputSerialization",
        xmlName: "InputSerialization",
        type: {
          name: "Composite",
          className: "QuerySerialization"
        }
      },
      outputSerialization: {
        serializedName: "OutputSerialization",
        xmlName: "OutputSerialization",
        type: {
          name: "Composite",
          className: "QuerySerialization"
        }
      }
    }
  }
}, mx = {
  serializedName: "QuerySerialization",
  type: {
    name: "Composite",
    className: "QuerySerialization",
    modelProperties: {
      format: {
        serializedName: "Format",
        xmlName: "Format",
        type: {
          name: "Composite",
          className: "QueryFormat"
        }
      }
    }
  }
}, hx = {
  serializedName: "QueryFormat",
  type: {
    name: "Composite",
    className: "QueryFormat",
    modelProperties: {
      type: {
        serializedName: "Type",
        required: !0,
        xmlName: "Type",
        type: {
          name: "Enum",
          allowedValues: ["delimited", "json", "arrow", "parquet"]
        }
      },
      delimitedTextConfiguration: {
        serializedName: "DelimitedTextConfiguration",
        xmlName: "DelimitedTextConfiguration",
        type: {
          name: "Composite",
          className: "DelimitedTextConfiguration"
        }
      },
      jsonTextConfiguration: {
        serializedName: "JsonTextConfiguration",
        xmlName: "JsonTextConfiguration",
        type: {
          name: "Composite",
          className: "JsonTextConfiguration"
        }
      },
      arrowConfiguration: {
        serializedName: "ArrowConfiguration",
        xmlName: "ArrowConfiguration",
        type: {
          name: "Composite",
          className: "ArrowConfiguration"
        }
      },
      parquetTextConfiguration: {
        serializedName: "ParquetTextConfiguration",
        xmlName: "ParquetTextConfiguration",
        type: {
          name: "Dictionary",
          value: { type: { name: "any" } }
        }
      }
    }
  }
}, px = {
  serializedName: "DelimitedTextConfiguration",
  xmlName: "DelimitedTextConfiguration",
  type: {
    name: "Composite",
    className: "DelimitedTextConfiguration",
    modelProperties: {
      columnSeparator: {
        serializedName: "ColumnSeparator",
        xmlName: "ColumnSeparator",
        type: {
          name: "String"
        }
      },
      fieldQuote: {
        serializedName: "FieldQuote",
        xmlName: "FieldQuote",
        type: {
          name: "String"
        }
      },
      recordSeparator: {
        serializedName: "RecordSeparator",
        xmlName: "RecordSeparator",
        type: {
          name: "String"
        }
      },
      escapeChar: {
        serializedName: "EscapeChar",
        xmlName: "EscapeChar",
        type: {
          name: "String"
        }
      },
      headersPresent: {
        serializedName: "HeadersPresent",
        xmlName: "HasHeaders",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, fx = {
  serializedName: "JsonTextConfiguration",
  xmlName: "JsonTextConfiguration",
  type: {
    name: "Composite",
    className: "JsonTextConfiguration",
    modelProperties: {
      recordSeparator: {
        serializedName: "RecordSeparator",
        xmlName: "RecordSeparator",
        type: {
          name: "String"
        }
      }
    }
  }
}, Ex = {
  serializedName: "ArrowConfiguration",
  xmlName: "ArrowConfiguration",
  type: {
    name: "Composite",
    className: "ArrowConfiguration",
    modelProperties: {
      schema: {
        serializedName: "Schema",
        required: !0,
        xmlName: "Schema",
        xmlIsWrapped: !0,
        xmlElementName: "Field",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ArrowField"
            }
          }
        }
      }
    }
  }
}, Cx = {
  serializedName: "ArrowField",
  xmlName: "Field",
  type: {
    name: "Composite",
    className: "ArrowField",
    modelProperties: {
      type: {
        serializedName: "Type",
        required: !0,
        xmlName: "Type",
        type: {
          name: "String"
        }
      },
      name: {
        serializedName: "Name",
        xmlName: "Name",
        type: {
          name: "String"
        }
      },
      precision: {
        serializedName: "Precision",
        xmlName: "Precision",
        type: {
          name: "Number"
        }
      },
      scale: {
        serializedName: "Scale",
        xmlName: "Scale",
        type: {
          name: "Number"
        }
      }
    }
  }
}, vC = {
  serializedName: "Service_setPropertiesHeaders",
  type: {
    name: "Composite",
    className: "ServiceSetPropertiesHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, xC = {
  serializedName: "Service_setPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceSetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, DC = {
  serializedName: "Service_getPropertiesHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetPropertiesHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, TC = {
  serializedName: "Service_getPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, kC = {
  serializedName: "Service_getStatisticsHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetStatisticsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, FC = {
  serializedName: "Service_getStatisticsExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetStatisticsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PC = {
  serializedName: "Service_listContainersSegmentHeaders",
  type: {
    name: "Composite",
    className: "ServiceListContainersSegmentHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, UC = {
  serializedName: "Service_listContainersSegmentExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceListContainersSegmentExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, LC = {
  serializedName: "Service_getUserDelegationKeyHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetUserDelegationKeyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, _C = {
  serializedName: "Service_getUserDelegationKeyExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetUserDelegationKeyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, MC = {
  serializedName: "Service_getAccountInfoHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        xmlName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        xmlName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        xmlName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, OC = {
  serializedName: "Service_getAccountInfoExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceGetAccountInfoExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, GC = {
  serializedName: "Service_submitBatchHeaders",
  type: {
    name: "Composite",
    className: "ServiceSubmitBatchHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, qC = {
  serializedName: "Service_submitBatchExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceSubmitBatchExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, HC = {
  serializedName: "Service_filterBlobsHeaders",
  type: {
    name: "Composite",
    className: "ServiceFilterBlobsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, zC = {
  serializedName: "Service_filterBlobsExceptionHeaders",
  type: {
    name: "Composite",
    className: "ServiceFilterBlobsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, YC = {
  serializedName: "Container_createHeaders",
  type: {
    name: "Composite",
    className: "ContainerCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, JC = {
  serializedName: "Container_createExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerCreateExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, VC = {
  serializedName: "Container_getPropertiesHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetPropertiesHeaders",
    modelProperties: {
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobPublicAccess: {
        serializedName: "x-ms-blob-public-access",
        xmlName: "x-ms-blob-public-access",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      },
      hasImmutabilityPolicy: {
        serializedName: "x-ms-has-immutability-policy",
        xmlName: "x-ms-has-immutability-policy",
        type: {
          name: "Boolean"
        }
      },
      hasLegalHold: {
        serializedName: "x-ms-has-legal-hold",
        xmlName: "x-ms-has-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      defaultEncryptionScope: {
        serializedName: "x-ms-default-encryption-scope",
        xmlName: "x-ms-default-encryption-scope",
        type: {
          name: "String"
        }
      },
      denyEncryptionScopeOverride: {
        serializedName: "x-ms-deny-encryption-scope-override",
        xmlName: "x-ms-deny-encryption-scope-override",
        type: {
          name: "Boolean"
        }
      },
      isImmutableStorageWithVersioningEnabled: {
        serializedName: "x-ms-immutable-storage-with-versioning-enabled",
        xmlName: "x-ms-immutable-storage-with-versioning-enabled",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, WC = {
  serializedName: "Container_getPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, jC = {
  serializedName: "Container_deleteHeaders",
  type: {
    name: "Composite",
    className: "ContainerDeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, $C = {
  serializedName: "Container_deleteExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerDeleteExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, XC = {
  serializedName: "Container_setMetadataHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetMetadataHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, KC = {
  serializedName: "Container_setMetadataExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetMetadataExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ZC = {
  serializedName: "Container_getAccessPolicyHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccessPolicyHeaders",
    modelProperties: {
      blobPublicAccess: {
        serializedName: "x-ms-blob-public-access",
        xmlName: "x-ms-blob-public-access",
        type: {
          name: "Enum",
          allowedValues: ["container", "blob"]
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, eB = {
  serializedName: "Container_getAccessPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccessPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, tB = {
  serializedName: "Container_setAccessPolicyHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetAccessPolicyHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, rB = {
  serializedName: "Container_setAccessPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerSetAccessPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, nB = {
  serializedName: "Container_restoreHeaders",
  type: {
    name: "Composite",
    className: "ContainerRestoreHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, sB = {
  serializedName: "Container_restoreExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerRestoreExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, iB = {
  serializedName: "Container_renameHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenameHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, oB = {
  serializedName: "Container_renameExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenameExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, aB = {
  serializedName: "Container_submitBatchHeaders",
  type: {
    name: "Composite",
    className: "ContainerSubmitBatchHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      }
    }
  }
}, AB = {
  serializedName: "Container_submitBatchExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerSubmitBatchExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, cB = {
  serializedName: "Container_filterBlobsHeaders",
  type: {
    name: "Composite",
    className: "ContainerFilterBlobsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, lB = {
  serializedName: "Container_filterBlobsExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerFilterBlobsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, uB = {
  serializedName: "Container_acquireLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerAcquireLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, dB = {
  serializedName: "Container_acquireLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerAcquireLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, gB = {
  serializedName: "Container_releaseLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerReleaseLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, mB = {
  serializedName: "Container_releaseLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerReleaseLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, hB = {
  serializedName: "Container_renewLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenewLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, pB = {
  serializedName: "Container_renewLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerRenewLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, fB = {
  serializedName: "Container_breakLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerBreakLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseTime: {
        serializedName: "x-ms-lease-time",
        xmlName: "x-ms-lease-time",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, EB = {
  serializedName: "Container_breakLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerBreakLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, CB = {
  serializedName: "Container_changeLeaseHeaders",
  type: {
    name: "Composite",
    className: "ContainerChangeLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, BB = {
  serializedName: "Container_changeLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerChangeLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, IB = {
  serializedName: "Container_listBlobFlatSegmentHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobFlatSegmentHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, yB = {
  serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobFlatSegmentExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, QB = {
  serializedName: "Container_listBlobHierarchySegmentHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobHierarchySegmentHeaders",
    modelProperties: {
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, bB = {
  serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerListBlobHierarchySegmentExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, wB = {
  serializedName: "Container_getAccountInfoHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        xmlName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        xmlName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        xmlName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, NB = {
  serializedName: "Container_getAccountInfoExceptionHeaders",
  type: {
    name: "Composite",
    className: "ContainerGetAccountInfoExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, Wl = {
  serializedName: "Blob_downloadHeaders",
  type: {
    name: "Composite",
    className: "BlobDownloadHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      createdOn: {
        serializedName: "x-ms-creation-time",
        xmlName: "x-ms-creation-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      objectReplicationPolicyId: {
        serializedName: "x-ms-or-policy-id",
        xmlName: "x-ms-or-policy-id",
        type: {
          name: "String"
        }
      },
      objectReplicationRules: {
        serializedName: "x-ms-or",
        headerCollectionPrefix: "x-ms-or-",
        xmlName: "x-ms-or",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      contentLength: {
        serializedName: "content-length",
        xmlName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      contentRange: {
        serializedName: "content-range",
        xmlName: "content-range",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        xmlName: "content-encoding",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        xmlName: "cache-control",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        xmlName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        xmlName: "content-language",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        xmlName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      copyCompletedOn: {
        serializedName: "x-ms-copy-completion-time",
        xmlName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        xmlName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        xmlName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "x-ms-is-current-version",
        xmlName: "x-ms-is-current-version",
        type: {
          name: "Boolean"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        xmlName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        xmlName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      blobContentMD5: {
        serializedName: "x-ms-blob-content-md5",
        xmlName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      },
      tagCount: {
        serializedName: "x-ms-tag-count",
        xmlName: "x-ms-tag-count",
        type: {
          name: "Number"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        xmlName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      lastAccessed: {
        serializedName: "x-ms-last-access-time",
        xmlName: "x-ms-last-access-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiresOn: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      },
      legalHold: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      contentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      }
    }
  }
}, RB = {
  serializedName: "Blob_downloadExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobDownloadExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, SB = {
  serializedName: "Blob_getPropertiesHeaders",
  type: {
    name: "Composite",
    className: "BlobGetPropertiesHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      createdOn: {
        serializedName: "x-ms-creation-time",
        xmlName: "x-ms-creation-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      objectReplicationPolicyId: {
        serializedName: "x-ms-or-policy-id",
        xmlName: "x-ms-or-policy-id",
        type: {
          name: "String"
        }
      },
      objectReplicationRules: {
        serializedName: "x-ms-or",
        headerCollectionPrefix: "x-ms-or-",
        xmlName: "x-ms-or",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        xmlName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      copyCompletedOn: {
        serializedName: "x-ms-copy-completion-time",
        xmlName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        xmlName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        xmlName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      isIncrementalCopy: {
        serializedName: "x-ms-incremental-copy",
        xmlName: "x-ms-incremental-copy",
        type: {
          name: "Boolean"
        }
      },
      destinationSnapshot: {
        serializedName: "x-ms-copy-destination-snapshot",
        xmlName: "x-ms-copy-destination-snapshot",
        type: {
          name: "String"
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      contentLength: {
        serializedName: "content-length",
        xmlName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        xmlName: "content-encoding",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        xmlName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        xmlName: "content-language",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        xmlName: "cache-control",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        xmlName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        xmlName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      accessTier: {
        serializedName: "x-ms-access-tier",
        xmlName: "x-ms-access-tier",
        type: {
          name: "String"
        }
      },
      accessTierInferred: {
        serializedName: "x-ms-access-tier-inferred",
        xmlName: "x-ms-access-tier-inferred",
        type: {
          name: "Boolean"
        }
      },
      archiveStatus: {
        serializedName: "x-ms-archive-status",
        xmlName: "x-ms-archive-status",
        type: {
          name: "String"
        }
      },
      accessTierChangedOn: {
        serializedName: "x-ms-access-tier-change-time",
        xmlName: "x-ms-access-tier-change-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      isCurrentVersion: {
        serializedName: "x-ms-is-current-version",
        xmlName: "x-ms-is-current-version",
        type: {
          name: "Boolean"
        }
      },
      tagCount: {
        serializedName: "x-ms-tag-count",
        xmlName: "x-ms-tag-count",
        type: {
          name: "Number"
        }
      },
      expiresOn: {
        serializedName: "x-ms-expiry-time",
        xmlName: "x-ms-expiry-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        xmlName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      },
      rehydratePriority: {
        serializedName: "x-ms-rehydrate-priority",
        xmlName: "x-ms-rehydrate-priority",
        type: {
          name: "Enum",
          allowedValues: ["High", "Standard"]
        }
      },
      lastAccessed: {
        serializedName: "x-ms-last-access-time",
        xmlName: "x-ms-last-access-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiresOn: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      },
      legalHold: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, vB = {
  serializedName: "Blob_getPropertiesExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobGetPropertiesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, xB = {
  serializedName: "Blob_deleteHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, DB = {
  serializedName: "Blob_deleteExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, TB = {
  serializedName: "Blob_undeleteHeaders",
  type: {
    name: "Composite",
    className: "BlobUndeleteHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, kB = {
  serializedName: "Blob_undeleteExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobUndeleteExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, FB = {
  serializedName: "Blob_setExpiryHeaders",
  type: {
    name: "Composite",
    className: "BlobSetExpiryHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, PB = {
  serializedName: "Blob_setExpiryExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetExpiryExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, UB = {
  serializedName: "Blob_setHttpHeadersHeaders",
  type: {
    name: "Composite",
    className: "BlobSetHttpHeadersHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, LB = {
  serializedName: "Blob_setHttpHeadersExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetHttpHeadersExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, _B = {
  serializedName: "Blob_setImmutabilityPolicyHeaders",
  type: {
    name: "Composite",
    className: "BlobSetImmutabilityPolicyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyExpiry: {
        serializedName: "x-ms-immutability-policy-until-date",
        xmlName: "x-ms-immutability-policy-until-date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      immutabilityPolicyMode: {
        serializedName: "x-ms-immutability-policy-mode",
        xmlName: "x-ms-immutability-policy-mode",
        type: {
          name: "Enum",
          allowedValues: ["Mutable", "Unlocked", "Locked"]
        }
      }
    }
  }
}, MB = {
  serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetImmutabilityPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, OB = {
  serializedName: "Blob_deleteImmutabilityPolicyHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteImmutabilityPolicyHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, GB = {
  serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, qB = {
  serializedName: "Blob_setLegalHoldHeaders",
  type: {
    name: "Composite",
    className: "BlobSetLegalHoldHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      legalHold: {
        serializedName: "x-ms-legal-hold",
        xmlName: "x-ms-legal-hold",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, HB = {
  serializedName: "Blob_setLegalHoldExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetLegalHoldExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, zB = {
  serializedName: "Blob_setMetadataHeaders",
  type: {
    name: "Composite",
    className: "BlobSetMetadataHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, YB = {
  serializedName: "Blob_setMetadataExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetMetadataExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, JB = {
  serializedName: "Blob_acquireLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobAcquireLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, VB = {
  serializedName: "Blob_acquireLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobAcquireLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, WB = {
  serializedName: "Blob_releaseLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobReleaseLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, jB = {
  serializedName: "Blob_releaseLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobReleaseLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, $B = {
  serializedName: "Blob_renewLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobRenewLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, XB = {
  serializedName: "Blob_renewLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobRenewLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, KB = {
  serializedName: "Blob_changeLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobChangeLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      leaseId: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, ZB = {
  serializedName: "Blob_changeLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobChangeLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, eI = {
  serializedName: "Blob_breakLeaseHeaders",
  type: {
    name: "Composite",
    className: "BlobBreakLeaseHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      leaseTime: {
        serializedName: "x-ms-lease-time",
        xmlName: "x-ms-lease-time",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      }
    }
  }
}, tI = {
  serializedName: "Blob_breakLeaseExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobBreakLeaseExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, rI = {
  serializedName: "Blob_createSnapshotHeaders",
  type: {
    name: "Composite",
    className: "BlobCreateSnapshotHeaders",
    modelProperties: {
      snapshot: {
        serializedName: "x-ms-snapshot",
        xmlName: "x-ms-snapshot",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, nI = {
  serializedName: "Blob_createSnapshotExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobCreateSnapshotExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, sI = {
  serializedName: "Blob_startCopyFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlobStartCopyFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, iI = {
  serializedName: "Blob_startCopyFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobStartCopyFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, oI = {
  serializedName: "Blob_copyFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlobCopyFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        defaultValue: "success",
        isConstant: !0,
        serializedName: "x-ms-copy-status",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, aI = {
  serializedName: "Blob_copyFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobCopyFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, AI = {
  serializedName: "Blob_abortCopyFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlobAbortCopyFromURLHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, cI = {
  serializedName: "Blob_abortCopyFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobAbortCopyFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, jl = {
  serializedName: "Blob_setTierHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTierHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, lI = {
  serializedName: "Blob_setTierExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTierExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, uI = {
  serializedName: "Blob_getAccountInfoHeaders",
  type: {
    name: "Composite",
    className: "BlobGetAccountInfoHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      skuName: {
        serializedName: "x-ms-sku-name",
        xmlName: "x-ms-sku-name",
        type: {
          name: "Enum",
          allowedValues: [
            "Standard_LRS",
            "Standard_GRS",
            "Standard_RAGRS",
            "Standard_ZRS",
            "Premium_LRS"
          ]
        }
      },
      accountKind: {
        serializedName: "x-ms-account-kind",
        xmlName: "x-ms-account-kind",
        type: {
          name: "Enum",
          allowedValues: [
            "Storage",
            "BlobStorage",
            "StorageV2",
            "FileStorage",
            "BlockBlobStorage"
          ]
        }
      },
      isHierarchicalNamespaceEnabled: {
        serializedName: "x-ms-is-hns-enabled",
        xmlName: "x-ms-is-hns-enabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, dI = {
  serializedName: "Blob_getAccountInfoExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobGetAccountInfoExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, $l = {
  serializedName: "Blob_queryHeaders",
  type: {
    name: "Composite",
    className: "BlobQueryHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      metadata: {
        serializedName: "x-ms-meta",
        headerCollectionPrefix: "x-ms-meta-",
        xmlName: "x-ms-meta",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      contentLength: {
        serializedName: "content-length",
        xmlName: "content-length",
        type: {
          name: "Number"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      contentRange: {
        serializedName: "content-range",
        xmlName: "content-range",
        type: {
          name: "String"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      contentEncoding: {
        serializedName: "content-encoding",
        xmlName: "content-encoding",
        type: {
          name: "String"
        }
      },
      cacheControl: {
        serializedName: "cache-control",
        xmlName: "cache-control",
        type: {
          name: "String"
        }
      },
      contentDisposition: {
        serializedName: "content-disposition",
        xmlName: "content-disposition",
        type: {
          name: "String"
        }
      },
      contentLanguage: {
        serializedName: "content-language",
        xmlName: "content-language",
        type: {
          name: "String"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      blobType: {
        serializedName: "x-ms-blob-type",
        xmlName: "x-ms-blob-type",
        type: {
          name: "Enum",
          allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
        }
      },
      copyCompletionTime: {
        serializedName: "x-ms-copy-completion-time",
        xmlName: "x-ms-copy-completion-time",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyStatusDescription: {
        serializedName: "x-ms-copy-status-description",
        xmlName: "x-ms-copy-status-description",
        type: {
          name: "String"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyProgress: {
        serializedName: "x-ms-copy-progress",
        xmlName: "x-ms-copy-progress",
        type: {
          name: "String"
        }
      },
      copySource: {
        serializedName: "x-ms-copy-source",
        xmlName: "x-ms-copy-source",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      leaseDuration: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
          name: "Enum",
          allowedValues: ["infinite", "fixed"]
        }
      },
      leaseState: {
        serializedName: "x-ms-lease-state",
        xmlName: "x-ms-lease-state",
        type: {
          name: "Enum",
          allowedValues: [
            "available",
            "leased",
            "expired",
            "breaking",
            "broken"
          ]
        }
      },
      leaseStatus: {
        serializedName: "x-ms-lease-status",
        xmlName: "x-ms-lease-status",
        type: {
          name: "Enum",
          allowedValues: ["locked", "unlocked"]
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      acceptRanges: {
        serializedName: "accept-ranges",
        xmlName: "accept-ranges",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-server-encrypted",
        xmlName: "x-ms-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      blobContentMD5: {
        serializedName: "x-ms-blob-content-md5",
        xmlName: "x-ms-blob-content-md5",
        type: {
          name: "ByteArray"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      },
      contentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      }
    }
  }
}, gI = {
  serializedName: "Blob_queryExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobQueryExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, mI = {
  serializedName: "Blob_getTagsHeaders",
  type: {
    name: "Composite",
    className: "BlobGetTagsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, hI = {
  serializedName: "Blob_getTagsExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobGetTagsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, pI = {
  serializedName: "Blob_setTagsHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTagsHeaders",
    modelProperties: {
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, fI = {
  serializedName: "Blob_setTagsExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlobSetTagsExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, EI = {
  serializedName: "PageBlob_createHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, CI = {
  serializedName: "PageBlob_createExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCreateExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, BI = {
  serializedName: "PageBlob_uploadPagesHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, II = {
  serializedName: "PageBlob_uploadPagesExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, yI = {
  serializedName: "PageBlob_clearPagesHeaders",
  type: {
    name: "Composite",
    className: "PageBlobClearPagesHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, QI = {
  serializedName: "PageBlob_clearPagesExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobClearPagesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, bI = {
  serializedName: "PageBlob_uploadPagesFromURLHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesFromURLHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, wI = {
  serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUploadPagesFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, NI = {
  serializedName: "PageBlob_getPageRangesHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, RI = {
  serializedName: "PageBlob_getPageRangesExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, SI = {
  serializedName: "PageBlob_getPageRangesDiffHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesDiffHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, vI = {
  serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobGetPageRangesDiffExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, xI = {
  serializedName: "PageBlob_resizeHeaders",
  type: {
    name: "Composite",
    className: "PageBlobResizeHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, DI = {
  serializedName: "PageBlob_resizeExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobResizeExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, TI = {
  serializedName: "PageBlob_updateSequenceNumberHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUpdateSequenceNumberHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobSequenceNumber: {
        serializedName: "x-ms-blob-sequence-number",
        xmlName: "x-ms-blob-sequence-number",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, kI = {
  serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobUpdateSequenceNumberExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, FI = {
  serializedName: "PageBlob_copyIncrementalHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCopyIncrementalHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      copyId: {
        serializedName: "x-ms-copy-id",
        xmlName: "x-ms-copy-id",
        type: {
          name: "String"
        }
      },
      copyStatus: {
        serializedName: "x-ms-copy-status",
        xmlName: "x-ms-copy-status",
        type: {
          name: "Enum",
          allowedValues: ["pending", "success", "aborted", "failed"]
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, PI = {
  serializedName: "PageBlob_copyIncrementalExceptionHeaders",
  type: {
    name: "Composite",
    className: "PageBlobCopyIncrementalExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, UI = {
  serializedName: "AppendBlob_createHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobCreateHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, LI = {
  serializedName: "AppendBlob_createExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobCreateExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, _I = {
  serializedName: "AppendBlob_appendBlockHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobAppendOffset: {
        serializedName: "x-ms-blob-append-offset",
        xmlName: "x-ms-blob-append-offset",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, MI = {
  serializedName: "AppendBlob_appendBlockExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, OI = {
  serializedName: "AppendBlob_appendBlockFromUrlHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockFromUrlHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      blobAppendOffset: {
        serializedName: "x-ms-blob-append-offset",
        xmlName: "x-ms-blob-append-offset",
        type: {
          name: "String"
        }
      },
      blobCommittedBlockCount: {
        serializedName: "x-ms-blob-committed-block-count",
        xmlName: "x-ms-blob-committed-block-count",
        type: {
          name: "Number"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, GI = {
  serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, qI = {
  serializedName: "AppendBlob_sealHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobSealHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isSealed: {
        serializedName: "x-ms-blob-sealed",
        xmlName: "x-ms-blob-sealed",
        type: {
          name: "Boolean"
        }
      }
    }
  }
}, HI = {
  serializedName: "AppendBlob_sealExceptionHeaders",
  type: {
    name: "Composite",
    className: "AppendBlobSealExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, zI = {
  serializedName: "BlockBlob_uploadHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobUploadHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, YI = {
  serializedName: "BlockBlob_uploadExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobUploadExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, JI = {
  serializedName: "BlockBlob_putBlobFromUrlHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobPutBlobFromUrlHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, VI = {
  serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobPutBlobFromUrlExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, WI = {
  serializedName: "BlockBlob_stageBlockHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockHeaders",
    modelProperties: {
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, jI = {
  serializedName: "BlockBlob_stageBlockExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, $I = {
  serializedName: "BlockBlob_stageBlockFromURLHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockFromURLHeaders",
    modelProperties: {
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, XI = {
  serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobStageBlockFromURLExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, KI = {
  serializedName: "BlockBlob_commitBlockListHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobCommitBlockListHeaders",
    modelProperties: {
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      contentMD5: {
        serializedName: "content-md5",
        xmlName: "content-md5",
        type: {
          name: "ByteArray"
        }
      },
      xMsContentCrc64: {
        serializedName: "x-ms-content-crc64",
        xmlName: "x-ms-content-crc64",
        type: {
          name: "ByteArray"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      versionId: {
        serializedName: "x-ms-version-id",
        xmlName: "x-ms-version-id",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      isServerEncrypted: {
        serializedName: "x-ms-request-server-encrypted",
        xmlName: "x-ms-request-server-encrypted",
        type: {
          name: "Boolean"
        }
      },
      encryptionKeySha256: {
        serializedName: "x-ms-encryption-key-sha256",
        xmlName: "x-ms-encryption-key-sha256",
        type: {
          name: "String"
        }
      },
      encryptionScope: {
        serializedName: "x-ms-encryption-scope",
        xmlName: "x-ms-encryption-scope",
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ZI = {
  serializedName: "BlockBlob_commitBlockListExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobCommitBlockListExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ey = {
  serializedName: "BlockBlob_getBlockListHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobGetBlockListHeaders",
    modelProperties: {
      lastModified: {
        serializedName: "last-modified",
        xmlName: "last-modified",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      etag: {
        serializedName: "etag",
        xmlName: "etag",
        type: {
          name: "String"
        }
      },
      contentType: {
        serializedName: "content-type",
        xmlName: "content-type",
        type: {
          name: "String"
        }
      },
      blobContentLength: {
        serializedName: "x-ms-blob-content-length",
        xmlName: "x-ms-blob-content-length",
        type: {
          name: "Number"
        }
      },
      clientRequestId: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
          name: "String"
        }
      },
      requestId: {
        serializedName: "x-ms-request-id",
        xmlName: "x-ms-request-id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "x-ms-version",
        xmlName: "x-ms-version",
        type: {
          name: "String"
        }
      },
      date: {
        serializedName: "date",
        xmlName: "date",
        type: {
          name: "DateTimeRfc1123"
        }
      },
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, ty = {
  serializedName: "BlockBlob_getBlockListExceptionHeaders",
  type: {
    name: "Composite",
    className: "BlockBlobGetBlockListExceptionHeaders",
    modelProperties: {
      errorCode: {
        serializedName: "x-ms-error-code",
        xmlName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
}, Os = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AccessPolicy: sx,
  AppendBlobAppendBlockExceptionHeaders: MI,
  AppendBlobAppendBlockFromUrlExceptionHeaders: GI,
  AppendBlobAppendBlockFromUrlHeaders: OI,
  AppendBlobAppendBlockHeaders: _I,
  AppendBlobCreateExceptionHeaders: LI,
  AppendBlobCreateHeaders: UI,
  AppendBlobSealExceptionHeaders: HI,
  AppendBlobSealHeaders: qI,
  ArrowConfiguration: Ex,
  ArrowField: Cx,
  BlobAbortCopyFromURLExceptionHeaders: cI,
  BlobAbortCopyFromURLHeaders: AI,
  BlobAcquireLeaseExceptionHeaders: VB,
  BlobAcquireLeaseHeaders: JB,
  BlobBreakLeaseExceptionHeaders: tI,
  BlobBreakLeaseHeaders: eI,
  BlobChangeLeaseExceptionHeaders: ZB,
  BlobChangeLeaseHeaders: KB,
  BlobCopyFromURLExceptionHeaders: aI,
  BlobCopyFromURLHeaders: oI,
  BlobCreateSnapshotExceptionHeaders: nI,
  BlobCreateSnapshotHeaders: rI,
  BlobDeleteExceptionHeaders: DB,
  BlobDeleteHeaders: xB,
  BlobDeleteImmutabilityPolicyExceptionHeaders: GB,
  BlobDeleteImmutabilityPolicyHeaders: OB,
  BlobDownloadExceptionHeaders: RB,
  BlobDownloadHeaders: Wl,
  BlobFlatListSegment: ix,
  BlobGetAccountInfoExceptionHeaders: dI,
  BlobGetAccountInfoHeaders: uI,
  BlobGetPropertiesExceptionHeaders: vB,
  BlobGetPropertiesHeaders: SB,
  BlobGetTagsExceptionHeaders: hI,
  BlobGetTagsHeaders: mI,
  BlobHierarchyListSegment: cx,
  BlobItemInternal: ox,
  BlobName: ax,
  BlobPrefix: lx,
  BlobPropertiesInternal: Ax,
  BlobQueryExceptionHeaders: gI,
  BlobQueryHeaders: $l,
  BlobReleaseLeaseExceptionHeaders: jB,
  BlobReleaseLeaseHeaders: WB,
  BlobRenewLeaseExceptionHeaders: XB,
  BlobRenewLeaseHeaders: $B,
  BlobServiceProperties: zu,
  BlobServiceStatistics: BC,
  BlobSetExpiryExceptionHeaders: PB,
  BlobSetExpiryHeaders: FB,
  BlobSetHttpHeadersExceptionHeaders: LB,
  BlobSetHttpHeadersHeaders: UB,
  BlobSetImmutabilityPolicyExceptionHeaders: MB,
  BlobSetImmutabilityPolicyHeaders: _B,
  BlobSetLegalHoldExceptionHeaders: HB,
  BlobSetLegalHoldHeaders: qB,
  BlobSetMetadataExceptionHeaders: YB,
  BlobSetMetadataHeaders: zB,
  BlobSetTagsExceptionHeaders: fI,
  BlobSetTagsHeaders: pI,
  BlobSetTierExceptionHeaders: lI,
  BlobSetTierHeaders: jl,
  BlobStartCopyFromURLExceptionHeaders: iI,
  BlobStartCopyFromURLHeaders: sI,
  BlobTag: rx,
  BlobTags: Ju,
  BlobUndeleteExceptionHeaders: kB,
  BlobUndeleteHeaders: TB,
  Block: ux,
  BlockBlobCommitBlockListExceptionHeaders: ZI,
  BlockBlobCommitBlockListHeaders: KI,
  BlockBlobGetBlockListExceptionHeaders: ty,
  BlockBlobGetBlockListHeaders: ey,
  BlockBlobPutBlobFromUrlExceptionHeaders: VI,
  BlockBlobPutBlobFromUrlHeaders: JI,
  BlockBlobStageBlockExceptionHeaders: jI,
  BlockBlobStageBlockFromURLExceptionHeaders: XI,
  BlockBlobStageBlockFromURLHeaders: $I,
  BlockBlobStageBlockHeaders: WI,
  BlockBlobUploadExceptionHeaders: YI,
  BlockBlobUploadHeaders: zI,
  BlockList: RC,
  BlockLookupList: NC,
  ClearRange: gx,
  ContainerAcquireLeaseExceptionHeaders: dB,
  ContainerAcquireLeaseHeaders: uB,
  ContainerBreakLeaseExceptionHeaders: EB,
  ContainerBreakLeaseHeaders: fB,
  ContainerChangeLeaseExceptionHeaders: BB,
  ContainerChangeLeaseHeaders: CB,
  ContainerCreateExceptionHeaders: JC,
  ContainerCreateHeaders: YC,
  ContainerDeleteExceptionHeaders: $C,
  ContainerDeleteHeaders: jC,
  ContainerFilterBlobsExceptionHeaders: lB,
  ContainerFilterBlobsHeaders: cB,
  ContainerGetAccessPolicyExceptionHeaders: eB,
  ContainerGetAccessPolicyHeaders: ZC,
  ContainerGetAccountInfoExceptionHeaders: NB,
  ContainerGetAccountInfoHeaders: wB,
  ContainerGetPropertiesExceptionHeaders: WC,
  ContainerGetPropertiesHeaders: VC,
  ContainerItem: Zv,
  ContainerListBlobFlatSegmentExceptionHeaders: yB,
  ContainerListBlobFlatSegmentHeaders: IB,
  ContainerListBlobHierarchySegmentExceptionHeaders: bB,
  ContainerListBlobHierarchySegmentHeaders: QB,
  ContainerProperties: ex,
  ContainerReleaseLeaseExceptionHeaders: mB,
  ContainerReleaseLeaseHeaders: gB,
  ContainerRenameExceptionHeaders: oB,
  ContainerRenameHeaders: iB,
  ContainerRenewLeaseExceptionHeaders: pB,
  ContainerRenewLeaseHeaders: hB,
  ContainerRestoreExceptionHeaders: sB,
  ContainerRestoreHeaders: nB,
  ContainerSetAccessPolicyExceptionHeaders: rB,
  ContainerSetAccessPolicyHeaders: tB,
  ContainerSetMetadataExceptionHeaders: KC,
  ContainerSetMetadataHeaders: XC,
  ContainerSubmitBatchExceptionHeaders: AB,
  ContainerSubmitBatchHeaders: aB,
  CorsRule: $v,
  DelimitedTextConfiguration: px,
  FilterBlobItem: tx,
  FilterBlobSegment: Yu,
  GeoReplication: Kv,
  JsonTextConfiguration: fx,
  KeyInfo: yC,
  ListBlobsFlatSegmentResponse: bC,
  ListBlobsHierarchySegmentResponse: wC,
  ListContainersSegmentResponse: IC,
  Logging: Vv,
  Metrics: jv,
  PageBlobClearPagesExceptionHeaders: QI,
  PageBlobClearPagesHeaders: yI,
  PageBlobCopyIncrementalExceptionHeaders: PI,
  PageBlobCopyIncrementalHeaders: FI,
  PageBlobCreateExceptionHeaders: CI,
  PageBlobCreateHeaders: EI,
  PageBlobGetPageRangesDiffExceptionHeaders: vI,
  PageBlobGetPageRangesDiffHeaders: SI,
  PageBlobGetPageRangesExceptionHeaders: RI,
  PageBlobGetPageRangesHeaders: NI,
  PageBlobResizeExceptionHeaders: DI,
  PageBlobResizeHeaders: xI,
  PageBlobUpdateSequenceNumberExceptionHeaders: kI,
  PageBlobUpdateSequenceNumberHeaders: TI,
  PageBlobUploadPagesExceptionHeaders: II,
  PageBlobUploadPagesFromURLExceptionHeaders: wI,
  PageBlobUploadPagesFromURLHeaders: bI,
  PageBlobUploadPagesHeaders: BI,
  PageList: Vu,
  PageRange: dx,
  QueryFormat: hx,
  QueryRequest: SC,
  QuerySerialization: mx,
  RetentionPolicy: Wv,
  ServiceFilterBlobsExceptionHeaders: zC,
  ServiceFilterBlobsHeaders: HC,
  ServiceGetAccountInfoExceptionHeaders: OC,
  ServiceGetAccountInfoHeaders: MC,
  ServiceGetPropertiesExceptionHeaders: TC,
  ServiceGetPropertiesHeaders: DC,
  ServiceGetStatisticsExceptionHeaders: FC,
  ServiceGetStatisticsHeaders: kC,
  ServiceGetUserDelegationKeyExceptionHeaders: _C,
  ServiceGetUserDelegationKeyHeaders: LC,
  ServiceListContainersSegmentExceptionHeaders: UC,
  ServiceListContainersSegmentHeaders: PC,
  ServiceSetPropertiesExceptionHeaders: xC,
  ServiceSetPropertiesHeaders: vC,
  ServiceSubmitBatchExceptionHeaders: qC,
  ServiceSubmitBatchHeaders: GC,
  SignedIdentifier: nx,
  StaticWebsite: Xv,
  StorageError: ye,
  UserDelegationKey: QC
}, Symbol.toStringTag, { value: "Module" })), Gs = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, Bx = {
  parameterPath: "blobServiceProperties",
  mapper: zu
}, Pn = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
}, we = {
  parameterPath: "url",
  mapper: {
    serializedName: "url",
    required: !0,
    xmlName: "url",
    type: {
      name: "String"
    }
  },
  skipEncoding: !0
}, ha = {
  parameterPath: "restype",
  mapper: {
    defaultValue: "service",
    isConstant: !0,
    serializedName: "restype",
    type: {
      name: "String"
    }
  }
}, Un = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "properties",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Ne = {
  parameterPath: ["options", "timeoutInSeconds"],
  mapper: {
    constraints: {
      InclusiveMinimum: 0
    },
    serializedName: "timeout",
    xmlName: "timeout",
    type: {
      name: "Number"
    }
  }
}, Re = {
  parameterPath: "version",
  mapper: {
    defaultValue: "2025-05-05",
    isConstant: !0,
    serializedName: "x-ms-version",
    type: {
      name: "String"
    }
  }
}, Se = {
  parameterPath: ["options", "requestId"],
  mapper: {
    serializedName: "x-ms-client-request-id",
    xmlName: "x-ms-client-request-id",
    type: {
      name: "String"
    }
  }
}, Fe = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
}, Ix = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "stats",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Wu = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "list",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, ju = {
  parameterPath: ["options", "prefix"],
  mapper: {
    serializedName: "prefix",
    xmlName: "prefix",
    type: {
      name: "String"
    }
  }
}, ss = {
  parameterPath: ["options", "marker"],
  mapper: {
    serializedName: "marker",
    xmlName: "marker",
    type: {
      name: "String"
    }
  }
}, is = {
  parameterPath: ["options", "maxPageSize"],
  mapper: {
    constraints: {
      InclusiveMinimum: 1
    },
    serializedName: "maxresults",
    xmlName: "maxresults",
    type: {
      name: "Number"
    }
  }
}, yx = {
  parameterPath: ["options", "include"],
  mapper: {
    serializedName: "include",
    xmlName: "include",
    xmlElementName: "ListContainersIncludeType",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: ["metadata", "deleted", "system"]
        }
      }
    }
  },
  collectionFormat: "CSV"
}, Qx = {
  parameterPath: "keyInfo",
  mapper: yC
}, bx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "userdelegationkey",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, $u = {
  parameterPath: "restype",
  mapper: {
    defaultValue: "account",
    isConstant: !0,
    serializedName: "restype",
    type: {
      name: "String"
    }
  }
}, ry = {
  parameterPath: "body",
  mapper: {
    serializedName: "body",
    required: !0,
    xmlName: "body",
    type: {
      name: "Stream"
    }
  }
}, ny = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "batch",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Lr = {
  parameterPath: "contentLength",
  mapper: {
    serializedName: "Content-Length",
    required: !0,
    xmlName: "Content-Length",
    type: {
      name: "Number"
    }
  }
}, sy = {
  parameterPath: "multipartContentType",
  mapper: {
    serializedName: "Content-Type",
    required: !0,
    xmlName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, iy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "blobs",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, oy = {
  parameterPath: ["options", "where"],
  mapper: {
    serializedName: "where",
    xmlName: "where",
    type: {
      name: "String"
    }
  }
}, sr = {
  parameterPath: "restype",
  mapper: {
    defaultValue: "container",
    isConstant: !0,
    serializedName: "restype",
    type: {
      name: "String"
    }
  }
}, tn = {
  parameterPath: ["options", "metadata"],
  mapper: {
    serializedName: "x-ms-meta",
    xmlName: "x-ms-meta",
    headerCollectionPrefix: "x-ms-meta-",
    type: {
      name: "Dictionary",
      value: { type: { name: "String" } }
    }
  }
}, ay = {
  parameterPath: ["options", "access"],
  mapper: {
    serializedName: "x-ms-blob-public-access",
    xmlName: "x-ms-blob-public-access",
    type: {
      name: "Enum",
      allowedValues: ["container", "blob"]
    }
  }
}, wx = {
  parameterPath: [
    "options",
    "containerEncryptionScope",
    "defaultEncryptionScope"
  ],
  mapper: {
    serializedName: "x-ms-default-encryption-scope",
    xmlName: "x-ms-default-encryption-scope",
    type: {
      name: "String"
    }
  }
}, Nx = {
  parameterPath: [
    "options",
    "containerEncryptionScope",
    "preventEncryptionScopeOverride"
  ],
  mapper: {
    serializedName: "x-ms-deny-encryption-scope-override",
    xmlName: "x-ms-deny-encryption-scope-override",
    type: {
      name: "Boolean"
    }
  }
}, et = {
  parameterPath: ["options", "leaseAccessConditions", "leaseId"],
  mapper: {
    serializedName: "x-ms-lease-id",
    xmlName: "x-ms-lease-id",
    type: {
      name: "String"
    }
  }
}, Ke = {
  parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
  mapper: {
    serializedName: "If-Modified-Since",
    xmlName: "If-Modified-Since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, Ze = {
  parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
  mapper: {
    serializedName: "If-Unmodified-Since",
    xmlName: "If-Unmodified-Since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, Ay = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "metadata",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, cy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "acl",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Rx = {
  parameterPath: ["options", "containerAcl"],
  mapper: {
    serializedName: "containerAcl",
    xmlName: "SignedIdentifiers",
    xmlIsWrapped: !0,
    xmlElementName: "SignedIdentifier",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Composite",
          className: "SignedIdentifier"
        }
      }
    }
  }
}, ly = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "undelete",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Sx = {
  parameterPath: ["options", "deletedContainerName"],
  mapper: {
    serializedName: "x-ms-deleted-container-name",
    xmlName: "x-ms-deleted-container-name",
    type: {
      name: "String"
    }
  }
}, vx = {
  parameterPath: ["options", "deletedContainerVersion"],
  mapper: {
    serializedName: "x-ms-deleted-container-version",
    xmlName: "x-ms-deleted-container-version",
    type: {
      name: "String"
    }
  }
}, xx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "rename",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Dx = {
  parameterPath: "sourceContainerName",
  mapper: {
    serializedName: "x-ms-source-container-name",
    required: !0,
    xmlName: "x-ms-source-container-name",
    type: {
      name: "String"
    }
  }
}, Tx = {
  parameterPath: ["options", "sourceLeaseId"],
  mapper: {
    serializedName: "x-ms-source-lease-id",
    xmlName: "x-ms-source-lease-id",
    type: {
      name: "String"
    }
  }
}, dn = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "lease",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, uy = {
  parameterPath: "action",
  mapper: {
    defaultValue: "acquire",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, dy = {
  parameterPath: ["options", "duration"],
  mapper: {
    serializedName: "x-ms-lease-duration",
    xmlName: "x-ms-lease-duration",
    type: {
      name: "Number"
    }
  }
}, gy = {
  parameterPath: ["options", "proposedLeaseId"],
  mapper: {
    serializedName: "x-ms-proposed-lease-id",
    xmlName: "x-ms-proposed-lease-id",
    type: {
      name: "String"
    }
  }
}, my = {
  parameterPath: "action",
  mapper: {
    defaultValue: "release",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, qs = {
  parameterPath: "leaseId",
  mapper: {
    serializedName: "x-ms-lease-id",
    required: !0,
    xmlName: "x-ms-lease-id",
    type: {
      name: "String"
    }
  }
}, hy = {
  parameterPath: "action",
  mapper: {
    defaultValue: "renew",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, py = {
  parameterPath: "action",
  mapper: {
    defaultValue: "break",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, fy = {
  parameterPath: ["options", "breakPeriod"],
  mapper: {
    serializedName: "x-ms-lease-break-period",
    xmlName: "x-ms-lease-break-period",
    type: {
      name: "Number"
    }
  }
}, Ey = {
  parameterPath: "action",
  mapper: {
    defaultValue: "change",
    isConstant: !0,
    serializedName: "x-ms-lease-action",
    type: {
      name: "String"
    }
  }
}, Cy = {
  parameterPath: "proposedLeaseId",
  mapper: {
    serializedName: "x-ms-proposed-lease-id",
    required: !0,
    xmlName: "x-ms-proposed-lease-id",
    type: {
      name: "String"
    }
  }
}, By = {
  parameterPath: ["options", "include"],
  mapper: {
    serializedName: "include",
    xmlName: "include",
    xmlElementName: "ListBlobsIncludeItem",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: [
            "copy",
            "deleted",
            "metadata",
            "snapshots",
            "uncommittedblobs",
            "versions",
            "tags",
            "immutabilitypolicy",
            "legalhold",
            "deletedwithversions"
          ]
        }
      }
    }
  },
  collectionFormat: "CSV"
}, kx = {
  parameterPath: "delimiter",
  mapper: {
    serializedName: "delimiter",
    required: !0,
    xmlName: "delimiter",
    type: {
      name: "String"
    }
  }
}, Gr = {
  parameterPath: ["options", "snapshot"],
  mapper: {
    serializedName: "snapshot",
    xmlName: "snapshot",
    type: {
      name: "String"
    }
  }
}, yn = {
  parameterPath: ["options", "versionId"],
  mapper: {
    serializedName: "versionid",
    xmlName: "versionid",
    type: {
      name: "String"
    }
  }
}, oo = {
  parameterPath: ["options", "range"],
  mapper: {
    serializedName: "x-ms-range",
    xmlName: "x-ms-range",
    type: {
      name: "String"
    }
  }
}, Fx = {
  parameterPath: ["options", "rangeGetContentMD5"],
  mapper: {
    serializedName: "x-ms-range-get-content-md5",
    xmlName: "x-ms-range-get-content-md5",
    type: {
      name: "Boolean"
    }
  }
}, Px = {
  parameterPath: ["options", "rangeGetContentCRC64"],
  mapper: {
    serializedName: "x-ms-range-get-content-crc64",
    xmlName: "x-ms-range-get-content-crc64",
    type: {
      name: "Boolean"
    }
  }
}, Xt = {
  parameterPath: ["options", "cpkInfo", "encryptionKey"],
  mapper: {
    serializedName: "x-ms-encryption-key",
    xmlName: "x-ms-encryption-key",
    type: {
      name: "String"
    }
  }
}, Kt = {
  parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
  mapper: {
    serializedName: "x-ms-encryption-key-sha256",
    xmlName: "x-ms-encryption-key-sha256",
    type: {
      name: "String"
    }
  }
}, Zt = {
  parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
  mapper: {
    serializedName: "x-ms-encryption-algorithm",
    xmlName: "x-ms-encryption-algorithm",
    type: {
      name: "String"
    }
  }
}, at = {
  parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
  mapper: {
    serializedName: "If-Match",
    xmlName: "If-Match",
    type: {
      name: "String"
    }
  }
}, At = {
  parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
  mapper: {
    serializedName: "If-None-Match",
    xmlName: "If-None-Match",
    type: {
      name: "String"
    }
  }
}, nt = {
  parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
  mapper: {
    serializedName: "x-ms-if-tags",
    xmlName: "x-ms-if-tags",
    type: {
      name: "String"
    }
  }
}, Ux = {
  parameterPath: ["options", "deleteSnapshots"],
  mapper: {
    serializedName: "x-ms-delete-snapshots",
    xmlName: "x-ms-delete-snapshots",
    type: {
      name: "Enum",
      allowedValues: ["include", "only"]
    }
  }
}, Lx = {
  parameterPath: ["options", "blobDeleteType"],
  mapper: {
    serializedName: "deletetype",
    xmlName: "deletetype",
    type: {
      name: "String"
    }
  }
}, _x = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "expiry",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Mx = {
  parameterPath: "expiryOptions",
  mapper: {
    serializedName: "x-ms-expiry-option",
    required: !0,
    xmlName: "x-ms-expiry-option",
    type: {
      name: "String"
    }
  }
}, Ox = {
  parameterPath: ["options", "expiresOn"],
  mapper: {
    serializedName: "x-ms-expiry-time",
    xmlName: "x-ms-expiry-time",
    type: {
      name: "String"
    }
  }
}, Hs = {
  parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
  mapper: {
    serializedName: "x-ms-blob-cache-control",
    xmlName: "x-ms-blob-cache-control",
    type: {
      name: "String"
    }
  }
}, zs = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
  mapper: {
    serializedName: "x-ms-blob-content-type",
    xmlName: "x-ms-blob-content-type",
    type: {
      name: "String"
    }
  }
}, Ys = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
  mapper: {
    serializedName: "x-ms-blob-content-md5",
    xmlName: "x-ms-blob-content-md5",
    type: {
      name: "ByteArray"
    }
  }
}, Js = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
  mapper: {
    serializedName: "x-ms-blob-content-encoding",
    xmlName: "x-ms-blob-content-encoding",
    type: {
      name: "String"
    }
  }
}, Vs = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
  mapper: {
    serializedName: "x-ms-blob-content-language",
    xmlName: "x-ms-blob-content-language",
    type: {
      name: "String"
    }
  }
}, Ws = {
  parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
  mapper: {
    serializedName: "x-ms-blob-content-disposition",
    xmlName: "x-ms-blob-content-disposition",
    type: {
      name: "String"
    }
  }
}, Iy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "immutabilityPolicies",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, os = {
  parameterPath: ["options", "immutabilityPolicyExpiry"],
  mapper: {
    serializedName: "x-ms-immutability-policy-until-date",
    xmlName: "x-ms-immutability-policy-until-date",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, as = {
  parameterPath: ["options", "immutabilityPolicyMode"],
  mapper: {
    serializedName: "x-ms-immutability-policy-mode",
    xmlName: "x-ms-immutability-policy-mode",
    type: {
      name: "Enum",
      allowedValues: ["Mutable", "Unlocked", "Locked"]
    }
  }
}, Gx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "legalhold",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, qx = {
  parameterPath: "legalHold",
  mapper: {
    serializedName: "x-ms-legal-hold",
    required: !0,
    xmlName: "x-ms-legal-hold",
    type: {
      name: "Boolean"
    }
  }
}, or = {
  parameterPath: ["options", "encryptionScope"],
  mapper: {
    serializedName: "x-ms-encryption-scope",
    xmlName: "x-ms-encryption-scope",
    type: {
      name: "String"
    }
  }
}, Hx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "snapshot",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, js = {
  parameterPath: ["options", "tier"],
  mapper: {
    serializedName: "x-ms-access-tier",
    xmlName: "x-ms-access-tier",
    type: {
      name: "Enum",
      allowedValues: [
        "P4",
        "P6",
        "P10",
        "P15",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "Hot",
        "Cool",
        "Archive",
        "Cold"
      ]
    }
  }
}, yy = {
  parameterPath: ["options", "rehydratePriority"],
  mapper: {
    serializedName: "x-ms-rehydrate-priority",
    xmlName: "x-ms-rehydrate-priority",
    type: {
      name: "Enum",
      allowedValues: ["High", "Standard"]
    }
  }
}, $s = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfModifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-source-if-modified-since",
    xmlName: "x-ms-source-if-modified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, Xs = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfUnmodifiedSince"
  ],
  mapper: {
    serializedName: "x-ms-source-if-unmodified-since",
    xmlName: "x-ms-source-if-unmodified-since",
    type: {
      name: "DateTimeRfc1123"
    }
  }
}, Ks = {
  parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
  mapper: {
    serializedName: "x-ms-source-if-match",
    xmlName: "x-ms-source-if-match",
    type: {
      name: "String"
    }
  }
}, Zs = {
  parameterPath: [
    "options",
    "sourceModifiedAccessConditions",
    "sourceIfNoneMatch"
  ],
  mapper: {
    serializedName: "x-ms-source-if-none-match",
    xmlName: "x-ms-source-if-none-match",
    type: {
      name: "String"
    }
  }
}, Qy = {
  parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
  mapper: {
    serializedName: "x-ms-source-if-tags",
    xmlName: "x-ms-source-if-tags",
    type: {
      name: "String"
    }
  }
}, pa = {
  parameterPath: "copySource",
  mapper: {
    serializedName: "x-ms-copy-source",
    required: !0,
    xmlName: "x-ms-copy-source",
    type: {
      name: "String"
    }
  }
}, As = {
  parameterPath: ["options", "blobTagsString"],
  mapper: {
    serializedName: "x-ms-tags",
    xmlName: "x-ms-tags",
    type: {
      name: "String"
    }
  }
}, zx = {
  parameterPath: ["options", "sealBlob"],
  mapper: {
    serializedName: "x-ms-seal-blob",
    xmlName: "x-ms-seal-blob",
    type: {
      name: "Boolean"
    }
  }
}, ei = {
  parameterPath: ["options", "legalHold"],
  mapper: {
    serializedName: "x-ms-legal-hold",
    xmlName: "x-ms-legal-hold",
    type: {
      name: "Boolean"
    }
  }
}, Yx = {
  parameterPath: "xMsRequiresSync",
  mapper: {
    defaultValue: "true",
    isConstant: !0,
    serializedName: "x-ms-requires-sync",
    type: {
      name: "String"
    }
  }
}, ao = {
  parameterPath: ["options", "sourceContentMD5"],
  mapper: {
    serializedName: "x-ms-source-content-md5",
    xmlName: "x-ms-source-content-md5",
    type: {
      name: "ByteArray"
    }
  }
}, Ao = {
  parameterPath: ["options", "copySourceAuthorization"],
  mapper: {
    serializedName: "x-ms-copy-source-authorization",
    xmlName: "x-ms-copy-source-authorization",
    type: {
      name: "String"
    }
  }
}, by = {
  parameterPath: ["options", "copySourceTags"],
  mapper: {
    serializedName: "x-ms-copy-source-tag-option",
    xmlName: "x-ms-copy-source-tag-option",
    type: {
      name: "Enum",
      allowedValues: ["REPLACE", "COPY"]
    }
  }
}, Jx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "copy",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Vx = {
  parameterPath: "copyActionAbortConstant",
  mapper: {
    defaultValue: "abort",
    isConstant: !0,
    serializedName: "x-ms-copy-action",
    type: {
      name: "String"
    }
  }
}, Wx = {
  parameterPath: "copyId",
  mapper: {
    serializedName: "copyid",
    required: !0,
    xmlName: "copyid",
    type: {
      name: "String"
    }
  }
}, jx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "tier",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, $x = {
  parameterPath: "tier",
  mapper: {
    serializedName: "x-ms-access-tier",
    required: !0,
    xmlName: "x-ms-access-tier",
    type: {
      name: "Enum",
      allowedValues: [
        "P4",
        "P6",
        "P10",
        "P15",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "Hot",
        "Cool",
        "Archive",
        "Cold"
      ]
    }
  }
}, Xx = {
  parameterPath: ["options", "queryRequest"],
  mapper: SC
}, Kx = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "query",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, wy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "tags",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Zx = {
  parameterPath: ["options", "tags"],
  mapper: Ju
}, Ln = {
  parameterPath: ["options", "transactionalContentMD5"],
  mapper: {
    serializedName: "Content-MD5",
    xmlName: "Content-MD5",
    type: {
      name: "ByteArray"
    }
  }
}, ti = {
  parameterPath: ["options", "transactionalContentCrc64"],
  mapper: {
    serializedName: "x-ms-content-crc64",
    xmlName: "x-ms-content-crc64",
    type: {
      name: "ByteArray"
    }
  }
}, eD = {
  parameterPath: "blobType",
  mapper: {
    defaultValue: "PageBlob",
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    type: {
      name: "String"
    }
  }
}, Ny = {
  parameterPath: "blobContentLength",
  mapper: {
    serializedName: "x-ms-blob-content-length",
    required: !0,
    xmlName: "x-ms-blob-content-length",
    type: {
      name: "Number"
    }
  }
}, Ry = {
  parameterPath: ["options", "blobSequenceNumber"],
  mapper: {
    defaultValue: 0,
    serializedName: "x-ms-blob-sequence-number",
    xmlName: "x-ms-blob-sequence-number",
    type: {
      name: "Number"
    }
  }
}, fa = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/octet-stream",
    isConstant: !0,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
}, Ea = {
  parameterPath: "body",
  mapper: {
    serializedName: "body",
    required: !0,
    xmlName: "body",
    type: {
      name: "Stream"
    }
  }
}, Ca = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/xml",
    isConstant: !0,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
}, Xu = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "page",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Sy = {
  parameterPath: "pageWrite",
  mapper: {
    defaultValue: "update",
    isConstant: !0,
    serializedName: "x-ms-page-write",
    type: {
      name: "String"
    }
  }
}, Ku = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberLessThanOrEqualTo"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-le",
    xmlName: "x-ms-if-sequence-number-le",
    type: {
      name: "Number"
    }
  }
}, Zu = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberLessThan"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-lt",
    xmlName: "x-ms-if-sequence-number-lt",
    type: {
      name: "Number"
    }
  }
}, ed = {
  parameterPath: [
    "options",
    "sequenceNumberAccessConditions",
    "ifSequenceNumberEqualTo"
  ],
  mapper: {
    serializedName: "x-ms-if-sequence-number-eq",
    xmlName: "x-ms-if-sequence-number-eq",
    type: {
      name: "Number"
    }
  }
}, tD = {
  parameterPath: "pageWrite",
  mapper: {
    defaultValue: "clear",
    isConstant: !0,
    serializedName: "x-ms-page-write",
    type: {
      name: "String"
    }
  }
}, td = {
  parameterPath: "sourceUrl",
  mapper: {
    serializedName: "x-ms-copy-source",
    required: !0,
    xmlName: "x-ms-copy-source",
    type: {
      name: "String"
    }
  }
}, rD = {
  parameterPath: "sourceRange",
  mapper: {
    serializedName: "x-ms-source-range",
    required: !0,
    xmlName: "x-ms-source-range",
    type: {
      name: "String"
    }
  }
}, rd = {
  parameterPath: ["options", "sourceContentCrc64"],
  mapper: {
    serializedName: "x-ms-source-content-crc64",
    xmlName: "x-ms-source-content-crc64",
    type: {
      name: "ByteArray"
    }
  }
}, nD = {
  parameterPath: "range",
  mapper: {
    serializedName: "x-ms-range",
    required: !0,
    xmlName: "x-ms-range",
    type: {
      name: "String"
    }
  }
}, vy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "pagelist",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, sD = {
  parameterPath: ["options", "prevsnapshot"],
  mapper: {
    serializedName: "prevsnapshot",
    xmlName: "prevsnapshot",
    type: {
      name: "String"
    }
  }
}, iD = {
  parameterPath: ["options", "prevSnapshotUrl"],
  mapper: {
    serializedName: "x-ms-previous-snapshot-url",
    xmlName: "x-ms-previous-snapshot-url",
    type: {
      name: "String"
    }
  }
}, oD = {
  parameterPath: "sequenceNumberAction",
  mapper: {
    serializedName: "x-ms-sequence-number-action",
    required: !0,
    xmlName: "x-ms-sequence-number-action",
    type: {
      name: "Enum",
      allowedValues: ["max", "update", "increment"]
    }
  }
}, aD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "incrementalcopy",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, AD = {
  parameterPath: "blobType",
  mapper: {
    defaultValue: "AppendBlob",
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    type: {
      name: "String"
    }
  }
}, xy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "appendblock",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Dy = {
  parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
  mapper: {
    serializedName: "x-ms-blob-condition-maxsize",
    xmlName: "x-ms-blob-condition-maxsize",
    type: {
      name: "Number"
    }
  }
}, nd = {
  parameterPath: [
    "options",
    "appendPositionAccessConditions",
    "appendPosition"
  ],
  mapper: {
    serializedName: "x-ms-blob-condition-appendpos",
    xmlName: "x-ms-blob-condition-appendpos",
    type: {
      name: "Number"
    }
  }
}, Ty = {
  parameterPath: ["options", "sourceRange"],
  mapper: {
    serializedName: "x-ms-source-range",
    xmlName: "x-ms-source-range",
    type: {
      name: "String"
    }
  }
}, cD = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "seal",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, ky = {
  parameterPath: "blobType",
  mapper: {
    defaultValue: "BlockBlob",
    isConstant: !0,
    serializedName: "x-ms-blob-type",
    type: {
      name: "String"
    }
  }
}, lD = {
  parameterPath: ["options", "copySourceBlobProperties"],
  mapper: {
    serializedName: "x-ms-copy-source-blob-properties",
    xmlName: "x-ms-copy-source-blob-properties",
    type: {
      name: "Boolean"
    }
  }
}, Fy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "block",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, Py = {
  parameterPath: "blockId",
  mapper: {
    serializedName: "blockid",
    required: !0,
    xmlName: "blockid",
    type: {
      name: "String"
    }
  }
}, uD = {
  parameterPath: "blocks",
  mapper: NC
}, Uy = {
  parameterPath: "comp",
  mapper: {
    defaultValue: "blocklist",
    isConstant: !0,
    serializedName: "comp",
    type: {
      name: "String"
    }
  }
}, dD = {
  parameterPath: "listType",
  mapper: {
    defaultValue: "committed",
    serializedName: "blocklisttype",
    required: !0,
    xmlName: "blocklisttype",
    type: {
      name: "Enum",
      allowedValues: ["committed", "uncommitted", "all"]
    }
  }
};
class gD {
  /**
   * Initialize a new instance of the class Service class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * Sets properties for a storage account's Blob service endpoint, including properties for Storage
   * Analytics and CORS (Cross-Origin Resource Sharing) rules
   * @param blobServiceProperties The StorageService properties.
   * @param options The options parameters.
   */
  setProperties(e, r) {
    return this.client.sendOperationRequest({ blobServiceProperties: e, options: r }, mD);
  }
  /**
   * gets the properties of a storage account's Blob service, including properties for Storage Analytics
   * and CORS (Cross-Origin Resource Sharing) rules.
   * @param options The options parameters.
   */
  getProperties(e) {
    return this.client.sendOperationRequest({ options: e }, hD);
  }
  /**
   * Retrieves statistics related to replication for the Blob service. It is only available on the
   * secondary location endpoint when read-access geo-redundant replication is enabled for the storage
   * account.
   * @param options The options parameters.
   */
  getStatistics(e) {
    return this.client.sendOperationRequest({ options: e }, pD);
  }
  /**
   * The List Containers Segment operation returns a list of the containers under the specified account
   * @param options The options parameters.
   */
  listContainersSegment(e) {
    return this.client.sendOperationRequest({ options: e }, fD);
  }
  /**
   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
   * bearer token authentication.
   * @param keyInfo Key information
   * @param options The options parameters.
   */
  getUserDelegationKey(e, r) {
    return this.client.sendOperationRequest({ keyInfo: e, options: r }, ED);
  }
  /**
   * Returns the sku name and account kind
   * @param options The options parameters.
   */
  getAccountInfo(e) {
    return this.client.sendOperationRequest({ options: e }, CD);
  }
  /**
   * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
   * @param contentLength The length of the request.
   * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
   *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
   * @param body Initial data
   * @param options The options parameters.
   */
  submitBatch(e, r, n, s) {
    return this.client.sendOperationRequest({ contentLength: e, multipartContentType: r, body: n, options: s }, BD);
  }
  /**
   * The Filter Blobs operation enables callers to list blobs across all containers whose tags match a
   * given search expression.  Filter blobs searches across all containers within a storage account but
   * can be scoped within the expression to a single container.
   * @param options The options parameters.
   */
  filterBlobs(e) {
    return this.client.sendOperationRequest({ options: e }, ID);
  }
}
const _n = Ls(
  Os,
  /* isXml */
  !0
), mD = {
  path: "/",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: vC
    },
    default: {
      bodyMapper: ye,
      headersMapper: xC
    }
  },
  requestBody: Bx,
  queryParameters: [
    ha,
    Un,
    Ne
  ],
  urlParameters: [we],
  headerParameters: [
    Gs,
    Pn,
    Re,
    Se
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: _n
}, hD = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: zu,
      headersMapper: DC
    },
    default: {
      bodyMapper: ye,
      headersMapper: TC
    }
  },
  queryParameters: [
    ha,
    Un,
    Ne
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: _n
}, pD = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: BC,
      headersMapper: kC
    },
    default: {
      bodyMapper: ye,
      headersMapper: FC
    }
  },
  queryParameters: [
    ha,
    Ne,
    Ix
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: _n
}, fD = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: IC,
      headersMapper: PC
    },
    default: {
      bodyMapper: ye,
      headersMapper: UC
    }
  },
  queryParameters: [
    Ne,
    Wu,
    ju,
    ss,
    is,
    yx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: _n
}, ED = {
  path: "/",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: QC,
      headersMapper: LC
    },
    default: {
      bodyMapper: ye,
      headersMapper: _C
    }
  },
  requestBody: Qx,
  queryParameters: [
    ha,
    Ne,
    bx
  ],
  urlParameters: [we],
  headerParameters: [
    Gs,
    Pn,
    Re,
    Se
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: _n
}, CD = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: MC
    },
    default: {
      bodyMapper: ye,
      headersMapper: OC
    }
  },
  queryParameters: [
    Un,
    Ne,
    $u
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: _n
}, BD = {
  path: "/",
  httpMethod: "POST",
  responses: {
    202: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: GC
    },
    default: {
      bodyMapper: ye,
      headersMapper: qC
    }
  },
  requestBody: ry,
  queryParameters: [Ne, ny],
  urlParameters: [we],
  headerParameters: [
    Pn,
    Re,
    Se,
    Lr,
    sy
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: _n
}, ID = {
  path: "/",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Yu,
      headersMapper: HC
    },
    default: {
      bodyMapper: ye,
      headersMapper: zC
    }
  },
  queryParameters: [
    Ne,
    ss,
    is,
    iy,
    oy
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: _n
};
class yD {
  /**
   * Initialize a new instance of the class Container class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * creates a new container under the specified account. If the container with the same name already
   * exists, the operation fails
   * @param options The options parameters.
   */
  create(e) {
    return this.client.sendOperationRequest({ options: e }, QD);
  }
  /**
   * returns all user-defined metadata and system properties for the specified container. The data
   * returned does not include the container's list of blobs
   * @param options The options parameters.
   */
  getProperties(e) {
    return this.client.sendOperationRequest({ options: e }, bD);
  }
  /**
   * operation marks the specified container for deletion. The container and any blobs contained within
   * it are later deleted during garbage collection
   * @param options The options parameters.
   */
  delete(e) {
    return this.client.sendOperationRequest({ options: e }, wD);
  }
  /**
   * operation sets one or more user-defined name-value pairs for the specified container.
   * @param options The options parameters.
   */
  setMetadata(e) {
    return this.client.sendOperationRequest({ options: e }, ND);
  }
  /**
   * gets the permissions for the specified container. The permissions indicate whether container data
   * may be accessed publicly.
   * @param options The options parameters.
   */
  getAccessPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, RD);
  }
  /**
   * sets the permissions for the specified container. The permissions indicate whether blobs in a
   * container may be accessed publicly.
   * @param options The options parameters.
   */
  setAccessPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, SD);
  }
  /**
   * Restores a previously-deleted container.
   * @param options The options parameters.
   */
  restore(e) {
    return this.client.sendOperationRequest({ options: e }, vD);
  }
  /**
   * Renames an existing container.
   * @param sourceContainerName Required.  Specifies the name of the container to rename.
   * @param options The options parameters.
   */
  rename(e, r) {
    return this.client.sendOperationRequest({ sourceContainerName: e, options: r }, xD);
  }
  /**
   * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
   * @param contentLength The length of the request.
   * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
   *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
   * @param body Initial data
   * @param options The options parameters.
   */
  submitBatch(e, r, n, s) {
    return this.client.sendOperationRequest({ contentLength: e, multipartContentType: r, body: n, options: s }, DD);
  }
  /**
   * The Filter Blobs operation enables callers to list blobs in a container whose tags match a given
   * search expression.  Filter blobs searches within the given container.
   * @param options The options parameters.
   */
  filterBlobs(e) {
    return this.client.sendOperationRequest({ options: e }, TD);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param options The options parameters.
   */
  acquireLease(e) {
    return this.client.sendOperationRequest({ options: e }, kD);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  releaseLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, FD);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  renewLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, PD);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param options The options parameters.
   */
  breakLease(e) {
    return this.client.sendOperationRequest({ options: e }, UD);
  }
  /**
   * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
   * be 15 to 60 seconds, or can be infinite
   * @param leaseId Specifies the current lease ID on the resource.
   * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
   *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
   *                        (String) for a list of valid GUID string formats.
   * @param options The options parameters.
   */
  changeLease(e, r, n) {
    return this.client.sendOperationRequest({ leaseId: e, proposedLeaseId: r, options: n }, LD);
  }
  /**
   * [Update] The List Blobs operation returns a list of the blobs under the specified container
   * @param options The options parameters.
   */
  listBlobFlatSegment(e) {
    return this.client.sendOperationRequest({ options: e }, _D);
  }
  /**
   * [Update] The List Blobs operation returns a list of the blobs under the specified container
   * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix
   *                  element in the response body that acts as a placeholder for all blobs whose names begin with the
   *                  same substring up to the appearance of the delimiter character. The delimiter may be a single
   *                  character or a string.
   * @param options The options parameters.
   */
  listBlobHierarchySegment(e, r) {
    return this.client.sendOperationRequest({ delimiter: e, options: r }, MD);
  }
  /**
   * Returns the sku name and account kind
   * @param options The options parameters.
   */
  getAccountInfo(e) {
    return this.client.sendOperationRequest({ options: e }, OD);
  }
}
const er = Ls(
  Os,
  /* isXml */
  !0
), QD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: YC
    },
    default: {
      bodyMapper: ye,
      headersMapper: JC
    }
  },
  queryParameters: [Ne, sr],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    tn,
    ay,
    wx,
    Nx
  ],
  isXML: !0,
  serializer: er
}, bD = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: VC
    },
    default: {
      bodyMapper: ye,
      headersMapper: WC
    }
  },
  queryParameters: [Ne, sr],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et
  ],
  isXML: !0,
  serializer: er
}, wD = {
  path: "/{containerName}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: jC
    },
    default: {
      bodyMapper: ye,
      headersMapper: $C
    }
  },
  queryParameters: [Ne, sr],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze
  ],
  isXML: !0,
  serializer: er
}, ND = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: XC
    },
    default: {
      bodyMapper: ye,
      headersMapper: KC
    }
  },
  queryParameters: [
    Ne,
    sr,
    Ay
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    tn,
    et,
    Ke
  ],
  isXML: !0,
  serializer: er
}, RD = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "SignedIdentifier" }
          }
        },
        serializedName: "SignedIdentifiers",
        xmlName: "SignedIdentifiers",
        xmlIsWrapped: !0,
        xmlElementName: "SignedIdentifier"
      },
      headersMapper: ZC
    },
    default: {
      bodyMapper: ye,
      headersMapper: eB
    }
  },
  queryParameters: [
    Ne,
    sr,
    cy
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et
  ],
  isXML: !0,
  serializer: er
}, SD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: tB
    },
    default: {
      bodyMapper: ye,
      headersMapper: rB
    }
  },
  requestBody: Rx,
  queryParameters: [
    Ne,
    sr,
    cy
  ],
  urlParameters: [we],
  headerParameters: [
    Gs,
    Pn,
    Re,
    Se,
    ay,
    et,
    Ke,
    Ze
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: er
}, vD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: nB
    },
    default: {
      bodyMapper: ye,
      headersMapper: sB
    }
  },
  queryParameters: [
    Ne,
    sr,
    ly
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Sx,
    vx
  ],
  isXML: !0,
  serializer: er
}, xD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: iB
    },
    default: {
      bodyMapper: ye,
      headersMapper: oB
    }
  },
  queryParameters: [
    Ne,
    sr,
    xx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Dx,
    Tx
  ],
  isXML: !0,
  serializer: er
}, DD = {
  path: "/{containerName}",
  httpMethod: "POST",
  responses: {
    202: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: aB
    },
    default: {
      bodyMapper: ye,
      headersMapper: AB
    }
  },
  requestBody: ry,
  queryParameters: [
    Ne,
    ny,
    sr
  ],
  urlParameters: [we],
  headerParameters: [
    Pn,
    Re,
    Se,
    Lr,
    sy
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: er
}, TD = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Yu,
      headersMapper: cB
    },
    default: {
      bodyMapper: ye,
      headersMapper: lB
    }
  },
  queryParameters: [
    Ne,
    ss,
    is,
    iy,
    oy,
    sr
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: er
}, kD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: uB
    },
    default: {
      bodyMapper: ye,
      headersMapper: dB
    }
  },
  queryParameters: [
    Ne,
    sr,
    dn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    uy,
    dy,
    gy
  ],
  isXML: !0,
  serializer: er
}, FD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: gB
    },
    default: {
      bodyMapper: ye,
      headersMapper: mB
    }
  },
  queryParameters: [
    Ne,
    sr,
    dn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    my,
    qs
  ],
  isXML: !0,
  serializer: er
}, PD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: hB
    },
    default: {
      bodyMapper: ye,
      headersMapper: pB
    }
  },
  queryParameters: [
    Ne,
    sr,
    dn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    qs,
    hy
  ],
  isXML: !0,
  serializer: er
}, UD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: fB
    },
    default: {
      bodyMapper: ye,
      headersMapper: EB
    }
  },
  queryParameters: [
    Ne,
    sr,
    dn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    py,
    fy
  ],
  isXML: !0,
  serializer: er
}, LD = {
  path: "/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: CB
    },
    default: {
      bodyMapper: ye,
      headersMapper: BB
    }
  },
  queryParameters: [
    Ne,
    sr,
    dn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    qs,
    Ey,
    Cy
  ],
  isXML: !0,
  serializer: er
}, _D = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: bC,
      headersMapper: IB
    },
    default: {
      bodyMapper: ye,
      headersMapper: yB
    }
  },
  queryParameters: [
    Ne,
    Wu,
    ju,
    ss,
    is,
    sr,
    By
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: er
}, MD = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: wC,
      headersMapper: QB
    },
    default: {
      bodyMapper: ye,
      headersMapper: bB
    }
  },
  queryParameters: [
    Ne,
    Wu,
    ju,
    ss,
    is,
    sr,
    By,
    kx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: er
}, OD = {
  path: "/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: wB
    },
    default: {
      bodyMapper: ye,
      headersMapper: NB
    }
  },
  queryParameters: [
    Un,
    Ne,
    $u
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: er
};
class GD {
  /**
   * Initialize a new instance of the class Blob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Download operation reads or downloads a blob from the system, including its metadata and
   * properties. You can also call Download to read a snapshot.
   * @param options The options parameters.
   */
  download(e) {
    return this.client.sendOperationRequest({ options: e }, qD);
  }
  /**
   * The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system
   * properties for the blob. It does not return the content of the blob.
   * @param options The options parameters.
   */
  getProperties(e) {
    return this.client.sendOperationRequest({ options: e }, HD);
  }
  /**
   * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
   * permanently removed from the storage account. If the storage account's soft delete feature is
   * enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
   * immediately. However, the blob service retains the blob or snapshot for the number of days specified
   * by the DeleteRetentionPolicy section of [Storage service properties]
   * (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is
   * permanently removed from the storage account. Note that you continue to be charged for the
   * soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the
   * "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You
   * can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a
   * soft-deleted blob or snapshot causes the service to return an HTTP status code of 404
   * (ResourceNotFound).
   * @param options The options parameters.
   */
  delete(e) {
    return this.client.sendOperationRequest({ options: e }, zD);
  }
  /**
   * Undelete a blob that was previously soft deleted
   * @param options The options parameters.
   */
  undelete(e) {
    return this.client.sendOperationRequest({ options: e }, YD);
  }
  /**
   * Sets the time a blob will expire and be deleted.
   * @param expiryOptions Required. Indicates mode of the expiry time
   * @param options The options parameters.
   */
  setExpiry(e, r) {
    return this.client.sendOperationRequest({ expiryOptions: e, options: r }, JD);
  }
  /**
   * The Set HTTP Headers operation sets system properties on the blob
   * @param options The options parameters.
   */
  setHttpHeaders(e) {
    return this.client.sendOperationRequest({ options: e }, VD);
  }
  /**
   * The Set Immutability Policy operation sets the immutability policy on the blob
   * @param options The options parameters.
   */
  setImmutabilityPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, WD);
  }
  /**
   * The Delete Immutability Policy operation deletes the immutability policy on the blob
   * @param options The options parameters.
   */
  deleteImmutabilityPolicy(e) {
    return this.client.sendOperationRequest({ options: e }, jD);
  }
  /**
   * The Set Legal Hold operation sets a legal hold on the blob.
   * @param legalHold Specified if a legal hold should be set on the blob.
   * @param options The options parameters.
   */
  setLegalHold(e, r) {
    return this.client.sendOperationRequest({ legalHold: e, options: r }, $D);
  }
  /**
   * The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more
   * name-value pairs
   * @param options The options parameters.
   */
  setMetadata(e) {
    return this.client.sendOperationRequest({ options: e }, XD);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param options The options parameters.
   */
  acquireLease(e) {
    return this.client.sendOperationRequest({ options: e }, KD);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  releaseLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, ZD);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  renewLease(e, r) {
    return this.client.sendOperationRequest({ leaseId: e, options: r }, eT);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
   *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
   *                        (String) for a list of valid GUID string formats.
   * @param options The options parameters.
   */
  changeLease(e, r, n) {
    return this.client.sendOperationRequest({ leaseId: e, proposedLeaseId: r, options: n }, tT);
  }
  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param options The options parameters.
   */
  breakLease(e) {
    return this.client.sendOperationRequest({ options: e }, rT);
  }
  /**
   * The Create Snapshot operation creates a read-only snapshot of a blob
   * @param options The options parameters.
   */
  createSnapshot(e) {
    return this.client.sendOperationRequest({ options: e }, nT);
  }
  /**
   * The Start Copy From URL operation copies a blob or an internet resource to a new blob.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  startCopyFromURL(e, r) {
    return this.client.sendOperationRequest({ copySource: e, options: r }, sT);
  }
  /**
   * The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return
   * a response until the copy is complete.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  copyFromURL(e, r) {
    return this.client.sendOperationRequest({ copySource: e, options: r }, iT);
  }
  /**
   * The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination
   * blob with zero length and full metadata.
   * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy Blob
   *               operation.
   * @param options The options parameters.
   */
  abortCopyFromURL(e, r) {
    return this.client.sendOperationRequest({ copyId: e, options: r }, oT);
  }
  /**
   * The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium
   * storage account and on a block blob in a blob storage account (locally redundant storage only). A
   * premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block
   * blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's
   * ETag.
   * @param tier Indicates the tier to be set on the blob.
   * @param options The options parameters.
   */
  setTier(e, r) {
    return this.client.sendOperationRequest({ tier: e, options: r }, aT);
  }
  /**
   * Returns the sku name and account kind
   * @param options The options parameters.
   */
  getAccountInfo(e) {
    return this.client.sendOperationRequest({ options: e }, AT);
  }
  /**
   * The Query operation enables users to select/project on blob data by providing simple query
   * expressions.
   * @param options The options parameters.
   */
  query(e) {
    return this.client.sendOperationRequest({ options: e }, cT);
  }
  /**
   * The Get Tags operation enables users to get the tags associated with a blob.
   * @param options The options parameters.
   */
  getTags(e) {
    return this.client.sendOperationRequest({ options: e }, lT);
  }
  /**
   * The Set Tags operation enables users to set tags on a blob.
   * @param options The options parameters.
   */
  setTags(e) {
    return this.client.sendOperationRequest({ options: e }, uT);
  }
}
const Rt = Ls(
  Os,
  /* isXml */
  !0
), qD = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: Wl
    },
    206: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: Wl
    },
    default: {
      bodyMapper: ye,
      headersMapper: RB
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    oo,
    Fx,
    Px,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, HD = {
  path: "/{containerName}/{blob}",
  httpMethod: "HEAD",
  responses: {
    200: {
      headersMapper: SB
    },
    default: {
      bodyMapper: ye,
      headersMapper: vB
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, zD = {
  path: "/{containerName}/{blob}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: xB
    },
    default: {
      bodyMapper: ye,
      headersMapper: DB
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn,
    Lx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    at,
    At,
    nt,
    Ux
  ],
  isXML: !0,
  serializer: Rt
}, YD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: TB
    },
    default: {
      bodyMapper: ye,
      headersMapper: kB
    }
  },
  queryParameters: [Ne, ly],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: Rt
}, JD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: FB
    },
    default: {
      bodyMapper: ye,
      headersMapper: PB
    }
  },
  queryParameters: [Ne, _x],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Mx,
    Ox
  ],
  isXML: !0,
  serializer: Rt
}, VD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: UB
    },
    default: {
      bodyMapper: ye,
      headersMapper: LB
    }
  },
  queryParameters: [Un, Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    at,
    At,
    nt,
    Hs,
    zs,
    Ys,
    Js,
    Vs,
    Ws
  ],
  isXML: !0,
  serializer: Rt
}, WD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: _B
    },
    default: {
      bodyMapper: ye,
      headersMapper: MB
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn,
    Iy
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ze,
    os,
    as
  ],
  isXML: !0,
  serializer: Rt
}, jD = {
  path: "/{containerName}/{blob}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: OB
    },
    default: {
      bodyMapper: ye,
      headersMapper: GB
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn,
    Iy
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: Rt
}, $D = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: qB
    },
    default: {
      bodyMapper: ye,
      headersMapper: HB
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn,
    Gx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    qx
  ],
  isXML: !0,
  serializer: Rt
}, XD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: zB
    },
    default: {
      bodyMapper: ye,
      headersMapper: YB
    }
  },
  queryParameters: [Ne, Ay],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or
  ],
  isXML: !0,
  serializer: Rt
}, KD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: JB
    },
    default: {
      bodyMapper: ye,
      headersMapper: VB
    }
  },
  queryParameters: [Ne, dn],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    uy,
    dy,
    gy,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, ZD = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: WB
    },
    default: {
      bodyMapper: ye,
      headersMapper: jB
    }
  },
  queryParameters: [Ne, dn],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    my,
    qs,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, eT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: $B
    },
    default: {
      bodyMapper: ye,
      headersMapper: XB
    }
  },
  queryParameters: [Ne, dn],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    qs,
    hy,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, tT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: KB
    },
    default: {
      bodyMapper: ye,
      headersMapper: ZB
    }
  },
  queryParameters: [Ne, dn],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    qs,
    Ey,
    Cy,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, rT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: eI
    },
    default: {
      bodyMapper: ye,
      headersMapper: tI
    }
  },
  queryParameters: [Ne, dn],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    py,
    fy,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, nT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: rI
    },
    default: {
      bodyMapper: ye,
      headersMapper: nI
    }
  },
  queryParameters: [Ne, Hx],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or
  ],
  isXML: !0,
  serializer: Rt
}, sT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: sI
    },
    default: {
      bodyMapper: ye,
      headersMapper: iI
    }
  },
  queryParameters: [Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    tn,
    et,
    Ke,
    Ze,
    at,
    At,
    nt,
    os,
    as,
    js,
    yy,
    $s,
    Xs,
    Ks,
    Zs,
    Qy,
    pa,
    As,
    zx,
    ei
  ],
  isXML: !0,
  serializer: Rt
}, iT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: oI
    },
    default: {
      bodyMapper: ye,
      headersMapper: aI
    }
  },
  queryParameters: [Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    tn,
    et,
    Ke,
    Ze,
    at,
    At,
    nt,
    os,
    as,
    or,
    js,
    $s,
    Xs,
    Ks,
    Zs,
    pa,
    As,
    ei,
    Yx,
    ao,
    Ao,
    by
  ],
  isXML: !0,
  serializer: Rt
}, oT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    204: {
      headersMapper: AI
    },
    default: {
      bodyMapper: ye,
      headersMapper: cI
    }
  },
  queryParameters: [
    Ne,
    Jx,
    Wx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Vx
  ],
  isXML: !0,
  serializer: Rt
}, aT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: jl
    },
    202: {
      headersMapper: jl
    },
    default: {
      bodyMapper: ye,
      headersMapper: lI
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn,
    jx
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    nt,
    yy,
    $x
  ],
  isXML: !0,
  serializer: Rt
}, AT = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      headersMapper: uI
    },
    default: {
      bodyMapper: ye,
      headersMapper: dI
    }
  },
  queryParameters: [
    Un,
    Ne,
    $u
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe
  ],
  isXML: !0,
  serializer: Rt
}, cT = {
  path: "/{containerName}/{blob}",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: $l
    },
    206: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: $l
    },
    default: {
      bodyMapper: ye,
      headersMapper: gI
    }
  },
  requestBody: Xx,
  queryParameters: [
    Ne,
    Gr,
    Kx
  ],
  urlParameters: [we],
  headerParameters: [
    Gs,
    Pn,
    Re,
    Se,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: Rt
}, lT = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Ju,
      headersMapper: mI
    },
    default: {
      bodyMapper: ye,
      headersMapper: hI
    }
  },
  queryParameters: [
    Ne,
    Gr,
    yn,
    wy
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    nt
  ],
  isXML: !0,
  serializer: Rt
}, uT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    204: {
      headersMapper: pI
    },
    default: {
      bodyMapper: ye,
      headersMapper: fI
    }
  },
  requestBody: Zx,
  queryParameters: [
    Ne,
    yn,
    wy
  ],
  urlParameters: [we],
  headerParameters: [
    Gs,
    Pn,
    Re,
    Se,
    et,
    nt,
    Ln,
    ti
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: Rt
};
class dT {
  /**
   * Initialize a new instance of the class PageBlob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Create operation creates a new page blob.
   * @param contentLength The length of the request.
   * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
   *                          page blob size must be aligned to a 512-byte boundary.
   * @param options The options parameters.
   */
  create(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, blobContentLength: r, options: n }, gT);
  }
  /**
   * The Upload Pages operation writes a range of pages to a page blob
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  uploadPages(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, body: r, options: n }, mT);
  }
  /**
   * The Clear Pages operation clears a set of pages from a page blob
   * @param contentLength The length of the request.
   * @param options The options parameters.
   */
  clearPages(e, r) {
    return this.client.sendOperationRequest({ contentLength: e, options: r }, hT);
  }
  /**
   * The Upload Pages operation writes a range of pages to a page blob where the contents are read from a
   * URL
   * @param sourceUrl Specify a URL to the copy source.
   * @param sourceRange Bytes of source data in the specified range. The length of this range should
   *                    match the ContentLength header and x-ms-range/Range destination range header.
   * @param contentLength The length of the request.
   * @param range The range of bytes to which the source range would be written. The range should be 512
   *              aligned and range-end is required.
   * @param options The options parameters.
   */
  uploadPagesFromURL(e, r, n, s, i) {
    return this.client.sendOperationRequest({ sourceUrl: e, sourceRange: r, contentLength: n, range: s, options: i }, pT);
  }
  /**
   * The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a
   * page blob
   * @param options The options parameters.
   */
  getPageRanges(e) {
    return this.client.sendOperationRequest({ options: e }, fT);
  }
  /**
   * The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were
   * changed between target blob and previous snapshot.
   * @param options The options parameters.
   */
  getPageRangesDiff(e) {
    return this.client.sendOperationRequest({ options: e }, ET);
  }
  /**
   * Resize the Blob
   * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
   *                          page blob size must be aligned to a 512-byte boundary.
   * @param options The options parameters.
   */
  resize(e, r) {
    return this.client.sendOperationRequest({ blobContentLength: e, options: r }, CT);
  }
  /**
   * Update the sequence number of the blob
   * @param sequenceNumberAction Required if the x-ms-blob-sequence-number header is set for the request.
   *                             This property applies to page blobs only. This property indicates how the service should modify the
   *                             blob's sequence number
   * @param options The options parameters.
   */
  updateSequenceNumber(e, r) {
    return this.client.sendOperationRequest({ sequenceNumberAction: e, options: r }, BT);
  }
  /**
   * The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob.
   * The snapshot is copied such that only the differential changes between the previously copied
   * snapshot are transferred to the destination. The copied snapshots are complete copies of the
   * original snapshot and can be read or copied from as usual. This API is supported since REST version
   * 2016-05-31.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  copyIncremental(e, r) {
    return this.client.sendOperationRequest({ copySource: e, options: r }, IT);
  }
}
const Qn = Ls(
  Os,
  /* isXml */
  !0
), gT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: EI
    },
    default: {
      bodyMapper: ye,
      headersMapper: CI
    }
  },
  queryParameters: [Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    Hs,
    zs,
    Ys,
    Js,
    Vs,
    Ws,
    os,
    as,
    or,
    js,
    As,
    ei,
    eD,
    Ny,
    Ry
  ],
  isXML: !0,
  serializer: Qn
}, mT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: BI
    },
    default: {
      bodyMapper: ye,
      headersMapper: II
    }
  },
  requestBody: Ea,
  queryParameters: [Ne, Xu],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Lr,
    et,
    Ke,
    Ze,
    oo,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or,
    Ln,
    ti,
    fa,
    Ca,
    Sy,
    Ku,
    Zu,
    ed
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: Qn
}, hT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: yI
    },
    default: {
      bodyMapper: ye,
      headersMapper: QI
    }
  },
  queryParameters: [Ne, Xu],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    et,
    Ke,
    Ze,
    oo,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or,
    Ku,
    Zu,
    ed,
    tD
  ],
  isXML: !0,
  serializer: Qn
}, pT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: bI
    },
    default: {
      bodyMapper: ye,
      headersMapper: wI
    }
  },
  queryParameters: [Ne, Xu],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or,
    $s,
    Xs,
    Ks,
    Zs,
    ao,
    Ao,
    Sy,
    Ku,
    Zu,
    ed,
    td,
    rD,
    rd,
    nD
  ],
  isXML: !0,
  serializer: Qn
}, fT = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Vu,
      headersMapper: NI
    },
    default: {
      bodyMapper: ye,
      headersMapper: RI
    }
  },
  queryParameters: [
    Ne,
    ss,
    is,
    Gr,
    vy
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    oo,
    at,
    At,
    nt
  ],
  isXML: !0,
  serializer: Qn
}, ET = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Vu,
      headersMapper: SI
    },
    default: {
      bodyMapper: ye,
      headersMapper: vI
    }
  },
  queryParameters: [
    Ne,
    ss,
    is,
    Gr,
    vy,
    sD
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    oo,
    at,
    At,
    nt,
    iD
  ],
  isXML: !0,
  serializer: Qn
}, CT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: xI
    },
    default: {
      bodyMapper: ye,
      headersMapper: DI
    }
  },
  queryParameters: [Un, Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or,
    Ny
  ],
  isXML: !0,
  serializer: Qn
}, BT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: TI
    },
    default: {
      bodyMapper: ye,
      headersMapper: kI
    }
  },
  queryParameters: [Un, Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    at,
    At,
    nt,
    Ry,
    oD
  ],
  isXML: !0,
  serializer: Qn
}, IT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: FI
    },
    default: {
      bodyMapper: ye,
      headersMapper: PI
    }
  },
  queryParameters: [Ne, aD],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Ke,
    Ze,
    at,
    At,
    nt,
    pa
  ],
  isXML: !0,
  serializer: Qn
};
class yT {
  /**
   * Initialize a new instance of the class AppendBlob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Create Append Blob operation creates a new append blob.
   * @param contentLength The length of the request.
   * @param options The options parameters.
   */
  create(e, r) {
    return this.client.sendOperationRequest({ contentLength: e, options: r }, QT);
  }
  /**
   * The Append Block operation commits a new block of data to the end of an existing append blob. The
   * Append Block operation is permitted only if the blob was created with x-ms-blob-type set to
   * AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  appendBlock(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, body: r, options: n }, bT);
  }
  /**
   * The Append Block operation commits a new block of data to the end of an existing append blob where
   * the contents are read from a source url. The Append Block operation is permitted only if the blob
   * was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version
   * 2015-02-21 version or later.
   * @param sourceUrl Specify a URL to the copy source.
   * @param contentLength The length of the request.
   * @param options The options parameters.
   */
  appendBlockFromUrl(e, r, n) {
    return this.client.sendOperationRequest({ sourceUrl: e, contentLength: r, options: n }, wT);
  }
  /**
   * The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version
   * 2019-12-12 version or later.
   * @param options The options parameters.
   */
  seal(e) {
    return this.client.sendOperationRequest({ options: e }, NT);
  }
}
const Ba = Ls(
  Os,
  /* isXml */
  !0
), QT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: UI
    },
    default: {
      bodyMapper: ye,
      headersMapper: LI
    }
  },
  queryParameters: [Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    Hs,
    zs,
    Ys,
    Js,
    Vs,
    Ws,
    os,
    as,
    or,
    As,
    ei,
    AD
  ],
  isXML: !0,
  serializer: Ba
}, bT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: _I
    },
    default: {
      bodyMapper: ye,
      headersMapper: MI
    }
  },
  requestBody: Ea,
  queryParameters: [Ne, xy],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Lr,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or,
    Ln,
    ti,
    fa,
    Ca,
    Dy,
    nd
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: Ba
}, wT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: OI
    },
    default: {
      bodyMapper: ye,
      headersMapper: GI
    }
  },
  queryParameters: [Ne, xy],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    or,
    $s,
    Xs,
    Ks,
    Zs,
    ao,
    Ao,
    Ln,
    td,
    rd,
    Dy,
    nd,
    Ty
  ],
  isXML: !0,
  serializer: Ba
}, NT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: qI
    },
    default: {
      bodyMapper: ye,
      headersMapper: HI
    }
  },
  queryParameters: [Ne, cD],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    Ke,
    Ze,
    at,
    At,
    nd
  ],
  isXML: !0,
  serializer: Ba
};
class RT {
  /**
   * Initialize a new instance of the class BlockBlob class.
   * @param client Reference to the service client
   */
  constructor(e) {
    this.client = e;
  }
  /**
   * The Upload Block Blob operation updates the content of an existing block blob. Updating an existing
   * block blob overwrites any existing metadata on the blob. Partial updates are not supported with Put
   * Blob; the content of the existing blob is overwritten with the content of the new blob. To perform a
   * partial update of the content of a block blob, use the Put Block List operation.
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  upload(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, body: r, options: n }, ST);
  }
  /**
   * The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read
   * from a given URL.  This API is supported beginning with the 2020-04-08 version. Partial updates are
   * not supported with Put Blob from URL; the content of an existing blob is overwritten with the
   * content of the new blob.  To perform partial updates to a block blobs contents using a source URL,
   * use the Put Block from URL API in conjunction with Put Block List.
   * @param contentLength The length of the request.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
   *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
   *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
   *                   access signature.
   * @param options The options parameters.
   */
  putBlobFromUrl(e, r, n) {
    return this.client.sendOperationRequest({ contentLength: e, copySource: r, options: n }, vT);
  }
  /**
   * The Stage Block operation creates a new block to be committed as part of a blob
   * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
   *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
   *                for the blockid parameter must be the same size for each block.
   * @param contentLength The length of the request.
   * @param body Initial data
   * @param options The options parameters.
   */
  stageBlock(e, r, n, s) {
    return this.client.sendOperationRequest({ blockId: e, contentLength: r, body: n, options: s }, xT);
  }
  /**
   * The Stage Block operation creates a new block to be committed as part of a blob where the contents
   * are read from a URL.
   * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
   *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
   *                for the blockid parameter must be the same size for each block.
   * @param contentLength The length of the request.
   * @param sourceUrl Specify a URL to the copy source.
   * @param options The options parameters.
   */
  stageBlockFromURL(e, r, n, s) {
    return this.client.sendOperationRequest({ blockId: e, contentLength: r, sourceUrl: n, options: s }, DT);
  }
  /**
   * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the
   * blob. In order to be written as part of a blob, a block must have been successfully written to the
   * server in a prior Put Block operation. You can call Put Block List to update a blob by uploading
   * only those blocks that have changed, then committing the new and existing blocks together. You can
   * do this by specifying whether to commit a block from the committed block list or from the
   * uncommitted block list, or to commit the most recently uploaded version of the block, whichever list
   * it may belong to.
   * @param blocks Blob Blocks.
   * @param options The options parameters.
   */
  commitBlockList(e, r) {
    return this.client.sendOperationRequest({ blocks: e, options: r }, TT);
  }
  /**
   * The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block
   * blob
   * @param listType Specifies whether to return the list of committed blocks, the list of uncommitted
   *                 blocks, or both lists together.
   * @param options The options parameters.
   */
  getBlockList(e, r) {
    return this.client.sendOperationRequest({ listType: e, options: r }, kT);
  }
}
const ri = Ls(
  Os,
  /* isXml */
  !0
), ST = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: zI
    },
    default: {
      bodyMapper: ye,
      headersMapper: YI
    }
  },
  requestBody: Ea,
  queryParameters: [Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Lr,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    Hs,
    zs,
    Ys,
    Js,
    Vs,
    Ws,
    os,
    as,
    or,
    js,
    As,
    ei,
    Ln,
    ti,
    fa,
    Ca,
    ky
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: ri
}, vT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: JI
    },
    default: {
      bodyMapper: ye,
      headersMapper: VI
    }
  },
  queryParameters: [Ne],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    Hs,
    zs,
    Ys,
    Js,
    Vs,
    Ws,
    or,
    js,
    $s,
    Xs,
    Ks,
    Zs,
    Qy,
    pa,
    As,
    ao,
    Ao,
    by,
    Ln,
    ky,
    lD
  ],
  isXML: !0,
  serializer: ri
}, xT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: WI
    },
    default: {
      bodyMapper: ye,
      headersMapper: jI
    }
  },
  requestBody: Ea,
  queryParameters: [
    Ne,
    Fy,
    Py
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Lr,
    et,
    Xt,
    Kt,
    Zt,
    or,
    Ln,
    ti,
    fa,
    Ca
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "binary",
  serializer: ri
}, DT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: $I
    },
    default: {
      bodyMapper: ye,
      headersMapper: XI
    }
  },
  queryParameters: [
    Ne,
    Fy,
    Py
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    Lr,
    et,
    Xt,
    Kt,
    Zt,
    or,
    $s,
    Xs,
    Ks,
    Zs,
    ao,
    Ao,
    td,
    rd,
    Ty
  ],
  isXML: !0,
  serializer: ri
}, TT = {
  path: "/{containerName}/{blob}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: KI
    },
    default: {
      bodyMapper: ye,
      headersMapper: ZI
    }
  },
  requestBody: uD,
  queryParameters: [Ne, Uy],
  urlParameters: [we],
  headerParameters: [
    Gs,
    Pn,
    Re,
    Se,
    tn,
    et,
    Ke,
    Ze,
    Xt,
    Kt,
    Zt,
    at,
    At,
    nt,
    Hs,
    zs,
    Ys,
    Js,
    Vs,
    Ws,
    os,
    as,
    or,
    js,
    As,
    ei,
    Ln,
    ti
  ],
  isXML: !0,
  contentType: "application/xml; charset=utf-8",
  mediaType: "xml",
  serializer: ri
}, kT = {
  path: "/{containerName}/{blob}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: RC,
      headersMapper: ey
    },
    default: {
      bodyMapper: ye,
      headersMapper: ty
    }
  },
  queryParameters: [
    Ne,
    Gr,
    Uy,
    dD
  ],
  urlParameters: [we],
  headerParameters: [
    Re,
    Se,
    Fe,
    et,
    nt
  ],
  isXML: !0,
  serializer: ri
};
let FT = class extends $S {
  /**
   * Initializes a new instance of the StorageClient class.
   * @param url The URL of the service account, container, or blob that is the target of the desired
   *            operation.
   * @param options The parameter options
   */
  constructor(e, r) {
    var n, s;
    if (e === void 0)
      throw new Error("'url' cannot be null");
    r || (r = {});
    const i = {
      requestContentType: "application/json; charset=utf-8"
    }, o = "azsdk-js-azure-storage-blob/12.27.0", c = r.userAgentOptions && r.userAgentOptions.userAgentPrefix ? `${r.userAgentOptions.userAgentPrefix} ${o}` : `${o}`, l = Object.assign(Object.assign(Object.assign({}, i), r), { userAgentOptions: {
      userAgentPrefix: c
    }, endpoint: (s = (n = r.endpoint) !== null && n !== void 0 ? n : r.baseUri) !== null && s !== void 0 ? s : "{url}" });
    super(l), this.url = e, this.version = r.version || "2025-05-05", this.service = new gD(this), this.container = new yD(this), this.blob = new GD(this), this.pageBlob = new dT(this), this.appendBlob = new yT(this), this.blockBlob = new RT(this);
  }
};
class Ly extends FT {
  async sendOperationRequest(e, r) {
    const n = Object.assign({}, r);
    return (n.path === "/{containerName}" || n.path === "/{containerName}/{blob}") && (n.path = ""), super.sendOperationRequest(e, n);
  }
}
class sd {
  /**
   * Creates an instance of StorageClient.
   * @param url - url to resource
   * @param pipeline - request policy pipeline.
   */
  constructor(e, r) {
    this.url = Ev(e), this.accountName = AC(e), this.pipeline = r, this.storageClientContext = new Ly(this.url, fC(r)), this.isHttps = aC(Iv(this.url) || "", "https"), this.credential = EC(r);
    const n = this.storageClientContext;
    n.requestContentType = void 0;
  }
}
const pe = TE({
  packageName: "@azure/storage-blob",
  packageVersion: tC,
  namespace: "Microsoft.Storage"
});
class Cn {
  constructor() {
    this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.tag = !1, this.move = !1, this.execute = !1, this.setImmutabilityPolicy = !1, this.permanentDelete = !1;
  }
  /**
   * Creates a {@link BlobSASPermissions} from the specified permissions string. This method will throw an
   * Error if it encounters a character that does not correspond to a valid permission.
   *
   * @param permissions -
   */
  static parse(e) {
    const r = new Cn();
    for (const n of e)
      switch (n) {
        case "r":
          r.read = !0;
          break;
        case "a":
          r.add = !0;
          break;
        case "c":
          r.create = !0;
          break;
        case "w":
          r.write = !0;
          break;
        case "d":
          r.delete = !0;
          break;
        case "x":
          r.deleteVersion = !0;
          break;
        case "t":
          r.tag = !0;
          break;
        case "m":
          r.move = !0;
          break;
        case "e":
          r.execute = !0;
          break;
        case "i":
          r.setImmutabilityPolicy = !0;
          break;
        case "y":
          r.permanentDelete = !0;
          break;
        default:
          throw new RangeError(`Invalid permission: ${n}`);
      }
    return r;
  }
  /**
   * Creates a {@link BlobSASPermissions} from a raw object which contains same keys as it
   * and boolean values for them.
   *
   * @param permissionLike -
   */
  static from(e) {
    const r = new Cn();
    return e.read && (r.read = !0), e.add && (r.add = !0), e.create && (r.create = !0), e.write && (r.write = !0), e.delete && (r.delete = !0), e.deleteVersion && (r.deleteVersion = !0), e.tag && (r.tag = !0), e.move && (r.move = !0), e.execute && (r.execute = !0), e.setImmutabilityPolicy && (r.setImmutabilityPolicy = !0), e.permanentDelete && (r.permanentDelete = !0), r;
  }
  /**
   * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
   * order accepted by the service.
   *
   * @returns A string which represents the BlobSASPermissions
   */
  toString() {
    const e = [];
    return this.read && e.push("r"), this.add && e.push("a"), this.create && e.push("c"), this.write && e.push("w"), this.delete && e.push("d"), this.deleteVersion && e.push("x"), this.tag && e.push("t"), this.move && e.push("m"), this.execute && e.push("e"), this.setImmutabilityPolicy && e.push("i"), this.permanentDelete && e.push("y"), e.join("");
  }
}
class Bn {
  constructor() {
    this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.tag = !1, this.move = !1, this.execute = !1, this.setImmutabilityPolicy = !1, this.permanentDelete = !1, this.filterByTags = !1;
  }
  /**
   * Creates an {@link ContainerSASPermissions} from the specified permissions string. This method will throw an
   * Error if it encounters a character that does not correspond to a valid permission.
   *
   * @param permissions -
   */
  static parse(e) {
    const r = new Bn();
    for (const n of e)
      switch (n) {
        case "r":
          r.read = !0;
          break;
        case "a":
          r.add = !0;
          break;
        case "c":
          r.create = !0;
          break;
        case "w":
          r.write = !0;
          break;
        case "d":
          r.delete = !0;
          break;
        case "l":
          r.list = !0;
          break;
        case "t":
          r.tag = !0;
          break;
        case "x":
          r.deleteVersion = !0;
          break;
        case "m":
          r.move = !0;
          break;
        case "e":
          r.execute = !0;
          break;
        case "i":
          r.setImmutabilityPolicy = !0;
          break;
        case "y":
          r.permanentDelete = !0;
          break;
        case "f":
          r.filterByTags = !0;
          break;
        default:
          throw new RangeError(`Invalid permission ${n}`);
      }
    return r;
  }
  /**
   * Creates a {@link ContainerSASPermissions} from a raw object which contains same keys as it
   * and boolean values for them.
   *
   * @param permissionLike -
   */
  static from(e) {
    const r = new Bn();
    return e.read && (r.read = !0), e.add && (r.add = !0), e.create && (r.create = !0), e.write && (r.write = !0), e.delete && (r.delete = !0), e.list && (r.list = !0), e.deleteVersion && (r.deleteVersion = !0), e.tag && (r.tag = !0), e.move && (r.move = !0), e.execute && (r.execute = !0), e.setImmutabilityPolicy && (r.setImmutabilityPolicy = !0), e.permanentDelete && (r.permanentDelete = !0), e.filterByTags && (r.filterByTags = !0), r;
  }
  /**
   * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
   * order accepted by the service.
   *
   * The order of the characters should be as specified here to ensure correctness.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   */
  toString() {
    const e = [];
    return this.read && e.push("r"), this.add && e.push("a"), this.create && e.push("c"), this.write && e.push("w"), this.delete && e.push("d"), this.deleteVersion && e.push("x"), this.list && e.push("l"), this.tag && e.push("t"), this.move && e.push("m"), this.execute && e.push("e"), this.setImmutabilityPolicy && e.push("i"), this.permanentDelete && e.push("y"), this.filterByTags && e.push("f"), e.join("");
  }
}
class PT {
}
function In(t) {
  return t.end ? `${t.start}-${t.end}` : t.start;
}
var jh;
(function(t) {
  t.Https = "https", t.HttpsAndHttp = "https,http";
})(jh || (jh = {}));
class cs {
  /**
   * Optional. IP range allowed for this SAS.
   *
   * @readonly
   */
  get ipRange() {
    if (this.ipRangeInner)
      return {
        end: this.ipRangeInner.end,
        start: this.ipRangeInner.start
      };
  }
  constructor(e, r, n, s, i, o, c, l, A, a, u, g, h, m, d, p, E, B, y, Q) {
    this.version = e, this.signature = r, n !== void 0 && typeof n != "string" ? (this.permissions = n.permissions, this.services = n.services, this.resourceTypes = n.resourceTypes, this.protocol = n.protocol, this.startsOn = n.startsOn, this.expiresOn = n.expiresOn, this.ipRangeInner = n.ipRange, this.identifier = n.identifier, this.encryptionScope = n.encryptionScope, this.resource = n.resource, this.cacheControl = n.cacheControl, this.contentDisposition = n.contentDisposition, this.contentEncoding = n.contentEncoding, this.contentLanguage = n.contentLanguage, this.contentType = n.contentType, n.userDelegationKey && (this.signedOid = n.userDelegationKey.signedObjectId, this.signedTenantId = n.userDelegationKey.signedTenantId, this.signedStartsOn = n.userDelegationKey.signedStartsOn, this.signedExpiresOn = n.userDelegationKey.signedExpiresOn, this.signedService = n.userDelegationKey.signedService, this.signedVersion = n.userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = n.preauthorizedAgentObjectId, this.correlationId = n.correlationId)) : (this.services = s, this.resourceTypes = i, this.expiresOn = l, this.permissions = n, this.protocol = o, this.startsOn = c, this.ipRangeInner = A, this.encryptionScope = Q, this.identifier = a, this.resource = u, this.cacheControl = g, this.contentDisposition = h, this.contentEncoding = m, this.contentLanguage = d, this.contentType = p, E && (this.signedOid = E.signedObjectId, this.signedTenantId = E.signedTenantId, this.signedStartsOn = E.signedStartsOn, this.signedExpiresOn = E.signedExpiresOn, this.signedService = E.signedService, this.signedVersion = E.signedVersion, this.preauthorizedAgentObjectId = B, this.correlationId = y));
  }
  /**
   * Encodes all SAS query parameters into a string that can be appended to a URL.
   *
   */
  toString() {
    const e = [
      "sv",
      "ss",
      "srt",
      "spr",
      "st",
      "se",
      "sip",
      "si",
      "ses",
      "skoid",
      // Signed object ID
      "sktid",
      // Signed tenant ID
      "skt",
      // Signed key start time
      "ske",
      // Signed key expiry time
      "sks",
      // Signed key service
      "skv",
      // Signed key version
      "sr",
      "sp",
      "sig",
      "rscc",
      "rscd",
      "rsce",
      "rscl",
      "rsct",
      "saoid",
      "scid"
    ], r = [];
    for (const n of e)
      switch (n) {
        case "sv":
          this.tryAppendQueryParameter(r, n, this.version);
          break;
        case "ss":
          this.tryAppendQueryParameter(r, n, this.services);
          break;
        case "srt":
          this.tryAppendQueryParameter(r, n, this.resourceTypes);
          break;
        case "spr":
          this.tryAppendQueryParameter(r, n, this.protocol);
          break;
        case "st":
          this.tryAppendQueryParameter(r, n, this.startsOn ? ot(this.startsOn, !1) : void 0);
          break;
        case "se":
          this.tryAppendQueryParameter(r, n, this.expiresOn ? ot(this.expiresOn, !1) : void 0);
          break;
        case "sip":
          this.tryAppendQueryParameter(r, n, this.ipRange ? In(this.ipRange) : void 0);
          break;
        case "si":
          this.tryAppendQueryParameter(r, n, this.identifier);
          break;
        case "ses":
          this.tryAppendQueryParameter(r, n, this.encryptionScope);
          break;
        case "skoid":
          this.tryAppendQueryParameter(r, n, this.signedOid);
          break;
        case "sktid":
          this.tryAppendQueryParameter(r, n, this.signedTenantId);
          break;
        case "skt":
          this.tryAppendQueryParameter(r, n, this.signedStartsOn ? ot(this.signedStartsOn, !1) : void 0);
          break;
        case "ske":
          this.tryAppendQueryParameter(r, n, this.signedExpiresOn ? ot(this.signedExpiresOn, !1) : void 0);
          break;
        case "sks":
          this.tryAppendQueryParameter(r, n, this.signedService);
          break;
        case "skv":
          this.tryAppendQueryParameter(r, n, this.signedVersion);
          break;
        case "sr":
          this.tryAppendQueryParameter(r, n, this.resource);
          break;
        case "sp":
          this.tryAppendQueryParameter(r, n, this.permissions);
          break;
        case "sig":
          this.tryAppendQueryParameter(r, n, this.signature);
          break;
        case "rscc":
          this.tryAppendQueryParameter(r, n, this.cacheControl);
          break;
        case "rscd":
          this.tryAppendQueryParameter(r, n, this.contentDisposition);
          break;
        case "rsce":
          this.tryAppendQueryParameter(r, n, this.contentEncoding);
          break;
        case "rscl":
          this.tryAppendQueryParameter(r, n, this.contentLanguage);
          break;
        case "rsct":
          this.tryAppendQueryParameter(r, n, this.contentType);
          break;
        case "saoid":
          this.tryAppendQueryParameter(r, n, this.preauthorizedAgentObjectId);
          break;
        case "scid":
          this.tryAppendQueryParameter(r, n, this.correlationId);
          break;
      }
    return r.join("&");
  }
  /**
   * A private helper method used to filter and append query key/value pairs into an array.
   *
   * @param queries -
   * @param key -
   * @param value -
   */
  tryAppendQueryParameter(e, r, n) {
    n && (r = encodeURIComponent(r), n = encodeURIComponent(n), r.length > 0 && n.length > 0 && e.push(`${r}=${n}`));
  }
}
function $o(t, e, r) {
  return qi(t, e, r).sasQueryParameters;
}
function qi(t, e, r) {
  const n = t.version ? t.version : Ou, s = e instanceof wt ? e : void 0;
  let i;
  if (s === void 0 && r !== void 0 && (i = new PT(r, e)), s === void 0 && i === void 0)
    throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
  if (n >= "2020-12-06")
    return s !== void 0 ? _T(t, s) : GT(t, i);
  if (n >= "2018-11-09")
    return s !== void 0 ? LT(t, s) : n >= "2020-02-10" ? OT(t, i) : MT(t, i);
  if (n >= "2015-04-05") {
    if (s !== void 0)
      return UT(t, s);
    throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
  }
  throw new RangeError("'version' must be >= '2015-04-05'.");
}
function UT(t, e) {
  if (t = si(t), !t.identifier && !(t.permissions && t.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  let r = "c";
  t.blobName && (r = "b");
  let n;
  t.permissions && (t.blobName ? n = Cn.parse(t.permissions.toString()).toString() : n = Bn.parse(t.permissions.toString()).toString());
  const s = [
    n || "",
    t.startsOn ? ot(t.startsOn, !1) : "",
    t.expiresOn ? ot(t.expiresOn, !1) : "",
    ni(e.accountName, t.containerName, t.blobName),
    t.identifier,
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    t.cacheControl ? t.cacheControl : "",
    t.contentDisposition ? t.contentDisposition : "",
    t.contentEncoding ? t.contentEncoding : "",
    t.contentLanguage ? t.contentLanguage : "",
    t.contentType ? t.contentType : ""
  ].join(`
`), i = e.computeHMACSHA256(s);
  return {
    sasQueryParameters: new cs(t.version, i, n, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType),
    stringToSign: s
  };
}
function LT(t, e) {
  if (t = si(t), !t.identifier && !(t.permissions && t.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Cn.parse(t.permissions.toString()).toString() : s = Bn.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? ot(t.startsOn, !1) : "",
    t.expiresOn ? ot(t.expiresOn, !1) : "",
    ni(e.accountName, t.containerName, t.blobName),
    t.identifier,
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.cacheControl ? t.cacheControl : "",
    t.contentDisposition ? t.contentDisposition : "",
    t.contentEncoding ? t.contentEncoding : "",
    t.contentLanguage ? t.contentLanguage : "",
    t.contentType ? t.contentType : ""
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new cs(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType),
    stringToSign: i
  };
}
function _T(t, e) {
  if (t = si(t), !t.identifier && !(t.permissions && t.expiresOn))
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Cn.parse(t.permissions.toString()).toString() : s = Bn.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? ot(t.startsOn, !1) : "",
    t.expiresOn ? ot(t.expiresOn, !1) : "",
    ni(e.accountName, t.containerName, t.blobName),
    t.identifier,
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.encryptionScope,
    t.cacheControl ? t.cacheControl : "",
    t.contentDisposition ? t.contentDisposition : "",
    t.contentEncoding ? t.contentEncoding : "",
    t.contentLanguage ? t.contentLanguage : "",
    t.contentType ? t.contentType : ""
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new cs(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, void 0, void 0, void 0, t.encryptionScope),
    stringToSign: i
  };
}
function MT(t, e) {
  if (t = si(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Cn.parse(t.permissions.toString()).toString() : s = Bn.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? ot(t.startsOn, !1) : "",
    t.expiresOn ? ot(t.expiresOn, !1) : "",
    ni(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? ot(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? ot(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new cs(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey),
    stringToSign: i
  };
}
function OT(t, e) {
  if (t = si(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Cn.parse(t.permissions.toString()).toString() : s = Bn.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? ot(t.startsOn, !1) : "",
    t.expiresOn ? ot(t.expiresOn, !1) : "",
    ni(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? ot(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? ot(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.preauthorizedAgentObjectId,
    void 0,
    // agentObjectId
    t.correlationId,
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new cs(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey, t.preauthorizedAgentObjectId, t.correlationId),
    stringToSign: i
  };
}
function GT(t, e) {
  if (t = si(t), !t.permissions || !t.expiresOn)
    throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
  let r = "c", n = t.snapshotTime;
  t.blobName && (r = "b", t.snapshotTime ? r = "bs" : t.versionId && (r = "bv", n = t.versionId));
  let s;
  t.permissions && (t.blobName ? s = Cn.parse(t.permissions.toString()).toString() : s = Bn.parse(t.permissions.toString()).toString());
  const i = [
    s || "",
    t.startsOn ? ot(t.startsOn, !1) : "",
    t.expiresOn ? ot(t.expiresOn, !1) : "",
    ni(e.accountName, t.containerName, t.blobName),
    e.userDelegationKey.signedObjectId,
    e.userDelegationKey.signedTenantId,
    e.userDelegationKey.signedStartsOn ? ot(e.userDelegationKey.signedStartsOn, !1) : "",
    e.userDelegationKey.signedExpiresOn ? ot(e.userDelegationKey.signedExpiresOn, !1) : "",
    e.userDelegationKey.signedService,
    e.userDelegationKey.signedVersion,
    t.preauthorizedAgentObjectId,
    void 0,
    // agentObjectId
    t.correlationId,
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    t.version,
    r,
    n,
    t.encryptionScope,
    t.cacheControl,
    t.contentDisposition,
    t.contentEncoding,
    t.contentLanguage,
    t.contentType
  ].join(`
`), o = e.computeHMACSHA256(i);
  return {
    sasQueryParameters: new cs(t.version, o, s, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, r, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, e.userDelegationKey, t.preauthorizedAgentObjectId, t.correlationId, t.encryptionScope),
    stringToSign: i
  };
}
function ni(t, e, r) {
  const n = [`/blob/${t}/${e}`];
  return r && n.push(`/${r}`), n.join("");
}
function si(t) {
  const e = t.version ? t.version : Ou;
  if (t.snapshotTime && e < "2018-11-09")
    throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
  if (t.blobName === void 0 && t.snapshotTime)
    throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
  if (t.versionId && e < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
  if (t.blobName === void 0 && t.versionId)
    throw RangeError("Must provide 'blobName' when providing 'versionId'.");
  if (t.permissions && t.permissions.setImmutabilityPolicy && e < "2020-08-04")
    throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
  if (t.permissions && t.permissions.deleteVersion && e < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
  if (t.permissions && t.permissions.permanentDelete && e < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
  if (t.permissions && t.permissions.tag && e < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
  if (e < "2020-02-10" && t.permissions && (t.permissions.move || t.permissions.execute))
    throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
  if (e < "2021-04-10" && t.permissions && t.permissions.filterByTags)
    throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
  if (e < "2020-02-10" && (t.preauthorizedAgentObjectId || t.correlationId))
    throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
  if (t.encryptionScope && e < "2020-12-06")
    throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
  return t.version = e, t;
}
class id {
  /**
   * Gets the lease Id.
   *
   * @readonly
   */
  get leaseId() {
    return this._leaseId;
  }
  /**
   * Gets the url.
   *
   * @readonly
   */
  get url() {
    return this._url;
  }
  /**
   * Creates an instance of BlobLeaseClient.
   * @param client - The client to make the lease operation requests.
   * @param leaseId - Initial proposed lease id.
   */
  constructor(e, r) {
    const n = e.storageClientContext;
    this._url = e.url, e.name === void 0 ? (this._isContainer = !0, this._containerOrBlobOperation = n.container) : (this._isContainer = !1, this._containerOrBlobOperation = n.blob), r || (r = Vo()), this._leaseId = r;
  }
  /**
   * Establishes and manages a lock on a container for delete operations, or on a blob
   * for write and delete operations.
   * The lock duration can be 15 to 60 seconds, or can be infinite.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob
   *
   * @param duration - Must be between 15 to 60 seconds, or infinite (-1)
   * @param options - option to configure lease management operations.
   * @returns Response data for acquire lease operation.
   */
  async acquireLease(e, r = {}) {
    var n, s, i, o, c;
    if (this._isContainer && (!((n = r.conditions) === null || n === void 0) && n.ifMatch && ((s = r.conditions) === null || s === void 0 ? void 0 : s.ifMatch) !== an || !((i = r.conditions) === null || i === void 0) && i.ifNoneMatch && ((o = r.conditions) === null || o === void 0 ? void 0 : o.ifNoneMatch) !== an || !((c = r.conditions) === null || c === void 0) && c.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return pe.withSpan("BlobLeaseClient-acquireLease", r, async (l) => {
      var A;
      return be(await this._containerOrBlobOperation.acquireLease({
        abortSignal: r.abortSignal,
        duration: e,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (A = r.conditions) === null || A === void 0 ? void 0 : A.tagConditions }),
        proposedLeaseId: this._leaseId,
        tracingOptions: l.tracingOptions
      }));
    });
  }
  /**
   * To change the ID of the lease.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob
   *
   * @param proposedLeaseId - the proposed new lease Id.
   * @param options - option to configure lease management operations.
   * @returns Response data for change lease operation.
   */
  async changeLease(e, r = {}) {
    var n, s, i, o, c;
    if (this._isContainer && (!((n = r.conditions) === null || n === void 0) && n.ifMatch && ((s = r.conditions) === null || s === void 0 ? void 0 : s.ifMatch) !== an || !((i = r.conditions) === null || i === void 0) && i.ifNoneMatch && ((o = r.conditions) === null || o === void 0 ? void 0 : o.ifNoneMatch) !== an || !((c = r.conditions) === null || c === void 0) && c.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return pe.withSpan("BlobLeaseClient-changeLease", r, async (l) => {
      var A;
      const a = be(await this._containerOrBlobOperation.changeLease(this._leaseId, e, {
        abortSignal: r.abortSignal,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (A = r.conditions) === null || A === void 0 ? void 0 : A.tagConditions }),
        tracingOptions: l.tracingOptions
      }));
      return this._leaseId = e, a;
    });
  }
  /**
   * To free the lease if it is no longer needed so that another client may
   * immediately acquire a lease against the container or the blob.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob
   *
   * @param options - option to configure lease management operations.
   * @returns Response data for release lease operation.
   */
  async releaseLease(e = {}) {
    var r, n, s, i, o;
    if (this._isContainer && (!((r = e.conditions) === null || r === void 0) && r.ifMatch && ((n = e.conditions) === null || n === void 0 ? void 0 : n.ifMatch) !== an || !((s = e.conditions) === null || s === void 0) && s.ifNoneMatch && ((i = e.conditions) === null || i === void 0 ? void 0 : i.ifNoneMatch) !== an || !((o = e.conditions) === null || o === void 0) && o.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return pe.withSpan("BlobLeaseClient-releaseLease", e, async (c) => {
      var l;
      return be(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
        abortSignal: e.abortSignal,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (l = e.conditions) === null || l === void 0 ? void 0 : l.tagConditions }),
        tracingOptions: c.tracingOptions
      }));
    });
  }
  /**
   * To renew the lease.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob
   *
   * @param options - Optional option to configure lease management operations.
   * @returns Response data for renew lease operation.
   */
  async renewLease(e = {}) {
    var r, n, s, i, o;
    if (this._isContainer && (!((r = e.conditions) === null || r === void 0) && r.ifMatch && ((n = e.conditions) === null || n === void 0 ? void 0 : n.ifMatch) !== an || !((s = e.conditions) === null || s === void 0) && s.ifNoneMatch && ((i = e.conditions) === null || i === void 0 ? void 0 : i.ifNoneMatch) !== an || !((o = e.conditions) === null || o === void 0) && o.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return pe.withSpan("BlobLeaseClient-renewLease", e, async (c) => {
      var l;
      return this._containerOrBlobOperation.renewLease(this._leaseId, {
        abortSignal: e.abortSignal,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (l = e.conditions) === null || l === void 0 ? void 0 : l.tagConditions }),
        tracingOptions: c.tracingOptions
      });
    });
  }
  /**
   * To end the lease but ensure that another client cannot acquire a new lease
   * until the current lease period has expired.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-container
   * and
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/lease-blob
   *
   * @param breakPeriod - Break period
   * @param options - Optional options to configure lease management operations.
   * @returns Response data for break lease operation.
   */
  async breakLease(e, r = {}) {
    var n, s, i, o, c;
    if (this._isContainer && (!((n = r.conditions) === null || n === void 0) && n.ifMatch && ((s = r.conditions) === null || s === void 0 ? void 0 : s.ifMatch) !== an || !((i = r.conditions) === null || i === void 0) && i.ifNoneMatch && ((o = r.conditions) === null || o === void 0 ? void 0 : o.ifNoneMatch) !== an || !((c = r.conditions) === null || c === void 0) && c.tagConditions))
      throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
    return pe.withSpan("BlobLeaseClient-breakLease", r, async (l) => {
      var A;
      const a = {
        abortSignal: r.abortSignal,
        breakPeriod: e,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (A = r.conditions) === null || A === void 0 ? void 0 : A.tagConditions }),
        tracingOptions: l.tracingOptions
      };
      return be(await this._containerOrBlobOperation.breakLease(a));
    });
  }
}
const qT = 1;
class HT {
  /**
   * Indicates that the service supports
   * requests for partial file content.
   *
   * @readonly
   */
  get acceptRanges() {
    return this.originalResponse.acceptRanges;
  }
  /**
   * Returns if it was previously specified
   * for the file.
   *
   * @readonly
   */
  get cacheControl() {
    return this.originalResponse.cacheControl;
  }
  /**
   * Returns the value that was specified
   * for the 'x-ms-content-disposition' header and specifies how to process the
   * response.
   *
   * @readonly
   */
  get contentDisposition() {
    return this.originalResponse.contentDisposition;
  }
  /**
   * Returns the value that was specified
   * for the Content-Encoding request header.
   *
   * @readonly
   */
  get contentEncoding() {
    return this.originalResponse.contentEncoding;
  }
  /**
   * Returns the value that was specified
   * for the Content-Language request header.
   *
   * @readonly
   */
  get contentLanguage() {
    return this.originalResponse.contentLanguage;
  }
  /**
   * The current sequence number for a
   * page blob. This header is not returned for block blobs or append blobs.
   *
   * @readonly
   */
  get blobSequenceNumber() {
    return this.originalResponse.blobSequenceNumber;
  }
  /**
   * The blob's type. Possible values include:
   * 'BlockBlob', 'PageBlob', 'AppendBlob'.
   *
   * @readonly
   */
  get blobType() {
    return this.originalResponse.blobType;
  }
  /**
   * The number of bytes present in the
   * response body.
   *
   * @readonly
   */
  get contentLength() {
    return this.originalResponse.contentLength;
  }
  /**
   * If the file has an MD5 hash and the
   * request is to read the full file, this response header is returned so that
   * the client can check for message content integrity. If the request is to
   * read a specified range and the 'x-ms-range-get-content-md5' is set to
   * true, then the request returns an MD5 hash for the range, as long as the
   * range size is less than or equal to 4 MB. If neither of these sets of
   * conditions is true, then no value is returned for the 'Content-MD5'
   * header.
   *
   * @readonly
   */
  get contentMD5() {
    return this.originalResponse.contentMD5;
  }
  /**
   * Indicates the range of bytes returned if
   * the client requested a subset of the file by setting the Range request
   * header.
   *
   * @readonly
   */
  get contentRange() {
    return this.originalResponse.contentRange;
  }
  /**
   * The content type specified for the file.
   * The default content type is 'application/octet-stream'
   *
   * @readonly
   */
  get contentType() {
    return this.originalResponse.contentType;
  }
  /**
   * Conclusion time of the last attempted
   * Copy File operation where this file was the destination file. This value
   * can specify the time of a completed, aborted, or failed copy attempt.
   *
   * @readonly
   */
  get copyCompletedOn() {
  }
  /**
   * String identifier for the last attempted Copy
   * File operation where this file was the destination file.
   *
   * @readonly
   */
  get copyId() {
    return this.originalResponse.copyId;
  }
  /**
   * Contains the number of bytes copied and
   * the total bytes in the source in the last attempted Copy File operation
   * where this file was the destination file. Can show between 0 and
   * Content-Length bytes copied.
   *
   * @readonly
   */
  get copyProgress() {
    return this.originalResponse.copyProgress;
  }
  /**
   * URL up to 2KB in length that specifies the
   * source file used in the last attempted Copy File operation where this file
   * was the destination file.
   *
   * @readonly
   */
  get copySource() {
    return this.originalResponse.copySource;
  }
  /**
   * State of the copy operation
   * identified by 'x-ms-copy-id'. Possible values include: 'pending',
   * 'success', 'aborted', 'failed'
   *
   * @readonly
   */
  get copyStatus() {
    return this.originalResponse.copyStatus;
  }
  /**
   * Only appears when
   * x-ms-copy-status is failed or pending. Describes cause of fatal or
   * non-fatal copy operation failure.
   *
   * @readonly
   */
  get copyStatusDescription() {
    return this.originalResponse.copyStatusDescription;
  }
  /**
   * When a blob is leased,
   * specifies whether the lease is of infinite or fixed duration. Possible
   * values include: 'infinite', 'fixed'.
   *
   * @readonly
   */
  get leaseDuration() {
    return this.originalResponse.leaseDuration;
  }
  /**
   * Lease state of the blob. Possible
   * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
   *
   * @readonly
   */
  get leaseState() {
    return this.originalResponse.leaseState;
  }
  /**
   * The current lease status of the
   * blob. Possible values include: 'locked', 'unlocked'.
   *
   * @readonly
   */
  get leaseStatus() {
    return this.originalResponse.leaseStatus;
  }
  /**
   * A UTC date/time value generated by the service that
   * indicates the time at which the response was initiated.
   *
   * @readonly
   */
  get date() {
    return this.originalResponse.date;
  }
  /**
   * The number of committed blocks
   * present in the blob. This header is returned only for append blobs.
   *
   * @readonly
   */
  get blobCommittedBlockCount() {
    return this.originalResponse.blobCommittedBlockCount;
  }
  /**
   * The ETag contains a value that you can use to
   * perform operations conditionally, in quotes.
   *
   * @readonly
   */
  get etag() {
    return this.originalResponse.etag;
  }
  /**
   * The error code.
   *
   * @readonly
   */
  get errorCode() {
    return this.originalResponse.errorCode;
  }
  /**
   * The value of this header is set to
   * true if the file data and application metadata are completely encrypted
   * using the specified algorithm. Otherwise, the value is set to false (when
   * the file is unencrypted, or if only parts of the file/application metadata
   * are encrypted).
   *
   * @readonly
   */
  get isServerEncrypted() {
    return this.originalResponse.isServerEncrypted;
  }
  /**
   * If the blob has a MD5 hash, and if
   * request contains range header (Range or x-ms-range), this response header
   * is returned with the value of the whole blob's MD5 value. This value may
   * or may not be equal to the value returned in Content-MD5 header, with the
   * latter calculated from the requested range.
   *
   * @readonly
   */
  get blobContentMD5() {
    return this.originalResponse.blobContentMD5;
  }
  /**
   * Returns the date and time the file was last
   * modified. Any operation that modifies the file or its properties updates
   * the last modified time.
   *
   * @readonly
   */
  get lastModified() {
    return this.originalResponse.lastModified;
  }
  /**
   * A name-value pair
   * to associate with a file storage object.
   *
   * @readonly
   */
  get metadata() {
    return this.originalResponse.metadata;
  }
  /**
   * This header uniquely identifies the request
   * that was made and can be used for troubleshooting the request.
   *
   * @readonly
   */
  get requestId() {
    return this.originalResponse.requestId;
  }
  /**
   * If a client request id header is sent in the request, this header will be present in the
   * response with the same value.
   *
   * @readonly
   */
  get clientRequestId() {
    return this.originalResponse.clientRequestId;
  }
  /**
   * Indicates the version of the File service used
   * to execute the request.
   *
   * @readonly
   */
  get version() {
    return this.originalResponse.version;
  }
  /**
   * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
   * when the blob was encrypted with a customer-provided key.
   *
   * @readonly
   */
  get encryptionKeySha256() {
    return this.originalResponse.encryptionKeySha256;
  }
  /**
   * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
   * true, then the request returns a crc64 for the range, as long as the range size is less than
   * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
   * specified in the same request, it will fail with 400(Bad Request)
   */
  get contentCrc64() {
    return this.originalResponse.contentCrc64;
  }
  /**
   * The response body as a browser Blob.
   * Always undefined in node.js.
   *
   * @readonly
   */
  get blobBody() {
    throw Error("Quick query in browser is not supported yet.");
  }
  /**
   * The response body as a node.js Readable stream.
   * Always undefined in the browser.
   *
   * @readonly
   */
  get readableStreamBody() {
  }
  /**
   * The HTTP response.
   */
  get _response() {
    return this.originalResponse._response;
  }
  /**
   * Creates an instance of BlobQueryResponse.
   *
   * @param originalResponse -
   * @param options -
   */
  constructor(e, r = {}) {
    this.originalResponse = e;
  }
}
var Xl;
(function(t) {
  t.Hot = "Hot", t.Cool = "Cool", t.Cold = "Cold", t.Archive = "Archive";
})(Xl || (Xl = {}));
var Kl;
(function(t) {
  t.P4 = "P4", t.P6 = "P6", t.P10 = "P10", t.P15 = "P15", t.P20 = "P20", t.P30 = "P30", t.P40 = "P40", t.P50 = "P50", t.P60 = "P60", t.P70 = "P70", t.P80 = "P80";
})(Kl || (Kl = {}));
function es(t) {
  if (t !== void 0)
    return t;
}
function $t(t, e) {
  if (t && !e)
    throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
  t && !t.encryptionAlgorithm && (t.encryptionAlgorithm = uv);
}
var $h;
(function(t) {
  t.StorageOAuthScopes = "https://storage.azure.com/.default", t.DiskComputeOAuthScopes = "https://disk.compute.azure.com/.default";
})($h || ($h = {}));
function Mc(t) {
  const e = (t._response.parsedBody.pageRange || []).map((n) => ({
    offset: n.start,
    count: n.end - n.start
  })), r = (t._response.parsedBody.clearRange || []).map((n) => ({
    offset: n.start,
    count: n.end - n.start
  }));
  return Object.assign(Object.assign({}, t), {
    pageRange: e,
    clearRange: r,
    _response: Object.assign(Object.assign({}, t._response), { parsedBody: {
      pageRange: e,
      clearRange: r
    } })
  });
}
class od extends Error {
  constructor(e) {
    super(e), this.name = "PollerStoppedError", Object.setPrototypeOf(this, od.prototype);
  }
}
class ad extends Error {
  constructor(e) {
    super(e), this.name = "PollerCancelledError", Object.setPrototypeOf(this, ad.prototype);
  }
}
class zT {
  /**
   * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
   *
   * When writing an implementation of a Poller, this implementation needs to deal with the initialization
   * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
   * operation has already been defined, at least its basic properties. The code below shows how to approach
   * the definition of the constructor of a new custom poller.
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor({
   *     // Anything you might need outside of the basics
   *   }) {
   *     let state: MyOperationState = {
   *       privateProperty: private,
   *       publicProperty: public,
   *     };
   *
   *     const operation = {
   *       state,
   *       update,
   *       cancel,
   *       toString
   *     }
   *
   *     // Sending the operation to the parent's constructor.
   *     super(operation);
   *
   *     // You can assign more local properties here.
   *   }
   * }
   * ```
   *
   * Inside of this constructor, a new promise is created. This will be used to
   * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
   * resolve and reject methods are also used internally to control when to resolve
   * or reject anyone waiting for the poller to finish.
   *
   * The constructor of a custom implementation of a poller is where any serialized version of
   * a previous poller's operation should be deserialized into the operation sent to the
   * base constructor. For example:
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor(
   *     baseOperation: string | undefined
   *   ) {
   *     let state: MyOperationState = {};
   *     if (baseOperation) {
   *       state = {
   *         ...JSON.parse(baseOperation).state,
   *         ...state
   *       };
   *     }
   *     const operation = {
   *       state,
   *       // ...
   *     }
   *     super(operation);
   *   }
   * }
   * ```
   *
   * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
   */
  constructor(e) {
    this.resolveOnUnsuccessful = !1, this.stopped = !0, this.pollProgressCallbacks = [], this.operation = e, this.promise = new Promise((r, n) => {
      this.resolve = r, this.reject = n;
    }), this.promise.catch(() => {
    });
  }
  /**
   * Starts a loop that will break only if the poller is done
   * or if the poller is stopped.
   */
  async startPolling(e = {}) {
    for (this.stopped && (this.stopped = !1); !this.isStopped() && !this.isDone(); )
      await this.poll(e), await this.delay();
  }
  /**
   * pollOnce does one polling, by calling to the update method of the underlying
   * poll operation to make any relevant change effective.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  async pollOnce(e = {}) {
    this.isDone() || (this.operation = await this.operation.update({
      abortSignal: e.abortSignal,
      fireProgress: this.fireProgress.bind(this)
    })), this.processUpdatedState();
  }
  /**
   * fireProgress calls the functions passed in via onProgress the method of the poller.
   *
   * It loops over all of the callbacks received from onProgress, and executes them, sending them
   * the current operation state.
   *
   * @param state - The current operation state.
   */
  fireProgress(e) {
    for (const r of this.pollProgressCallbacks)
      r(e);
  }
  /**
   * Invokes the underlying operation's cancel method.
   */
  async cancelOnce(e = {}) {
    this.operation = await this.operation.cancel(e);
  }
  /**
   * Returns a promise that will resolve once a single polling request finishes.
   * It does this by calling the update method of the Poller's operation.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  poll(e = {}) {
    if (!this.pollOncePromise) {
      this.pollOncePromise = this.pollOnce(e);
      const r = () => {
        this.pollOncePromise = void 0;
      };
      this.pollOncePromise.then(r, r).catch(this.reject);
    }
    return this.pollOncePromise;
  }
  processUpdatedState() {
    if (this.operation.state.error && (this.stopped = !0, !this.resolveOnUnsuccessful))
      throw this.reject(this.operation.state.error), this.operation.state.error;
    if (this.operation.state.isCancelled && (this.stopped = !0, !this.resolveOnUnsuccessful)) {
      const e = new ad("Operation was canceled");
      throw this.reject(e), e;
    }
    this.isDone() && this.resolve && this.resolve(this.getResult());
  }
  /**
   * Returns a promise that will resolve once the underlying operation is completed.
   */
  async pollUntilDone(e = {}) {
    return this.stopped && this.startPolling(e).catch(this.reject), this.processUpdatedState(), this.promise;
  }
  /**
   * Invokes the provided callback after each polling is completed,
   * sending the current state of the poller's operation.
   *
   * It returns a method that can be used to stop receiving updates on the given callback function.
   */
  onProgress(e) {
    return this.pollProgressCallbacks.push(e), () => {
      this.pollProgressCallbacks = this.pollProgressCallbacks.filter((r) => r !== e);
    };
  }
  /**
   * Returns true if the poller has finished polling.
   */
  isDone() {
    const e = this.operation.state;
    return !!(e.isCompleted || e.isCancelled || e.error);
  }
  /**
   * Stops the poller from continuing to poll.
   */
  stopPolling() {
    this.stopped || (this.stopped = !0, this.reject && this.reject(new od("This poller is already stopped")));
  }
  /**
   * Returns true if the poller is stopped.
   */
  isStopped() {
    return this.stopped;
  }
  /**
   * Attempts to cancel the underlying operation.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * If it's called again before it finishes, it will throw an error.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  cancelOperation(e = {}) {
    if (!this.cancelPromise)
      this.cancelPromise = this.cancelOnce(e);
    else if (e.abortSignal)
      throw new Error("A cancel request is currently pending");
    return this.cancelPromise;
  }
  /**
   * Returns the state of the operation.
   *
   * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
   * implementations of the pollers can customize what's shared with the public by writing their own
   * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
   * and a public type representing a safe to share subset of the properties of the internal state.
   * Their definition of getOperationState can then return their public type.
   *
   * Example:
   *
   * ```ts
   * // Let's say we have our poller's operation state defined as:
   * interface MyOperationState extends PollOperationState<ResultType> {
   *   privateProperty?: string;
   *   publicProperty?: string;
   * }
   *
   * // To allow us to have a true separation of public and private state, we have to define another interface:
   * interface PublicState extends PollOperationState<ResultType> {
   *   publicProperty?: string;
   * }
   *
   * // Then, we define our Poller as follows:
   * export class MyPoller extends Poller<MyOperationState, ResultType> {
   *   // ... More content is needed here ...
   *
   *   public getOperationState(): PublicState {
   *     const state: PublicState = this.operation.state;
   *     return {
   *       // Properties from PollOperationState<TResult>
   *       isStarted: state.isStarted,
   *       isCompleted: state.isCompleted,
   *       isCancelled: state.isCancelled,
   *       error: state.error,
   *       result: state.result,
   *
   *       // The only other property needed by PublicState.
   *       publicProperty: state.publicProperty
   *     }
   *   }
   * }
   * ```
   *
   * You can see this in the tests of this repository, go to the file:
   * `../test/utils/testPoller.ts`
   * and look for the getOperationState implementation.
   */
  getOperationState() {
    return this.operation.state;
  }
  /**
   * Returns the result value of the operation,
   * regardless of the state of the poller.
   * It can return undefined or an incomplete form of the final TResult value
   * depending on the implementation.
   */
  getResult() {
    return this.operation.state.result;
  }
  /**
   * Returns a serialized version of the poller's operation
   * by invoking the operation's toString method.
   */
  toString() {
    return this.operation.toString();
  }
}
class YT extends zT {
  constructor(e) {
    const { blobClient: r, copySource: n, intervalInMs: s = 15e3, onProgress: i, resumeFrom: o, startCopyFromURLOptions: c } = e;
    let l;
    o && (l = JSON.parse(o).state);
    const A = ki(Object.assign(Object.assign({}, l), {
      blobClient: r,
      copySource: n,
      startCopyFromURLOptions: c
    }));
    super(A), typeof i == "function" && this.onProgress(i), this.intervalInMs = s;
  }
  delay() {
    return SE(this.intervalInMs);
  }
}
const JT = async function(e = {}) {
  const r = this.state, { copyId: n } = r;
  return r.isCompleted ? ki(r) : n ? (await r.blobClient.abortCopyFromURL(n, {
    abortSignal: e.abortSignal
  }), r.isCancelled = !0, ki(r)) : (r.isCancelled = !0, ki(r));
}, VT = async function(e = {}) {
  const r = this.state, { blobClient: n, copySource: s, startCopyFromURLOptions: i } = r;
  if (r.isStarted) {
    if (!r.isCompleted)
      try {
        const o = await r.blobClient.getProperties({ abortSignal: e.abortSignal }), { copyStatus: c, copyProgress: l } = o, A = r.copyProgress;
        l && (r.copyProgress = l), c === "pending" && l !== A && typeof e.fireProgress == "function" ? e.fireProgress(r) : c === "success" ? (r.result = o, r.isCompleted = !0) : c === "failed" && (r.error = new Error(`Blob copy failed with reason: "${o.copyStatusDescription || "unknown"}"`), r.isCompleted = !0);
      } catch (o) {
        r.error = o, r.isCompleted = !0;
      }
  } else {
    r.isStarted = !0;
    const o = await n.startCopyFromURL(s, i);
    r.copyId = o.copyId, o.copyStatus === "success" && (r.result = o, r.isCompleted = !0);
  }
  return ki(r);
}, WT = function() {
  return JSON.stringify({ state: this.state }, (e, r) => {
    if (e !== "blobClient")
      return r;
  });
};
function ki(t) {
  return {
    state: Object.assign({}, t),
    cancel: JT,
    toString: WT,
    update: VT
  };
}
function kr(t) {
  if (t.offset < 0)
    throw new RangeError("Range.offset cannot be smaller than 0.");
  if (t.count && t.count <= 0)
    throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
  return t.count ? `bytes=${t.offset}-${t.offset + t.count - 1}` : `bytes=${t.offset}-`;
}
var Fi;
(function(t) {
  t[t.Good = 0] = "Good", t[t.Error = 1] = "Error";
})(Fi || (Fi = {}));
class _y {
  /**
   * Creates an instance of Batch.
   * @param concurrency -
   */
  constructor(e = 5) {
    if (this.actives = 0, this.completed = 0, this.offset = 0, this.operations = [], this.state = Fi.Good, e < 1)
      throw new RangeError("concurrency must be larger than 0");
    this.concurrency = e, this.emitter = new TQ();
  }
  /**
   * Add a operation into queue.
   *
   * @param operation -
   */
  addOperation(e) {
    this.operations.push(async () => {
      try {
        this.actives++, await e(), this.actives--, this.completed++, this.parallelExecute();
      } catch (r) {
        this.emitter.emit("error", r);
      }
    });
  }
  /**
   * Start execute operations in the queue.
   *
   */
  async do() {
    return this.operations.length === 0 ? Promise.resolve() : (this.parallelExecute(), new Promise((e, r) => {
      this.emitter.on("finish", e), this.emitter.on("error", (n) => {
        this.state = Fi.Error, r(n);
      });
    }));
  }
  /**
   * Get next operation to be executed. Return null when reaching ends.
   *
   */
  nextOperation() {
    return this.offset < this.operations.length ? this.operations[this.offset++] : null;
  }
  /**
   * Start execute operations. One one the most important difference between
   * this method with do() is that do() wraps as an sync method.
   *
   */
  parallelExecute() {
    if (this.state !== Fi.Error) {
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      for (; this.actives < this.concurrency; ) {
        const e = this.nextOperation();
        if (e)
          e();
        else
          return;
      }
    }
  }
}
class jT {
}
async function $T(t) {
  const e = new FileReader();
  return new Promise((r, n) => {
    e.onloadend = (s) => {
      r(s.target.result);
    }, e.onerror = n, e.readAsText(t);
  });
}
const XT = function() {
}, KT = function() {
};
class Mr extends sd {
  /**
   * The name of the blob.
   */
  get name() {
    return this._name;
  }
  /**
   * The name of the storage container the blob is associated with.
   */
  get containerName() {
    return this._containerName;
  }
  constructor(e, r, n, s) {
    s = s || {};
    let i, o;
    if (Fn(r))
      o = e, i = r;
    else if (Mt && r instanceof wt || r instanceof Qt || Or(r))
      o = e, s = n, i = ht(r, s);
    else if (!r && typeof r != "string")
      o = e, n && typeof n != "string" && (s = n), i = ht(new Qt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const c = r, l = n, A = Ms(e);
      if (A.kind === "AccountConnString")
        if (Mt) {
          const a = new wt(A.accountName, A.accountKey);
          o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)), s.proxyOptions || (s.proxyOptions = Us(A.proxyUri)), i = ht(a, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (A.kind === "SASConnString")
        o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)) + "?" + A.accountSas, i = ht(new Qt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), { blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl(), this.blobContext = this.storageClientContext.blob, this._snapshot = Yh(this.url, Xr.Parameters.SNAPSHOT), this._versionId = Yh(this.url, Xr.Parameters.VERSIONID);
  }
  /**
   * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a Client to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp
   */
  withSnapshot(e) {
    return new Mr(En(this.url, Xr.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a new BlobClient object pointing to a version of this blob.
   * Provide "" will remove the versionId and return a Client to the base blob.
   *
   * @param versionId - The versionId.
   * @returns A new BlobClient object pointing to the version of this blob.
   */
  withVersion(e) {
    return new Mr(En(this.url, Xr.Parameters.VERSIONID, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a AppendBlobClient object.
   *
   */
  getAppendBlobClient() {
    return new co(this.url, this.pipeline);
  }
  /**
   * Creates a BlockBlobClient object.
   *
   */
  getBlockBlobClient() {
    return new lo(this.url, this.pipeline);
  }
  /**
   * Creates a PageBlobClient object.
   *
   */
  getPageBlobClient() {
    return new uo(this.url, this.pipeline);
  }
  /**
   * Reads or downloads a blob from the system, including its metadata and properties.
   * You can also call Get Blob to read a snapshot.
   *
   * * In Node.js, data returns in a Readable stream readableStreamBody
   * * In browsers, data returns in a promise blobBody
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob
   *
   * @param offset - From which position of the blob to download, greater than or equal to 0
   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
   * @param options - Optional options to Blob Download operation.
   *
   *
   * Example usage (Node.js):
   *
   * ```js
   * // Download and convert a blob to a string
   * const downloadBlockBlobResponse = await blobClient.download();
   * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);
   * console.log("Downloaded blob content:", downloaded.toString());
   *
   * async function streamToBuffer(readableStream) {
   *   return new Promise((resolve, reject) => {
   *     const chunks = [];
   *     readableStream.on("data", (data) => {
   *       chunks.push(typeof data === "string" ? Buffer.from(data) : data);
   *     });
   *     readableStream.on("end", () => {
   *       resolve(Buffer.concat(chunks));
   *     });
   *     readableStream.on("error", reject);
   *   });
   * }
   * ```
   *
   * Example usage (browser):
   *
   * ```js
   * // Download and convert a blob to a string
   * const downloadBlockBlobResponse = await blobClient.download();
   * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);
   * console.log(
   *   "Downloaded blob content",
   *   downloaded
   * );
   *
   * async function blobToString(blob: Blob): Promise<string> {
   *   const fileReader = new FileReader();
   *   return new Promise<string>((resolve, reject) => {
   *     fileReader.onloadend = (ev: any) => {
   *       resolve(ev.target!.result);
   *     };
   *     fileReader.onerror = reject;
   *     fileReader.readAsText(blob);
   *   });
   * }
   * ```
   */
  async download(e = 0, r, n = {}) {
    return n.conditions = n.conditions || {}, n.conditions = n.conditions || {}, $t(n.customerProvidedKey, this.isHttps), pe.withSpan("BlobClient-download", n, async (s) => {
      var i;
      const o = be(await this.blobContext.download({
        abortSignal: n.abortSignal,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, n.conditions), { ifTags: (i = n.conditions) === null || i === void 0 ? void 0 : i.tagConditions }),
        requestOptions: {
          onDownloadProgress: Mt ? void 0 : n.onProgress
          // for Node.js, progress is reported by RetriableReadableStream
        },
        range: e === 0 && !r ? void 0 : kr({ offset: e, count: r }),
        rangeGetContentMD5: n.rangeGetContentMD5,
        rangeGetContentCRC64: n.rangeGetContentCrc64,
        snapshot: n.snapshot,
        cpkInfo: n.customerProvidedKey,
        tracingOptions: s.tracingOptions
      })), c = Object.assign(Object.assign({}, o), { _response: o._response, objectReplicationDestinationPolicyId: o.objectReplicationPolicyId, objectReplicationSourceProperties: jo(o.objectReplicationRules) });
      if (!Mt)
        return c;
      if ((n.maxRetryRequests === void 0 || n.maxRetryRequests < 0) && (n.maxRetryRequests = cv), o.contentLength === void 0)
        throw new RangeError("File download response doesn't contain valid content length header");
      if (!o.etag)
        throw new RangeError("File download response doesn't contain valid etag header");
      return new qT(c, async (l) => {
        var A;
        const a = {
          leaseAccessConditions: n.conditions,
          modifiedAccessConditions: {
            ifMatch: n.conditions.ifMatch || o.etag,
            ifModifiedSince: n.conditions.ifModifiedSince,
            ifNoneMatch: n.conditions.ifNoneMatch,
            ifUnmodifiedSince: n.conditions.ifUnmodifiedSince,
            ifTags: (A = n.conditions) === null || A === void 0 ? void 0 : A.tagConditions
          },
          range: kr({
            count: e + o.contentLength - l,
            offset: l
          }),
          rangeGetContentMD5: n.rangeGetContentMD5,
          rangeGetContentCRC64: n.rangeGetContentCrc64,
          snapshot: n.snapshot,
          cpkInfo: n.customerProvidedKey
        };
        return (await this.blobContext.download(Object.assign({ abortSignal: n.abortSignal }, a))).readableStreamBody;
      }, e, o.contentLength, {
        maxRetryRequests: n.maxRetryRequests,
        onProgress: n.onProgress
      });
    });
  }
  /**
   * Returns true if the Azure blob resource represented by this client exists; false otherwise.
   *
   * NOTE: use this function with care since an existing blob might be deleted by other clients or
   * applications. Vice versa new blobs might be added by other clients or applications after this
   * function completes.
   *
   * @param options - options to Exists operation.
   */
  async exists(e = {}) {
    return pe.withSpan("BlobClient-exists", e, async (r) => {
      try {
        return $t(e.customerProvidedKey, this.isHttps), await this.getProperties({
          abortSignal: e.abortSignal,
          customerProvidedKey: e.customerProvidedKey,
          conditions: e.conditions,
          tracingOptions: r.tracingOptions
        }), !0;
      } catch (n) {
        if (n.statusCode === 404)
          return !1;
        if (n.statusCode === 409 && (n.details.errorCode === hv || n.details.errorCode === pv))
          return !0;
        throw n;
      }
    });
  }
  /**
   * Returns all user-defined metadata, standard HTTP properties, and system properties
   * for the blob. It does not return the content of the blob.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-properties
   *
   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
   * they originally contained uppercase characters. This differs from the metadata keys returned by
   * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which
   * will retain their original casing.
   *
   * @param options - Optional options to Get Properties operation.
   */
  async getProperties(e = {}) {
    return e.conditions = e.conditions || {}, $t(e.customerProvidedKey, this.isHttps), pe.withSpan("BlobClient-getProperties", e, async (r) => {
      var n;
      const s = be(await this.blobContext.getProperties({
        abortSignal: e.abortSignal,
        leaseAccessConditions: e.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || n === void 0 ? void 0 : n.tagConditions }),
        cpkInfo: e.customerProvidedKey,
        tracingOptions: r.tracingOptions
      }));
      return Object.assign(Object.assign({}, s), { _response: s._response, objectReplicationDestinationPolicyId: s.objectReplicationPolicyId, objectReplicationSourceProperties: jo(s.objectReplicationRules) });
    });
  }
  /**
   * Marks the specified blob or snapshot for deletion. The blob is later deleted
   * during garbage collection. Note that in order to delete a blob, you must delete
   * all of its snapshots. You can delete both at the same time with the Delete
   * Blob operation.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/delete-blob
   *
   * @param options - Optional options to Blob Delete operation.
   */
  async delete(e = {}) {
    return e.conditions = e.conditions || {}, pe.withSpan("BlobClient-delete", e, async (r) => {
      var n;
      return be(await this.blobContext.delete({
        abortSignal: e.abortSignal,
        deleteSnapshots: e.deleteSnapshots,
        leaseAccessConditions: e.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || n === void 0 ? void 0 : n.tagConditions }),
        tracingOptions: r.tracingOptions
      }));
    });
  }
  /**
   * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted
   * during garbage collection. Note that in order to delete a blob, you must delete
   * all of its snapshots. You can delete both at the same time with the Delete
   * Blob operation.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/delete-blob
   *
   * @param options - Optional options to Blob Delete operation.
   */
  async deleteIfExists(e = {}) {
    return pe.withSpan("BlobClient-deleteIfExists", e, async (r) => {
      var n, s;
      try {
        const i = be(await this.delete(r));
        return Object.assign(Object.assign({ succeeded: !0 }, i), { _response: i._response });
      } catch (i) {
        if (((n = i.details) === null || n === void 0 ? void 0 : n.errorCode) === "BlobNotFound")
          return Object.assign(Object.assign({ succeeded: !1 }, (s = i.response) === null || s === void 0 ? void 0 : s.parsedHeaders), { _response: i.response });
        throw i;
      }
    });
  }
  /**
   * Restores the contents and metadata of soft deleted blob and any associated
   * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29
   * or later.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/undelete-blob
   *
   * @param options - Optional options to Blob Undelete operation.
   */
  async undelete(e = {}) {
    return pe.withSpan("BlobClient-undelete", e, async (r) => be(await this.blobContext.undelete({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Sets system properties on the blob.
   *
   * If no value provided, or no value provided for the specified blob HTTP headers,
   * these blob HTTP headers without a value will be cleared.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-properties
   *
   * @param blobHTTPHeaders - If no value provided, or no value provided for
   *                                                   the specified blob HTTP headers, these blob HTTP
   *                                                   headers without a value will be cleared.
   *                                                   A common header to set is `blobContentType`
   *                                                   enabling the browser to provide functionality
   *                                                   based on file type.
   * @param options - Optional options to Blob Set HTTP Headers operation.
   */
  async setHTTPHeaders(e, r = {}) {
    return r.conditions = r.conditions || {}, $t(r.customerProvidedKey, this.isHttps), pe.withSpan("BlobClient-setHTTPHeaders", r, async (n) => {
      var s;
      return be(await this.blobContext.setHttpHeaders({
        abortSignal: r.abortSignal,
        blobHttpHeaders: e,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        // cpkInfo: options.customerProvidedKey, // CPK is not included in Swagger, should change this back when this issue is fixed in Swagger.
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Sets user-defined metadata for the specified blob as one or more name-value pairs.
   *
   * If no option provided, or no metadata defined in the parameter, the blob
   * metadata will be removed.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata
   *
   * @param metadata - Replace existing metadata with this value.
   *                               If no value provided the existing metadata will be removed.
   * @param options - Optional options to Set Metadata operation.
   */
  async setMetadata(e, r = {}) {
    return r.conditions = r.conditions || {}, $t(r.customerProvidedKey, this.isHttps), pe.withSpan("BlobClient-setMetadata", r, async (n) => {
      var s;
      return be(await this.blobContext.setMetadata({
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        metadata: e,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        cpkInfo: r.customerProvidedKey,
        encryptionScope: r.encryptionScope,
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Sets tags on the underlying blob.
   * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.
   * Valid tag key and value characters include lower and upper case letters, digits (0-9),
   * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').
   *
   * @param tags -
   * @param options -
   */
  async setTags(e, r = {}) {
    return pe.withSpan("BlobClient-setTags", r, async (n) => {
      var s;
      return be(await this.blobContext.setTags({
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        tracingOptions: n.tracingOptions,
        tags: wv(e)
      }));
    });
  }
  /**
   * Gets the tags associated with the underlying blob.
   *
   * @param options -
   */
  async getTags(e = {}) {
    return pe.withSpan("BlobClient-getTags", e, async (r) => {
      var n;
      const s = be(await this.blobContext.getTags({
        abortSignal: e.abortSignal,
        leaseAccessConditions: e.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || n === void 0 ? void 0 : n.tagConditions }),
        tracingOptions: r.tracingOptions
      }));
      return Object.assign(Object.assign({}, s), { _response: s._response, tags: Ti({ blobTagSet: s.blobTagSet }) || {} });
    });
  }
  /**
   * Get a {@link BlobLeaseClient} that manages leases on the blob.
   *
   * @param proposeLeaseId - Initial proposed lease Id.
   * @returns A new BlobLeaseClient object for managing leases on the blob.
   */
  getBlobLeaseClient(e) {
    return new id(this, e);
  }
  /**
   * Creates a read-only snapshot of a blob.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/snapshot-blob
   *
   * @param options - Optional options to the Blob Create Snapshot operation.
   */
  async createSnapshot(e = {}) {
    return e.conditions = e.conditions || {}, $t(e.customerProvidedKey, this.isHttps), pe.withSpan("BlobClient-createSnapshot", e, async (r) => {
      var n;
      return be(await this.blobContext.createSnapshot({
        abortSignal: e.abortSignal,
        leaseAccessConditions: e.conditions,
        metadata: e.metadata,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || n === void 0 ? void 0 : n.tagConditions }),
        cpkInfo: e.customerProvidedKey,
        encryptionScope: e.encryptionScope,
        tracingOptions: r.tracingOptions
      }));
    });
  }
  /**
   * Asynchronously copies a blob to a destination within the storage account.
   * This method returns a long running operation poller that allows you to wait
   * indefinitely until the copy is completed.
   * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.
   * Note that the onProgress callback will not be invoked if the operation completes in the first
   * request, and attempting to cancel a completed copy will result in an error being thrown.
   *
   * In version 2012-02-12 and later, the source for a Copy Blob operation can be
   * a committed blob in any Azure storage account.
   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
   * an Azure file in any Azure storage account.
   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
   * operation to copy from another storage account.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/copy-blob
   *
   * Example using automatic polling:
   *
   * ```js
   * const copyPoller = await blobClient.beginCopyFromURL('url');
   * const result = await copyPoller.pollUntilDone();
   * ```
   *
   * Example using manual polling:
   *
   * ```js
   * const copyPoller = await blobClient.beginCopyFromURL('url');
   * while (!poller.isDone()) {
   *    await poller.poll();
   * }
   * const result = copyPoller.getResult();
   * ```
   *
   * Example using progress updates:
   *
   * ```js
   * const copyPoller = await blobClient.beginCopyFromURL('url', {
   *   onProgress(state) {
   *     console.log(`Progress: ${state.copyProgress}`);
   *   }
   * });
   * const result = await copyPoller.pollUntilDone();
   * ```
   *
   * Example using a changing polling interval (default 15 seconds):
   *
   * ```js
   * const copyPoller = await blobClient.beginCopyFromURL('url', {
   *   intervalInMs: 1000 // poll blob every 1 second for copy progress
   * });
   * const result = await copyPoller.pollUntilDone();
   * ```
   *
   * Example using copy cancellation:
   *
   * ```js
   * const copyPoller = await blobClient.beginCopyFromURL('url');
   * // cancel operation after starting it.
   * try {
   *   await copyPoller.cancelOperation();
   *   // calls to get the result now throw PollerCancelledError
   *   await copyPoller.getResult();
   * } catch (err) {
   *   if (err.name === 'PollerCancelledError') {
   *     console.log('The copy was cancelled.');
   *   }
   * }
   * ```
   *
   * @param copySource - url to the source Azure Blob/File.
   * @param options - Optional options to the Blob Start Copy From URL operation.
   */
  async beginCopyFromURL(e, r = {}) {
    const n = {
      abortCopyFromURL: (...i) => this.abortCopyFromURL(...i),
      getProperties: (...i) => this.getProperties(...i),
      startCopyFromURL: (...i) => this.startCopyFromURL(...i)
    }, s = new YT({
      blobClient: n,
      copySource: e,
      intervalInMs: r.intervalInMs,
      onProgress: r.onProgress,
      resumeFrom: r.resumeFrom,
      startCopyFromURLOptions: r
    });
    return await s.poll(), s;
  }
  /**
   * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero
   * length and full metadata. Version 2012-02-12 and newer.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob
   *
   * @param copyId - Id of the Copy From URL operation.
   * @param options - Optional options to the Blob Abort Copy From URL operation.
   */
  async abortCopyFromURL(e, r = {}) {
    return pe.withSpan("BlobClient-abortCopyFromURL", r, async (n) => be(await this.blobContext.abortCopyFromURL(e, {
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not
   * return a response until the copy is complete.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url
   *
   * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication
   * @param options -
   */
  async syncCopyFromURL(e, r = {}) {
    return r.conditions = r.conditions || {}, r.sourceConditions = r.sourceConditions || {}, pe.withSpan("BlobClient-syncCopyFromURL", r, async (n) => {
      var s, i, o, c, l, A, a;
      return be(await this.blobContext.copyFromURL(e, {
        abortSignal: r.abortSignal,
        metadata: r.metadata,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        sourceModifiedAccessConditions: {
          sourceIfMatch: (i = r.sourceConditions) === null || i === void 0 ? void 0 : i.ifMatch,
          sourceIfModifiedSince: (o = r.sourceConditions) === null || o === void 0 ? void 0 : o.ifModifiedSince,
          sourceIfNoneMatch: (c = r.sourceConditions) === null || c === void 0 ? void 0 : c.ifNoneMatch,
          sourceIfUnmodifiedSince: (l = r.sourceConditions) === null || l === void 0 ? void 0 : l.ifUnmodifiedSince
        },
        sourceContentMD5: r.sourceContentMD5,
        copySourceAuthorization: Oi(r.sourceAuthorization),
        tier: es(r.tier),
        blobTagsString: Zn(r.tags),
        immutabilityPolicyExpiry: (A = r.immutabilityPolicy) === null || A === void 0 ? void 0 : A.expiriesOn,
        immutabilityPolicyMode: (a = r.immutabilityPolicy) === null || a === void 0 ? void 0 : a.policyMode,
        legalHold: r.legalHold,
        encryptionScope: r.encryptionScope,
        copySourceTags: r.copySourceTags,
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Sets the tier on a blob. The operation is allowed on a page blob in a premium
   * storage account and on a block blob in a blob storage account (locally redundant
   * storage only). A premium page blob's tier determines the allowed size, IOPS,
   * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive
   * storage type. This operation does not update the blob's ETag.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-tier
   *
   * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.
   * @param options - Optional options to the Blob Set Tier operation.
   */
  async setAccessTier(e, r = {}) {
    return pe.withSpan("BlobClient-setAccessTier", r, async (n) => {
      var s;
      return be(await this.blobContext.setTier(es(e), {
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        rehydratePriority: r.rehydratePriority,
        tracingOptions: n.tracingOptions
      }));
    });
  }
  async downloadToBuffer(e, r, n, s = {}) {
    var i;
    let o, c = 0, l = 0, A = s;
    e instanceof Buffer ? (o = e, c = r || 0, l = typeof n == "number" ? n : 0) : (c = typeof e == "number" ? e : 0, l = typeof r == "number" ? r : 0, A = n || {});
    let a = (i = A.blockSize) !== null && i !== void 0 ? i : 0;
    if (a < 0)
      throw new RangeError("blockSize option must be >= 0");
    if (a === 0 && (a = Vl), c < 0)
      throw new RangeError("offset option must be >= 0");
    if (l && l <= 0)
      throw new RangeError("count option must be greater than 0");
    return A.conditions || (A.conditions = {}), pe.withSpan("BlobClient-downloadToBuffer", A, async (u) => {
      if (!l) {
        const m = await this.getProperties(Object.assign(Object.assign({}, A), { tracingOptions: u.tracingOptions }));
        if (l = m.contentLength - c, l < 0)
          throw new RangeError(`offset ${c} shouldn't be larger than blob size ${m.contentLength}`);
      }
      if (!o)
        try {
          o = Buffer.alloc(l);
        } catch (m) {
          throw new Error(`Unable to allocate the buffer of size: ${l}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${m.message}`);
        }
      if (o.length < l)
        throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${l}`);
      let g = 0;
      const h = new _y(A.concurrency);
      for (let m = c; m < c + l; m = m + a)
        h.addOperation(async () => {
          let d = c + l;
          m + a < d && (d = m + a), (await this.download(m, d - m, {
            abortSignal: A.abortSignal,
            conditions: A.conditions,
            maxRetryRequests: A.maxRetryRequestsPerBlock,
            customerProvidedKey: A.customerProvidedKey,
            tracingOptions: u.tracingOptions
          })).readableStreamBody, await void 0, g += d - m, A.onProgress && A.onProgress({ loadedBytes: g });
        });
      return await h.do(), o;
    });
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Downloads an Azure Blob to a local file.
   * Fails if the the given file path already exits.
   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
   *
   * @param filePath -
   * @param offset - From which position of the block blob to download.
   * @param count - How much data to be downloaded. Will download to the end when passing undefined.
   * @param options - Options to Blob download options.
   * @returns The response data for blob download operation,
   *                                                 but with readableStreamBody set to undefined since its
   *                                                 content is already read and written into a local file
   *                                                 at the specified path.
   */
  async downloadToFile(e, r = 0, n, s = {}) {
    return pe.withSpan("BlobClient-downloadToFile", s, async (i) => {
      const o = await this.download(r, n, Object.assign(Object.assign({}, s), { tracingOptions: i.tracingOptions }));
      return o.readableStreamBody && await (o.readableStreamBody, void 0), o.blobDownloadStream = void 0, o;
    });
  }
  getBlobAndContainerNamesFromUrl() {
    let e, r;
    try {
      const n = new URL(this.url);
      if (n.host.split(".")[1] === "blob") {
        const s = n.pathname.match("/([^/]*)(/(.*))?");
        e = s[1], r = s[3];
      } else if (qu(n)) {
        const s = n.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
        e = s[2], r = s[4];
      } else {
        const s = n.pathname.match("/([^/]*)(/(.*))?");
        e = s[1], r = s[3];
      }
      if (e = decodeURIComponent(e), r = decodeURIComponent(r), r = r.replace(/\\/g, "/"), !e)
        throw new Error("Provided containerName is invalid.");
      return { blobName: r, containerName: e };
    } catch {
      throw new Error("Unable to extract blobName and containerName with provided information.");
    }
  }
  /**
   * Asynchronously copies a blob to a destination within the storage account.
   * In version 2012-02-12 and later, the source for a Copy Blob operation can be
   * a committed blob in any Azure storage account.
   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
   * an Azure file in any Azure storage account.
   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
   * operation to copy from another storage account.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/copy-blob
   *
   * @param copySource - url to the source Azure Blob/File.
   * @param options - Optional options to the Blob Start Copy From URL operation.
   */
  async startCopyFromURL(e, r = {}) {
    return pe.withSpan("BlobClient-startCopyFromURL", r, async (n) => {
      var s, i, o;
      return r.conditions = r.conditions || {}, r.sourceConditions = r.sourceConditions || {}, be(await this.blobContext.startCopyFromURL(e, {
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        metadata: r.metadata,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        sourceModifiedAccessConditions: {
          sourceIfMatch: r.sourceConditions.ifMatch,
          sourceIfModifiedSince: r.sourceConditions.ifModifiedSince,
          sourceIfNoneMatch: r.sourceConditions.ifNoneMatch,
          sourceIfUnmodifiedSince: r.sourceConditions.ifUnmodifiedSince,
          sourceIfTags: r.sourceConditions.tagConditions
        },
        immutabilityPolicyExpiry: (i = r.immutabilityPolicy) === null || i === void 0 ? void 0 : i.expiriesOn,
        immutabilityPolicyMode: (o = r.immutabilityPolicy) === null || o === void 0 ? void 0 : o.policyMode,
        legalHold: r.legalHold,
        rehydratePriority: r.rehydratePriority,
        tier: es(r.tier),
        blobTagsString: Zn(r.tags),
        sealBlob: r.sealBlob,
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Only available for BlobClient constructed with a shared key credential.
   *
   * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties
   * and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateSasUrl(e) {
    return new Promise((r) => {
      if (!(this.credential instanceof wt))
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      const n = $o(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, e), this.credential).toString();
      r(Mi(this.url, n));
    });
  }
  /**
   * Only available for BlobClient constructed with a shared key credential.
   *
   * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
  generateSasStringToSign(e) {
    if (!(this.credential instanceof wt))
      throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
    return qi(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, e), this.credential).stringToSign;
  }
  /**
   *
   * Generates a Blob Service Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateUserDelegationSasUrl(e, r) {
    return new Promise((n) => {
      const s = $o(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, e), r, this.accountName).toString();
      n(Mi(this.url, s));
    });
  }
  /**
   * Only available for BlobClient constructed with a shared key credential.
   *
   * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateUserDelegationSasStringToSign(e, r) {
    return qi(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, e), r, this.accountName).stringToSign;
  }
  /**
   * Delete the immutablility policy on the blob.
   *
   * @param options - Optional options to delete immutability policy on the blob.
   */
  async deleteImmutabilityPolicy(e = {}) {
    return pe.withSpan("BlobClient-deleteImmutabilityPolicy", e, async (r) => be(await this.blobContext.deleteImmutabilityPolicy({
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Set immutability policy on the blob.
   *
   * @param options - Optional options to set immutability policy on the blob.
   */
  async setImmutabilityPolicy(e, r = {}) {
    return pe.withSpan("BlobClient-setImmutabilityPolicy", r, async (n) => be(await this.blobContext.setImmutabilityPolicy({
      immutabilityPolicyExpiry: e.expiriesOn,
      immutabilityPolicyMode: e.policyMode,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Set legal hold on the blob.
   *
   * @param options - Optional options to set legal hold on the blob.
   */
  async setLegalHold(e, r = {}) {
    return pe.withSpan("BlobClient-setLegalHold", r, async (n) => be(await this.blobContext.setLegalHold(e, {
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * The Get Account Information operation returns the sku name and account kind
   * for the specified account.
   * The Get Account Information operation is available on service versions beginning
   * with version 2018-03-28.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-account-information
   *
   * @param options - Options to the Service Get Account Info operation.
   * @returns Response data for the Service Get Account Info operation.
   */
  async getAccountInfo(e = {}) {
    return pe.withSpan("BlobClient-getAccountInfo", e, async (r) => be(await this.blobContext.getAccountInfo({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
}
class co extends Mr {
  constructor(e, r, n, s) {
    let i, o;
    if (s = s || {}, Fn(r))
      o = e, i = r;
    else if (Mt && r instanceof wt || r instanceof Qt || Or(r))
      o = e, s = n, i = ht(r, s);
    else if (!r && typeof r != "string")
      o = e, i = ht(new Qt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const c = r, l = n, A = Ms(e);
      if (A.kind === "AccountConnString")
        if (Mt) {
          const a = new wt(A.accountName, A.accountKey);
          o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)), s.proxyOptions || (s.proxyOptions = Us(A.proxyUri)), i = ht(a, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (A.kind === "SASConnString")
        o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)) + "?" + A.accountSas, i = ht(new Qt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), this.appendBlobContext = this.storageClientContext.appendBlob;
  }
  /**
   * Creates a new AppendBlobClient object identical to the source but with the
   * specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a Client to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.
   */
  withSnapshot(e) {
    return new co(En(this.url, Xr.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param options - Options to the Append Block Create operation.
   *
   *
   * Example usage:
   *
   * ```js
   * const appendBlobClient = containerClient.getAppendBlobClient("<blob name>");
   * await appendBlobClient.create();
   * ```
   */
  async create(e = {}) {
    return e.conditions = e.conditions || {}, $t(e.customerProvidedKey, this.isHttps), pe.withSpan("AppendBlobClient-create", e, async (r) => {
      var n, s, i;
      return be(await this.appendBlobContext.create(0, {
        abortSignal: e.abortSignal,
        blobHttpHeaders: e.blobHTTPHeaders,
        leaseAccessConditions: e.conditions,
        metadata: e.metadata,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || n === void 0 ? void 0 : n.tagConditions }),
        cpkInfo: e.customerProvidedKey,
        encryptionScope: e.encryptionScope,
        immutabilityPolicyExpiry: (s = e.immutabilityPolicy) === null || s === void 0 ? void 0 : s.expiriesOn,
        immutabilityPolicyMode: (i = e.immutabilityPolicy) === null || i === void 0 ? void 0 : i.policyMode,
        legalHold: e.legalHold,
        blobTagsString: Zn(e.tags),
        tracingOptions: r.tracingOptions
      }));
    });
  }
  /**
   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
   * If the blob with the same name already exists, the content of the existing blob will remain unchanged.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param options -
   */
  async createIfNotExists(e = {}) {
    const r = { ifNoneMatch: rC };
    return pe.withSpan("AppendBlobClient-createIfNotExists", e, async (n) => {
      var s, i;
      try {
        const o = be(await this.create(Object.assign(Object.assign({}, n), { conditions: r })));
        return Object.assign(Object.assign({ succeeded: !0 }, o), { _response: o._response });
      } catch (o) {
        if (((s = o.details) === null || s === void 0 ? void 0 : s.errorCode) === "BlobAlreadyExists")
          return Object.assign(Object.assign({ succeeded: !1 }, (i = o.response) === null || i === void 0 ? void 0 : i.parsedHeaders), { _response: o.response });
        throw o;
      }
    });
  }
  /**
   * Seals the append blob, making it read only.
   *
   * @param options -
   */
  async seal(e = {}) {
    return e.conditions = e.conditions || {}, pe.withSpan("AppendBlobClient-seal", e, async (r) => {
      var n;
      return be(await this.appendBlobContext.seal({
        abortSignal: e.abortSignal,
        appendPositionAccessConditions: e.conditions,
        leaseAccessConditions: e.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, e.conditions), { ifTags: (n = e.conditions) === null || n === void 0 ? void 0 : n.tagConditions }),
        tracingOptions: r.tracingOptions
      }));
    });
  }
  /**
   * Commits a new block of data to the end of the existing append blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/append-block
   *
   * @param body - Data to be appended.
   * @param contentLength - Length of the body in bytes.
   * @param options - Options to the Append Block operation.
   *
   *
   * Example usage:
   *
   * ```js
   * const content = "Hello World!";
   *
   * // Create a new append blob and append data to the blob.
   * const newAppendBlobClient = containerClient.getAppendBlobClient("<blob name>");
   * await newAppendBlobClient.create();
   * await newAppendBlobClient.appendBlock(content, content.length);
   *
   * // Append data to an existing append blob.
   * const existingAppendBlobClient = containerClient.getAppendBlobClient("<blob name>");
   * await existingAppendBlobClient.appendBlock(content, content.length);
   * ```
   */
  async appendBlock(e, r, n = {}) {
    return n.conditions = n.conditions || {}, $t(n.customerProvidedKey, this.isHttps), pe.withSpan("AppendBlobClient-appendBlock", n, async (s) => {
      var i;
      return be(await this.appendBlobContext.appendBlock(r, e, {
        abortSignal: n.abortSignal,
        appendPositionAccessConditions: n.conditions,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, n.conditions), { ifTags: (i = n.conditions) === null || i === void 0 ? void 0 : i.tagConditions }),
        requestOptions: {
          onUploadProgress: n.onProgress
        },
        transactionalContentMD5: n.transactionalContentMD5,
        transactionalContentCrc64: n.transactionalContentCrc64,
        cpkInfo: n.customerProvidedKey,
        encryptionScope: n.encryptionScope,
        tracingOptions: s.tracingOptions
      }));
    });
  }
  /**
   * The Append Block operation commits a new block of data to the end of an existing append blob
   * where the contents are read from a source url.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/append-block-from-url
   *
   * @param sourceURL -
   *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can
   *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob
   *                 must either be public or must be authenticated via a shared access signature. If the source blob is
   *                 public, no authentication is required to perform the operation.
   * @param sourceOffset - Offset in source to be appended
   * @param count - Number of bytes to be appended as a block
   * @param options -
   */
  async appendBlockFromURL(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, s.sourceConditions = s.sourceConditions || {}, $t(s.customerProvidedKey, this.isHttps), pe.withSpan("AppendBlobClient-appendBlockFromURL", s, async (i) => {
      var o, c, l, A, a;
      return be(await this.appendBlobContext.appendBlockFromUrl(e, 0, {
        abortSignal: s.abortSignal,
        sourceRange: kr({ offset: r, count: n }),
        sourceContentMD5: s.sourceContentMD5,
        sourceContentCrc64: s.sourceContentCrc64,
        leaseAccessConditions: s.conditions,
        appendPositionAccessConditions: s.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, s.conditions), { ifTags: (o = s.conditions) === null || o === void 0 ? void 0 : o.tagConditions }),
        sourceModifiedAccessConditions: {
          sourceIfMatch: (c = s.sourceConditions) === null || c === void 0 ? void 0 : c.ifMatch,
          sourceIfModifiedSince: (l = s.sourceConditions) === null || l === void 0 ? void 0 : l.ifModifiedSince,
          sourceIfNoneMatch: (A = s.sourceConditions) === null || A === void 0 ? void 0 : A.ifNoneMatch,
          sourceIfUnmodifiedSince: (a = s.sourceConditions) === null || a === void 0 ? void 0 : a.ifUnmodifiedSince
        },
        copySourceAuthorization: Oi(s.sourceAuthorization),
        cpkInfo: s.customerProvidedKey,
        encryptionScope: s.encryptionScope,
        tracingOptions: i.tracingOptions
      }));
    });
  }
}
class lo extends Mr {
  constructor(e, r, n, s) {
    let i, o;
    if (s = s || {}, Fn(r))
      o = e, i = r;
    else if (Mt && r instanceof wt || r instanceof Qt || Or(r))
      o = e, s = n, i = ht(r, s);
    else if (!r && typeof r != "string")
      o = e, n && typeof n != "string" && (s = n), i = ht(new Qt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const c = r, l = n, A = Ms(e);
      if (A.kind === "AccountConnString")
        if (Mt) {
          const a = new wt(A.accountName, A.accountKey);
          o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)), s.proxyOptions || (s.proxyOptions = Us(A.proxyUri)), i = ht(a, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (A.kind === "SASConnString")
        o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)) + "?" + A.accountSas, i = ht(new Qt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), this.blockBlobContext = this.storageClientContext.blockBlob, this._blobContext = this.storageClientContext.blob;
  }
  /**
   * Creates a new BlockBlobClient object identical to the source but with the
   * specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a URL to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.
   */
  withSnapshot(e) {
    return new lo(En(this.url, Xr.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Quick query for a JSON or CSV formatted blob.
   *
   * Example usage (Node.js):
   *
   * ```js
   * // Query and convert a blob to a string
   * const queryBlockBlobResponse = await blockBlobClient.query("select * from BlobStorage");
   * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();
   * console.log("Query blob content:", downloaded);
   *
   * async function streamToBuffer(readableStream) {
   *   return new Promise((resolve, reject) => {
   *     const chunks = [];
   *     readableStream.on("data", (data) => {
   *       chunks.push(typeof data === "string" ? Buffer.from(data) : data);
   *     });
   *     readableStream.on("end", () => {
   *       resolve(Buffer.concat(chunks));
   *     });
   *     readableStream.on("error", reject);
   *   });
   * }
   * ```
   *
   * @param query -
   * @param options -
   */
  async query(e, r = {}) {
    if ($t(r.customerProvidedKey, this.isHttps), !Mt)
      throw new Error("This operation currently is only supported in Node.js.");
    return pe.withSpan("BlockBlobClient-query", r, async (n) => {
      var s;
      const i = be(await this._blobContext.query({
        abortSignal: r.abortSignal,
        queryRequest: {
          queryType: "SQL",
          expression: e,
          inputSerialization: Vh(r.inputTextConfiguration),
          outputSerialization: Vh(r.outputTextConfiguration)
        },
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        cpkInfo: r.customerProvidedKey,
        tracingOptions: n.tracingOptions
      }));
      return new HT(i, {
        abortSignal: r.abortSignal,
        onProgress: r.onProgress,
        onError: r.onError
      });
    });
  }
  /**
   * Creates a new block blob, or updates the content of an existing block blob.
   * Updating an existing block blob overwrites any existing metadata on the blob.
   * Partial updates are not supported; the content of the existing blob is
   * overwritten with the new content. To perform a partial update of a block blob's,
   * use {@link stageBlock} and {@link commitBlockList}.
   *
   * This is a non-parallel uploading method, please use {@link uploadFile},
   * {@link uploadStream} or {@link uploadBrowserData} for better performance
   * with concurrency uploading.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
   *                               which returns a new Readable stream whose offset is from data source beginning.
   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
   *                               string including non non-Base64/Hex-encoded characters.
   * @param options - Options to the Block Blob Upload operation.
   * @returns Response data for the Block Blob Upload operation.
   *
   * Example usage:
   *
   * ```js
   * const content = "Hello world!";
   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
   * ```
   */
  async upload(e, r, n = {}) {
    return n.conditions = n.conditions || {}, $t(n.customerProvidedKey, this.isHttps), pe.withSpan("BlockBlobClient-upload", n, async (s) => {
      var i, o, c;
      return be(await this.blockBlobContext.upload(r, e, {
        abortSignal: n.abortSignal,
        blobHttpHeaders: n.blobHTTPHeaders,
        leaseAccessConditions: n.conditions,
        metadata: n.metadata,
        modifiedAccessConditions: Object.assign(Object.assign({}, n.conditions), { ifTags: (i = n.conditions) === null || i === void 0 ? void 0 : i.tagConditions }),
        requestOptions: {
          onUploadProgress: n.onProgress
        },
        cpkInfo: n.customerProvidedKey,
        encryptionScope: n.encryptionScope,
        immutabilityPolicyExpiry: (o = n.immutabilityPolicy) === null || o === void 0 ? void 0 : o.expiriesOn,
        immutabilityPolicyMode: (c = n.immutabilityPolicy) === null || c === void 0 ? void 0 : c.policyMode,
        legalHold: n.legalHold,
        tier: es(n.tier),
        blobTagsString: Zn(n.tags),
        tracingOptions: s.tracingOptions
      }));
    });
  }
  /**
   * Creates a new Block Blob where the contents of the blob are read from a given URL.
   * This API is supported beginning with the 2020-04-08 version. Partial updates
   * are not supported with Put Blob from URL; the content of an existing blob is overwritten with
   * the content of the new blob.  To perform partial updates to a block blobs contents using a
   * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.
   *
   * @param sourceURL - Specifies the URL of the blob. The value
   *                           may be a URL of up to 2 KB in length that specifies a blob.
   *                           The value should be URL-encoded as it would appear
   *                           in a request URI. The source blob must either be public
   *                           or must be authenticated via a shared access signature.
   *                           If the source blob is public, no authentication is required
   *                           to perform the operation. Here are some examples of source object URLs:
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
   * @param options - Optional parameters.
   */
  async syncUploadFromURL(e, r = {}) {
    return r.conditions = r.conditions || {}, $t(r.customerProvidedKey, this.isHttps), pe.withSpan("BlockBlobClient-syncUploadFromURL", r, async (n) => {
      var s, i, o, c, l, A;
      return be(await this.blockBlobContext.putBlobFromUrl(0, e, Object.assign(Object.assign({}, r), { blobHttpHeaders: r.blobHTTPHeaders, leaseAccessConditions: r.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }), sourceModifiedAccessConditions: {
        sourceIfMatch: (i = r.sourceConditions) === null || i === void 0 ? void 0 : i.ifMatch,
        sourceIfModifiedSince: (o = r.sourceConditions) === null || o === void 0 ? void 0 : o.ifModifiedSince,
        sourceIfNoneMatch: (c = r.sourceConditions) === null || c === void 0 ? void 0 : c.ifNoneMatch,
        sourceIfUnmodifiedSince: (l = r.sourceConditions) === null || l === void 0 ? void 0 : l.ifUnmodifiedSince,
        sourceIfTags: (A = r.sourceConditions) === null || A === void 0 ? void 0 : A.tagConditions
      }, cpkInfo: r.customerProvidedKey, copySourceAuthorization: Oi(r.sourceAuthorization), tier: es(r.tier), blobTagsString: Zn(r.tags), copySourceTags: r.copySourceTags, tracingOptions: n.tracingOptions })));
    });
  }
  /**
   * Uploads the specified block to the block blob's "staging area" to be later
   * committed by a call to commitBlockList.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-block
   *
   * @param blockId - A 64-byte value that is base64-encoded
   * @param body - Data to upload to the staging area.
   * @param contentLength - Number of bytes to upload.
   * @param options - Options to the Block Blob Stage Block operation.
   * @returns Response data for the Block Blob Stage Block operation.
   */
  async stageBlock(e, r, n, s = {}) {
    return $t(s.customerProvidedKey, this.isHttps), pe.withSpan("BlockBlobClient-stageBlock", s, async (i) => be(await this.blockBlobContext.stageBlock(e, n, r, {
      abortSignal: s.abortSignal,
      leaseAccessConditions: s.conditions,
      requestOptions: {
        onUploadProgress: s.onProgress
      },
      transactionalContentMD5: s.transactionalContentMD5,
      transactionalContentCrc64: s.transactionalContentCrc64,
      cpkInfo: s.customerProvidedKey,
      encryptionScope: s.encryptionScope,
      tracingOptions: i.tracingOptions
    })));
  }
  /**
   * The Stage Block From URL operation creates a new block to be committed as part
   * of a blob where the contents are read from a URL.
   * This API is available starting in version 2018-03-28.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/put-block-from-url
   *
   * @param blockId - A 64-byte value that is base64-encoded
   * @param sourceURL - Specifies the URL of the blob. The value
   *                           may be a URL of up to 2 KB in length that specifies a blob.
   *                           The value should be URL-encoded as it would appear
   *                           in a request URI. The source blob must either be public
   *                           or must be authenticated via a shared access signature.
   *                           If the source blob is public, no authentication is required
   *                           to perform the operation. Here are some examples of source object URLs:
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
   * @param offset - From which position of the blob to download, greater than or equal to 0
   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
   * @param options - Options to the Block Blob Stage Block From URL operation.
   * @returns Response data for the Block Blob Stage Block From URL operation.
   */
  async stageBlockFromURL(e, r, n = 0, s, i = {}) {
    return $t(i.customerProvidedKey, this.isHttps), pe.withSpan("BlockBlobClient-stageBlockFromURL", i, async (o) => be(await this.blockBlobContext.stageBlockFromURL(e, 0, r, {
      abortSignal: i.abortSignal,
      leaseAccessConditions: i.conditions,
      sourceContentMD5: i.sourceContentMD5,
      sourceContentCrc64: i.sourceContentCrc64,
      sourceRange: n === 0 && !s ? void 0 : kr({ offset: n, count: s }),
      cpkInfo: i.customerProvidedKey,
      encryptionScope: i.encryptionScope,
      copySourceAuthorization: Oi(i.sourceAuthorization),
      tracingOptions: o.tracingOptions
    })));
  }
  /**
   * Writes a blob by specifying the list of block IDs that make up the blob.
   * In order to be written as part of a blob, a block must have been successfully written
   * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to
   * update a blob by uploading only those blocks that have changed, then committing the new and existing
   * blocks together. Any blocks not specified in the block list and permanently deleted.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-block-list
   *
   * @param blocks -  Array of 64-byte value that is base64-encoded
   * @param options - Options to the Block Blob Commit Block List operation.
   * @returns Response data for the Block Blob Commit Block List operation.
   */
  async commitBlockList(e, r = {}) {
    return r.conditions = r.conditions || {}, $t(r.customerProvidedKey, this.isHttps), pe.withSpan("BlockBlobClient-commitBlockList", r, async (n) => {
      var s, i, o;
      return be(await this.blockBlobContext.commitBlockList({ latest: e }, {
        abortSignal: r.abortSignal,
        blobHttpHeaders: r.blobHTTPHeaders,
        leaseAccessConditions: r.conditions,
        metadata: r.metadata,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        cpkInfo: r.customerProvidedKey,
        encryptionScope: r.encryptionScope,
        immutabilityPolicyExpiry: (i = r.immutabilityPolicy) === null || i === void 0 ? void 0 : i.expiriesOn,
        immutabilityPolicyMode: (o = r.immutabilityPolicy) === null || o === void 0 ? void 0 : o.policyMode,
        legalHold: r.legalHold,
        tier: es(r.tier),
        blobTagsString: Zn(r.tags),
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Returns the list of blocks that have been uploaded as part of a block blob
   * using the specified block list filter.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-block-list
   *
   * @param listType - Specifies whether to return the list of committed blocks,
   *                                        the list of uncommitted blocks, or both lists together.
   * @param options - Options to the Block Blob Get Block List operation.
   * @returns Response data for the Block Blob Get Block List operation.
   */
  async getBlockList(e, r = {}) {
    return pe.withSpan("BlockBlobClient-getBlockList", r, async (n) => {
      var s;
      const i = be(await this.blockBlobContext.getBlockList(e, {
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        tracingOptions: n.tracingOptions
      }));
      return i.committedBlocks || (i.committedBlocks = []), i.uncommittedBlocks || (i.uncommittedBlocks = []), i;
    });
  }
  // High level functions
  /**
   * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.
   *
   * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
   * to commit the block list.
   *
   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
   * `blobContentType`, enabling the browser to provide
   * functionality based on file type.
   *
   * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView
   * @param options -
   */
  async uploadData(e, r = {}) {
    return pe.withSpan("BlockBlobClient-uploadData", r, async (n) => {
      if (Mt) {
        let s;
        return e instanceof Buffer ? s = e : e instanceof ArrayBuffer ? s = Buffer.from(e) : (e = e, s = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), this.uploadSeekableInternal((i, o) => s.slice(i, i + o), s.byteLength, n);
      } else {
        const s = new Blob([e]);
        return this.uploadSeekableInternal((i, o) => s.slice(i, i + o), s.size, n);
      }
    });
  }
  /**
   * ONLY AVAILABLE IN BROWSERS.
   *
   * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.
   *
   * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call
   * {@link commitBlockList} to commit the block list.
   *
   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
   * `blobContentType`, enabling the browser to provide
   * functionality based on file type.
   *
   * @deprecated Use {@link uploadData} instead.
   *
   * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView
   * @param options - Options to upload browser data.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadBrowserData(e, r = {}) {
    return pe.withSpan("BlockBlobClient-uploadBrowserData", r, async (n) => {
      const s = new Blob([e]);
      return this.uploadSeekableInternal((i, o) => s.slice(i, i + o), s.size, n);
    });
  }
  /**
   *
   * Uploads data to block blob. Requires a bodyFactory as the data source,
   * which need to return a {@link HttpRequestBody} object with the offset and size provided.
   *
   * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
   * to commit the block list.
   *
   * @param bodyFactory -
   * @param size - size of the data to upload.
   * @param options - Options to Upload to Block Blob operation.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadSeekableInternal(e, r, n = {}) {
    var s, i;
    let o = (s = n.blockSize) !== null && s !== void 0 ? s : 0;
    if (o < 0 || o > Lc)
      throw new RangeError(`blockSize option must be >= 0 and <= ${Lc}`);
    const c = (i = n.maxSingleShotSize) !== null && i !== void 0 ? i : Uc;
    if (c < 0 || c > Uc)
      throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${Uc}`);
    if (o === 0) {
      if (r > Lc * vo)
        throw new RangeError(`${r} is too larger to upload to a block blob.`);
      r > c && (o = Math.ceil(r / vo), o < Vl && (o = Vl));
    }
    return n.blobHTTPHeaders || (n.blobHTTPHeaders = {}), n.conditions || (n.conditions = {}), pe.withSpan("BlockBlobClient-uploadSeekableInternal", n, async (l) => {
      if (r <= c)
        return be(await this.upload(e(0, r), r, l));
      const A = Math.floor((r - 1) / o) + 1;
      if (A > vo)
        throw new RangeError(`The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${vo}`);
      const a = [], u = Vo();
      let g = 0;
      const h = new _y(n.concurrency);
      for (let m = 0; m < A; m++)
        h.addOperation(async () => {
          const d = Jh(u, m), p = o * m, B = (m === A - 1 ? r : p + o) - p;
          a.push(d), await this.stageBlock(d, e(p, B), B, {
            abortSignal: n.abortSignal,
            conditions: n.conditions,
            encryptionScope: n.encryptionScope,
            tracingOptions: l.tracingOptions
          }), g += B, n.onProgress && n.onProgress({
            loadedBytes: g
          });
        });
      return await h.do(), this.commitBlockList(a, l);
    });
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Uploads a local file in blocks to a block blob.
   *
   * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
   * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList
   * to commit the block list.
   *
   * @param filePath - Full path of local file
   * @param options - Options to Upload to Block Blob operation.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadFile(e, r = {}) {
    return pe.withSpan("BlockBlobClient-uploadFile", r, async (n) => {
      const s = (await XT()).size;
      return this.uploadSeekableInternal((i, o) => () => KT(), s, Object.assign(Object.assign({}, r), { tracingOptions: n.tracingOptions }));
    });
  }
  /**
   * ONLY AVAILABLE IN NODE.JS RUNTIME.
   *
   * Uploads a Node.js Readable stream into block blob.
   *
   * PERFORMANCE IMPROVEMENT TIPS:
   * * Input stream highWaterMark is better to set a same value with bufferSize
   *    parameter, which will avoid Buffer.concat() operations.
   *
   * @param stream - Node.js Readable stream
   * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB
   * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,
   *                                 positive correlation with max uploading concurrency. Default value is 5
   * @param options - Options to Upload Stream to Block Blob operation.
   * @returns Response data for the Blob Upload operation.
   */
  async uploadStream(e, r = Av, n = 5, s = {}) {
    return s.blobHTTPHeaders || (s.blobHTTPHeaders = {}), s.conditions || (s.conditions = {}), pe.withSpan("BlockBlobClient-uploadStream", s, async (i) => {
      let o = 0;
      const c = Vo();
      let l = 0;
      const A = [];
      return await new jT(
        e,
        r,
        n,
        async (u, g) => {
          const h = Jh(c, o);
          A.push(h), o++, await this.stageBlock(h, u, g, {
            customerProvidedKey: s.customerProvidedKey,
            conditions: s.conditions,
            encryptionScope: s.encryptionScope,
            tracingOptions: i.tracingOptions
          }), l += g, s.onProgress && s.onProgress({ loadedBytes: l });
        },
        // concurrency should set a smaller value than maxConcurrency, which is helpful to
        // reduce the possibility when a outgoing handler waits for stream data, in
        // this situation, outgoing handlers are blocked.
        // Outgoing queue shouldn't be empty.
        Math.ceil(n / 4 * 3)
      ).do(), be(await this.commitBlockList(A, Object.assign(Object.assign({}, s), { tracingOptions: i.tracingOptions })));
    });
  }
}
class uo extends Mr {
  constructor(e, r, n, s) {
    let i, o;
    if (s = s || {}, Fn(r))
      o = e, i = r;
    else if (Mt && r instanceof wt || r instanceof Qt || Or(r))
      o = e, s = n, i = ht(r, s);
    else if (!r && typeof r != "string")
      o = e, i = ht(new Qt(), s);
    else if (r && typeof r == "string" && n && typeof n == "string") {
      const c = r, l = n, A = Ms(e);
      if (A.kind === "AccountConnString")
        if (Mt) {
          const a = new wt(A.accountName, A.accountKey);
          o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)), s.proxyOptions || (s.proxyOptions = Us(A.proxyUri)), i = ht(a, s);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (A.kind === "SASConnString")
        o = kt(kt(A.url, encodeURIComponent(c)), encodeURIComponent(l)) + "?" + A.accountSas, i = ht(new Qt(), s);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName and blobName parameters");
    super(o, i), this.pageBlobContext = this.storageClientContext.pageBlob;
  }
  /**
   * Creates a new PageBlobClient object identical to the source but with the
   * specified snapshot timestamp.
   * Provide "" will remove the snapshot and return a Client to the base blob.
   *
   * @param snapshot - The snapshot timestamp.
   * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.
   */
  withSnapshot(e) {
    return new uo(En(this.url, Xr.Parameters.SNAPSHOT, e.length === 0 ? void 0 : e), this.pipeline);
  }
  /**
   * Creates a page blob of the specified length. Call uploadPages to upload data
   * data to a page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param size - size of the page blob.
   * @param options - Options to the Page Blob Create operation.
   * @returns Response data for the Page Blob Create operation.
   */
  async create(e, r = {}) {
    return r.conditions = r.conditions || {}, $t(r.customerProvidedKey, this.isHttps), pe.withSpan("PageBlobClient-create", r, async (n) => {
      var s, i, o;
      return be(await this.pageBlobContext.create(0, e, {
        abortSignal: r.abortSignal,
        blobHttpHeaders: r.blobHTTPHeaders,
        blobSequenceNumber: r.blobSequenceNumber,
        leaseAccessConditions: r.conditions,
        metadata: r.metadata,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        cpkInfo: r.customerProvidedKey,
        encryptionScope: r.encryptionScope,
        immutabilityPolicyExpiry: (i = r.immutabilityPolicy) === null || i === void 0 ? void 0 : i.expiriesOn,
        immutabilityPolicyMode: (o = r.immutabilityPolicy) === null || o === void 0 ? void 0 : o.policyMode,
        legalHold: r.legalHold,
        tier: es(r.tier),
        blobTagsString: Zn(r.tags),
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Creates a page blob of the specified length. Call uploadPages to upload data
   * data to a page blob. If the blob with the same name already exists, the content
   * of the existing blob will remain unchanged.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param size - size of the page blob.
   * @param options -
   */
  async createIfNotExists(e, r = {}) {
    return pe.withSpan("PageBlobClient-createIfNotExists", r, async (n) => {
      var s, i;
      try {
        const o = { ifNoneMatch: rC }, c = be(await this.create(e, Object.assign(Object.assign({}, r), { conditions: o, tracingOptions: n.tracingOptions })));
        return Object.assign(Object.assign({ succeeded: !0 }, c), { _response: c._response });
      } catch (o) {
        if (((s = o.details) === null || s === void 0 ? void 0 : s.errorCode) === "BlobAlreadyExists")
          return Object.assign(Object.assign({ succeeded: !1 }, (i = o.response) === null || i === void 0 ? void 0 : i.parsedHeaders), { _response: o.response });
        throw o;
      }
    });
  }
  /**
   * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-page
   *
   * @param body - Data to upload
   * @param offset - Offset of destination page blob
   * @param count - Content length of the body, also number of bytes to be uploaded
   * @param options - Options to the Page Blob Upload Pages operation.
   * @returns Response data for the Page Blob Upload Pages operation.
   */
  async uploadPages(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, $t(s.customerProvidedKey, this.isHttps), pe.withSpan("PageBlobClient-uploadPages", s, async (i) => {
      var o;
      return be(await this.pageBlobContext.uploadPages(n, e, {
        abortSignal: s.abortSignal,
        leaseAccessConditions: s.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, s.conditions), { ifTags: (o = s.conditions) === null || o === void 0 ? void 0 : o.tagConditions }),
        requestOptions: {
          onUploadProgress: s.onProgress
        },
        range: kr({ offset: r, count: n }),
        sequenceNumberAccessConditions: s.conditions,
        transactionalContentMD5: s.transactionalContentMD5,
        transactionalContentCrc64: s.transactionalContentCrc64,
        cpkInfo: s.customerProvidedKey,
        encryptionScope: s.encryptionScope,
        tracingOptions: i.tracingOptions
      }));
    });
  }
  /**
   * The Upload Pages operation writes a range of pages to a page blob where the
   * contents are read from a URL.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/put-page-from-url
   *
   * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication
   * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob
   * @param destOffset - Offset of destination page blob
   * @param count - Number of bytes to be uploaded from source page blob
   * @param options -
   */
  async uploadPagesFromURL(e, r, n, s, i = {}) {
    return i.conditions = i.conditions || {}, i.sourceConditions = i.sourceConditions || {}, $t(i.customerProvidedKey, this.isHttps), pe.withSpan("PageBlobClient-uploadPagesFromURL", i, async (o) => {
      var c, l, A, a, u;
      return be(await this.pageBlobContext.uploadPagesFromURL(e, kr({ offset: r, count: s }), 0, kr({ offset: n, count: s }), {
        abortSignal: i.abortSignal,
        sourceContentMD5: i.sourceContentMD5,
        sourceContentCrc64: i.sourceContentCrc64,
        leaseAccessConditions: i.conditions,
        sequenceNumberAccessConditions: i.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, i.conditions), { ifTags: (c = i.conditions) === null || c === void 0 ? void 0 : c.tagConditions }),
        sourceModifiedAccessConditions: {
          sourceIfMatch: (l = i.sourceConditions) === null || l === void 0 ? void 0 : l.ifMatch,
          sourceIfModifiedSince: (A = i.sourceConditions) === null || A === void 0 ? void 0 : A.ifModifiedSince,
          sourceIfNoneMatch: (a = i.sourceConditions) === null || a === void 0 ? void 0 : a.ifNoneMatch,
          sourceIfUnmodifiedSince: (u = i.sourceConditions) === null || u === void 0 ? void 0 : u.ifUnmodifiedSince
        },
        cpkInfo: i.customerProvidedKey,
        encryptionScope: i.encryptionScope,
        copySourceAuthorization: Oi(i.sourceAuthorization),
        tracingOptions: o.tracingOptions
      }));
    });
  }
  /**
   * Frees the specified pages from the page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/put-page
   *
   * @param offset - Starting byte position of the pages to clear.
   * @param count - Number of bytes to clear.
   * @param options - Options to the Page Blob Clear Pages operation.
   * @returns Response data for the Page Blob Clear Pages operation.
   */
  async clearPages(e = 0, r, n = {}) {
    return n.conditions = n.conditions || {}, pe.withSpan("PageBlobClient-clearPages", n, async (s) => {
      var i;
      return be(await this.pageBlobContext.clearPages(0, {
        abortSignal: n.abortSignal,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, n.conditions), { ifTags: (i = n.conditions) === null || i === void 0 ? void 0 : i.tagConditions }),
        range: kr({ offset: e, count: r }),
        sequenceNumberAccessConditions: n.conditions,
        cpkInfo: n.customerProvidedKey,
        encryptionScope: n.encryptionScope,
        tracingOptions: s.tracingOptions
      }));
    });
  }
  /**
   * Returns the list of valid page ranges for a page blob or snapshot of a page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param options - Options to the Page Blob Get Ranges operation.
   * @returns Response data for the Page Blob Get Ranges operation.
   */
  async getPageRanges(e = 0, r, n = {}) {
    return n.conditions = n.conditions || {}, pe.withSpan("PageBlobClient-getPageRanges", n, async (s) => {
      var i;
      const o = be(await this.pageBlobContext.getPageRanges({
        abortSignal: n.abortSignal,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, n.conditions), { ifTags: (i = n.conditions) === null || i === void 0 ? void 0 : i.tagConditions }),
        range: kr({ offset: e, count: r }),
        tracingOptions: s.tracingOptions
      }));
      return Mc(o);
    });
  }
  /**
   * getPageRangesSegment returns a single segment of page ranges starting from the
   * specified Marker. Use an empty Marker to start enumeration from the beginning.
   * After getting a segment, process it, and then call getPageRangesSegment again
   * (passing the the previously-returned Marker) to get the next segment.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
   * @param options - Options to PageBlob Get Page Ranges Segment operation.
   */
  async listPageRangesSegment(e = 0, r, n, s = {}) {
    return pe.withSpan("PageBlobClient-getPageRangesSegment", s, async (i) => {
      var o;
      return be(await this.pageBlobContext.getPageRanges({
        abortSignal: s.abortSignal,
        leaseAccessConditions: s.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, s.conditions), { ifTags: (o = s.conditions) === null || o === void 0 ? void 0 : o.tagConditions }),
        range: kr({ offset: e, count: r }),
        marker: n,
        maxPageSize: s.maxPageSize,
        tracingOptions: i.tracingOptions
      }));
    });
  }
  /**
   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param marker - A string value that identifies the portion of
   *                          the get of page ranges to be returned with the next getting operation. The
   *                          operation returns the ContinuationToken value within the response body if the
   *                          getting operation did not return all page ranges remaining within the current page.
   *                          The ContinuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of get
   *                          items. The marker value is opaque to the client.
   * @param options - Options to List Page Ranges operation.
   */
  listPageRangeItemSegments() {
    return Ir(this, arguments, function* (r = 0, n, s, i = {}) {
      let o;
      if (s || s === void 0)
        do
          o = yield qe(this.listPageRangesSegment(r, n, s, i)), s = o.continuationToken, yield yield qe(yield qe(o));
        while (s);
    });
  }
  /**
   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param options - Options to List Page Ranges operation.
   */
  listPageRangeItems() {
    return Ir(this, arguments, function* (r = 0, n, s = {}) {
      var i, o, c, l;
      let A;
      try {
        for (var a = !0, u = Ur(this.listPageRangeItemSegments(r, n, A, s)), g; g = yield qe(u.next()), i = g.done, !i; a = !0)
          l = g.value, a = !1, yield qe(yield* Rs(Ur(Wh(l))));
      } catch (h) {
        o = { error: h };
      } finally {
        try {
          !a && !i && (c = u.return) && (yield qe(c.call(u)));
        } finally {
          if (o) throw o.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list of page ranges for a page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.
   *
   * Example using `for await` syntax:
   *
   * ```js
   * // Get the pageBlobClient before you run these snippets,
   * // Can be obtained from `blobServiceClient.getContainerClient("<your-container-name>").getPageBlobClient("<your-blob-name>");`
   * let i = 1;
   * for await (const pageRange of pageBlobClient.listPageRanges()) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let i = 1;
   * let iter = pageBlobClient.listPageRanges();
   * let pageRangeItem = await iter.next();
   * while (!pageRangeItem.done) {
   *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);
   *   pageRangeItem = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * // passing optional maxPageSize in the page settings
   * let i = 1;
   * for await (const response of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {
   *   for (const pageRange of response) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   * ```
   *
   * Example using paging with a marker:
   *
   * ```js
   * let i = 1;
   * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   *
   * // Prints 2 page ranges
   * for (const pageRange of response) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   *
   * // Gets next marker
   * let marker = response.continuationToken;
   *
   * // Passing next marker as continuationToken
   *
   * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   *
   * // Prints 10 page ranges
   * for (const blob of response) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   * ```
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param options - Options to the Page Blob Get Ranges operation.
   * @returns An asyncIterableIterator that supports paging.
   */
  listPageRanges(e = 0, r, n = {}) {
    n.conditions = n.conditions || {};
    const s = this.listPageRangeItems(e, r, n);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return s.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (i = {}) => this.listPageRangeItemSegments(e, r, i.continuationToken, Object.assign({ maxPageSize: i.maxPageSize }, n))
    };
  }
  /**
   * Gets the collection of page ranges that differ between a specified snapshot and this page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page blob
   * @param count - Number of bytes to get ranges diff.
   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   * @returns Response data for the Page Blob Get Page Range Diff operation.
   */
  async getPageRangesDiff(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, pe.withSpan("PageBlobClient-getPageRangesDiff", s, async (i) => {
      var o;
      const c = be(await this.pageBlobContext.getPageRangesDiff({
        abortSignal: s.abortSignal,
        leaseAccessConditions: s.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, s.conditions), { ifTags: (o = s.conditions) === null || o === void 0 ? void 0 : o.tagConditions }),
        prevsnapshot: n,
        range: kr({ offset: e, count: r }),
        tracingOptions: i.tracingOptions
      }));
      return Mc(c);
    });
  }
  /**
   * getPageRangesDiffSegment returns a single segment of page ranges starting from the
   * specified Marker for difference between previous snapshot and the target page blob.
   * Use an empty Marker to start enumeration from the beginning.
   * After getting a segment, process it, and then call getPageRangesDiffSegment again
   * (passing the the previously-returned Marker) to get the next segment.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
   * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   */
  async listPageRangesDiffSegment(e, r, n, s, i = {}) {
    return pe.withSpan("PageBlobClient-getPageRangesDiffSegment", i, async (o) => {
      var c;
      return be(await this.pageBlobContext.getPageRangesDiff({
        abortSignal: i?.abortSignal,
        leaseAccessConditions: i?.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, i?.conditions), { ifTags: (c = i?.conditions) === null || c === void 0 ? void 0 : c.tagConditions }),
        prevsnapshot: n,
        range: kr({
          offset: e,
          count: r
        }),
        marker: s,
        maxPageSize: i?.maxPageSize,
        tracingOptions: o.tracingOptions
      }));
    });
  }
  /**
   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}
   *
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
   * @param marker - A string value that identifies the portion of
   *                          the get of page ranges to be returned with the next getting operation. The
   *                          operation returns the ContinuationToken value within the response body if the
   *                          getting operation did not return all page ranges remaining within the current page.
   *                          The ContinuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of get
   *                          items. The marker value is opaque to the client.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   */
  listPageRangeDiffItemSegments(e, r, n, s, i) {
    return Ir(this, arguments, function* () {
      let c;
      if (s || s === void 0)
        do
          c = yield qe(this.listPageRangesDiffSegment(e, r, n, s, i)), s = c.continuationToken, yield yield qe(yield qe(c));
        while (s);
    });
  }
  /**
   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
   *
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   */
  listPageRangeDiffItems(e, r, n, s) {
    return Ir(this, arguments, function* () {
      var o, c, l, A;
      let a;
      try {
        for (var u = !0, g = Ur(this.listPageRangeDiffItemSegments(e, r, n, a, s)), h; h = yield qe(g.next()), o = h.done, !o; u = !0)
          A = h.value, u = !1, yield qe(yield* Rs(Ur(Wh(A))));
      } catch (m) {
        c = { error: m };
      } finally {
        try {
          !u && !o && (l = g.return) && (yield qe(l.call(g)));
        } finally {
          if (c) throw c.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
   *
   * Example using `for await` syntax:
   *
   * ```js
   * // Get the pageBlobClient before you run these snippets,
   * // Can be obtained from `blobServiceClient.getContainerClient("<your-container-name>").getPageBlobClient("<your-blob-name>");`
   * let i = 1;
   * for await (const pageRange of pageBlobClient.listPageRangesDiff()) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let i = 1;
   * let iter = pageBlobClient.listPageRangesDiff();
   * let pageRangeItem = await iter.next();
   * while (!pageRangeItem.done) {
   *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);
   *   pageRangeItem = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * // passing optional maxPageSize in the page settings
   * let i = 1;
   * for await (const response of pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 20 })) {
   *   for (const pageRange of response) {
   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   *   }
   * }
   * ```
   *
   * Example using paging with a marker:
   *
   * ```js
   * let i = 1;
   * let iterator = pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   *
   * // Prints 2 page ranges
   * for (const pageRange of response) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   *
   * // Gets next marker
   * let marker = response.continuationToken;
   *
   * // Passing next marker as continuationToken
   *
   * iterator = pageBlobClient.listPageRangesDiff().byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   *
   * // Prints 10 page ranges
   * for (const blob of response) {
   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
   * }
   * ```
   * @param offset - Starting byte position of the page ranges.
   * @param count - Number of bytes to get.
   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Ranges operation.
   * @returns An asyncIterableIterator that supports paging.
   */
  listPageRangesDiff(e, r, n, s = {}) {
    s.conditions = s.conditions || {};
    const i = this.listPageRangeDiffItems(e, r, n, Object.assign({}, s));
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return i.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (o = {}) => this.listPageRangeDiffItemSegments(e, r, n, o.continuationToken, Object.assign({ maxPageSize: o.maxPageSize }, s))
    };
  }
  /**
   * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.
   * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
   *
   * @param offset - Starting byte position of the page blob
   * @param count - Number of bytes to get ranges diff.
   * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.
   * @param options - Options to the Page Blob Get Page Ranges Diff operation.
   * @returns Response data for the Page Blob Get Page Range Diff operation.
   */
  async getPageRangesDiffForManagedDisks(e, r, n, s = {}) {
    return s.conditions = s.conditions || {}, pe.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", s, async (i) => {
      var o;
      const c = be(await this.pageBlobContext.getPageRangesDiff({
        abortSignal: s.abortSignal,
        leaseAccessConditions: s.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, s.conditions), { ifTags: (o = s.conditions) === null || o === void 0 ? void 0 : o.tagConditions }),
        prevSnapshotUrl: n,
        range: kr({ offset: e, count: r }),
        tracingOptions: i.tracingOptions
      }));
      return Mc(c);
    });
  }
  /**
   * Resizes the page blob to the specified size (which must be a multiple of 512).
   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
   *
   * @param size - Target size
   * @param options - Options to the Page Blob Resize operation.
   * @returns Response data for the Page Blob Resize operation.
   */
  async resize(e, r = {}) {
    return r.conditions = r.conditions || {}, pe.withSpan("PageBlobClient-resize", r, async (n) => {
      var s;
      return be(await this.pageBlobContext.resize(e, {
        abortSignal: r.abortSignal,
        leaseAccessConditions: r.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        encryptionScope: r.encryptionScope,
        tracingOptions: n.tracingOptions
      }));
    });
  }
  /**
   * Sets a page blob's sequence number.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-properties
   *
   * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.
   * @param sequenceNumber - Required if sequenceNumberAction is max or update
   * @param options - Options to the Page Blob Update Sequence Number operation.
   * @returns Response data for the Page Blob Update Sequence Number operation.
   */
  async updateSequenceNumber(e, r, n = {}) {
    return n.conditions = n.conditions || {}, pe.withSpan("PageBlobClient-updateSequenceNumber", n, async (s) => {
      var i;
      return be(await this.pageBlobContext.updateSequenceNumber(e, {
        abortSignal: n.abortSignal,
        blobSequenceNumber: r,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: Object.assign(Object.assign({}, n.conditions), { ifTags: (i = n.conditions) === null || i === void 0 ? void 0 : i.tagConditions }),
        tracingOptions: s.tracingOptions
      }));
    });
  }
  /**
   * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.
   * The snapshot is copied such that only the differential changes between the previously
   * copied snapshot are transferred to the destination.
   * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.
   * @see https://learn.microsoft.com/rest/api/storageservices/incremental-copy-blob
   * @see https://learn.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots
   *
   * @param copySource - Specifies the name of the source page blob snapshot. For example,
   *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
   * @param options - Options to the Page Blob Copy Incremental operation.
   * @returns Response data for the Page Blob Copy Incremental operation.
   */
  async startCopyIncremental(e, r = {}) {
    return pe.withSpan("PageBlobClient-startCopyIncremental", r, async (n) => {
      var s;
      return be(await this.pageBlobContext.copyIncremental(e, {
        abortSignal: r.abortSignal,
        modifiedAccessConditions: Object.assign(Object.assign({}, r.conditions), { ifTags: (s = r.conditions) === null || s === void 0 ? void 0 : s.tagConditions }),
        tracingOptions: n.tracingOptions
      }));
    });
  }
}
async function ZT(t) {
  const e = await t.blobBody;
  return $T(e);
}
function ek(t) {
  return new Blob([t]).size;
}
const Do = ": ", Xh = " ", Kh = -1;
class tk {
  constructor(e, r) {
    if (!e || !e.contentType)
      throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
    if (!r || r.size === 0)
      throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
    this.batchResponse = e, this.subRequests = r, this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1], this.perResponsePrefix = `--${this.responseBatchBoundary}${pn}`, this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
  }
  // For example of response, please refer to https://learn.microsoft.com/en-us/rest/api/storageservices/blob-batch#response
  async parseBatchResponse() {
    if (this.batchResponse._response.status !== lv.HTTP_ACCEPTED)
      throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
    const r = (await ZT(this.batchResponse)).split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1), n = r.length;
    if (n !== this.subRequests.size && n !== 1)
      throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
    const s = new Array(n);
    let i = 0, o = 0;
    for (let c = 0; c < n; c++) {
      const l = r[c], A = {};
      A.headers = _u(da());
      const a = l.split(`${pn}`);
      let u = !1, g = !1, h = !1, m = Kh;
      for (const d of a) {
        if (!u) {
          if (d.startsWith(An.CONTENT_ID) && (m = parseInt(d.split(Do)[1])), d.startsWith(nC)) {
            u = !0;
            const p = d.split(Xh);
            A.status = parseInt(p[1]), A.statusMessage = p.slice(2).join(Xh);
          }
          continue;
        }
        if (d.trim() === "") {
          g || (g = !0);
          continue;
        }
        if (g)
          A.bodyAsText || (A.bodyAsText = ""), A.bodyAsText += d;
        else {
          if (d.indexOf(Do) === -1)
            throw new Error(`Invalid state: find non-empty line '${d}' without HTTP header delimiter '${Do}'.`);
          const p = d.split(Do);
          A.headers.set(p[0], p[1]), p[0] === An.X_MS_ERROR_CODE && (A.errorCode = p[1], h = !0);
        }
      }
      m !== Kh && Number.isInteger(m) && m >= 0 && m < this.subRequests.size && s[m] === void 0 ? (A._request = this.subRequests.get(m), s[m] = A) : qt.error(`subResponses[${c}] is dropped as the Content-ID is not found or invalid, Content-ID: ${m}`), h ? o++ : i++;
    }
    return {
      subResponses: s,
      subResponsesSucceededCount: i,
      subResponsesFailedCount: o
    };
  }
}
var Cs;
(function(t) {
  t[t.LOCKED = 0] = "LOCKED", t[t.UNLOCKED = 1] = "UNLOCKED";
})(Cs || (Cs = {}));
class Xo {
  /**
   * Lock for a specific key. If the lock has been acquired by another customer, then
   * will wait until getting the lock.
   *
   * @param key - lock key
   */
  static async lock(e) {
    return new Promise((r) => {
      this.keys[e] === void 0 || this.keys[e] === Cs.UNLOCKED ? (this.keys[e] = Cs.LOCKED, r()) : this.onUnlockEvent(e, () => {
        this.keys[e] = Cs.LOCKED, r();
      });
    });
  }
  /**
   * Unlock a key.
   *
   * @param key -
   */
  static async unlock(e) {
    return new Promise((r) => {
      this.keys[e] === Cs.LOCKED && this.emitUnlockEvent(e), delete this.keys[e], r();
    });
  }
  static onUnlockEvent(e, r) {
    this.listeners[e] === void 0 ? this.listeners[e] = [r] : this.listeners[e].push(r);
  }
  static emitUnlockEvent(e) {
    if (this.listeners[e] !== void 0 && this.listeners[e].length > 0) {
      const r = this.listeners[e].shift();
      setImmediate(() => {
        r.call(this);
      });
    }
  }
}
Xo.keys = {};
Xo.listeners = {};
class _o {
  constructor() {
    this.batch = "batch", this.batchRequest = new rk();
  }
  /**
   * Get the value of Content-Type for a batch request.
   * The value must be multipart/mixed with a batch boundary.
   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252
   */
  getMultiPartContentType() {
    return this.batchRequest.getMultipartContentType();
  }
  /**
   * Get assembled HTTP request body for sub requests.
   */
  getHttpRequestBody() {
    return this.batchRequest.getHttpRequestBody();
  }
  /**
   * Get sub requests that are added into the batch request.
   */
  getSubRequests() {
    return this.batchRequest.getSubRequests();
  }
  async addSubRequestInternal(e, r) {
    await Xo.lock(this.batch);
    try {
      this.batchRequest.preAddSubRequest(e), await r(), this.batchRequest.postAddSubRequest(e);
    } finally {
      await Xo.unlock(this.batch);
    }
  }
  setBatchType(e) {
    if (this.batchType || (this.batchType = e), this.batchType !== e)
      throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
  }
  async deleteBlob(e, r, n) {
    let s, i;
    if (typeof e == "string" && (Mt && r instanceof wt || r instanceof Qt || Or(r)))
      s = e, i = r;
    else if (e instanceof Mr)
      s = e.url, i = e.credential, n = r;
    else
      throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
    return n || (n = {}), pe.withSpan("BatchDeleteRequest-addSubRequest", n, async (o) => {
      this.setBatchType("delete"), await this.addSubRequestInternal({
        url: s,
        credential: i
      }, async () => {
        await new Mr(s, this.batchRequest.createPipeline(i)).delete(o);
      });
    });
  }
  async setBlobAccessTier(e, r, n, s) {
    let i, o, c;
    if (typeof e == "string" && (Mt && r instanceof wt || r instanceof Qt || Or(r)))
      i = e, o = r, c = n;
    else if (e instanceof Mr)
      i = e.url, o = e.credential, c = r, s = n;
    else
      throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
    return s || (s = {}), pe.withSpan("BatchSetTierRequest-addSubRequest", s, async (l) => {
      this.setBatchType("setAccessTier"), await this.addSubRequestInternal({
        url: i,
        credential: o
      }, async () => {
        await new Mr(i, this.batchRequest.createPipeline(o)).setAccessTier(c, l);
      });
    });
  }
}
class rk {
  constructor() {
    this.operationCount = 0, this.body = "";
    const e = Vo();
    this.boundary = `batch_${e}`, this.subRequestPrefix = `--${this.boundary}${pn}${An.CONTENT_TYPE}: application/http${pn}${An.CONTENT_TRANSFER_ENCODING}: binary`, this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`, this.batchRequestEnding = `--${this.boundary}--`, this.subRequests = /* @__PURE__ */ new Map();
  }
  /**
   * Create pipeline to assemble sub requests. The idea here is to use existing
   * credential and serialization/deserialization components, with additional policies to
   * filter unnecessary headers, assemble sub requests into request's body
   * and intercept request from going to wire.
   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
   */
  createPipeline(e) {
    const r = yE();
    r.addPolicy(zE({
      stringifyXML: eC
    }), { phase: "Serialize" }), r.addPolicy(sk()), r.addPolicy(nk(this), { afterPhase: "Sign" }), Or(e) ? r.addPolicy(Uu({
      credential: e,
      scopes: Gu,
      challengeCallbacks: { authorizeRequestOnChallenge: VE }
    }), { phase: "Sign" }) : e instanceof wt && r.addPolicy(mC({
      accountName: e.accountName,
      accountKey: e.accountKey
    }), { phase: "Sign" });
    const n = new Hu([]);
    return n._credential = e, n._corePipeline = r, n;
  }
  appendSubRequestToBody(e) {
    this.body += [
      this.subRequestPrefix,
      // sub request constant prefix
      `${An.CONTENT_ID}: ${this.operationCount}`,
      // sub request's content ID
      "",
      // empty line after sub request's content ID
      `${e.method.toString()} ${yv(e.url)} ${nC}${pn}`
      // sub request start line with method
    ].join(pn);
    for (const [r, n] of e.headers)
      this.body += `${r}: ${n}${pn}`;
    this.body += pn;
  }
  preAddSubRequest(e) {
    if (this.operationCount >= zh)
      throw new RangeError(`Cannot exceed ${zh} sub requests in a single batch`);
    const r = iC(e.url);
    if (!r || r === "")
      throw new RangeError(`Invalid url for sub request: '${e.url}'`);
  }
  postAddSubRequest(e) {
    this.subRequests.set(this.operationCount, e), this.operationCount++;
  }
  // Return the http request body with assembling the ending line to the sub request body.
  getHttpRequestBody() {
    return `${this.body}${this.batchRequestEnding}${pn}`;
  }
  getMultipartContentType() {
    return this.multipartContentType;
  }
  getSubRequests() {
    return this.subRequests;
  }
}
function nk(t) {
  return {
    name: "batchRequestAssemblePolicy",
    async sendRequest(e) {
      return t.appendSubRequestToBody(e), {
        request: e,
        status: 200,
        headers: da()
      };
    }
  };
}
function sk() {
  return {
    name: "batchHeaderFilterPolicy",
    async sendRequest(t, e) {
      let r = "";
      for (const [n] of t.headers)
        aC(n, An.X_MS_VERSION) && (r = n);
      return r !== "" && t.headers.delete(r), e(t);
    }
  };
}
class Ad {
  constructor(e, r, n) {
    let s;
    Fn(r) ? s = r : r ? s = ht(r, n) : s = ht(new Qt(), n);
    const i = new Ly(e, fC(s)), o = iC(e);
    o && o !== "/" ? this.serviceOrContainerContext = i.container : this.serviceOrContainerContext = i.service;
  }
  /**
   * Creates a {@link BlobBatch}.
   * A BlobBatch represents an aggregated set of operations on blobs.
   */
  createBatch() {
    return new _o();
  }
  async deleteBlobs(e, r, n) {
    const s = new _o();
    for (const i of e)
      typeof i == "string" ? await s.deleteBlob(i, r, n) : await s.deleteBlob(i, r);
    return this.submitBatch(s);
  }
  async setBlobsAccessTier(e, r, n, s) {
    const i = new _o();
    for (const o of e)
      typeof o == "string" ? await i.setBlobAccessTier(o, r, n, s) : await i.setBlobAccessTier(o, r, n);
    return this.submitBatch(i);
  }
  /**
   * Submit batch request which consists of multiple subrequests.
   *
   * Get `blobBatchClient` and other details before running the snippets.
   * `blobServiceClient.getBlobBatchClient()` gives the `blobBatchClient`
   *
   * Example usage:
   *
   * ```js
   * let batchRequest = new BlobBatch();
   * await batchRequest.deleteBlob(urlInString0, credential0);
   * await batchRequest.deleteBlob(urlInString1, credential1, {
   *  deleteSnapshots: "include"
   * });
   * const batchResp = await blobBatchClient.submitBatch(batchRequest);
   * console.log(batchResp.subResponsesSucceededCount);
   * ```
   *
   * Example using a lease:
   *
   * ```js
   * let batchRequest = new BlobBatch();
   * await batchRequest.setBlobAccessTier(blockBlobClient0, "Cool");
   * await batchRequest.setBlobAccessTier(blockBlobClient1, "Cool", {
   *  conditions: { leaseId: leaseId }
   * });
   * const batchResp = await blobBatchClient.submitBatch(batchRequest);
   * console.log(batchResp.subResponsesSucceededCount);
   * ```
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/blob-batch
   *
   * @param batchRequest - A set of Delete or SetTier operations.
   * @param options -
   */
  async submitBatch(e, r = {}) {
    if (!e || e.getSubRequests().size === 0)
      throw new RangeError("Batch request should contain one or more sub requests.");
    return pe.withSpan("BlobBatchClient-submitBatch", r, async (n) => {
      const s = e.getHttpRequestBody(), i = be(await this.serviceOrContainerContext.submitBatch(ek(s), e.getMultiPartContentType(), s, Object.assign({}, n))), c = await new tk(i, e.getSubRequests()).parseBatchResponse();
      return {
        _response: i._response,
        contentType: i.contentType,
        errorCode: i.errorCode,
        requestId: i.requestId,
        clientRequestId: i.clientRequestId,
        version: i.version,
        subResponses: c.subResponses,
        subResponsesSucceededCount: c.subResponsesSucceededCount,
        subResponsesFailedCount: c.subResponsesFailedCount
      };
    });
  }
}
class My extends sd {
  /**
   * The name of the container.
   */
  get containerName() {
    return this._containerName;
  }
  constructor(e, r, n) {
    let s, i;
    if (n = n || {}, Fn(r))
      i = e, s = r;
    else if (Mt && r instanceof wt || r instanceof Qt || Or(r))
      i = e, s = ht(r, n);
    else if (!r && typeof r != "string")
      i = e, s = ht(new Qt(), n);
    else if (r && typeof r == "string") {
      const o = r, c = Ms(e);
      if (c.kind === "AccountConnString")
        if (Mt) {
          const l = new wt(c.accountName, c.accountKey);
          i = kt(c.url, encodeURIComponent(o)), n.proxyOptions || (n.proxyOptions = Us(c.proxyUri)), s = ht(l, n);
        } else
          throw new Error("Account connection string is only supported in Node.js environment");
      else if (c.kind === "SASConnString")
        i = kt(c.url, encodeURIComponent(o)) + "?" + c.accountSas, s = ht(new Qt(), n);
      else
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
    } else
      throw new Error("Expecting non-empty strings for containerName parameter");
    super(i, s), this._containerName = this.getContainerNameFromUrl(), this.containerContext = this.storageClientContext.container;
  }
  /**
   * Creates a new container under the specified account. If the container with
   * the same name already exists, the operation fails.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-container
   * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
   *
   * @param options - Options to Container Create operation.
   *
   *
   * Example usage:
   *
   * ```js
   * const containerClient = blobServiceClient.getContainerClient("<container name>");
   * const createContainerResponse = await containerClient.create();
   * console.log("Container was created successfully", createContainerResponse.requestId);
   * ```
   */
  async create(e = {}) {
    return pe.withSpan("ContainerClient-create", e, async (r) => be(await this.containerContext.create(r)));
  }
  /**
   * Creates a new container under the specified account. If the container with
   * the same name already exists, it is not changed.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-container
   * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
   *
   * @param options -
   */
  async createIfNotExists(e = {}) {
    return pe.withSpan("ContainerClient-createIfNotExists", e, async (r) => {
      var n, s;
      try {
        const i = await this.create(r);
        return Object.assign(Object.assign({ succeeded: !0 }, i), { _response: i._response });
      } catch (i) {
        if (((n = i.details) === null || n === void 0 ? void 0 : n.errorCode) === "ContainerAlreadyExists")
          return Object.assign(Object.assign({ succeeded: !1 }, (s = i.response) === null || s === void 0 ? void 0 : s.parsedHeaders), { _response: i.response });
        throw i;
      }
    });
  }
  /**
   * Returns true if the Azure container resource represented by this client exists; false otherwise.
   *
   * NOTE: use this function with care since an existing container might be deleted by other clients or
   * applications. Vice versa new containers with the same name might be added by other clients or
   * applications after this function completes.
   *
   * @param options -
   */
  async exists(e = {}) {
    return pe.withSpan("ContainerClient-exists", e, async (r) => {
      try {
        return await this.getProperties({
          abortSignal: e.abortSignal,
          tracingOptions: r.tracingOptions
        }), !0;
      } catch (n) {
        if (n.statusCode === 404)
          return !1;
        throw n;
      }
    });
  }
  /**
   * Creates a {@link BlobClient}
   *
   * @param blobName - A blob name
   * @returns A new BlobClient object for the given blob name.
   */
  getBlobClient(e) {
    return new Mr(kt(this.url, xo(e)), this.pipeline);
  }
  /**
   * Creates an {@link AppendBlobClient}
   *
   * @param blobName - An append blob name
   */
  getAppendBlobClient(e) {
    return new co(kt(this.url, xo(e)), this.pipeline);
  }
  /**
   * Creates a {@link BlockBlobClient}
   *
   * @param blobName - A block blob name
   *
   *
   * Example usage:
   *
   * ```js
   * const content = "Hello world!";
   *
   * const blockBlobClient = containerClient.getBlockBlobClient("<blob name>");
   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
   * ```
   */
  getBlockBlobClient(e) {
    return new lo(kt(this.url, xo(e)), this.pipeline);
  }
  /**
   * Creates a {@link PageBlobClient}
   *
   * @param blobName - A page blob name
   */
  getPageBlobClient(e) {
    return new uo(kt(this.url, xo(e)), this.pipeline);
  }
  /**
   * Returns all user-defined metadata and system properties for the specified
   * container. The data returned does not include the container's list of blobs.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-container-properties
   *
   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
   * they originally contained uppercase characters. This differs from the metadata keys returned by
   * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which
   * will retain their original casing.
   *
   * @param options - Options to Container Get Properties operation.
   */
  async getProperties(e = {}) {
    return e.conditions || (e.conditions = {}), pe.withSpan("ContainerClient-getProperties", e, async (r) => be(await this.containerContext.getProperties(Object.assign(Object.assign({ abortSignal: e.abortSignal }, e.conditions), { tracingOptions: r.tracingOptions }))));
  }
  /**
   * Marks the specified container for deletion. The container and any blobs
   * contained within it are later deleted during garbage collection.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/delete-container
   *
   * @param options - Options to Container Delete operation.
   */
  async delete(e = {}) {
    return e.conditions || (e.conditions = {}), pe.withSpan("ContainerClient-delete", e, async (r) => be(await this.containerContext.delete({
      abortSignal: e.abortSignal,
      leaseAccessConditions: e.conditions,
      modifiedAccessConditions: e.conditions,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Marks the specified container for deletion if it exists. The container and any blobs
   * contained within it are later deleted during garbage collection.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/delete-container
   *
   * @param options - Options to Container Delete operation.
   */
  async deleteIfExists(e = {}) {
    return pe.withSpan("ContainerClient-deleteIfExists", e, async (r) => {
      var n, s;
      try {
        const i = await this.delete(r);
        return Object.assign(Object.assign({ succeeded: !0 }, i), { _response: i._response });
      } catch (i) {
        if (((n = i.details) === null || n === void 0 ? void 0 : n.errorCode) === "ContainerNotFound")
          return Object.assign(Object.assign({ succeeded: !1 }, (s = i.response) === null || s === void 0 ? void 0 : s.parsedHeaders), { _response: i.response });
        throw i;
      }
    });
  }
  /**
   * Sets one or more user-defined name-value pairs for the specified container.
   *
   * If no option provided, or no metadata defined in the parameter, the container
   * metadata will be removed.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-container-metadata
   *
   * @param metadata - Replace existing metadata with this value.
   *                            If no value provided the existing metadata will be removed.
   * @param options - Options to Container Set Metadata operation.
   */
  async setMetadata(e, r = {}) {
    if (r.conditions || (r.conditions = {}), r.conditions.ifUnmodifiedSince)
      throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
    return pe.withSpan("ContainerClient-setMetadata", r, async (n) => be(await this.containerContext.setMetadata({
      abortSignal: r.abortSignal,
      leaseAccessConditions: r.conditions,
      metadata: e,
      modifiedAccessConditions: r.conditions,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Gets the permissions for the specified container. The permissions indicate
   * whether container data may be accessed publicly.
   *
   * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
   * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-container-acl
   *
   * @param options - Options to Container Get Access Policy operation.
   */
  async getAccessPolicy(e = {}) {
    return e.conditions || (e.conditions = {}), pe.withSpan("ContainerClient-getAccessPolicy", e, async (r) => {
      const n = be(await this.containerContext.getAccessPolicy({
        abortSignal: e.abortSignal,
        leaseAccessConditions: e.conditions,
        tracingOptions: r.tracingOptions
      })), s = {
        _response: n._response,
        blobPublicAccess: n.blobPublicAccess,
        date: n.date,
        etag: n.etag,
        errorCode: n.errorCode,
        lastModified: n.lastModified,
        requestId: n.requestId,
        clientRequestId: n.clientRequestId,
        signedIdentifiers: [],
        version: n.version
      };
      for (const i of n) {
        let o;
        i.accessPolicy && (o = {
          permissions: i.accessPolicy.permissions
        }, i.accessPolicy.expiresOn && (o.expiresOn = new Date(i.accessPolicy.expiresOn)), i.accessPolicy.startsOn && (o.startsOn = new Date(i.accessPolicy.startsOn))), s.signedIdentifiers.push({
          accessPolicy: o,
          id: i.id
        });
      }
      return s;
    });
  }
  /**
   * Sets the permissions for the specified container. The permissions indicate
   * whether blobs in a container may be accessed publicly.
   *
   * When you set permissions for a container, the existing permissions are replaced.
   * If no access or containerAcl provided, the existing container ACL will be
   * removed.
   *
   * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.
   * During this interval, a shared access signature that is associated with the stored access policy will
   * fail with status code 403 (Forbidden), until the access policy becomes active.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-container-acl
   *
   * @param access - The level of public access to data in the container.
   * @param containerAcl - Array of elements each having a unique Id and details of the access policy.
   * @param options - Options to Container Set Access Policy operation.
   */
  async setAccessPolicy(e, r, n = {}) {
    return n.conditions = n.conditions || {}, pe.withSpan("ContainerClient-setAccessPolicy", n, async (s) => {
      const i = [];
      for (const o of r || [])
        i.push({
          accessPolicy: {
            expiresOn: o.accessPolicy.expiresOn ? ot(o.accessPolicy.expiresOn) : "",
            permissions: o.accessPolicy.permissions,
            startsOn: o.accessPolicy.startsOn ? ot(o.accessPolicy.startsOn) : ""
          },
          id: o.id
        });
      return be(await this.containerContext.setAccessPolicy({
        abortSignal: n.abortSignal,
        access: e,
        containerAcl: i,
        leaseAccessConditions: n.conditions,
        modifiedAccessConditions: n.conditions,
        tracingOptions: s.tracingOptions
      }));
    });
  }
  /**
   * Get a {@link BlobLeaseClient} that manages leases on the container.
   *
   * @param proposeLeaseId - Initial proposed lease Id.
   * @returns A new BlobLeaseClient object for managing leases on the container.
   */
  getBlobLeaseClient(e) {
    return new id(this, e);
  }
  /**
   * Creates a new block blob, or updates the content of an existing block blob.
   *
   * Updating an existing block blob overwrites any existing metadata on the blob.
   * Partial updates are not supported; the content of the existing blob is
   * overwritten with the new content. To perform a partial update of a block blob's,
   * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.
   *
   * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},
   * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better
   * performance with concurrency uploading.
   *
   * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
   *
   * @param blobName - Name of the block blob to create or update.
   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
   *                               which returns a new Readable stream whose offset is from data source beginning.
   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
   *                               string including non non-Base64/Hex-encoded characters.
   * @param options - Options to configure the Block Blob Upload operation.
   * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.
   */
  async uploadBlockBlob(e, r, n, s = {}) {
    return pe.withSpan("ContainerClient-uploadBlockBlob", s, async (i) => {
      const o = this.getBlockBlobClient(e), c = await o.upload(r, n, i);
      return {
        blockBlobClient: o,
        response: c
      };
    });
  }
  /**
   * Marks the specified blob or snapshot for deletion. The blob is later deleted
   * during garbage collection. Note that in order to delete a blob, you must delete
   * all of its snapshots. You can delete both at the same time with the Delete
   * Blob operation.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/delete-blob
   *
   * @param blobName -
   * @param options - Options to Blob Delete operation.
   * @returns Block blob deletion response data.
   */
  async deleteBlob(e, r = {}) {
    return pe.withSpan("ContainerClient-deleteBlob", r, async (n) => {
      let s = this.getBlobClient(e);
      return r.versionId && (s = s.withVersion(r.versionId)), s.delete(n);
    });
  }
  /**
   * listBlobFlatSegment returns a single segment of blobs starting from the
   * specified Marker. Use an empty Marker to start enumeration from the beginning.
   * After getting a segment, process it, and then call listBlobsFlatSegment again
   * (passing the the previously-returned Marker) to get the next segment.
   * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
   *
   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
   * @param options - Options to Container List Blob Flat Segment operation.
   */
  async listBlobFlatSegment(e, r = {}) {
    return pe.withSpan("ContainerClient-listBlobFlatSegment", r, async (n) => {
      const s = be(await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({ marker: e }, r), { tracingOptions: n.tracingOptions })));
      return Object.assign(Object.assign({}, s), { _response: Object.assign(Object.assign({}, s._response), { parsedBody: Nv(s._response.parsedBody) }), segment: Object.assign(Object.assign({}, s.segment), { blobItems: s.segment.blobItems.map((o) => Object.assign(Object.assign({}, o), { name: Qs(o.name), tags: Ti(o.blobTags), objectReplicationSourceProperties: jo(o.objectReplicationMetadata) })) }) });
    });
  }
  /**
   * listBlobHierarchySegment returns a single segment of blobs starting from
   * the specified Marker. Use an empty Marker to start enumeration from the
   * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment
   * again (passing the the previously-returned Marker) to get the next segment.
   * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
   *
   * @param delimiter - The character or string used to define the virtual hierarchy
   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
   * @param options - Options to Container List Blob Hierarchy Segment operation.
   */
  async listBlobHierarchySegment(e, r, n = {}) {
    return pe.withSpan("ContainerClient-listBlobHierarchySegment", n, async (s) => {
      var i;
      const o = be(await this.containerContext.listBlobHierarchySegment(e, Object.assign(Object.assign({ marker: r }, n), { tracingOptions: s.tracingOptions })));
      return Object.assign(Object.assign({}, o), { _response: Object.assign(Object.assign({}, o._response), { parsedBody: Rv(o._response.parsedBody) }), segment: Object.assign(Object.assign({}, o.segment), { blobItems: o.segment.blobItems.map((l) => Object.assign(Object.assign({}, l), { name: Qs(l.name), tags: Ti(l.blobTags), objectReplicationSourceProperties: jo(l.objectReplicationMetadata) })), blobPrefixes: (i = o.segment.blobPrefixes) === null || i === void 0 ? void 0 : i.map((l) => Object.assign(Object.assign({}, l), { name: Qs(l.name) })) }) });
    });
  }
  /**
   * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse
   *
   * @param marker - A string value that identifies the portion of
   *                          the list of blobs to be returned with the next listing operation. The
   *                          operation returns the ContinuationToken value within the response body if the
   *                          listing operation did not return all blobs remaining to be listed
   *                          with the current page. The ContinuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of list
   *                          items. The marker value is opaque to the client.
   * @param options - Options to list blobs operation.
   */
  listSegments(e) {
    return Ir(this, arguments, function* (n, s = {}) {
      let i;
      if (n || n === void 0)
        do
          i = yield qe(this.listBlobFlatSegment(n, s)), n = i.continuationToken, yield yield qe(yield qe(i));
        while (n);
    });
  }
  /**
   * Returns an AsyncIterableIterator of {@link BlobItem} objects
   *
   * @param options - Options to list blobs operation.
   */
  listItems() {
    return Ir(this, arguments, function* (r = {}) {
      var n, s, i, o;
      let c;
      try {
        for (var l = !0, A = Ur(this.listSegments(c, r)), a; a = yield qe(A.next()), n = a.done, !n; l = !0)
          o = a.value, l = !1, yield qe(yield* Rs(Ur(o.segment.blobItems)));
      } catch (u) {
        s = { error: u };
      } finally {
        try {
          !l && !n && (i = A.return) && (yield qe(i.call(A)));
        } finally {
          if (s) throw s.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list all the blobs
   * under the specified account.
   *
   * .byPage() returns an async iterable iterator to list the blobs in pages.
   *
   * Example using `for await` syntax:
   *
   * ```js
   * // Get the containerClient before you run these snippets,
   * // Can be obtained from `blobServiceClient.getContainerClient("<your-container-name>");`
   * let i = 1;
   * for await (const blob of containerClient.listBlobsFlat()) {
   *   console.log(`Blob ${i++}: ${blob.name}`);
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let i = 1;
   * let iter = containerClient.listBlobsFlat();
   * let blobItem = await iter.next();
   * while (!blobItem.done) {
   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);
   *   blobItem = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * // passing optional maxPageSize in the page settings
   * let i = 1;
   * for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {
   *   for (const blob of response.segment.blobItems) {
   *     console.log(`Blob ${i++}: ${blob.name}`);
   *   }
   * }
   * ```
   *
   * Example using paging with a marker:
   *
   * ```js
   * let i = 1;
   * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   *
   * // Prints 2 blob names
   * for (const blob of response.segment.blobItems) {
   *   console.log(`Blob ${i++}: ${blob.name}`);
   * }
   *
   * // Gets next marker
   * let marker = response.continuationToken;
   *
   * // Passing next marker as continuationToken
   *
   * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   *
   * // Prints 10 blob names
   * for (const blob of response.segment.blobItems) {
   *   console.log(`Blob ${i++}: ${blob.name}`);
   * }
   * ```
   *
   * @param options - Options to list blobs.
   * @returns An asyncIterableIterator that supports paging.
   */
  listBlobsFlat(e = {}) {
    const r = [];
    e.includeCopy && r.push("copy"), e.includeDeleted && r.push("deleted"), e.includeMetadata && r.push("metadata"), e.includeSnapshots && r.push("snapshots"), e.includeVersions && r.push("versions"), e.includeUncommitedBlobs && r.push("uncommittedblobs"), e.includeTags && r.push("tags"), e.includeDeletedWithVersions && r.push("deletedwithversions"), e.includeImmutabilityPolicy && r.push("immutabilitypolicy"), e.includeLegalHold && r.push("legalhold"), e.prefix === "" && (e.prefix = void 0);
    const n = Object.assign(Object.assign({}, e), r.length > 0 ? { include: r } : {}), s = this.listItems(n);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return s.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (i = {}) => this.listSegments(i.continuationToken, Object.assign({ maxPageSize: i.maxPageSize }, n))
    };
  }
  /**
   * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse
   *
   * @param delimiter - The character or string used to define the virtual hierarchy
   * @param marker - A string value that identifies the portion of
   *                          the list of blobs to be returned with the next listing operation. The
   *                          operation returns the ContinuationToken value within the response body if the
   *                          listing operation did not return all blobs remaining to be listed
   *                          with the current page. The ContinuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of list
   *                          items. The marker value is opaque to the client.
   * @param options - Options to list blobs operation.
   */
  listHierarchySegments(e, r) {
    return Ir(this, arguments, function* (s, i, o = {}) {
      let c;
      if (i || i === void 0)
        do
          c = yield qe(this.listBlobHierarchySegment(s, i, o)), i = c.continuationToken, yield yield qe(yield qe(c));
        while (i);
    });
  }
  /**
   * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.
   *
   * @param delimiter - The character or string used to define the virtual hierarchy
   * @param options - Options to list blobs operation.
   */
  listItemsByHierarchy(e) {
    return Ir(this, arguments, function* (n, s = {}) {
      var i, o, c, l;
      let A;
      try {
        for (var a = !0, u = Ur(this.listHierarchySegments(n, A, s)), g; g = yield qe(u.next()), i = g.done, !i; a = !0) {
          l = g.value, a = !1;
          const m = l.segment;
          if (m.blobPrefixes)
            for (const d of m.blobPrefixes)
              yield yield qe(Object.assign({ kind: "prefix" }, d));
          for (const d of m.blobItems)
            yield yield qe(Object.assign({ kind: "blob" }, d));
        }
      } catch (h) {
        o = { error: h };
      } finally {
        try {
          !a && !i && (c = u.return) && (yield qe(c.call(u)));
        } finally {
          if (o) throw o.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list all the blobs by hierarchy.
   * under the specified account.
   *
   * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.
   *
   * Example using `for await` syntax:
   *
   * ```js
   * for await (const item of containerClient.listBlobsByHierarchy("/")) {
   *   if (item.kind === "prefix") {
   *     console.log(`\tBlobPrefix: ${item.name}`);
   *   } else {
   *     console.log(`\tBlobItem: name - ${item.name}`);
   *   }
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let iter = containerClient.listBlobsByHierarchy("/", { prefix: "prefix1/" });
   * let entity = await iter.next();
   * while (!entity.done) {
   *   let item = entity.value;
   *   if (item.kind === "prefix") {
   *     console.log(`\tBlobPrefix: ${item.name}`);
   *   } else {
   *     console.log(`\tBlobItem: name - ${item.name}`);
   *   }
   *   entity = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * console.log("Listing blobs by hierarchy by page");
   * for await (const response of containerClient.listBlobsByHierarchy("/").byPage()) {
   *   const segment = response.segment;
   *   if (segment.blobPrefixes) {
   *     for (const prefix of segment.blobPrefixes) {
   *       console.log(`\tBlobPrefix: ${prefix.name}`);
   *     }
   *   }
   *   for (const blob of response.segment.blobItems) {
   *     console.log(`\tBlobItem: name - ${blob.name}`);
   *   }
   * }
   * ```
   *
   * Example using paging with a max page size:
   *
   * ```js
   * console.log("Listing blobs by hierarchy by page, specifying a prefix and a max page size");
   *
   * let i = 1;
   * for await (const response of containerClient
   *   .listBlobsByHierarchy("/", { prefix: "prefix2/sub1/" })
   *   .byPage({ maxPageSize: 2 })) {
   *   console.log(`Page ${i++}`);
   *   const segment = response.segment;
   *
   *   if (segment.blobPrefixes) {
   *     for (const prefix of segment.blobPrefixes) {
   *       console.log(`\tBlobPrefix: ${prefix.name}`);
   *     }
   *   }
   *
   *   for (const blob of response.segment.blobItems) {
   *     console.log(`\tBlobItem: name - ${blob.name}`);
   *   }
   * }
   * ```
   *
   * @param delimiter - The character or string used to define the virtual hierarchy
   * @param options - Options to list blobs operation.
   */
  listBlobsByHierarchy(e, r = {}) {
    if (e === "")
      throw new RangeError("delimiter should contain one or more characters");
    const n = [];
    r.includeCopy && n.push("copy"), r.includeDeleted && n.push("deleted"), r.includeMetadata && n.push("metadata"), r.includeSnapshots && n.push("snapshots"), r.includeVersions && n.push("versions"), r.includeUncommitedBlobs && n.push("uncommittedblobs"), r.includeTags && n.push("tags"), r.includeDeletedWithVersions && n.push("deletedwithversions"), r.includeImmutabilityPolicy && n.push("immutabilitypolicy"), r.includeLegalHold && n.push("legalhold"), r.prefix === "" && (r.prefix = void 0);
    const s = Object.assign(Object.assign({}, r), n.length > 0 ? { include: n } : {}), i = this.listItemsByHierarchy(e, s);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      async next() {
        return i.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (o = {}) => this.listHierarchySegments(e, o.continuationToken, Object.assign({ maxPageSize: o.maxPageSize }, s))
    };
  }
  /**
   * The Filter Blobs operation enables callers to list blobs in the container whose tags
   * match a given search expression.
   *
   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                        The given expression must evaluate to true for a blob to be returned in the results.
   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param marker - A string value that identifies the portion of
   *                          the list of blobs to be returned with the next listing operation. The
   *                          operation returns the continuationToken value within the response body if the
   *                          listing operation did not return all blobs remaining to be listed
   *                          with the current page. The continuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of list
   *                          items. The marker value is opaque to the client.
   * @param options - Options to find blobs by tags.
   */
  async findBlobsByTagsSegment(e, r, n = {}) {
    return pe.withSpan("ContainerClient-findBlobsByTagsSegment", n, async (s) => {
      const i = be(await this.containerContext.filterBlobs({
        abortSignal: n.abortSignal,
        where: e,
        marker: r,
        maxPageSize: n.maxPageSize,
        tracingOptions: s.tracingOptions
      }));
      return Object.assign(Object.assign({}, i), { _response: i._response, blobs: i.blobs.map((c) => {
        var l;
        let A = "";
        return ((l = c.tags) === null || l === void 0 ? void 0 : l.blobTagSet.length) === 1 && (A = c.tags.blobTagSet[0].value), Object.assign(Object.assign({}, c), { tags: Ti(c.tags), tagValue: A });
      }) });
    });
  }
  /**
   * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.
   *
   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                         The given expression must evaluate to true for a blob to be returned in the results.
   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param marker - A string value that identifies the portion of
   *                          the list of blobs to be returned with the next listing operation. The
   *                          operation returns the continuationToken value within the response body if the
   *                          listing operation did not return all blobs remaining to be listed
   *                          with the current page. The continuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of list
   *                          items. The marker value is opaque to the client.
   * @param options - Options to find blobs by tags.
   */
  findBlobsByTagsSegments(e, r) {
    return Ir(this, arguments, function* (s, i, o = {}) {
      let c;
      if (i || i === void 0)
        do
          c = yield qe(this.findBlobsByTagsSegment(s, i, o)), c.blobs = c.blobs || [], i = c.continuationToken, yield yield qe(c);
        while (i);
    });
  }
  /**
   * Returns an AsyncIterableIterator for blobs.
   *
   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                         The given expression must evaluate to true for a blob to be returned in the results.
   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param options - Options to findBlobsByTagsItems.
   */
  findBlobsByTagsItems(e) {
    return Ir(this, arguments, function* (n, s = {}) {
      var i, o, c, l;
      let A;
      try {
        for (var a = !0, u = Ur(this.findBlobsByTagsSegments(n, A, s)), g; g = yield qe(u.next()), i = g.done, !i; a = !0)
          l = g.value, a = !1, yield qe(yield* Rs(Ur(l.blobs)));
      } catch (h) {
        o = { error: h };
      } finally {
        try {
          !a && !i && (c = u.return) && (yield qe(c.call(u)));
        } finally {
          if (o) throw o.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to find all blobs with specified tag
   * under the specified container.
   *
   * .byPage() returns an async iterable iterator to list the blobs in pages.
   *
   * Example using `for await` syntax:
   *
   * ```js
   * let i = 1;
   * for await (const blob of containerClient.findBlobsByTags("tagkey='tagvalue'")) {
   *   console.log(`Blob ${i++}: ${blob.name}`);
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let i = 1;
   * const iter = containerClient.findBlobsByTags("tagkey='tagvalue'");
   * let blobItem = await iter.next();
   * while (!blobItem.done) {
   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);
   *   blobItem = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * // passing optional maxPageSize in the page settings
   * let i = 1;
   * for await (const response of containerClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 20 })) {
   *   if (response.blobs) {
   *     for (const blob of response.blobs) {
   *       console.log(`Blob ${i++}: ${blob.name}`);
   *     }
   *   }
   * }
   * ```
   *
   * Example using paging with a marker:
   *
   * ```js
   * let i = 1;
   * let iterator = containerClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   *
   * // Prints 2 blob names
   * if (response.blobs) {
   *   for (const blob of response.blobs) {
   *     console.log(`Blob ${i++}: ${blob.name}`);
   *   }
   * }
   *
   * // Gets next marker
   * let marker = response.continuationToken;
   * // Passing next marker as continuationToken
   * iterator = containerClient
   *   .findBlobsByTags("tagkey='tagvalue'")
   *   .byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   *
   * // Prints blob names
   * if (response.blobs) {
   *   for (const blob of response.blobs) {
   *      console.log(`Blob ${i++}: ${blob.name}`);
   *   }
   * }
   * ```
   *
   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                         The given expression must evaluate to true for a blob to be returned in the results.
   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param options - Options to find blobs by tags.
   */
  findBlobsByTags(e, r = {}) {
    const n = Object.assign({}, r), s = this.findBlobsByTagsItems(e, n);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return s.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (i = {}) => this.findBlobsByTagsSegments(e, i.continuationToken, Object.assign({ maxPageSize: i.maxPageSize }, n))
    };
  }
  /**
   * The Get Account Information operation returns the sku name and account kind
   * for the specified account.
   * The Get Account Information operation is available on service versions beginning
   * with version 2018-03-28.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-account-information
   *
   * @param options - Options to the Service Get Account Info operation.
   * @returns Response data for the Service Get Account Info operation.
   */
  async getAccountInfo(e = {}) {
    return pe.withSpan("ContainerClient-getAccountInfo", e, async (r) => be(await this.containerContext.getAccountInfo({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
  getContainerNameFromUrl() {
    let e;
    try {
      const r = new URL(this.url);
      if (r.hostname.split(".")[1] === "blob" ? e = r.pathname.split("/")[1] : qu(r) ? e = r.pathname.split("/")[2] : e = r.pathname.split("/")[1], e = decodeURIComponent(e), !e)
        throw new Error("Provided containerName is invalid.");
      return e;
    } catch {
      throw new Error("Unable to extract containerName with provided information.");
    }
  }
  /**
   * Only available for ContainerClient constructed with a shared key credential.
   *
   * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
   * and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateSasUrl(e) {
    return new Promise((r) => {
      if (!(this.credential instanceof wt))
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      const n = $o(Object.assign({ containerName: this._containerName }, e), this.credential).toString();
      r(Mi(this.url, n));
    });
  }
  /**
   * Only available for ContainerClient constructed with a shared key credential.
   *
   * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
   * based on the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
  generateSasStringToSign(e) {
    if (!(this.credential instanceof wt))
      throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
    return qi(Object.assign({ containerName: this._containerName }, e), this.credential).stringToSign;
  }
  /**
   * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
   * and parameters passed in. The SAS is signed by the input user delegation key.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateUserDelegationSasUrl(e, r) {
    return new Promise((n) => {
      const s = $o(Object.assign({ containerName: this._containerName }, e), r, this.accountName).toString();
      n(Mi(this.url, s));
    });
  }
  /**
   * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
   * based on the client properties and parameters passed in. The SAS is signed by the input user delegation key.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
   *
   * @param options - Optional parameters.
   * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateUserDelegationSasStringToSign(e, r) {
    return qi(Object.assign({ containerName: this._containerName }, e), r, this.accountName).stringToSign;
  }
  /**
   * Creates a BlobBatchClient object to conduct batch operations.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/blob-batch
   *
   * @returns A new BlobBatchClient object for this container.
   */
  getBlobBatchClient() {
    return new Ad(this.url, this.pipeline);
  }
}
class xs {
  constructor() {
    this.read = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.add = !1, this.create = !1, this.update = !1, this.process = !1, this.tag = !1, this.filter = !1, this.setImmutabilityPolicy = !1, this.permanentDelete = !1;
  }
  /**
   * Parse initializes the AccountSASPermissions fields from a string.
   *
   * @param permissions -
   */
  static parse(e) {
    const r = new xs();
    for (const n of e)
      switch (n) {
        case "r":
          r.read = !0;
          break;
        case "w":
          r.write = !0;
          break;
        case "d":
          r.delete = !0;
          break;
        case "x":
          r.deleteVersion = !0;
          break;
        case "l":
          r.list = !0;
          break;
        case "a":
          r.add = !0;
          break;
        case "c":
          r.create = !0;
          break;
        case "u":
          r.update = !0;
          break;
        case "p":
          r.process = !0;
          break;
        case "t":
          r.tag = !0;
          break;
        case "f":
          r.filter = !0;
          break;
        case "i":
          r.setImmutabilityPolicy = !0;
          break;
        case "y":
          r.permanentDelete = !0;
          break;
        default:
          throw new RangeError(`Invalid permission character: ${n}`);
      }
    return r;
  }
  /**
   * Creates a {@link AccountSASPermissions} from a raw object which contains same keys as it
   * and boolean values for them.
   *
   * @param permissionLike -
   */
  static from(e) {
    const r = new xs();
    return e.read && (r.read = !0), e.write && (r.write = !0), e.delete && (r.delete = !0), e.deleteVersion && (r.deleteVersion = !0), e.filter && (r.filter = !0), e.tag && (r.tag = !0), e.list && (r.list = !0), e.add && (r.add = !0), e.create && (r.create = !0), e.update && (r.update = !0), e.process && (r.process = !0), e.setImmutabilityPolicy && (r.setImmutabilityPolicy = !0), e.permanentDelete && (r.permanentDelete = !0), r;
  }
  /**
   * Produces the SAS permissions string for an Azure Storage account.
   * Call this method to set AccountSASSignatureValues Permissions field.
   *
   * Using this method will guarantee the resource types are in
   * an order accepted by the service.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
   *
   */
  toString() {
    const e = [];
    return this.read && e.push("r"), this.write && e.push("w"), this.delete && e.push("d"), this.deleteVersion && e.push("x"), this.filter && e.push("f"), this.tag && e.push("t"), this.list && e.push("l"), this.add && e.push("a"), this.create && e.push("c"), this.update && e.push("u"), this.process && e.push("p"), this.setImmutabilityPolicy && e.push("i"), this.permanentDelete && e.push("y"), e.join("");
  }
}
class cd {
  constructor() {
    this.service = !1, this.container = !1, this.object = !1;
  }
  /**
   * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
   * Error if it encounters a character that does not correspond to a valid resource type.
   *
   * @param resourceTypes -
   */
  static parse(e) {
    const r = new cd();
    for (const n of e)
      switch (n) {
        case "s":
          r.service = !0;
          break;
        case "c":
          r.container = !0;
          break;
        case "o":
          r.object = !0;
          break;
        default:
          throw new RangeError(`Invalid resource type: ${n}`);
      }
    return r;
  }
  /**
   * Converts the given resource types to a string.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
   *
   */
  toString() {
    const e = [];
    return this.service && e.push("s"), this.container && e.push("c"), this.object && e.push("o"), e.join("");
  }
}
class Hi {
  constructor() {
    this.blob = !1, this.file = !1, this.queue = !1, this.table = !1;
  }
  /**
   * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
   * Error if it encounters a character that does not correspond to a valid service.
   *
   * @param services -
   */
  static parse(e) {
    const r = new Hi();
    for (const n of e)
      switch (n) {
        case "b":
          r.blob = !0;
          break;
        case "f":
          r.file = !0;
          break;
        case "q":
          r.queue = !0;
          break;
        case "t":
          r.table = !0;
          break;
        default:
          throw new RangeError(`Invalid service character: ${n}`);
      }
    return r;
  }
  /**
   * Converts the given services to a string.
   *
   */
  toString() {
    const e = [];
    return this.blob && e.push("b"), this.table && e.push("t"), this.queue && e.push("q"), this.file && e.push("f"), e.join("");
  }
}
function ik(t, e) {
  return Oy(t, e).sasQueryParameters;
}
function Oy(t, e) {
  const r = t.version ? t.version : Ou;
  if (t.permissions && t.permissions.setImmutabilityPolicy && r < "2020-08-04")
    throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
  if (t.permissions && t.permissions.deleteVersion && r < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
  if (t.permissions && t.permissions.permanentDelete && r < "2019-10-10")
    throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
  if (t.permissions && t.permissions.tag && r < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
  if (t.permissions && t.permissions.filter && r < "2019-12-12")
    throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
  if (t.encryptionScope && r < "2020-12-06")
    throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
  const n = xs.parse(t.permissions.toString()), s = Hi.parse(t.services).toString(), i = cd.parse(t.resourceTypes).toString();
  let o;
  r >= "2020-12-06" ? o = [
    e.accountName,
    n,
    s,
    i,
    t.startsOn ? ot(t.startsOn, !1) : "",
    ot(t.expiresOn, !1),
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    r,
    t.encryptionScope ? t.encryptionScope : "",
    ""
    // Account SAS requires an additional newline character
  ].join(`
`) : o = [
    e.accountName,
    n,
    s,
    i,
    t.startsOn ? ot(t.startsOn, !1) : "",
    ot(t.expiresOn, !1),
    t.ipRange ? In(t.ipRange) : "",
    t.protocol ? t.protocol : "",
    r,
    ""
    // Account SAS requires an additional newline character
  ].join(`
`);
  const c = e.computeHMACSHA256(o);
  return {
    sasQueryParameters: new cs(r, c, n.toString(), s, i, t.protocol, t.startsOn, t.expiresOn, t.ipRange, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, t.encryptionScope),
    stringToSign: o
  };
}
class Ko extends sd {
  /**
   *
   * Creates an instance of BlobServiceClient from connection string.
   *
   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
   *                                  Account connection string example -
   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
   *                                  SAS connection string example -
   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
   * @param options - Optional. Options to configure the HTTP pipeline.
   */
  static fromConnectionString(e, r) {
    r = r || {};
    const n = Ms(e);
    if (n.kind === "AccountConnString")
      if (Mt) {
        const s = new wt(n.accountName, n.accountKey);
        r.proxyOptions || (r.proxyOptions = Us(n.proxyUri));
        const i = ht(s, r);
        return new Ko(n.url, i);
      } else
        throw new Error("Account connection string is only supported in Node.js environment");
    else if (n.kind === "SASConnString") {
      const s = ht(new Qt(), r);
      return new Ko(n.url + "?" + n.accountSas, s);
    } else
      throw new Error("Connection string must be either an Account connection string or a SAS connection string");
  }
  constructor(e, r, n) {
    let s;
    Fn(r) ? s = r : Mt && r instanceof wt || r instanceof Qt || Or(r) ? s = ht(r, n) : s = ht(new Qt(), n), super(e, s), this.serviceContext = this.storageClientContext.service;
  }
  /**
   * Creates a {@link ContainerClient} object
   *
   * @param containerName - A container name
   * @returns A new ContainerClient object for the given container name.
   *
   * Example usage:
   *
   * ```js
   * const containerClient = blobServiceClient.getContainerClient("<container name>");
   * ```
   */
  getContainerClient(e) {
    return new My(kt(this.url, encodeURIComponent(e)), this.pipeline);
  }
  /**
   * Create a Blob container. @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-container
   *
   * @param containerName - Name of the container to create.
   * @param options - Options to configure Container Create operation.
   * @returns Container creation response and the corresponding container client.
   */
  async createContainer(e, r = {}) {
    return pe.withSpan("BlobServiceClient-createContainer", r, async (n) => {
      const s = this.getContainerClient(e), i = await s.create(n);
      return {
        containerClient: s,
        containerCreateResponse: i
      };
    });
  }
  /**
   * Deletes a Blob container.
   *
   * @param containerName - Name of the container to delete.
   * @param options - Options to configure Container Delete operation.
   * @returns Container deletion response.
   */
  async deleteContainer(e, r = {}) {
    return pe.withSpan("BlobServiceClient-deleteContainer", r, async (n) => this.getContainerClient(e).delete(n));
  }
  /**
   * Restore a previously deleted Blob container.
   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.
   *
   * @param deletedContainerName - Name of the previously deleted container.
   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.
   * @param options - Options to configure Container Restore operation.
   * @returns Container deletion response.
   */
  async undeleteContainer(e, r, n = {}) {
    return pe.withSpan("BlobServiceClient-undeleteContainer", n, async (s) => {
      const i = this.getContainerClient(n.destinationContainerName || e), o = i.storageClientContext.container, c = be(await o.restore({
        deletedContainerName: e,
        deletedContainerVersion: r,
        tracingOptions: s.tracingOptions
      }));
      return { containerClient: i, containerUndeleteResponse: c };
    });
  }
  /**
   * Rename an existing Blob Container.
   *
   * @param sourceContainerName - The name of the source container.
   * @param destinationContainerName - The new name of the container.
   * @param options - Options to configure Container Rename operation.
   */
  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */
  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.
  async renameContainer(e, r, n = {}) {
    return pe.withSpan("BlobServiceClient-renameContainer", n, async (s) => {
      var i;
      const o = this.getContainerClient(r), c = o.storageClientContext.container, l = be(await c.rename(e, Object.assign(Object.assign({}, s), { sourceLeaseId: (i = n.sourceCondition) === null || i === void 0 ? void 0 : i.leaseId })));
      return { containerClient: o, containerRenameResponse: l };
    });
  }
  /**
   * Gets the properties of a storage accounts Blob service, including properties
   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties
   *
   * @param options - Options to the Service Get Properties operation.
   * @returns Response data for the Service Get Properties operation.
   */
  async getProperties(e = {}) {
    return pe.withSpan("BlobServiceClient-getProperties", e, async (r) => be(await this.serviceContext.getProperties({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Sets properties for a storage accounts Blob service endpoint, including properties
   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties
   *
   * @param properties -
   * @param options - Options to the Service Set Properties operation.
   * @returns Response data for the Service Set Properties operation.
   */
  async setProperties(e, r = {}) {
    return pe.withSpan("BlobServiceClient-setProperties", r, async (n) => be(await this.serviceContext.setProperties(e, {
      abortSignal: r.abortSignal,
      tracingOptions: n.tracingOptions
    })));
  }
  /**
   * Retrieves statistics related to replication for the Blob service. It is only
   * available on the secondary location endpoint when read-access geo-redundant
   * replication is enabled for the storage account.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats
   *
   * @param options - Options to the Service Get Statistics operation.
   * @returns Response data for the Service Get Statistics operation.
   */
  async getStatistics(e = {}) {
    return pe.withSpan("BlobServiceClient-getStatistics", e, async (r) => be(await this.serviceContext.getStatistics({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * The Get Account Information operation returns the sku name and account kind
   * for the specified account.
   * The Get Account Information operation is available on service versions beginning
   * with version 2018-03-28.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-account-information
   *
   * @param options - Options to the Service Get Account Info operation.
   * @returns Response data for the Service Get Account Info operation.
   */
  async getAccountInfo(e = {}) {
    return pe.withSpan("BlobServiceClient-getAccountInfo", e, async (r) => be(await this.serviceContext.getAccountInfo({
      abortSignal: e.abortSignal,
      tracingOptions: r.tracingOptions
    })));
  }
  /**
   * Returns a list of the containers under the specified account.
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/list-containers2
   *
   * @param marker - A string value that identifies the portion of
   *                        the list of containers to be returned with the next listing operation. The
   *                        operation returns the continuationToken value within the response body if the
   *                        listing operation did not return all containers remaining to be listed
   *                        with the current page. The continuationToken value can be used as the value for
   *                        the marker parameter in a subsequent call to request the next page of list
   *                        items. The marker value is opaque to the client.
   * @param options - Options to the Service List Container Segment operation.
   * @returns Response data for the Service List Container Segment operation.
   */
  async listContainersSegment(e, r = {}) {
    return pe.withSpan("BlobServiceClient-listContainersSegment", r, async (n) => be(await this.serviceContext.listContainersSegment(Object.assign(Object.assign({ abortSignal: r.abortSignal, marker: e }, r), { include: typeof r.include == "string" ? [r.include] : r.include, tracingOptions: n.tracingOptions }))));
  }
  /**
   * The Filter Blobs operation enables callers to list blobs across all containers whose tags
   * match a given search expression. Filter blobs searches across all containers within a
   * storage account but can be scoped within the expression to a single container.
   *
   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                        The given expression must evaluate to true for a blob to be returned in the results.
   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param marker - A string value that identifies the portion of
   *                          the list of blobs to be returned with the next listing operation. The
   *                          operation returns the continuationToken value within the response body if the
   *                          listing operation did not return all blobs remaining to be listed
   *                          with the current page. The continuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of list
   *                          items. The marker value is opaque to the client.
   * @param options - Options to find blobs by tags.
   */
  async findBlobsByTagsSegment(e, r, n = {}) {
    return pe.withSpan("BlobServiceClient-findBlobsByTagsSegment", n, async (s) => {
      const i = be(await this.serviceContext.filterBlobs({
        abortSignal: n.abortSignal,
        where: e,
        marker: r,
        maxPageSize: n.maxPageSize,
        tracingOptions: s.tracingOptions
      }));
      return Object.assign(Object.assign({}, i), { _response: i._response, blobs: i.blobs.map((c) => {
        var l;
        let A = "";
        return ((l = c.tags) === null || l === void 0 ? void 0 : l.blobTagSet.length) === 1 && (A = c.tags.blobTagSet[0].value), Object.assign(Object.assign({}, c), { tags: Ti(c.tags), tagValue: A });
      }) });
    });
  }
  /**
   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.
   *
   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                         The given expression must evaluate to true for a blob to be returned in the results.
   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param marker - A string value that identifies the portion of
   *                          the list of blobs to be returned with the next listing operation. The
   *                          operation returns the continuationToken value within the response body if the
   *                          listing operation did not return all blobs remaining to be listed
   *                          with the current page. The continuationToken value can be used as the value for
   *                          the marker parameter in a subsequent call to request the next page of list
   *                          items. The marker value is opaque to the client.
   * @param options - Options to find blobs by tags.
   */
  findBlobsByTagsSegments(e, r) {
    return Ir(this, arguments, function* (s, i, o = {}) {
      let c;
      if (i || i === void 0)
        do
          c = yield qe(this.findBlobsByTagsSegment(s, i, o)), c.blobs = c.blobs || [], i = c.continuationToken, yield yield qe(c);
        while (i);
    });
  }
  /**
   * Returns an AsyncIterableIterator for blobs.
   *
   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                         The given expression must evaluate to true for a blob to be returned in the results.
   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param options - Options to findBlobsByTagsItems.
   */
  findBlobsByTagsItems(e) {
    return Ir(this, arguments, function* (n, s = {}) {
      var i, o, c, l;
      let A;
      try {
        for (var a = !0, u = Ur(this.findBlobsByTagsSegments(n, A, s)), g; g = yield qe(u.next()), i = g.done, !i; a = !0)
          l = g.value, a = !1, yield qe(yield* Rs(Ur(l.blobs)));
      } catch (h) {
        o = { error: h };
      } finally {
        try {
          !a && !i && (c = u.return) && (yield qe(c.call(u)));
        } finally {
          if (o) throw o.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to find all blobs with specified tag
   * under the specified account.
   *
   * .byPage() returns an async iterable iterator to list the blobs in pages.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties
   *
   * Example using `for await` syntax:
   *
   * ```js
   * let i = 1;
   * for await (const blob of blobServiceClient.findBlobsByTags("tagkey='tagvalue'")) {
   *   console.log(`Blob ${i++}: ${container.name}`);
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let i = 1;
   * const iter = blobServiceClient.findBlobsByTags("tagkey='tagvalue'");
   * let blobItem = await iter.next();
   * while (!blobItem.done) {
   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);
   *   blobItem = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * // passing optional maxPageSize in the page settings
   * let i = 1;
   * for await (const response of blobServiceClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 20 })) {
   *   if (response.blobs) {
   *     for (const blob of response.blobs) {
   *       console.log(`Blob ${i++}: ${blob.name}`);
   *     }
   *   }
   * }
   * ```
   *
   * Example using paging with a marker:
   *
   * ```js
   * let i = 1;
   * let iterator = blobServiceClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   *
   * // Prints 2 blob names
   * if (response.blobs) {
   *   for (const blob of response.blobs) {
   *     console.log(`Blob ${i++}: ${blob.name}`);
   *   }
   * }
   *
   * // Gets next marker
   * let marker = response.continuationToken;
   * // Passing next marker as continuationToken
   * iterator = blobServiceClient
   *   .findBlobsByTags("tagkey='tagvalue'")
   *   .byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   *
   * // Prints blob names
   * if (response.blobs) {
   *   for (const blob of response.blobs) {
   *      console.log(`Blob ${i++}: ${blob.name}`);
   *   }
   * }
   * ```
   *
   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
   *                                         The given expression must evaluate to true for a blob to be returned in the results.
   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
   * @param options - Options to find blobs by tags.
   */
  findBlobsByTags(e, r = {}) {
    const n = Object.assign({}, r), s = this.findBlobsByTagsItems(e, n);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return s.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (i = {}) => this.findBlobsByTagsSegments(e, i.continuationToken, Object.assign({ maxPageSize: i.maxPageSize }, n))
    };
  }
  /**
   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses
   *
   * @param marker - A string value that identifies the portion of
   *                        the list of containers to be returned with the next listing operation. The
   *                        operation returns the continuationToken value within the response body if the
   *                        listing operation did not return all containers remaining to be listed
   *                        with the current page. The continuationToken value can be used as the value for
   *                        the marker parameter in a subsequent call to request the next page of list
   *                        items. The marker value is opaque to the client.
   * @param options - Options to list containers operation.
   */
  listSegments(e) {
    return Ir(this, arguments, function* (n, s = {}) {
      let i;
      if (n || n === void 0)
        do
          i = yield qe(this.listContainersSegment(n, s)), i.containerItems = i.containerItems || [], n = i.continuationToken, yield yield qe(yield qe(i));
        while (n);
    });
  }
  /**
   * Returns an AsyncIterableIterator for Container Items
   *
   * @param options - Options to list containers operation.
   */
  listItems() {
    return Ir(this, arguments, function* (r = {}) {
      var n, s, i, o;
      let c;
      try {
        for (var l = !0, A = Ur(this.listSegments(c, r)), a; a = yield qe(A.next()), n = a.done, !n; l = !0)
          o = a.value, l = !1, yield qe(yield* Rs(Ur(o.containerItems)));
      } catch (u) {
        s = { error: u };
      } finally {
        try {
          !l && !n && (i = A.return) && (yield qe(i.call(A)));
        } finally {
          if (s) throw s.error;
        }
      }
    });
  }
  /**
   * Returns an async iterable iterator to list all the containers
   * under the specified account.
   *
   * .byPage() returns an async iterable iterator to list the containers in pages.
   *
   * Example using `for await` syntax:
   *
   * ```js
   * let i = 1;
   * for await (const container of blobServiceClient.listContainers()) {
   *   console.log(`Container ${i++}: ${container.name}`);
   * }
   * ```
   *
   * Example using `iter.next()`:
   *
   * ```js
   * let i = 1;
   * const iter = blobServiceClient.listContainers();
   * let containerItem = await iter.next();
   * while (!containerItem.done) {
   *   console.log(`Container ${i++}: ${containerItem.value.name}`);
   *   containerItem = await iter.next();
   * }
   * ```
   *
   * Example using `byPage()`:
   *
   * ```js
   * // passing optional maxPageSize in the page settings
   * let i = 1;
   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {
   *   if (response.containerItems) {
   *     for (const container of response.containerItems) {
   *       console.log(`Container ${i++}: ${container.name}`);
   *     }
   *   }
   * }
   * ```
   *
   * Example using paging with a marker:
   *
   * ```js
   * let i = 1;
   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });
   * let response = (await iterator.next()).value;
   *
   * // Prints 2 container names
   * if (response.containerItems) {
   *   for (const container of response.containerItems) {
   *     console.log(`Container ${i++}: ${container.name}`);
   *   }
   * }
   *
   * // Gets next marker
   * let marker = response.continuationToken;
   * // Passing next marker as continuationToken
   * iterator = blobServiceClient
   *   .listContainers()
   *   .byPage({ continuationToken: marker, maxPageSize: 10 });
   * response = (await iterator.next()).value;
   *
   * // Prints 10 container names
   * if (response.containerItems) {
   *   for (const container of response.containerItems) {
   *      console.log(`Container ${i++}: ${container.name}`);
   *   }
   * }
   * ```
   *
   * @param options - Options to list containers.
   * @returns An asyncIterableIterator that supports paging.
   */
  listContainers(e = {}) {
    e.prefix === "" && (e.prefix = void 0);
    const r = [];
    e.includeDeleted && r.push("deleted"), e.includeMetadata && r.push("metadata"), e.includeSystem && r.push("system");
    const n = Object.assign(Object.assign({}, e), r.length > 0 ? { include: r } : {}), s = this.listItems(n);
    return {
      /**
       * The next method, part of the iteration protocol
       */
      next() {
        return s.next();
      },
      /**
       * The connection to the async iterator, part of the iteration protocol
       */
      [Symbol.asyncIterator]() {
        return this;
      },
      /**
       * Return an AsyncIterableIterator that works a page at a time
       */
      byPage: (i = {}) => this.listSegments(i.continuationToken, Object.assign({ maxPageSize: i.maxPageSize }, n))
    };
  }
  /**
   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).
   *
   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
   * bearer token authentication.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key
   *
   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time
   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time
   */
  async getUserDelegationKey(e, r, n = {}) {
    return pe.withSpan("BlobServiceClient-getUserDelegationKey", n, async (s) => {
      const i = be(await this.serviceContext.getUserDelegationKey({
        startsOn: ot(e, !1),
        expiresOn: ot(r, !1)
      }, {
        abortSignal: n.abortSignal,
        tracingOptions: s.tracingOptions
      })), o = {
        signedObjectId: i.signedObjectId,
        signedTenantId: i.signedTenantId,
        signedStartsOn: new Date(i.signedStartsOn),
        signedExpiresOn: new Date(i.signedExpiresOn),
        signedService: i.signedService,
        signedVersion: i.signedVersion,
        value: i.value
      };
      return Object.assign({ _response: i._response, requestId: i.requestId, clientRequestId: i.clientRequestId, version: i.version, date: i.date, errorCode: i.errorCode }, o);
    });
  }
  /**
   * Creates a BlobBatchClient object to conduct batch operations.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/blob-batch
   *
   * @returns A new BlobBatchClient object for this service.
   */
  getBlobBatchClient() {
    return new Ad(this.url, this.pipeline);
  }
  /**
   * Only available for BlobServiceClient constructed with a shared key credential.
   *
   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties
   * and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-account-sas
   *
   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
   * @param permissions - Specifies the list of permissions to be associated with the SAS.
   * @param resourceTypes - Specifies the resource types associated with the shared access signature.
   * @param options - Optional parameters.
   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateAccountSasUrl(e, r = xs.parse("r"), n = "sco", s = {}) {
    if (!(this.credential instanceof wt))
      throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
    if (e === void 0) {
      const o = /* @__PURE__ */ new Date();
      e = new Date(o.getTime() + 3600 * 1e3);
    }
    const i = ik(Object.assign({
      permissions: r,
      expiresOn: e,
      resourceTypes: n,
      services: Hi.parse("b").toString()
    }, s), this.credential).toString();
    return Mi(this.url, i);
  }
  /**
   * Only available for BlobServiceClient constructed with a shared key credential.
   *
   * Generates string to sign for a Blob account Shared Access Signature (SAS) URI based on
   * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
   *
   * @see https://learn.microsoft.com/en-us/rest/api/storageservices/create-account-sas
   *
   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
   * @param permissions - Specifies the list of permissions to be associated with the SAS.
   * @param resourceTypes - Specifies the resource types associated with the shared access signature.
   * @param options - Optional parameters.
   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
   */
  generateSasStringToSign(e, r = xs.parse("r"), n = "sco", s = {}) {
    if (!(this.credential instanceof wt))
      throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
    if (e === void 0) {
      const i = /* @__PURE__ */ new Date();
      e = new Date(i.getTime() + 3600 * 1e3);
    }
    return Oy(Object.assign({
      permissions: r,
      expiresOn: e,
      resourceTypes: n,
      services: Hi.parse("b").toString()
    }, s), this.credential).stringToSign;
  }
}
var Zl;
(function(t) {
  t.AES256 = "AES256";
})(Zl || (Zl = {}));
const ok = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnonymousCredential: Qt,
  AnonymousCredentialPolicy: dC,
  AppendBlobClient: co,
  BaseRequestPolicy: ma,
  BlobBatch: _o,
  BlobBatchClient: Ad,
  BlobClient: Mr,
  BlobLeaseClient: id,
  BlobServiceClient: Ko,
  BlockBlobClient: lo,
  get BlockBlobTier() {
    return Xl;
  },
  ContainerClient: My,
  Credential: gC,
  CredentialPolicy: uC,
  get KnownEncryptionAlgorithmType() {
    return Zl;
  },
  PageBlobClient: uo,
  Pipeline: Hu,
  get PremiumPageBlobTier() {
    return Kl;
  },
  RestError: Ns,
  StorageBrowserPolicy: hC,
  StorageBrowserPolicyFactory: pC,
  StorageOAuthScopes: Gu,
  StorageRetryPolicy: cC,
  StorageRetryPolicyFactory: lC,
  get StorageRetryPolicyType() {
    return vs;
  },
  isPipelineLike: Fn,
  logger: qt,
  newPipeline: ht
}, Symbol.toStringTag, { value: "Module" })), Gy = /* @__PURE__ */ rs(ok);
var hr = {}, Zh;
function qy() {
  if (Zh) return hr;
  Zh = 1, Object.defineProperty(hr, "__esModule", { value: !0 }), hr.UsageError = hr.NetworkError = hr.GHESNotSupportedError = hr.CacheNotFoundError = hr.InvalidResponseError = hr.FilesNotFoundError = void 0;
  class t extends Error {
    constructor(c = []) {
      let l = "No files were found to upload";
      c.length > 0 && (l += `: ${c.join(", ")}`), super(l), this.files = c, this.name = "FilesNotFoundError";
    }
  }
  hr.FilesNotFoundError = t;
  class e extends Error {
    constructor(c) {
      super(c), this.name = "InvalidResponseError";
    }
  }
  hr.InvalidResponseError = e;
  class r extends Error {
    constructor(c = "Cache not found") {
      super(c), this.name = "CacheNotFoundError";
    }
  }
  hr.CacheNotFoundError = r;
  class n extends Error {
    constructor(c = "@actions/cache v4.1.4+, actions/cache/save@v4+ and actions/cache/restore@v4+ are not currently supported on GHES.") {
      super(c), this.name = "GHESNotSupportedError";
    }
  }
  hr.GHESNotSupportedError = n;
  class s extends Error {
    constructor(c) {
      const l = `Unable to make request: ${c}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
      super(l), this.code = c, this.name = "NetworkError";
    }
  }
  hr.NetworkError = s, s.isNetworkErrorCode = (o) => o ? [
    "ECONNRESET",
    "ENOTFOUND",
    "ETIMEDOUT",
    "ECONNREFUSED",
    "EHOSTUNREACH"
  ].includes(o) : !1;
  class i extends Error {
    constructor() {
      super(`Cache storage quota has been hit. Unable to upload any new cache entries. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`), this.name = "UsageError";
    }
  }
  return hr.UsageError = i, i.isUsageErrorMessage = (o) => o ? o.includes("insufficient usage") : !1, hr;
}
var ep;
function ak() {
  if (ep) return mr;
  ep = 1;
  var t = mr && mr.__createBinding || (Object.create ? function(A, a, u, g) {
    g === void 0 && (g = u);
    var h = Object.getOwnPropertyDescriptor(a, u);
    (!h || ("get" in h ? !a.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return a[u];
    } }), Object.defineProperty(A, g, h);
  } : function(A, a, u, g) {
    g === void 0 && (g = u), A[g] = a[u];
  }), e = mr && mr.__setModuleDefault || (Object.create ? function(A, a) {
    Object.defineProperty(A, "default", { enumerable: !0, value: a });
  } : function(A, a) {
    A.default = a;
  }), r = mr && mr.__importStar || function(A) {
    if (A && A.__esModule) return A;
    var a = {};
    if (A != null) for (var u in A) u !== "default" && Object.prototype.hasOwnProperty.call(A, u) && t(a, A, u);
    return e(a, A), a;
  }, n = mr && mr.__awaiter || function(A, a, u, g) {
    function h(m) {
      return m instanceof u ? m : new u(function(d) {
        d(m);
      });
    }
    return new (u || (u = Promise))(function(m, d) {
      function p(y) {
        try {
          B(g.next(y));
        } catch (Q) {
          d(Q);
        }
      }
      function E(y) {
        try {
          B(g.throw(y));
        } catch (Q) {
          d(Q);
        }
      }
      function B(y) {
        y.done ? m(y.value) : h(y.value).then(p, E);
      }
      B((g = g.apply(A, a || [])).next());
    });
  };
  Object.defineProperty(mr, "__esModule", { value: !0 }), mr.uploadCacheArchiveSDK = mr.UploadProgress = void 0;
  const s = r(ir()), i = Gy, o = qy();
  class c {
    constructor(a) {
      this.contentLength = a, this.sentBytes = 0, this.displayedComplete = !1, this.startTime = Date.now();
    }
    /**
     * Sets the number of bytes sent
     *
     * @param sentBytes the number of bytes sent
     */
    setSentBytes(a) {
      this.sentBytes = a;
    }
    /**
     * Returns the total number of bytes transferred.
     */
    getTransferredBytes() {
      return this.sentBytes;
    }
    /**
     * Returns true if the upload is complete.
     */
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    /**
     * Prints the current upload stats. Once the upload completes, this will print one
     * last line and then stop.
     */
    display() {
      if (this.displayedComplete)
        return;
      const a = this.sentBytes, u = (100 * (a / this.contentLength)).toFixed(1), g = Date.now() - this.startTime, h = (a / (1024 * 1024) / (g / 1e3)).toFixed(1);
      s.info(`Sent ${a} of ${this.contentLength} (${u}%), ${h} MBs/sec`), this.isDone() && (this.displayedComplete = !0);
    }
    /**
     * Returns a function used to handle TransferProgressEvents.
     */
    onProgress() {
      return (a) => {
        this.setSentBytes(a.loadedBytes);
      };
    }
    /**
     * Starts the timer that displays the stats.
     *
     * @param delayInMs the delay between each write
     */
    startDisplayTimer(a = 1e3) {
      const u = () => {
        this.display(), this.isDone() || (this.timeoutHandle = setTimeout(u, a));
      };
      this.timeoutHandle = setTimeout(u, a);
    }
    /**
     * Stops the timer that displays the stats. As this typically indicates the upload
     * is complete, this will display one last line, unless the last line has already
     * been written.
     */
    stopDisplayTimer() {
      this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = void 0), this.display();
    }
  }
  mr.UploadProgress = c;
  function l(A, a, u) {
    var g;
    return n(this, void 0, void 0, function* () {
      const h = new i.BlobClient(A), m = h.getBlockBlobClient(), d = new c((g = u?.archiveSizeBytes) !== null && g !== void 0 ? g : 0), p = {
        blockSize: u?.uploadChunkSize,
        concurrency: u?.uploadConcurrency,
        maxSingleShotSize: 128 * 1024 * 1024,
        onProgress: d.onProgress()
      };
      try {
        d.startDisplayTimer(), s.debug(`BlobClient: ${h.name}:${h.accountName}:${h.containerName}`);
        const E = yield m.uploadFile(a, p);
        if (E._response.status >= 400)
          throw new o.InvalidResponseError(`uploadCacheArchiveSDK: upload failed with status code ${E._response.status}`);
        return E;
      } catch (E) {
        throw s.warning(`uploadCacheArchiveSDK: internal error uploading cache archive: ${E.message}`), E;
      } finally {
        d.stopDisplayTimer();
      }
    });
  }
  return mr.uploadCacheArchiveSDK = l, mr;
}
var Yt = {}, Tt = {}, tp;
function Hy() {
  if (tp) return Tt;
  tp = 1;
  var t = Tt && Tt.__createBinding || (Object.create ? function(m, d, p, E) {
    E === void 0 && (E = p);
    var B = Object.getOwnPropertyDescriptor(d, p);
    (!B || ("get" in B ? !d.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return d[p];
    } }), Object.defineProperty(m, E, B);
  } : function(m, d, p, E) {
    E === void 0 && (E = p), m[E] = d[p];
  }), e = Tt && Tt.__setModuleDefault || (Object.create ? function(m, d) {
    Object.defineProperty(m, "default", { enumerable: !0, value: d });
  } : function(m, d) {
    m.default = d;
  }), r = Tt && Tt.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var d = {};
    if (m != null) for (var p in m) p !== "default" && Object.prototype.hasOwnProperty.call(m, p) && t(d, m, p);
    return e(d, m), d;
  }, n = Tt && Tt.__awaiter || function(m, d, p, E) {
    function B(y) {
      return y instanceof p ? y : new p(function(Q) {
        Q(y);
      });
    }
    return new (p || (p = Promise))(function(y, Q) {
      function I(C) {
        try {
          f(E.next(C));
        } catch (b) {
          Q(b);
        }
      }
      function w(C) {
        try {
          f(E.throw(C));
        } catch (b) {
          Q(b);
        }
      }
      function f(C) {
        C.done ? y(C.value) : B(C.value).then(I, w);
      }
      f((E = E.apply(m, d || [])).next());
    });
  };
  Object.defineProperty(Tt, "__esModule", { value: !0 }), Tt.retryHttpClientResponse = Tt.retryTypedResponse = Tt.retry = Tt.isRetryableStatusCode = Tt.isServerErrorStatusCode = Tt.isSuccessStatusCode = void 0;
  const s = r(ir()), i = kn(), o = no();
  function c(m) {
    return m ? m >= 200 && m < 300 : !1;
  }
  Tt.isSuccessStatusCode = c;
  function l(m) {
    return m ? m >= 500 : !0;
  }
  Tt.isServerErrorStatusCode = l;
  function A(m) {
    return m ? [
      i.HttpCodes.BadGateway,
      i.HttpCodes.ServiceUnavailable,
      i.HttpCodes.GatewayTimeout
    ].includes(m) : !1;
  }
  Tt.isRetryableStatusCode = A;
  function a(m) {
    return n(this, void 0, void 0, function* () {
      return new Promise((d) => setTimeout(d, m));
    });
  }
  function u(m, d, p, E = o.DefaultRetryAttempts, B = o.DefaultRetryDelay, y = void 0) {
    return n(this, void 0, void 0, function* () {
      let Q = "", I = 1;
      for (; I <= E; ) {
        let w, f, C = !1;
        try {
          w = yield d();
        } catch (b) {
          y && (w = y(b)), C = !0, Q = b.message;
        }
        if (w && (f = p(w), !l(f)))
          return w;
        if (f && (C = A(f), Q = `Cache service responded with ${f}`), s.debug(`${m} - Attempt ${I} of ${E} failed with error: ${Q}`), !C) {
          s.debug(`${m} - Error is not retryable`);
          break;
        }
        yield a(B), I++;
      }
      throw Error(`${m} failed: ${Q}`);
    });
  }
  Tt.retry = u;
  function g(m, d, p = o.DefaultRetryAttempts, E = o.DefaultRetryDelay) {
    return n(this, void 0, void 0, function* () {
      return yield u(
        m,
        d,
        (B) => B.statusCode,
        p,
        E,
        // If the error object contains the statusCode property, extract it and return
        // an TypedResponse<T> so it can be processed by the retry logic.
        (B) => {
          if (B instanceof i.HttpClientError)
            return {
              statusCode: B.statusCode,
              result: null,
              headers: {},
              error: B
            };
        }
      );
    });
  }
  Tt.retryTypedResponse = g;
  function h(m, d, p = o.DefaultRetryAttempts, E = o.DefaultRetryDelay) {
    return n(this, void 0, void 0, function* () {
      return yield u(m, d, (B) => B.message.statusCode, p, E);
    });
  }
  return Tt.retryHttpClientResponse = h, Tt;
}
const fs = /* @__PURE__ */ new WeakMap(), Mo = /* @__PURE__ */ new WeakMap();
let eu = class zy {
  constructor() {
    this.onabort = null, fs.set(this, []), Mo.set(this, !1);
  }
  /**
   * Status of whether aborted or not.
   *
   * @readonly
   */
  get aborted() {
    if (!Mo.has(this))
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    return Mo.get(this);
  }
  /**
   * Creates a new AbortSignal instance that will never be aborted.
   *
   * @readonly
   */
  static get none() {
    return new zy();
  }
  /**
   * Added new "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be added
   */
  addEventListener(e, r) {
    if (!fs.has(this))
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    fs.get(this).push(r);
  }
  /**
   * Remove "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be removed
   */
  removeEventListener(e, r) {
    if (!fs.has(this))
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    const n = fs.get(this), s = n.indexOf(r);
    s > -1 && n.splice(s, 1);
  }
  /**
   * Dispatches a synthetic event to the AbortSignal.
   */
  dispatchEvent(e) {
    throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
  }
};
function rp(t) {
  if (t.aborted)
    return;
  t.onabort && t.onabort.call(t);
  const e = fs.get(t);
  e && e.slice().forEach((r) => {
    r.call(t, { type: "abort" });
  }), Mo.set(t, !0);
}
class Ak extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
}
let ck = class {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(e) {
    if (this._signal = new eu(), !!e) {
      Array.isArray(e) || (e = arguments);
      for (const r of e)
        r.aborted ? this.abort() : r.addEventListener("abort", () => {
          this.abort();
        });
    }
  }
  /**
   * The AbortSignal associated with this controller that will signal aborted
   * when the abort method is called on this controller.
   *
   * @readonly
   */
  get signal() {
    return this._signal;
  }
  /**
   * Signal that any operations passed this controller's associated abort signal
   * to cancel any remaining work and throw an `AbortError`.
   */
  abort() {
    rp(this._signal);
  }
  /**
   * Creates a new AbortSignal instance that will abort after the provided ms.
   * @param ms - Elapsed time in milliseconds to trigger an abort.
   */
  static timeout(e) {
    const r = new eu(), n = setTimeout(rp, e, r);
    return typeof n.unref == "function" && n.unref(), r;
  }
};
const lk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortController: ck,
  AbortError: Ak,
  AbortSignal: eu
}, Symbol.toStringTag, { value: "Module" })), uk = /* @__PURE__ */ rs(lk);
var np;
function dk() {
  if (np) return Yt;
  np = 1;
  var t = Yt && Yt.__createBinding || (Object.create ? function(f, C, b, N) {
    N === void 0 && (N = b);
    var v = Object.getOwnPropertyDescriptor(C, b);
    (!v || ("get" in v ? !C.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return C[b];
    } }), Object.defineProperty(f, N, v);
  } : function(f, C, b, N) {
    N === void 0 && (N = b), f[N] = C[b];
  }), e = Yt && Yt.__setModuleDefault || (Object.create ? function(f, C) {
    Object.defineProperty(f, "default", { enumerable: !0, value: C });
  } : function(f, C) {
    f.default = C;
  }), r = Yt && Yt.__importStar || function(f) {
    if (f && f.__esModule) return f;
    var C = {};
    if (f != null) for (var b in f) b !== "default" && Object.prototype.hasOwnProperty.call(f, b) && t(C, f, b);
    return e(C, f), C;
  }, n = Yt && Yt.__awaiter || function(f, C, b, N) {
    function v(R) {
      return R instanceof b ? R : new b(function(x) {
        x(R);
      });
    }
    return new (b || (b = Promise))(function(R, x) {
      function S(k) {
        try {
          T(N.next(k));
        } catch (L) {
          x(L);
        }
      }
      function D(k) {
        try {
          T(N.throw(k));
        } catch (L) {
          x(L);
        }
      }
      function T(k) {
        k.done ? R(k.value) : v(k.value).then(S, D);
      }
      T((N = N.apply(f, C || [])).next());
    });
  };
  Object.defineProperty(Yt, "__esModule", { value: !0 }), Yt.downloadCacheStorageSDK = Yt.downloadCacheHttpClientConcurrent = Yt.downloadCacheHttpClient = Yt.DownloadProgress = void 0;
  const s = r(ir()), i = kn(), o = Gy, c = r(Dn), l = r(Zr), A = r(ln), a = r(Qr), u = r(so()), g = no(), h = Hy(), m = uk;
  function d(f, C) {
    return n(this, void 0, void 0, function* () {
      yield a.promisify(A.pipeline)(f.message, C);
    });
  }
  class p {
    constructor(C) {
      this.contentLength = C, this.segmentIndex = 0, this.segmentSize = 0, this.segmentOffset = 0, this.receivedBytes = 0, this.displayedComplete = !1, this.startTime = Date.now();
    }
    /**
     * Progress to the next segment. Only call this method when the previous segment
     * is complete.
     *
     * @param segmentSize the length of the next segment
     */
    nextSegment(C) {
      this.segmentOffset = this.segmentOffset + this.segmentSize, this.segmentIndex = this.segmentIndex + 1, this.segmentSize = C, this.receivedBytes = 0, s.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
    }
    /**
     * Sets the number of bytes received for the current segment.
     *
     * @param receivedBytes the number of bytes received
     */
    setReceivedBytes(C) {
      this.receivedBytes = C;
    }
    /**
     * Returns the total number of bytes transferred.
     */
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    /**
     * Returns true if the download is complete.
     */
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    /**
     * Prints the current download stats. Once the download completes, this will print one
     * last line and then stop.
     */
    display() {
      if (this.displayedComplete)
        return;
      const C = this.segmentOffset + this.receivedBytes, b = (100 * (C / this.contentLength)).toFixed(1), N = Date.now() - this.startTime, v = (C / (1024 * 1024) / (N / 1e3)).toFixed(1);
      s.info(`Received ${C} of ${this.contentLength} (${b}%), ${v} MBs/sec`), this.isDone() && (this.displayedComplete = !0);
    }
    /**
     * Returns a function used to handle TransferProgressEvents.
     */
    onProgress() {
      return (C) => {
        this.setReceivedBytes(C.loadedBytes);
      };
    }
    /**
     * Starts the timer that displays the stats.
     *
     * @param delayInMs the delay between each write
     */
    startDisplayTimer(C = 1e3) {
      const b = () => {
        this.display(), this.isDone() || (this.timeoutHandle = setTimeout(b, C));
      };
      this.timeoutHandle = setTimeout(b, C);
    }
    /**
     * Stops the timer that displays the stats. As this typically indicates the download
     * is complete, this will display one last line, unless the last line has already
     * been written.
     */
    stopDisplayTimer() {
      this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = void 0), this.display();
    }
  }
  Yt.DownloadProgress = p;
  function E(f, C) {
    return n(this, void 0, void 0, function* () {
      const b = l.createWriteStream(C), N = new i.HttpClient("actions/cache"), v = yield (0, h.retryHttpClientResponse)("downloadCache", () => n(this, void 0, void 0, function* () {
        return N.get(f);
      }));
      v.message.socket.setTimeout(g.SocketTimeout, () => {
        v.message.destroy(), s.debug(`Aborting download, socket timed out after ${g.SocketTimeout} ms`);
      }), yield d(v, b);
      const R = v.message.headers["content-length"];
      if (R) {
        const x = parseInt(R), S = u.getArchiveFileSizeInBytes(C);
        if (S !== x)
          throw new Error(`Incomplete download. Expected file size: ${x}, actual file size: ${S}`);
      } else
        s.debug("Unable to validate download, no Content-Length header");
    });
  }
  Yt.downloadCacheHttpClient = E;
  function B(f, C, b) {
    var N;
    return n(this, void 0, void 0, function* () {
      const v = yield l.promises.open(C, "w"), R = new i.HttpClient("actions/cache", void 0, {
        socketTimeout: b.timeoutInMs,
        keepAlive: !0
      });
      try {
        const S = (yield (0, h.retryHttpClientResponse)("downloadCacheMetadata", () => n(this, void 0, void 0, function* () {
          return yield R.request("HEAD", f, null, {});
        }))).message.headers["content-length"];
        if (S == null)
          throw new Error("Content-Length not found on blob response");
        const D = parseInt(S);
        if (Number.isNaN(D))
          throw new Error(`Could not interpret Content-Length: ${D}`);
        const T = [], k = 4 * 1024 * 1024;
        for (let J = 0; J < D; J += k) {
          const j = Math.min(k, D - J);
          T.push({
            offset: J,
            promiseGetter: () => n(this, void 0, void 0, function* () {
              return yield y(R, f, J, j);
            })
          });
        }
        T.reverse();
        let L = 0, W = 0;
        const O = new p(D);
        O.startDisplayTimer();
        const _ = O.onProgress(), M = [];
        let $;
        const U = () => n(this, void 0, void 0, function* () {
          const J = yield Promise.race(Object.values(M));
          yield v.write(J.buffer, 0, J.count, J.offset), L--, delete M[J.offset], W += J.count, _({ loadedBytes: W });
        });
        for (; $ = T.pop(); )
          M[$.offset] = $.promiseGetter(), L++, L >= ((N = b.downloadConcurrency) !== null && N !== void 0 ? N : 10) && (yield U());
        for (; L > 0; )
          yield U();
      } finally {
        R.dispose(), yield v.close();
      }
    });
  }
  Yt.downloadCacheHttpClientConcurrent = B;
  function y(f, C, b, N) {
    return n(this, void 0, void 0, function* () {
      let R = 0;
      for (; ; )
        try {
          const S = yield w(3e4, Q(f, C, b, N));
          if (typeof S == "string")
            throw new Error("downloadSegmentRetry failed due to timeout");
          return S;
        } catch (x) {
          if (R >= 5)
            throw x;
          R++;
        }
    });
  }
  function Q(f, C, b, N) {
    return n(this, void 0, void 0, function* () {
      const v = yield (0, h.retryHttpClientResponse)("downloadCachePart", () => n(this, void 0, void 0, function* () {
        return yield f.get(C, {
          Range: `bytes=${b}-${b + N - 1}`
        });
      }));
      if (!v.readBodyBuffer)
        throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
      return {
        offset: b,
        count: N,
        buffer: yield v.readBodyBuffer()
      };
    });
  }
  function I(f, C, b) {
    var N;
    return n(this, void 0, void 0, function* () {
      const v = new o.BlockBlobClient(f, void 0, {
        retryOptions: {
          // Override the timeout used when downloading each 4 MB chunk
          // The default is 2 min / MB, which is way too slow
          tryTimeoutInMs: b.timeoutInMs
        }
      }), x = (N = (yield v.getProperties()).contentLength) !== null && N !== void 0 ? N : -1;
      if (x < 0)
        s.debug("Unable to determine content length, downloading file with http-client..."), yield E(f, C);
      else {
        const S = Math.min(134217728, c.constants.MAX_LENGTH), D = new p(x), T = l.openSync(C, "w");
        try {
          D.startDisplayTimer();
          const k = new m.AbortController(), L = k.signal;
          for (; !D.isDone(); ) {
            const W = D.segmentOffset + D.segmentSize, O = Math.min(S, x - W);
            D.nextSegment(O);
            const _ = yield w(b.segmentTimeoutInMs || 36e5, v.downloadToBuffer(W, O, {
              abortSignal: L,
              concurrency: b.downloadConcurrency,
              onProgress: D.onProgress()
            }));
            if (_ === "timeout")
              throw k.abort(), new Error("Aborting cache download as the download time exceeded the timeout.");
            Buffer.isBuffer(_) && l.writeFileSync(T, _);
          }
        } finally {
          D.stopDisplayTimer(), l.closeSync(T);
        }
      }
    });
  }
  Yt.downloadCacheStorageSDK = I;
  const w = (f, C) => n(void 0, void 0, void 0, function* () {
    let b;
    const N = new Promise((v) => {
      b = setTimeout(() => v("timeout"), f);
    });
    return Promise.race([C, N]).then((v) => (clearTimeout(b), v));
  });
  return Yt;
}
var Dr = {}, sp;
function gk() {
  if (sp) return Dr;
  sp = 1;
  var t = Dr && Dr.__createBinding || (Object.create ? function(o, c, l, A) {
    A === void 0 && (A = l);
    var a = Object.getOwnPropertyDescriptor(c, l);
    (!a || ("get" in a ? !c.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return c[l];
    } }), Object.defineProperty(o, A, a);
  } : function(o, c, l, A) {
    A === void 0 && (A = l), o[A] = c[l];
  }), e = Dr && Dr.__setModuleDefault || (Object.create ? function(o, c) {
    Object.defineProperty(o, "default", { enumerable: !0, value: c });
  } : function(o, c) {
    o.default = c;
  }), r = Dr && Dr.__importStar || function(o) {
    if (o && o.__esModule) return o;
    var c = {};
    if (o != null) for (var l in o) l !== "default" && Object.prototype.hasOwnProperty.call(o, l) && t(c, o, l);
    return e(c, o), c;
  };
  Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.getDownloadOptions = Dr.getUploadOptions = void 0;
  const n = r(ir());
  function s(o) {
    const c = {
      useAzureSdk: !1,
      uploadConcurrency: 4,
      uploadChunkSize: 33554432
    };
    return o && (typeof o.useAzureSdk == "boolean" && (c.useAzureSdk = o.useAzureSdk), typeof o.uploadConcurrency == "number" && (c.uploadConcurrency = o.uploadConcurrency), typeof o.uploadChunkSize == "number" && (c.uploadChunkSize = o.uploadChunkSize)), c.uploadConcurrency = isNaN(Number(process.env.CACHE_UPLOAD_CONCURRENCY)) ? c.uploadConcurrency : Math.min(32, Number(process.env.CACHE_UPLOAD_CONCURRENCY)), c.uploadChunkSize = isNaN(Number(process.env.CACHE_UPLOAD_CHUNK_SIZE)) ? c.uploadChunkSize : Math.min(128 * 1024 * 1024, Number(process.env.CACHE_UPLOAD_CHUNK_SIZE) * 1024 * 1024), n.debug(`Use Azure SDK: ${c.useAzureSdk}`), n.debug(`Upload concurrency: ${c.uploadConcurrency}`), n.debug(`Upload chunk size: ${c.uploadChunkSize}`), c;
  }
  Dr.getUploadOptions = s;
  function i(o) {
    const c = {
      useAzureSdk: !1,
      concurrentBlobDownloads: !0,
      downloadConcurrency: 8,
      timeoutInMs: 3e4,
      segmentTimeoutInMs: 6e5,
      lookupOnly: !1
    };
    o && (typeof o.useAzureSdk == "boolean" && (c.useAzureSdk = o.useAzureSdk), typeof o.concurrentBlobDownloads == "boolean" && (c.concurrentBlobDownloads = o.concurrentBlobDownloads), typeof o.downloadConcurrency == "number" && (c.downloadConcurrency = o.downloadConcurrency), typeof o.timeoutInMs == "number" && (c.timeoutInMs = o.timeoutInMs), typeof o.segmentTimeoutInMs == "number" && (c.segmentTimeoutInMs = o.segmentTimeoutInMs), typeof o.lookupOnly == "boolean" && (c.lookupOnly = o.lookupOnly));
    const l = process.env.SEGMENT_DOWNLOAD_TIMEOUT_MINS;
    return l && !isNaN(Number(l)) && isFinite(Number(l)) && (c.segmentTimeoutInMs = Number(l) * 60 * 1e3), n.debug(`Use Azure SDK: ${c.useAzureSdk}`), n.debug(`Download concurrency: ${c.downloadConcurrency}`), n.debug(`Request timeout (ms): ${c.timeoutInMs}`), n.debug(`Cache segment download timeout mins env var: ${process.env.SEGMENT_DOWNLOAD_TIMEOUT_MINS}`), n.debug(`Segment download timeout (ms): ${c.segmentTimeoutInMs}`), n.debug(`Lookup only: ${c.lookupOnly}`), c;
  }
  return Dr.getDownloadOptions = i, Dr;
}
var hn = {}, ip;
function ld() {
  if (ip) return hn;
  ip = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.getCacheServiceURL = hn.getCacheServiceVersion = hn.isGhes = void 0;
  function t() {
    const s = new URL(process.env.GITHUB_SERVER_URL || "https://github.com").hostname.trimEnd().toUpperCase(), i = s === "GITHUB.COM", o = s.endsWith(".GHE.COM"), c = s.endsWith(".LOCALHOST");
    return !i && !o && !c;
  }
  hn.isGhes = t;
  function e() {
    return t() ? "v1" : process.env.ACTIONS_CACHE_SERVICE_V2 ? "v2" : "v1";
  }
  hn.getCacheServiceVersion = e;
  function r() {
    const n = e();
    switch (n) {
      case "v1":
        return process.env.ACTIONS_CACHE_URL || process.env.ACTIONS_RESULTS_URL || "";
      case "v2":
        return process.env.ACTIONS_RESULTS_URL || "";
      default:
        throw new Error(`Unsupported cache service version: ${n}`);
    }
  }
  return hn.getCacheServiceURL = r, hn;
}
var yi = {};
const mk = "4.0.3", hk = {
  version: mk
};
var op;
function Yy() {
  if (op) return yi;
  op = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.getUserAgentString = void 0;
  const t = hk;
  function e() {
    return `@actions/cache-${t.version}`;
  }
  return yi.getUserAgentString = e, yi;
}
var ap;
function pk() {
  if (ap) return zt;
  ap = 1;
  var t = zt && zt.__createBinding || (Object.create ? function(x, S, D, T) {
    T === void 0 && (T = D);
    var k = Object.getOwnPropertyDescriptor(S, D);
    (!k || ("get" in k ? !S.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return S[D];
    } }), Object.defineProperty(x, T, k);
  } : function(x, S, D, T) {
    T === void 0 && (T = D), x[T] = S[D];
  }), e = zt && zt.__setModuleDefault || (Object.create ? function(x, S) {
    Object.defineProperty(x, "default", { enumerable: !0, value: S });
  } : function(x, S) {
    x.default = S;
  }), r = zt && zt.__importStar || function(x) {
    if (x && x.__esModule) return x;
    var S = {};
    if (x != null) for (var D in x) D !== "default" && Object.prototype.hasOwnProperty.call(x, D) && t(S, x, D);
    return e(S, x), S;
  }, n = zt && zt.__awaiter || function(x, S, D, T) {
    function k(L) {
      return L instanceof D ? L : new D(function(W) {
        W(L);
      });
    }
    return new (D || (D = Promise))(function(L, W) {
      function O($) {
        try {
          M(T.next($));
        } catch (U) {
          W(U);
        }
      }
      function _($) {
        try {
          M(T.throw($));
        } catch (U) {
          W(U);
        }
      }
      function M($) {
        $.done ? L($.value) : k($.value).then(O, _);
      }
      M((T = T.apply(x, S || [])).next());
    });
  };
  Object.defineProperty(zt, "__esModule", { value: !0 }), zt.saveCache = zt.reserveCache = zt.downloadCache = zt.getCacheEntry = void 0;
  const s = r(ir()), i = kn(), o = fu(), c = r(Zr), l = Qf, A = r(so()), a = ak(), u = dk(), g = gk(), h = Hy(), m = ld(), d = Yy();
  function p(x) {
    const S = (0, m.getCacheServiceURL)();
    if (!S)
      throw new Error("Cache Service Url not found, unable to restore cache.");
    const D = `${S}_apis/artifactcache/${x}`;
    return s.debug(`Resource Url: ${D}`), D;
  }
  function E(x, S) {
    return `${x};api-version=${S}`;
  }
  function B() {
    return {
      headers: {
        Accept: E("application/json", "6.0-preview.1")
      }
    };
  }
  function y() {
    const x = process.env.ACTIONS_RUNTIME_TOKEN || "", S = new o.BearerCredentialHandler(x);
    return new i.HttpClient((0, d.getUserAgentString)(), [S], B());
  }
  function Q(x, S, D) {
    return n(this, void 0, void 0, function* () {
      const T = y(), k = A.getCacheVersion(S, D?.compressionMethod, D?.enableCrossOsArchive), L = `cache?keys=${encodeURIComponent(x.join(","))}&version=${k}`, W = yield (0, h.retryTypedResponse)("getCacheEntry", () => n(this, void 0, void 0, function* () {
        return T.getJson(p(L));
      }));
      if (W.statusCode === 204)
        return s.isDebug() && (yield I(x[0], T, k)), null;
      if (!(0, h.isSuccessStatusCode)(W.statusCode))
        throw new Error(`Cache service responded with ${W.statusCode}`);
      const O = W.result, _ = O?.archiveLocation;
      if (!_)
        throw new Error("Cache not found.");
      return s.setSecret(_), s.debug("Cache Result:"), s.debug(JSON.stringify(O)), O;
    });
  }
  zt.getCacheEntry = Q;
  function I(x, S, D) {
    return n(this, void 0, void 0, function* () {
      const T = `caches?key=${encodeURIComponent(x)}`, k = yield (0, h.retryTypedResponse)("listCache", () => n(this, void 0, void 0, function* () {
        return S.getJson(p(T));
      }));
      if (k.statusCode === 200) {
        const L = k.result, W = L?.totalCount;
        if (W && W > 0) {
          s.debug(`No matching cache found for cache key '${x}', version '${D} and scope ${process.env.GITHUB_REF}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
          for (const O of L?.artifactCaches || [])
            s.debug(`Cache Key: ${O?.cacheKey}, Cache Version: ${O?.cacheVersion}, Cache Scope: ${O?.scope}, Cache Created: ${O?.creationTime}`);
        }
      }
    });
  }
  function w(x, S, D) {
    return n(this, void 0, void 0, function* () {
      const T = new l.URL(x), k = (0, g.getDownloadOptions)(D);
      T.hostname.endsWith(".blob.core.windows.net") ? k.useAzureSdk ? yield (0, u.downloadCacheStorageSDK)(x, S, k) : k.concurrentBlobDownloads ? yield (0, u.downloadCacheHttpClientConcurrent)(x, S, k) : yield (0, u.downloadCacheHttpClient)(x, S) : yield (0, u.downloadCacheHttpClient)(x, S);
    });
  }
  zt.downloadCache = w;
  function f(x, S, D) {
    return n(this, void 0, void 0, function* () {
      const T = y(), k = A.getCacheVersion(S, D?.compressionMethod, D?.enableCrossOsArchive), L = {
        key: x,
        version: k,
        cacheSize: D?.cacheSize
      };
      return yield (0, h.retryTypedResponse)("reserveCache", () => n(this, void 0, void 0, function* () {
        return T.postJson(p("caches"), L);
      }));
    });
  }
  zt.reserveCache = f;
  function C(x, S) {
    return `bytes ${x}-${S}/*`;
  }
  function b(x, S, D, T, k) {
    return n(this, void 0, void 0, function* () {
      s.debug(`Uploading chunk of size ${k - T + 1} bytes at offset ${T} with content range: ${C(T, k)}`);
      const L = {
        "Content-Type": "application/octet-stream",
        "Content-Range": C(T, k)
      }, W = yield (0, h.retryHttpClientResponse)(`uploadChunk (start: ${T}, end: ${k})`, () => n(this, void 0, void 0, function* () {
        return x.sendStream("PATCH", S, D(), L);
      }));
      if (!(0, h.isSuccessStatusCode)(W.message.statusCode))
        throw new Error(`Cache service responded with ${W.message.statusCode} during upload chunk.`);
    });
  }
  function N(x, S, D, T) {
    return n(this, void 0, void 0, function* () {
      const k = A.getArchiveFileSizeInBytes(D), L = p(`caches/${S.toString()}`), W = c.openSync(D, "r"), O = (0, g.getUploadOptions)(T), _ = A.assertDefined("uploadConcurrency", O.uploadConcurrency), M = A.assertDefined("uploadChunkSize", O.uploadChunkSize), $ = [...new Array(_).keys()];
      s.debug("Awaiting all uploads");
      let U = 0;
      try {
        yield Promise.all($.map(() => n(this, void 0, void 0, function* () {
          for (; U < k; ) {
            const J = Math.min(k - U, M), j = U, te = U + J - 1;
            U += M, yield b(x, L, () => c.createReadStream(D, {
              fd: W,
              start: j,
              end: te,
              autoClose: !1
            }).on("error", (ie) => {
              throw new Error(`Cache upload failed because file read failed with ${ie.message}`);
            }), j, te);
          }
        })));
      } finally {
        c.closeSync(W);
      }
    });
  }
  function v(x, S, D) {
    return n(this, void 0, void 0, function* () {
      const T = { size: D };
      return yield (0, h.retryTypedResponse)("commitCache", () => n(this, void 0, void 0, function* () {
        return x.postJson(p(`caches/${S.toString()}`), T);
      }));
    });
  }
  function R(x, S, D, T) {
    return n(this, void 0, void 0, function* () {
      if ((0, g.getUploadOptions)(T).useAzureSdk) {
        if (!D)
          throw new Error("Azure Storage SDK can only be used when a signed URL is provided.");
        yield (0, a.uploadCacheArchiveSDK)(D, S, T);
      } else {
        const L = y();
        s.debug("Upload cache"), yield N(L, x, S, T), s.debug("Commiting cache");
        const W = A.getArchiveFileSizeInBytes(S);
        s.info(`Cache Size: ~${Math.round(W / (1024 * 1024))} MB (${W} B)`);
        const O = yield v(L, x, W);
        if (!(0, h.isSuccessStatusCode)(O.statusCode))
          throw new Error(`Cache service responded with ${O.statusCode} during commit cache.`);
        s.info("Cache saved successfully");
      }
    });
  }
  return zt.saveCache = R, zt;
}
var Vn = {}, Wn = {}, Oc = {};
function ud(t) {
  let e = typeof t;
  if (e == "object") {
    if (Array.isArray(t))
      return "array";
    if (t === null)
      return "null";
  }
  return e;
}
function Jy(t) {
  return t !== null && typeof t == "object" && !Array.isArray(t);
}
let fn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), Ia = [];
for (let t = 0; t < fn.length; t++)
  Ia[fn[t].charCodeAt(0)] = t;
Ia[45] = fn.indexOf("+");
Ia[95] = fn.indexOf("/");
function Vy(t) {
  let e = t.length * 3 / 4;
  t[t.length - 2] == "=" ? e -= 2 : t[t.length - 1] == "=" && (e -= 1);
  let r = new Uint8Array(e), n = 0, s = 0, i, o = 0;
  for (let c = 0; c < t.length; c++) {
    if (i = Ia[t.charCodeAt(c)], i === void 0)
      switch (t[c]) {
        case "=":
          s = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string.");
      }
    switch (s) {
      case 0:
        o = i, s = 1;
        break;
      case 1:
        r[n++] = o << 2 | (i & 48) >> 4, o = i, s = 2;
        break;
      case 2:
        r[n++] = (o & 15) << 4 | (i & 60) >> 2, o = i, s = 3;
        break;
      case 3:
        r[n++] = (o & 3) << 6 | i, s = 0;
        break;
    }
  }
  if (s == 1)
    throw Error("invalid base64 string.");
  return r.subarray(0, n);
}
function Wy(t) {
  let e = "", r = 0, n, s = 0;
  for (let i = 0; i < t.length; i++)
    switch (n = t[i], r) {
      case 0:
        e += fn[n >> 2], s = (n & 3) << 4, r = 1;
        break;
      case 1:
        e += fn[s | n >> 4], s = (n & 15) << 2, r = 2;
        break;
      case 2:
        e += fn[s | n >> 6], e += fn[n & 63], r = 0;
        break;
    }
  return r && (e += fn[s], e += "=", r == 1 && (e += "=")), e;
}
const Gc = (t) => String.fromCharCode.apply(String, t);
function fk(t) {
  if (t.length < 1)
    return "";
  let e = 0, r = [], n = [], s = 0, i, o = t.length;
  for (; e < o; )
    i = t[e++], i < 128 ? n[s++] = i : i > 191 && i < 224 ? n[s++] = (i & 31) << 6 | t[e++] & 63 : i > 239 && i < 365 ? (i = ((i & 7) << 18 | (t[e++] & 63) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) - 65536, n[s++] = 55296 + (i >> 10), n[s++] = 56320 + (i & 1023)) : n[s++] = (i & 15) << 12 | (t[e++] & 63) << 6 | t[e++] & 63, s > 8191 && (r.push(Gc(n)), s = 0);
  return r.length ? (s && r.push(Gc(n.slice(0, s))), r.join("")) : Gc(n.slice(0, s));
}
var zi;
(function(t) {
  t.symbol = Symbol.for("protobuf-ts/unknown"), t.onRead = (r, n, s, i, o) => {
    (e(n) ? n[t.symbol] : n[t.symbol] = []).push({ no: s, wireType: i, data: o });
  }, t.onWrite = (r, n, s) => {
    for (let { no: i, wireType: o, data: c } of t.list(n))
      s.tag(i, o).raw(c);
  }, t.list = (r, n) => {
    if (e(r)) {
      let s = r[t.symbol];
      return n ? s.filter((i) => i.no == n) : s;
    }
    return [];
  }, t.last = (r, n) => t.list(r, n).slice(-1)[0];
  const e = (r) => r && Array.isArray(r[t.symbol]);
})(zi || (zi = {}));
function jy(t, e) {
  return Object.assign(Object.assign({}, t), e);
}
var Ft;
(function(t) {
  t[t.Varint = 0] = "Varint", t[t.Bit64 = 1] = "Bit64", t[t.LengthDelimited = 2] = "LengthDelimited", t[t.StartGroup = 3] = "StartGroup", t[t.EndGroup = 4] = "EndGroup", t[t.Bit32 = 5] = "Bit32";
})(Ft || (Ft = {}));
function Ek() {
  let t = 0, e = 0;
  for (let n = 0; n < 28; n += 7) {
    let s = this.buf[this.pos++];
    if (t |= (s & 127) << n, (s & 128) == 0)
      return this.assertBounds(), [t, e];
  }
  let r = this.buf[this.pos++];
  if (t |= (r & 15) << 28, e = (r & 112) >> 4, (r & 128) == 0)
    return this.assertBounds(), [t, e];
  for (let n = 3; n <= 31; n += 7) {
    let s = this.buf[this.pos++];
    if (e |= (s & 127) << n, (s & 128) == 0)
      return this.assertBounds(), [t, e];
  }
  throw new Error("invalid varint");
}
function qc(t, e, r) {
  for (let i = 0; i < 28; i = i + 7) {
    const o = t >>> i, c = !(!(o >>> 7) && e == 0), l = (c ? o | 128 : o) & 255;
    if (r.push(l), !c)
      return;
  }
  const n = t >>> 28 & 15 | (e & 7) << 4, s = e >> 3 != 0;
  if (r.push((s ? n | 128 : n) & 255), !!s) {
    for (let i = 3; i < 31; i = i + 7) {
      const o = e >>> i, c = !!(o >>> 7), l = (c ? o | 128 : o) & 255;
      if (r.push(l), !c)
        return;
    }
    r.push(e >>> 31 & 1);
  }
}
const Oo = 65536 * 65536;
function $y(t) {
  let e = t[0] == "-";
  e && (t = t.slice(1));
  const r = 1e6;
  let n = 0, s = 0;
  function i(o, c) {
    const l = Number(t.slice(o, c));
    s *= r, n = n * r + l, n >= Oo && (s = s + (n / Oo | 0), n = n % Oo);
  }
  return i(-24, -18), i(-18, -12), i(-12, -6), i(-6), [e, n, s];
}
function tu(t, e) {
  if (e >>> 0 <= 2097151)
    return "" + (Oo * e + (t >>> 0));
  let r = t & 16777215, n = (t >>> 24 | e << 8) >>> 0 & 16777215, s = e >> 16 & 65535, i = r + n * 6777216 + s * 6710656, o = n + s * 8147497, c = s * 2, l = 1e7;
  i >= l && (o += Math.floor(i / l), i %= l), o >= l && (c += Math.floor(o / l), o %= l);
  function A(a, u) {
    let g = a ? String(a) : "";
    return u ? "0000000".slice(g.length) + g : g;
  }
  return A(
    c,
    /*needLeadingZeros=*/
    0
  ) + A(
    o,
    /*needLeadingZeros=*/
    c
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  A(
    i,
    /*needLeadingZeros=*/
    1
  );
}
function Ap(t, e) {
  if (t >= 0) {
    for (; t > 127; )
      e.push(t & 127 | 128), t = t >>> 7;
    e.push(t);
  } else {
    for (let r = 0; r < 9; r++)
      e.push(t & 127 | 128), t = t >> 7;
    e.push(1);
  }
}
function Ck() {
  let t = this.buf[this.pos++], e = t & 127;
  if ((t & 128) == 0)
    return this.assertBounds(), e;
  if (t = this.buf[this.pos++], e |= (t & 127) << 7, (t & 128) == 0)
    return this.assertBounds(), e;
  if (t = this.buf[this.pos++], e |= (t & 127) << 14, (t & 128) == 0)
    return this.assertBounds(), e;
  if (t = this.buf[this.pos++], e |= (t & 127) << 21, (t & 128) == 0)
    return this.assertBounds(), e;
  t = this.buf[this.pos++], e |= (t & 15) << 28;
  for (let r = 5; (t & 128) !== 0 && r < 10; r++)
    t = this.buf[this.pos++];
  if ((t & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), e >>> 0;
}
let gt;
function Bk() {
  const t = new DataView(new ArrayBuffer(8));
  gt = globalThis.BigInt !== void 0 && typeof t.getBigInt64 == "function" && typeof t.getBigUint64 == "function" && typeof t.setBigInt64 == "function" && typeof t.setBigUint64 == "function" ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: t
  } : void 0;
}
Bk();
function Xy(t) {
  if (!t)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
const Ky = /^-?[0-9]+$/, Zo = 4294967296, To = 2147483648;
class Zy {
  /**
   * Create a new instance with the given bits.
   */
  constructor(e, r) {
    this.lo = e | 0, this.hi = r | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let e = this.hi * Zo + (this.lo >>> 0);
    if (!Number.isSafeInteger(e))
      throw new Error("cannot convert to safe number");
    return e;
  }
}
class nr extends Zy {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(e) {
    if (gt)
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e == "")
            throw new Error("string is no integer");
          e = gt.C(e);
        case "number":
          if (e === 0)
            return this.ZERO;
          e = gt.C(e);
        case "bigint":
          if (!e)
            return this.ZERO;
          if (e < gt.UMIN)
            throw new Error("signed value for ulong");
          if (e > gt.UMAX)
            throw new Error("ulong too large");
          return gt.V.setBigUint64(0, e, !0), new nr(gt.V.getInt32(0, !0), gt.V.getInt32(4, !0));
      }
    else
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e = e.trim(), !Ky.test(e))
            throw new Error("string is no integer");
          let [r, n, s] = $y(e);
          if (r)
            throw new Error("signed value for ulong");
          return new nr(n, s);
        case "number":
          if (e == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(e))
            throw new Error("number is no integer");
          if (e < 0)
            throw new Error("signed value for ulong");
          return new nr(e, e / Zo);
      }
    throw new Error("unknown value " + typeof e);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return gt ? this.toBigInt().toString() : tu(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    return Xy(gt), gt.V.setInt32(0, this.lo, !0), gt.V.setInt32(4, this.hi, !0), gt.V.getBigUint64(0, !0);
  }
}
nr.ZERO = new nr(0, 0);
class Pt extends Zy {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(e) {
    if (gt)
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e == "")
            throw new Error("string is no integer");
          e = gt.C(e);
        case "number":
          if (e === 0)
            return this.ZERO;
          e = gt.C(e);
        case "bigint":
          if (!e)
            return this.ZERO;
          if (e < gt.MIN)
            throw new Error("signed long too small");
          if (e > gt.MAX)
            throw new Error("signed long too large");
          return gt.V.setBigInt64(0, e, !0), new Pt(gt.V.getInt32(0, !0), gt.V.getInt32(4, !0));
      }
    else
      switch (typeof e) {
        case "string":
          if (e == "0")
            return this.ZERO;
          if (e = e.trim(), !Ky.test(e))
            throw new Error("string is no integer");
          let [r, n, s] = $y(e);
          if (r) {
            if (s > To || s == To && n != 0)
              throw new Error("signed long too small");
          } else if (s >= To)
            throw new Error("signed long too large");
          let i = new Pt(n, s);
          return r ? i.negate() : i;
        case "number":
          if (e == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(e))
            throw new Error("number is no integer");
          return e > 0 ? new Pt(e, e / Zo) : new Pt(-e, -e / Zo).negate();
      }
    throw new Error("unknown value " + typeof e);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & To) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let e = ~this.hi, r = this.lo;
    return r ? r = ~r + 1 : e += 1, new Pt(r, e);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (gt)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let e = this.negate();
      return "-" + tu(e.lo, e.hi);
    }
    return tu(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    return Xy(gt), gt.V.setInt32(0, this.lo, !0), gt.V.setInt32(4, this.hi, !0), gt.V.getBigInt64(0, !0);
  }
}
Pt.ZERO = new Pt(0, 0);
const cp = {
  readUnknownField: !0,
  readerFactory: (t) => new tQ(t)
};
function eQ(t) {
  return t ? Object.assign(Object.assign({}, cp), t) : cp;
}
class tQ {
  constructor(e, r) {
    this.varint64 = Ek, this.uint32 = Ck, this.buf = e, this.len = e.length, this.pos = 0, this.view = new DataView(e.buffer, e.byteOffset, e.byteLength), this.textDecoder = r ?? new TextDecoder("utf-8", {
      fatal: !0,
      ignoreBOM: !0
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let e = this.uint32(), r = e >>> 3, n = e & 7;
    if (r <= 0 || n < 0 || n > 5)
      throw new Error("illegal tag: field no " + r + " wire type " + n);
    return [r, n];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(e) {
    let r = this.pos;
    switch (e) {
      case Ft.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case Ft.Bit64:
        this.pos += 4;
      case Ft.Bit32:
        this.pos += 4;
        break;
      case Ft.LengthDelimited:
        let n = this.uint32();
        this.pos += n;
        break;
      case Ft.StartGroup:
        let s;
        for (; (s = this.tag()[1]) !== Ft.EndGroup; )
          this.skip(s);
        break;
      default:
        throw new Error("cant skip wire type " + e);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let e = this.uint32();
    return e >>> 1 ^ -(e & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new Pt(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new nr(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [e, r] = this.varint64(), n = -(e & 1);
    return e = (e >>> 1 | (r & 1) << 31) ^ n, r = r >>> 1 ^ n, new Pt(e, r);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [e, r] = this.varint64();
    return e !== 0 || r !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new nr(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new Pt(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let e = this.uint32(), r = this.pos;
    return this.pos += e, this.assertBounds(), this.buf.subarray(r, r + e);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function ze(t, e) {
  if (!t)
    throw new Error(e);
}
function rQ(t, e) {
  throw new Error(e ?? "Unexpected object: " + t);
}
const Ik = 34028234663852886e22, yk = -34028234663852886e22, Qk = 4294967295, bk = 2147483647, wk = -2147483648;
function bs(t) {
  if (typeof t != "number")
    throw new Error("invalid int 32: " + typeof t);
  if (!Number.isInteger(t) || t > bk || t < wk)
    throw new Error("invalid int 32: " + t);
}
function Yi(t) {
  if (typeof t != "number")
    throw new Error("invalid uint 32: " + typeof t);
  if (!Number.isInteger(t) || t > Qk || t < 0)
    throw new Error("invalid uint 32: " + t);
}
function ya(t) {
  if (typeof t != "number")
    throw new Error("invalid float 32: " + typeof t);
  if (Number.isFinite(t) && (t > Ik || t < yk))
    throw new Error("invalid float 32: " + t);
}
const lp = {
  writeUnknownFields: !0,
  writerFactory: () => new sQ()
};
function nQ(t) {
  return t ? Object.assign(Object.assign({}, lp), t) : lp;
}
class sQ {
  constructor(e) {
    this.stack = [], this.textEncoder = e ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let e = 0;
    for (let s = 0; s < this.chunks.length; s++)
      e += this.chunks[s].length;
    let r = new Uint8Array(e), n = 0;
    for (let s = 0; s < this.chunks.length; s++)
      r.set(this.chunks[s], n), n += this.chunks[s].length;
    return this.chunks = [], r;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let e = this.finish(), r = this.stack.pop();
    if (!r)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = r.chunks, this.buf = r.buf, this.uint32(e.byteLength), this.raw(e);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(e, r) {
    return this.uint32((e << 3 | r) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(e) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(e), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(e) {
    for (Yi(e); e > 127; )
      this.buf.push(e & 127 | 128), e = e >>> 7;
    return this.buf.push(e), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(e) {
    return bs(e), Ap(e, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(e) {
    return this.buf.push(e ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(e) {
    return this.uint32(e.byteLength), this.raw(e);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(e) {
    let r = this.textEncoder.encode(e);
    return this.uint32(r.byteLength), this.raw(r);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(e) {
    ya(e);
    let r = new Uint8Array(4);
    return new DataView(r.buffer).setFloat32(0, e, !0), this.raw(r);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(e) {
    let r = new Uint8Array(8);
    return new DataView(r.buffer).setFloat64(0, e, !0), this.raw(r);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(e) {
    Yi(e);
    let r = new Uint8Array(4);
    return new DataView(r.buffer).setUint32(0, e, !0), this.raw(r);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(e) {
    bs(e);
    let r = new Uint8Array(4);
    return new DataView(r.buffer).setInt32(0, e, !0), this.raw(r);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(e) {
    return bs(e), e = (e << 1 ^ e >> 31) >>> 0, Ap(e, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(e) {
    let r = new Uint8Array(8), n = new DataView(r.buffer), s = Pt.from(e);
    return n.setInt32(0, s.lo, !0), n.setInt32(4, s.hi, !0), this.raw(r);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(e) {
    let r = new Uint8Array(8), n = new DataView(r.buffer), s = nr.from(e);
    return n.setInt32(0, s.lo, !0), n.setInt32(4, s.hi, !0), this.raw(r);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(e) {
    let r = Pt.from(e);
    return qc(r.lo, r.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(e) {
    let r = Pt.from(e), n = r.hi >> 31, s = r.lo << 1 ^ n, i = (r.hi << 1 | r.lo >>> 31) ^ n;
    return qc(s, i, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(e) {
    let r = nr.from(e);
    return qc(r.lo, r.hi, this.buf), this;
  }
}
const up = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
}, dp = {
  ignoreUnknownFields: !1
};
function iQ(t) {
  return t ? Object.assign(Object.assign({}, dp), t) : dp;
}
function oQ(t) {
  return t ? Object.assign(Object.assign({}, up), t) : up;
}
function aQ(t, e) {
  var r, n;
  let s = Object.assign(Object.assign({}, t), e);
  return s.typeRegistry = [...(r = t?.typeRegistry) !== null && r !== void 0 ? r : [], ...(n = e?.typeRegistry) !== null && n !== void 0 ? n : []], s;
}
const Qa = Symbol.for("protobuf-ts/message-type");
function ea(t) {
  let e = !1;
  const r = [];
  for (let n = 0; n < t.length; n++) {
    let s = t.charAt(n);
    s == "_" ? e = !0 : /\d/.test(s) ? (r.push(s), e = !0) : e ? (r.push(s.toUpperCase()), e = !1) : n == 0 ? r.push(s.toLowerCase()) : r.push(s);
  }
  return r.join("");
}
var ue;
(function(t) {
  t[t.DOUBLE = 1] = "DOUBLE", t[t.FLOAT = 2] = "FLOAT", t[t.INT64 = 3] = "INT64", t[t.UINT64 = 4] = "UINT64", t[t.INT32 = 5] = "INT32", t[t.FIXED64 = 6] = "FIXED64", t[t.FIXED32 = 7] = "FIXED32", t[t.BOOL = 8] = "BOOL", t[t.STRING = 9] = "STRING", t[t.BYTES = 12] = "BYTES", t[t.UINT32 = 13] = "UINT32", t[t.SFIXED32 = 15] = "SFIXED32", t[t.SFIXED64 = 16] = "SFIXED64", t[t.SINT32 = 17] = "SINT32", t[t.SINT64 = 18] = "SINT64";
})(ue || (ue = {}));
var Kr;
(function(t) {
  t[t.BIGINT = 0] = "BIGINT", t[t.STRING = 1] = "STRING", t[t.NUMBER = 2] = "NUMBER";
})(Kr || (Kr = {}));
var Ji;
(function(t) {
  t[t.NO = 0] = "NO", t[t.PACKED = 1] = "PACKED", t[t.UNPACKED = 2] = "UNPACKED";
})(Ji || (Ji = {}));
function AQ(t) {
  var e, r, n, s;
  return t.localName = (e = t.localName) !== null && e !== void 0 ? e : ea(t.name), t.jsonName = (r = t.jsonName) !== null && r !== void 0 ? r : ea(t.name), t.repeat = (n = t.repeat) !== null && n !== void 0 ? n : Ji.NO, t.opt = (s = t.opt) !== null && s !== void 0 ? s : t.repeat || t.oneof ? !1 : t.kind == "message", t;
}
function Nk(t, e, r, n) {
  var s;
  const i = (s = t.fields.find((o, c) => o.localName == e || c == e)) === null || s === void 0 ? void 0 : s.options;
  return i && i[r] ? n.fromJson(i[r]) : void 0;
}
function Rk(t, e, r, n) {
  var s;
  const i = (s = t.fields.find((c, l) => c.localName == e || l == e)) === null || s === void 0 ? void 0 : s.options;
  if (!i)
    return;
  const o = i[r];
  return o === void 0 ? o : n ? n.fromJson(o) : o;
}
function Sk(t, e, r) {
  const s = t.options[e];
  return s === void 0 ? s : r ? r.fromJson(s) : s;
}
function cQ(t) {
  if (typeof t != "object" || t === null || !t.hasOwnProperty("oneofKind"))
    return !1;
  switch (typeof t.oneofKind) {
    case "string":
      return t[t.oneofKind] === void 0 ? !1 : Object.keys(t).length == 2;
    case "undefined":
      return Object.keys(t).length == 1;
    default:
      return !1;
  }
}
function vk(t, e) {
  return t[e];
}
function xk(t, e, r) {
  t.oneofKind !== void 0 && delete t[t.oneofKind], t.oneofKind = e, r !== void 0 && (t[e] = r);
}
function Dk(t) {
  t.oneofKind !== void 0 && delete t[t.oneofKind], t.oneofKind = void 0;
}
function Tk(t) {
  if (t.oneofKind !== void 0)
    return t[t.oneofKind];
}
class lQ {
  constructor(e) {
    var r;
    this.fields = (r = e.fields) !== null && r !== void 0 ? r : [];
  }
  prepare() {
    if (this.data)
      return;
    const e = [], r = [], n = [];
    for (let s of this.fields)
      if (s.oneof)
        n.includes(s.oneof) || (n.push(s.oneof), e.push(s.oneof), r.push(s.oneof));
      else
        switch (r.push(s.localName), s.kind) {
          case "scalar":
          case "enum":
            (!s.opt || s.repeat) && e.push(s.localName);
            break;
          case "message":
            s.repeat && e.push(s.localName);
            break;
          case "map":
            e.push(s.localName);
            break;
        }
    this.data = { req: e, known: r, oneofs: Object.values(n) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(e, r, n = !1) {
    if (r < 0)
      return !0;
    if (e == null || typeof e != "object")
      return !1;
    this.prepare();
    let s = Object.keys(e), i = this.data;
    if (s.length < i.req.length || i.req.some((o) => !s.includes(o)) || !n && s.some((o) => !i.known.includes(o)))
      return !1;
    if (r < 1)
      return !0;
    for (const o of i.oneofs) {
      const c = e[o];
      if (!cQ(c))
        return !1;
      if (c.oneofKind === void 0)
        continue;
      const l = this.fields.find((A) => A.localName === c.oneofKind);
      if (!l || !this.field(c[c.oneofKind], l, n, r))
        return !1;
    }
    for (const o of this.fields)
      if (o.oneof === void 0 && !this.field(e[o.localName], o, n, r))
        return !1;
    return !0;
  }
  field(e, r, n, s) {
    let i = r.repeat;
    switch (r.kind) {
      case "scalar":
        return e === void 0 ? r.opt : i ? this.scalars(e, r.T, s, r.L) : this.scalar(e, r.T, r.L);
      case "enum":
        return e === void 0 ? r.opt : i ? this.scalars(e, ue.INT32, s) : this.scalar(e, ue.INT32);
      case "message":
        return e === void 0 ? !0 : i ? this.messages(e, r.T(), n, s) : this.message(e, r.T(), n, s);
      case "map":
        if (typeof e != "object" || e === null)
          return !1;
        if (s < 2)
          return !0;
        if (!this.mapKeys(e, r.K, s))
          return !1;
        switch (r.V.kind) {
          case "scalar":
            return this.scalars(Object.values(e), r.V.T, s, r.V.L);
          case "enum":
            return this.scalars(Object.values(e), ue.INT32, s);
          case "message":
            return this.messages(Object.values(e), r.V.T(), n, s);
        }
        break;
    }
    return !0;
  }
  message(e, r, n, s) {
    return n ? r.isAssignable(e, s) : r.is(e, s);
  }
  messages(e, r, n, s) {
    if (!Array.isArray(e))
      return !1;
    if (s < 2)
      return !0;
    if (n) {
      for (let i = 0; i < e.length && i < s; i++)
        if (!r.isAssignable(e[i], s - 1))
          return !1;
    } else
      for (let i = 0; i < e.length && i < s; i++)
        if (!r.is(e[i], s - 1))
          return !1;
    return !0;
  }
  scalar(e, r, n) {
    let s = typeof e;
    switch (r) {
      case ue.UINT64:
      case ue.FIXED64:
      case ue.INT64:
      case ue.SFIXED64:
      case ue.SINT64:
        switch (n) {
          case Kr.BIGINT:
            return s == "bigint";
          case Kr.NUMBER:
            return s == "number" && !isNaN(e);
          default:
            return s == "string";
        }
      case ue.BOOL:
        return s == "boolean";
      case ue.STRING:
        return s == "string";
      case ue.BYTES:
        return e instanceof Uint8Array;
      case ue.DOUBLE:
      case ue.FLOAT:
        return s == "number" && !isNaN(e);
      default:
        return s == "number" && Number.isInteger(e);
    }
  }
  scalars(e, r, n, s) {
    if (!Array.isArray(e))
      return !1;
    if (n < 2)
      return !0;
    if (Array.isArray(e)) {
      for (let i = 0; i < e.length && i < n; i++)
        if (!this.scalar(e[i], r, s))
          return !1;
    }
    return !0;
  }
  mapKeys(e, r, n) {
    let s = Object.keys(e);
    switch (r) {
      case ue.INT32:
      case ue.FIXED32:
      case ue.SFIXED32:
      case ue.SINT32:
      case ue.UINT32:
        return this.scalars(s.slice(0, n).map((i) => parseInt(i)), r, n);
      case ue.BOOL:
        return this.scalars(s.slice(0, n).map((i) => i == "true" ? !0 : i == "false" ? !1 : i), r, n);
      default:
        return this.scalars(s, r, n, Kr.STRING);
    }
  }
}
function $r(t, e) {
  switch (e) {
    case Kr.BIGINT:
      return t.toBigInt();
    case Kr.NUMBER:
      return t.toNumber();
    default:
      return t.toString();
  }
}
class uQ {
  constructor(e) {
    this.info = e;
  }
  prepare() {
    var e;
    if (this.fMap === void 0) {
      this.fMap = {};
      const r = (e = this.info.fields) !== null && e !== void 0 ? e : [];
      for (const n of r)
        this.fMap[n.name] = n, this.fMap[n.jsonName] = n, this.fMap[n.localName] = n;
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(e, r, n) {
    if (!e) {
      let s = ud(n);
      throw (s == "number" || s == "boolean") && (s = n.toString()), new Error(`Cannot parse JSON ${s} for ${this.info.typeName}#${r}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(e, r, n) {
    this.prepare();
    const s = [];
    for (const [i, o] of Object.entries(e)) {
      const c = this.fMap[i];
      if (!c) {
        if (!n.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${i}`);
        continue;
      }
      const l = c.localName;
      let A;
      if (c.oneof) {
        if (o === null && (c.kind !== "enum" || c.T()[0] !== "google.protobuf.NullValue"))
          continue;
        if (s.includes(c.oneof))
          throw new Error(`Multiple members of the oneof group "${c.oneof}" of ${this.info.typeName} are present in JSON.`);
        s.push(c.oneof), A = r[c.oneof] = {
          oneofKind: l
        };
      } else
        A = r;
      if (c.kind == "map") {
        if (o === null)
          continue;
        this.assert(Jy(o), c.name, o);
        const a = A[l];
        for (const [u, g] of Object.entries(o)) {
          this.assert(g !== null, c.name + " map value", null);
          let h;
          switch (c.V.kind) {
            case "message":
              h = c.V.T().internalJsonRead(g, n);
              break;
            case "enum":
              if (h = this.enum(c.V.T(), g, c.name, n.ignoreUnknownFields), h === !1)
                continue;
              break;
            case "scalar":
              h = this.scalar(g, c.V.T, c.V.L, c.name);
              break;
          }
          this.assert(h !== void 0, c.name + " map value", g);
          let m = u;
          c.K == ue.BOOL && (m = m == "true" ? !0 : m == "false" ? !1 : m), m = this.scalar(m, c.K, Kr.STRING, c.name).toString(), a[m] = h;
        }
      } else if (c.repeat) {
        if (o === null)
          continue;
        this.assert(Array.isArray(o), c.name, o);
        const a = A[l];
        for (const u of o) {
          this.assert(u !== null, c.name, null);
          let g;
          switch (c.kind) {
            case "message":
              g = c.T().internalJsonRead(u, n);
              break;
            case "enum":
              if (g = this.enum(c.T(), u, c.name, n.ignoreUnknownFields), g === !1)
                continue;
              break;
            case "scalar":
              g = this.scalar(u, c.T, c.L, c.name);
              break;
          }
          this.assert(g !== void 0, c.name, o), a.push(g);
        }
      } else
        switch (c.kind) {
          case "message":
            if (o === null && c.T().typeName != "google.protobuf.Value") {
              this.assert(c.oneof === void 0, c.name + " (oneof member)", null);
              continue;
            }
            A[l] = c.T().internalJsonRead(o, n, A[l]);
            break;
          case "enum":
            if (o === null)
              continue;
            let a = this.enum(c.T(), o, c.name, n.ignoreUnknownFields);
            if (a === !1)
              continue;
            A[l] = a;
            break;
          case "scalar":
            if (o === null)
              continue;
            A[l] = this.scalar(o, c.T, c.L, c.name);
            break;
        }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(e, r, n, s) {
    if (e[0] == "google.protobuf.NullValue" && ze(r === null || r === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${n}, enum ${e[0]} only accepts null.`), r === null)
      return 0;
    switch (typeof r) {
      case "number":
        return ze(Number.isInteger(r), `Unable to parse field ${this.info.typeName}#${n}, enum can only be integral number, got ${r}.`), r;
      case "string":
        let i = r;
        e[2] && r.substring(0, e[2].length) === e[2] && (i = r.substring(e[2].length));
        let o = e[1][i];
        return typeof o > "u" && s ? !1 : (ze(typeof o == "number", `Unable to parse field ${this.info.typeName}#${n}, enum ${e[0]} has no value for "${r}".`), o);
    }
    ze(!1, `Unable to parse field ${this.info.typeName}#${n}, cannot parse enum value from ${typeof r}".`);
  }
  scalar(e, r, n, s) {
    let i;
    try {
      switch (r) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ue.DOUBLE:
        case ue.FLOAT:
          if (e === null)
            return 0;
          if (e === "NaN")
            return Number.NaN;
          if (e === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (e === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (e === "") {
            i = "empty string";
            break;
          }
          if (typeof e == "string" && e.trim().length !== e.length) {
            i = "extra whitespace";
            break;
          }
          if (typeof e != "string" && typeof e != "number")
            break;
          let o = Number(e);
          if (Number.isNaN(o)) {
            i = "not a number";
            break;
          }
          if (!Number.isFinite(o)) {
            i = "too large or small";
            break;
          }
          return r == ue.FLOAT && ya(o), o;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ue.INT32:
        case ue.FIXED32:
        case ue.SFIXED32:
        case ue.SINT32:
        case ue.UINT32:
          if (e === null)
            return 0;
          let c;
          if (typeof e == "number" ? c = e : e === "" ? i = "empty string" : typeof e == "string" && (e.trim().length !== e.length ? i = "extra whitespace" : c = Number(e)), c === void 0)
            break;
          return r == ue.UINT32 ? Yi(c) : bs(c), c;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ue.INT64:
        case ue.SFIXED64:
        case ue.SINT64:
          if (e === null)
            return $r(Pt.ZERO, n);
          if (typeof e != "number" && typeof e != "string")
            break;
          return $r(Pt.from(e), n);
        case ue.FIXED64:
        case ue.UINT64:
          if (e === null)
            return $r(nr.ZERO, n);
          if (typeof e != "number" && typeof e != "string")
            break;
          return $r(nr.from(e), n);
        // bool:
        case ue.BOOL:
          if (e === null)
            return !1;
          if (typeof e != "boolean")
            break;
          return e;
        // string:
        case ue.STRING:
          if (e === null)
            return "";
          if (typeof e != "string") {
            i = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(e);
          } catch (l) {
            l = "invalid UTF8";
            break;
          }
          return e;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ue.BYTES:
          if (e === null || e === "")
            return new Uint8Array(0);
          if (typeof e != "string")
            break;
          return Vy(e);
      }
    } catch (o) {
      i = o.message;
    }
    this.assert(!1, s + (i ? " - " + i : ""), e);
  }
}
class dQ {
  constructor(e) {
    var r;
    this.fields = (r = e.fields) !== null && r !== void 0 ? r : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(e, r) {
    const n = {}, s = e;
    for (const i of this.fields) {
      if (!i.oneof) {
        let A = this.field(i, s[i.localName], r);
        A !== void 0 && (n[r.useProtoFieldName ? i.name : i.jsonName] = A);
        continue;
      }
      const o = s[i.oneof];
      if (o.oneofKind !== i.localName)
        continue;
      const c = i.kind == "scalar" || i.kind == "enum" ? Object.assign(Object.assign({}, r), { emitDefaultValues: !0 }) : r;
      let l = this.field(i, o[i.localName], c);
      ze(l !== void 0), n[r.useProtoFieldName ? i.name : i.jsonName] = l;
    }
    return n;
  }
  field(e, r, n) {
    let s;
    if (e.kind == "map") {
      ze(typeof r == "object" && r !== null);
      const i = {};
      switch (e.V.kind) {
        case "scalar":
          for (const [l, A] of Object.entries(r)) {
            const a = this.scalar(e.V.T, A, e.name, !1, !0);
            ze(a !== void 0), i[l.toString()] = a;
          }
          break;
        case "message":
          const o = e.V.T();
          for (const [l, A] of Object.entries(r)) {
            const a = this.message(o, A, e.name, n);
            ze(a !== void 0), i[l.toString()] = a;
          }
          break;
        case "enum":
          const c = e.V.T();
          for (const [l, A] of Object.entries(r)) {
            ze(A === void 0 || typeof A == "number");
            const a = this.enum(c, A, e.name, !1, !0, n.enumAsInteger);
            ze(a !== void 0), i[l.toString()] = a;
          }
          break;
      }
      (n.emitDefaultValues || Object.keys(i).length > 0) && (s = i);
    } else if (e.repeat) {
      ze(Array.isArray(r));
      const i = [];
      switch (e.kind) {
        case "scalar":
          for (let l = 0; l < r.length; l++) {
            const A = this.scalar(e.T, r[l], e.name, e.opt, !0);
            ze(A !== void 0), i.push(A);
          }
          break;
        case "enum":
          const o = e.T();
          for (let l = 0; l < r.length; l++) {
            ze(r[l] === void 0 || typeof r[l] == "number");
            const A = this.enum(o, r[l], e.name, e.opt, !0, n.enumAsInteger);
            ze(A !== void 0), i.push(A);
          }
          break;
        case "message":
          const c = e.T();
          for (let l = 0; l < r.length; l++) {
            const A = this.message(c, r[l], e.name, n);
            ze(A !== void 0), i.push(A);
          }
          break;
      }
      (n.emitDefaultValues || i.length > 0 || n.emitDefaultValues) && (s = i);
    } else
      switch (e.kind) {
        case "scalar":
          s = this.scalar(e.T, r, e.name, e.opt, n.emitDefaultValues);
          break;
        case "enum":
          s = this.enum(e.T(), r, e.name, e.opt, n.emitDefaultValues, n.enumAsInteger);
          break;
        case "message":
          s = this.message(e.T(), r, e.name, n);
          break;
      }
    return s;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(e, r, n, s, i, o) {
    if (e[0] == "google.protobuf.NullValue")
      return !i && !s ? void 0 : null;
    if (r === void 0) {
      ze(s);
      return;
    }
    if (!(r === 0 && !i && !s))
      return ze(typeof r == "number"), ze(Number.isInteger(r)), o || !e[1].hasOwnProperty(r) ? r : e[2] ? e[2] + e[1][r] : e[1][r];
  }
  message(e, r, n, s) {
    return r === void 0 ? s.emitDefaultValues ? null : void 0 : e.internalJsonWrite(r, s);
  }
  scalar(e, r, n, s, i) {
    if (r === void 0) {
      ze(s);
      return;
    }
    const o = i || s;
    switch (e) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ue.INT32:
      case ue.SFIXED32:
      case ue.SINT32:
        return r === 0 ? o ? 0 : void 0 : (bs(r), r);
      case ue.FIXED32:
      case ue.UINT32:
        return r === 0 ? o ? 0 : void 0 : (Yi(r), r);
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ue.FLOAT:
        ya(r);
      case ue.DOUBLE:
        return r === 0 ? o ? 0 : void 0 : (ze(typeof r == "number"), Number.isNaN(r) ? "NaN" : r === Number.POSITIVE_INFINITY ? "Infinity" : r === Number.NEGATIVE_INFINITY ? "-Infinity" : r);
      // string:
      case ue.STRING:
        return r === "" ? o ? "" : void 0 : (ze(typeof r == "string"), r);
      // bool:
      case ue.BOOL:
        return r === !1 ? o ? !1 : void 0 : (ze(typeof r == "boolean"), r);
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ue.UINT64:
      case ue.FIXED64:
        ze(typeof r == "number" || typeof r == "string" || typeof r == "bigint");
        let c = nr.from(r);
        return c.isZero() && !o ? void 0 : c.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ue.INT64:
      case ue.SFIXED64:
      case ue.SINT64:
        ze(typeof r == "number" || typeof r == "string" || typeof r == "bigint");
        let l = Pt.from(r);
        return l.isZero() && !o ? void 0 : l.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ue.BYTES:
        return ze(r instanceof Uint8Array), r.byteLength ? Wy(r) : o ? "" : void 0;
    }
  }
}
function ta(t, e = Kr.STRING) {
  switch (t) {
    case ue.BOOL:
      return !1;
    case ue.UINT64:
    case ue.FIXED64:
      return $r(nr.ZERO, e);
    case ue.INT64:
    case ue.SFIXED64:
    case ue.SINT64:
      return $r(Pt.ZERO, e);
    case ue.DOUBLE:
    case ue.FLOAT:
      return 0;
    case ue.BYTES:
      return new Uint8Array(0);
    case ue.STRING:
      return "";
    default:
      return 0;
  }
}
class gQ {
  constructor(e) {
    this.info = e;
  }
  prepare() {
    var e;
    if (!this.fieldNoToField) {
      const r = (e = this.info.fields) !== null && e !== void 0 ? e : [];
      this.fieldNoToField = new Map(r.map((n) => [n.no, n]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(e, r, n, s) {
    this.prepare();
    const i = s === void 0 ? e.len : e.pos + s;
    for (; e.pos < i; ) {
      const [o, c] = e.tag(), l = this.fieldNoToField.get(o);
      if (!l) {
        let g = n.readUnknownField;
        if (g == "throw")
          throw new Error(`Unknown field ${o} (wire type ${c}) for ${this.info.typeName}`);
        let h = e.skip(c);
        g !== !1 && (g === !0 ? zi.onRead : g)(this.info.typeName, r, o, c, h);
        continue;
      }
      let A = r, a = l.repeat, u = l.localName;
      switch (l.oneof && (A = A[l.oneof], A.oneofKind !== u && (A = r[l.oneof] = {
        oneofKind: u
      })), l.kind) {
        case "scalar":
        case "enum":
          let g = l.kind == "enum" ? ue.INT32 : l.T, h = l.kind == "scalar" ? l.L : void 0;
          if (a) {
            let p = A[u];
            if (c == Ft.LengthDelimited && g != ue.STRING && g != ue.BYTES) {
              let E = e.uint32() + e.pos;
              for (; e.pos < E; )
                p.push(this.scalar(e, g, h));
            } else
              p.push(this.scalar(e, g, h));
          } else
            A[u] = this.scalar(e, g, h);
          break;
        case "message":
          if (a) {
            let p = A[u], E = l.T().internalBinaryRead(e, e.uint32(), n);
            p.push(E);
          } else
            A[u] = l.T().internalBinaryRead(e, e.uint32(), n, A[u]);
          break;
        case "map":
          let [m, d] = this.mapEntry(l, e, n);
          A[u][m] = d;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(e, r, n) {
    let s = r.uint32(), i = r.pos + s, o, c;
    for (; r.pos < i; ) {
      let [l, A] = r.tag();
      switch (l) {
        case 1:
          e.K == ue.BOOL ? o = r.bool().toString() : o = this.scalar(r, e.K, Kr.STRING);
          break;
        case 2:
          switch (e.V.kind) {
            case "scalar":
              c = this.scalar(r, e.V.T, e.V.L);
              break;
            case "enum":
              c = r.int32();
              break;
            case "message":
              c = e.V.T().internalBinaryRead(r, r.uint32(), n);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${l} (wire type ${A}) in map entry for ${this.info.typeName}#${e.name}`);
      }
    }
    if (o === void 0) {
      let l = ta(e.K);
      o = e.K == ue.BOOL ? l.toString() : l;
    }
    if (c === void 0)
      switch (e.V.kind) {
        case "scalar":
          c = ta(e.V.T, e.V.L);
          break;
        case "enum":
          c = 0;
          break;
        case "message":
          c = e.V.T().create();
          break;
      }
    return [o, c];
  }
  scalar(e, r, n) {
    switch (r) {
      case ue.INT32:
        return e.int32();
      case ue.STRING:
        return e.string();
      case ue.BOOL:
        return e.bool();
      case ue.DOUBLE:
        return e.double();
      case ue.FLOAT:
        return e.float();
      case ue.INT64:
        return $r(e.int64(), n);
      case ue.UINT64:
        return $r(e.uint64(), n);
      case ue.FIXED64:
        return $r(e.fixed64(), n);
      case ue.FIXED32:
        return e.fixed32();
      case ue.BYTES:
        return e.bytes();
      case ue.UINT32:
        return e.uint32();
      case ue.SFIXED32:
        return e.sfixed32();
      case ue.SFIXED64:
        return $r(e.sfixed64(), n);
      case ue.SINT32:
        return e.sint32();
      case ue.SINT64:
        return $r(e.sint64(), n);
    }
  }
}
class mQ {
  constructor(e) {
    this.info = e;
  }
  prepare() {
    if (!this.fields) {
      const e = this.info.fields ? this.info.fields.concat() : [];
      this.fields = e.sort((r, n) => r.no - n.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(e, r, n) {
    this.prepare();
    for (const i of this.fields) {
      let o, c, l = i.repeat, A = i.localName;
      if (i.oneof) {
        const a = e[i.oneof];
        if (a.oneofKind !== A)
          continue;
        o = a[A], c = !0;
      } else
        o = e[A], c = !1;
      switch (i.kind) {
        case "scalar":
        case "enum":
          let a = i.kind == "enum" ? ue.INT32 : i.T;
          if (l)
            if (ze(Array.isArray(o)), l == Ji.PACKED)
              this.packed(r, a, i.no, o);
            else
              for (const u of o)
                this.scalar(r, a, i.no, u, !0);
          else o === void 0 ? ze(i.opt) : this.scalar(r, a, i.no, o, c || i.opt);
          break;
        case "message":
          if (l) {
            ze(Array.isArray(o));
            for (const u of o)
              this.message(r, n, i.T(), i.no, u);
          } else
            this.message(r, n, i.T(), i.no, o);
          break;
        case "map":
          ze(typeof o == "object" && o !== null);
          for (const [u, g] of Object.entries(o))
            this.mapEntry(r, n, i, u, g);
          break;
      }
    }
    let s = n.writeUnknownFields;
    s !== !1 && (s === !0 ? zi.onWrite : s)(this.info.typeName, e, r);
  }
  mapEntry(e, r, n, s, i) {
    e.tag(n.no, Ft.LengthDelimited), e.fork();
    let o = s;
    switch (n.K) {
      case ue.INT32:
      case ue.FIXED32:
      case ue.UINT32:
      case ue.SFIXED32:
      case ue.SINT32:
        o = Number.parseInt(s);
        break;
      case ue.BOOL:
        ze(s == "true" || s == "false"), o = s == "true";
        break;
    }
    switch (this.scalar(e, n.K, 1, o, !0), n.V.kind) {
      case "scalar":
        this.scalar(e, n.V.T, 2, i, !0);
        break;
      case "enum":
        this.scalar(e, ue.INT32, 2, i, !0);
        break;
      case "message":
        this.message(e, r, n.V.T(), 2, i);
        break;
    }
    e.join();
  }
  message(e, r, n, s, i) {
    i !== void 0 && (n.internalBinaryWrite(i, e.tag(s, Ft.LengthDelimited).fork(), r), e.join());
  }
  /**
   * Write a single scalar value.
   */
  scalar(e, r, n, s, i) {
    let [o, c, l] = this.scalarInfo(r, s);
    (!l || i) && (e.tag(n, o), e[c](s));
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(e, r, n, s) {
    if (!s.length)
      return;
    ze(r !== ue.BYTES && r !== ue.STRING), e.tag(n, Ft.LengthDelimited), e.fork();
    let [, i] = this.scalarInfo(r);
    for (let o = 0; o < s.length; o++)
      e[i](s[o]);
    e.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(e, r) {
    let n = Ft.Varint, s, i = r === void 0, o = r === 0;
    switch (e) {
      case ue.INT32:
        s = "int32";
        break;
      case ue.STRING:
        o = i || !r.length, n = Ft.LengthDelimited, s = "string";
        break;
      case ue.BOOL:
        o = r === !1, s = "bool";
        break;
      case ue.UINT32:
        s = "uint32";
        break;
      case ue.DOUBLE:
        n = Ft.Bit64, s = "double";
        break;
      case ue.FLOAT:
        n = Ft.Bit32, s = "float";
        break;
      case ue.INT64:
        o = i || Pt.from(r).isZero(), s = "int64";
        break;
      case ue.UINT64:
        o = i || nr.from(r).isZero(), s = "uint64";
        break;
      case ue.FIXED64:
        o = i || nr.from(r).isZero(), n = Ft.Bit64, s = "fixed64";
        break;
      case ue.BYTES:
        o = i || !r.byteLength, n = Ft.LengthDelimited, s = "bytes";
        break;
      case ue.FIXED32:
        n = Ft.Bit32, s = "fixed32";
        break;
      case ue.SFIXED32:
        n = Ft.Bit32, s = "sfixed32";
        break;
      case ue.SFIXED64:
        o = i || Pt.from(r).isZero(), n = Ft.Bit64, s = "sfixed64";
        break;
      case ue.SINT32:
        s = "sint32";
        break;
      case ue.SINT64:
        o = i || Pt.from(r).isZero(), s = "sint64";
        break;
    }
    return [n, s, i || o];
  }
}
function hQ(t) {
  const e = t.messagePrototype ? Object.create(t.messagePrototype) : Object.defineProperty({}, Qa, { value: t });
  for (let r of t.fields) {
    let n = r.localName;
    if (!r.opt)
      if (r.oneof)
        e[r.oneof] = { oneofKind: void 0 };
      else if (r.repeat)
        e[n] = [];
      else
        switch (r.kind) {
          case "scalar":
            e[n] = ta(r.T, r.L);
            break;
          case "enum":
            e[n] = 0;
            break;
          case "map":
            e[n] = {};
            break;
        }
  }
  return e;
}
function Go(t, e, r) {
  let n, s = r, i;
  for (let o of t.fields) {
    let c = o.localName;
    if (o.oneof) {
      const l = s[o.oneof];
      if (l?.oneofKind == null)
        continue;
      if (n = l[c], i = e[o.oneof], i.oneofKind = l.oneofKind, n == null) {
        delete i[c];
        continue;
      }
    } else if (n = s[c], i = e, n == null)
      continue;
    switch (o.repeat && (i[c].length = n.length), o.kind) {
      case "scalar":
      case "enum":
        if (o.repeat)
          for (let A = 0; A < n.length; A++)
            i[c][A] = n[A];
        else
          i[c] = n;
        break;
      case "message":
        let l = o.T();
        if (o.repeat)
          for (let A = 0; A < n.length; A++)
            i[c][A] = l.create(n[A]);
        else i[c] === void 0 ? i[c] = l.create(n) : l.mergePartial(i[c], n);
        break;
      case "map":
        switch (o.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(i[c], n);
            break;
          case "message":
            let A = o.V.T();
            for (let a of Object.keys(n))
              i[c][a] = A.create(n[a]);
            break;
        }
        break;
    }
  }
}
function pQ(t, e, r) {
  if (e === r)
    return !0;
  if (!e || !r)
    return !1;
  for (let n of t.fields) {
    let s = n.localName, i = n.oneof ? e[n.oneof][s] : e[s], o = n.oneof ? r[n.oneof][s] : r[s];
    switch (n.kind) {
      case "enum":
      case "scalar":
        let c = n.kind == "enum" ? ue.INT32 : n.T;
        if (!(n.repeat ? gp(c, i, o) : fQ(c, i, o)))
          return !1;
        break;
      case "map":
        if (!(n.V.kind == "message" ? mp(n.V.T(), ko(i), ko(o)) : gp(n.V.kind == "enum" ? ue.INT32 : n.V.T, ko(i), ko(o))))
          return !1;
        break;
      case "message":
        let l = n.T();
        if (!(n.repeat ? mp(l, i, o) : l.equals(i, o)))
          return !1;
        break;
    }
  }
  return !0;
}
const ko = Object.values;
function fQ(t, e, r) {
  if (e === r)
    return !0;
  if (t !== ue.BYTES)
    return !1;
  let n = e, s = r;
  if (n.length !== s.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (n[i] != s[i])
      return !1;
  return !0;
}
function gp(t, e, r) {
  if (e.length !== r.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!fQ(t, e[n], r[n]))
      return !1;
  return !0;
}
function mp(t, e, r) {
  if (e.length !== r.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!t.equals(e[n], r[n]))
      return !1;
  return !0;
}
const EQ = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({})), kk = EQ[Qa] = {};
class Fk {
  constructor(e, r, n) {
    this.defaultCheckDepth = 16, this.typeName = e, this.fields = r.map(AQ), this.options = n ?? {}, kk.value = this, this.messagePrototype = Object.create(null, EQ), this.refTypeCheck = new lQ(this), this.refJsonReader = new uQ(this), this.refJsonWriter = new dQ(this), this.refBinReader = new gQ(this), this.refBinWriter = new mQ(this);
  }
  create(e) {
    let r = hQ(this);
    return e !== void 0 && Go(this, r, e), r;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(e) {
    let r = this.create();
    return Go(this, r, e), r;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(e, r) {
    return pQ(this, e, r);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(e, r = this.defaultCheckDepth) {
    return this.refTypeCheck.is(e, r, !1);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(e, r = this.defaultCheckDepth) {
    return this.refTypeCheck.is(e, r, !0);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(e, r) {
    Go(this, e, r);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(e, r) {
    let n = eQ(r);
    return this.internalBinaryRead(n.readerFactory(e), e.byteLength, n);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(e, r) {
    return this.internalJsonRead(e, iQ(r));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(e, r) {
    let n = JSON.parse(e);
    return this.fromJson(n, r);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(e, r) {
    return this.internalJsonWrite(e, oQ(r));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(e, r) {
    var n;
    let s = this.toJson(e, r);
    return JSON.stringify(s, null, (n = r?.prettySpaces) !== null && n !== void 0 ? n : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(e, r) {
    let n = nQ(r);
    return this.internalBinaryWrite(e, n.writerFactory(), n).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(e, r, n) {
    if (e !== null && typeof e == "object" && !Array.isArray(e)) {
      let s = n ?? this.create();
      return this.refJsonReader.read(e, s, r), s;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${ud(e)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(e, r) {
    return this.refJsonWriter.write(e, r);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(e, r, n) {
    return this.refBinWriter.write(e, r, n), r;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(e, r, n, s) {
    let i = s ?? this.create();
    return this.refBinReader.read(e, i, n, r), i;
  }
}
function Pk(t) {
  return t[Qa] != null;
}
function CQ(t) {
  if (typeof t != "object" || t === null || !t.hasOwnProperty(0))
    return !1;
  for (let e of Object.keys(t)) {
    let r = parseInt(e);
    if (Number.isNaN(r)) {
      let n = t[e];
      if (n === void 0 || typeof n != "number" || t[n] === void 0)
        return !1;
    } else {
      let n = t[r];
      if (n === void 0 || t[n] !== r)
        return !1;
    }
  }
  return !0;
}
function dd(t) {
  if (!CQ(t))
    throw new Error("not a typescript enum object");
  let e = [];
  for (let [r, n] of Object.entries(t))
    typeof n == "number" && e.push({ name: r, number: n });
  return e;
}
function Uk(t) {
  return dd(t).map((e) => e.name);
}
function Lk(t) {
  return dd(t).map((e) => e.number).filter((e, r, n) => n.indexOf(e) == r);
}
const _k = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BinaryReader: tQ,
  BinaryWriter: sQ,
  get LongType() {
    return Kr;
  },
  MESSAGE_TYPE: Qa,
  MessageType: Fk,
  PbLong: Pt,
  PbULong: nr,
  ReflectionBinaryReader: gQ,
  ReflectionBinaryWriter: mQ,
  ReflectionJsonReader: uQ,
  ReflectionJsonWriter: dQ,
  ReflectionTypeCheck: lQ,
  get RepeatType() {
    return Ji;
  },
  get ScalarType() {
    return ue;
  },
  get UnknownFieldHandler() {
    return zi;
  },
  get WireType() {
    return Ft;
  },
  assert: ze,
  assertFloat32: ya,
  assertInt32: bs,
  assertNever: rQ,
  assertUInt32: Yi,
  base64decode: Vy,
  base64encode: Wy,
  binaryReadOptions: eQ,
  binaryWriteOptions: nQ,
  clearOneofValue: Dk,
  containsMessageType: Pk,
  getOneofValue: vk,
  getSelectedOneofValue: Tk,
  isEnumObject: CQ,
  isJsonObject: Jy,
  isOneofGroup: cQ,
  jsonReadOptions: iQ,
  jsonWriteOptions: oQ,
  listEnumNames: Uk,
  listEnumNumbers: Lk,
  listEnumValues: dd,
  lowerCamelCase: ea,
  mergeBinaryOptions: jy,
  mergeJsonOptions: aQ,
  normalizeFieldInfo: AQ,
  readFieldOption: Rk,
  readFieldOptions: Nk,
  readMessageOption: Sk,
  reflectionCreate: hQ,
  reflectionEquals: pQ,
  reflectionMergePartial: Go,
  reflectionScalarDefault: ta,
  setOneofValue: xk,
  typeofJsonValue: ud,
  utf8read: fk
}, Symbol.toStringTag, { value: "Module" }));
function Mk(t, e) {
  var r, n, s;
  let i = t;
  return i.service = e, i.localName = (r = i.localName) !== null && r !== void 0 ? r : ea(i.name), i.serverStreaming = !!i.serverStreaming, i.clientStreaming = !!i.clientStreaming, i.options = (n = i.options) !== null && n !== void 0 ? n : {}, i.idempotency = (s = i.idempotency) !== null && s !== void 0 ? s : void 0, i;
}
function Ok(t, e, r, n) {
  var s;
  const i = (s = t.methods.find((o, c) => o.localName === e || c === e)) === null || s === void 0 ? void 0 : s.options;
  return i && i[r] ? n.fromJson(i[r]) : void 0;
}
function Gk(t, e, r, n) {
  var s;
  const i = (s = t.methods.find((c, l) => c.localName === e || l === e)) === null || s === void 0 ? void 0 : s.options;
  if (!i)
    return;
  const o = i[r];
  return o === void 0 ? o : n ? n.fromJson(o) : o;
}
function qk(t, e, r) {
  const n = t.options;
  if (!n)
    return;
  const s = n[e];
  return s === void 0 ? s : r ? r.fromJson(s) : s;
}
class Hk {
  constructor(e, r, n) {
    this.typeName = e, this.methods = r.map((s) => Mk(s, this)), this.options = n ?? {};
  }
}
class Pr extends Error {
  constructor(e, r = "UNKNOWN", n) {
    super(e), this.name = "RpcError", Object.setPrototypeOf(this, new.target.prototype), this.code = r, this.meta = n ?? {};
  }
  toString() {
    const e = [this.name + ": " + this.message];
    this.code && (e.push(""), e.push("Code: " + this.code)), this.serviceName && this.methodName && e.push("Method: " + this.serviceName + "/" + this.methodName);
    let r = Object.entries(this.meta);
    if (r.length) {
      e.push(""), e.push("Meta:");
      for (let [n, s] of r)
        e.push(`  ${n}: ${s}`);
    }
    return e.join(`
`);
  }
}
function BQ(t, e) {
  if (!e)
    return t;
  let r = {};
  Fo(t, r), Fo(e, r);
  for (let n of Object.keys(e)) {
    let s = e[n];
    switch (n) {
      case "jsonOptions":
        r.jsonOptions = aQ(t.jsonOptions, r.jsonOptions);
        break;
      case "binaryOptions":
        r.binaryOptions = jy(t.binaryOptions, r.binaryOptions);
        break;
      case "meta":
        r.meta = {}, Fo(t.meta, r.meta), Fo(e.meta, r.meta);
        break;
      case "interceptors":
        r.interceptors = t.interceptors ? t.interceptors.concat(s) : s.concat();
        break;
    }
  }
  return r;
}
function Fo(t, e) {
  if (!t)
    return;
  let r = e;
  for (let [n, s] of Object.entries(t))
    s instanceof Date ? r[n] = new Date(s.getTime()) : Array.isArray(s) ? r[n] = s.concat() : r[n] = s;
}
var Fr;
(function(t) {
  t[t.PENDING = 0] = "PENDING", t[t.REJECTED = 1] = "REJECTED", t[t.RESOLVED = 2] = "RESOLVED";
})(Fr || (Fr = {}));
class IQ {
  /**
   * @param preventUnhandledRejectionWarning - prevents the warning
   * "Unhandled Promise rejection" by adding a noop rejection handler.
   * Working with calls returned from the runtime-rpc package in an
   * async function usually means awaiting one call property after
   * the other. This means that the "status" is not being awaited when
   * an earlier await for the "headers" is rejected. This causes the
   * "unhandled promise reject" warning. A more correct behaviour for
   * calls might be to become aware whether at least one of the
   * promises is handled and swallow the rejection warning for the
   * others.
   */
  constructor(e = !0) {
    this._state = Fr.PENDING, this._promise = new Promise((r, n) => {
      this._resolve = r, this._reject = n;
    }), e && this._promise.catch((r) => {
    });
  }
  /**
   * Get the current state of the promise.
   */
  get state() {
    return this._state;
  }
  /**
   * Get the deferred promise.
   */
  get promise() {
    return this._promise;
  }
  /**
   * Resolve the promise. Throws if the promise is already resolved or rejected.
   */
  resolve(e) {
    if (this.state !== Fr.PENDING)
      throw new Error(`cannot resolve ${Fr[this.state].toLowerCase()}`);
    this._resolve(e), this._state = Fr.RESOLVED;
  }
  /**
   * Reject the promise. Throws if the promise is already resolved or rejected.
   */
  reject(e) {
    if (this.state !== Fr.PENDING)
      throw new Error(`cannot reject ${Fr[this.state].toLowerCase()}`);
    this._reject(e), this._state = Fr.REJECTED;
  }
  /**
   * Resolve the promise. Ignore if not pending.
   */
  resolvePending(e) {
    this._state === Fr.PENDING && this.resolve(e);
  }
  /**
   * Reject the promise. Ignore if not pending.
   */
  rejectPending(e) {
    this._state === Fr.PENDING && this.reject(e);
  }
}
class ru {
  constructor() {
    this._lis = {
      nxt: [],
      msg: [],
      err: [],
      cmp: []
    }, this._closed = !1, this._itState = { q: [] };
  }
  // --- RpcOutputStream callback API
  onNext(e) {
    return this.addLis(e, this._lis.nxt);
  }
  onMessage(e) {
    return this.addLis(e, this._lis.msg);
  }
  onError(e) {
    return this.addLis(e, this._lis.err);
  }
  onComplete(e) {
    return this.addLis(e, this._lis.cmp);
  }
  addLis(e, r) {
    return r.push(e), () => {
      let n = r.indexOf(e);
      n >= 0 && r.splice(n, 1);
    };
  }
  // remove all listeners
  clearLis() {
    for (let e of Object.values(this._lis))
      e.splice(0, e.length);
  }
  // --- Controller API
  /**
   * Is this stream already closed by a completion or error?
   */
  get closed() {
    return this._closed !== !1;
  }
  /**
   * Emit message, close with error, or close successfully, but only one
   * at a time.
   * Can be used to wrap a stream by using the other stream's `onNext`.
   */
  notifyNext(e, r, n) {
    ze((e ? 1 : 0) + (r ? 1 : 0) + (n ? 1 : 0) <= 1, "only one emission at a time"), e && this.notifyMessage(e), r && this.notifyError(r), n && this.notifyComplete();
  }
  /**
   * Emits a new message. Throws if stream is closed.
   *
   * Triggers onNext and onMessage callbacks.
   */
  notifyMessage(e) {
    ze(!this.closed, "stream is closed"), this.pushIt({ value: e, done: !1 }), this._lis.msg.forEach((r) => r(e)), this._lis.nxt.forEach((r) => r(e, void 0, !1));
  }
  /**
   * Closes the stream with an error. Throws if stream is closed.
   *
   * Triggers onNext and onError callbacks.
   */
  notifyError(e) {
    ze(!this.closed, "stream is closed"), this._closed = e, this.pushIt(e), this._lis.err.forEach((r) => r(e)), this._lis.nxt.forEach((r) => r(void 0, e, !1)), this.clearLis();
  }
  /**
   * Closes the stream successfully. Throws if stream is closed.
   *
   * Triggers onNext and onComplete callbacks.
   */
  notifyComplete() {
    ze(!this.closed, "stream is closed"), this._closed = !0, this.pushIt({ value: null, done: !0 }), this._lis.cmp.forEach((e) => e()), this._lis.nxt.forEach((e) => e(void 0, void 0, !0)), this.clearLis();
  }
  /**
   * Creates an async iterator (that can be used with `for await {...}`)
   * to consume the stream.
   *
   * Some things to note:
   * - If an error occurs, the `for await` will throw it.
   * - If an error occurred before the `for await` was started, `for await`
   *   will re-throw it.
   * - If the stream is already complete, the `for await` will be empty.
   * - If your `for await` consumes slower than the stream produces,
   *   for example because you are relaying messages in a slow operation,
   *   messages are queued.
   */
  [Symbol.asyncIterator]() {
    return this._closed === !0 ? this.pushIt({ value: null, done: !0 }) : this._closed !== !1 && this.pushIt(this._closed), {
      next: () => {
        let e = this._itState;
        ze(e, "bad state"), ze(!e.p, "iterator contract broken");
        let r = e.q.shift();
        return r ? "value" in r ? Promise.resolve(r) : Promise.reject(r) : (e.p = new IQ(), e.p.promise);
      }
    };
  }
  // "push" a new iterator result.
  // this either resolves a pending promise, or enqueues the result.
  pushIt(e) {
    let r = this._itState;
    if (r.p) {
      const n = r.p;
      ze(n.state == Fr.PENDING, "iterator contract broken"), "value" in e ? n.resolve(e) : n.reject(e), delete r.p;
    } else
      r.q.push(e);
  }
}
var zk = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function c(a) {
      try {
        A(n.next(a));
      } catch (u) {
        o(u);
      }
    }
    function l(a) {
      try {
        A(n.throw(a));
      } catch (u) {
        o(u);
      }
    }
    function A(a) {
      a.done ? i(a.value) : s(a.value).then(c, l);
    }
    A((n = n.apply(t, e || [])).next());
  });
};
class yQ {
  constructor(e, r, n, s, i, o, c) {
    this.method = e, this.requestHeaders = r, this.request = n, this.headers = s, this.response = i, this.status = o, this.trailers = c;
  }
  /**
   * If you are only interested in the final outcome of this call,
   * you can await it to receive a `FinishedUnaryCall`.
   */
  then(e, r) {
    return this.promiseFinished().then((n) => e ? Promise.resolve(e(n)) : n, (n) => r ? Promise.resolve(r(n)) : Promise.reject(n));
  }
  promiseFinished() {
    return zk(this, void 0, void 0, function* () {
      let [e, r, n, s] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers: e,
        response: r,
        status: n,
        trailers: s
      };
    });
  }
}
var Yk = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function c(a) {
      try {
        A(n.next(a));
      } catch (u) {
        o(u);
      }
    }
    function l(a) {
      try {
        A(n.throw(a));
      } catch (u) {
        o(u);
      }
    }
    function A(a) {
      a.done ? i(a.value) : s(a.value).then(c, l);
    }
    A((n = n.apply(t, e || [])).next());
  });
};
class QQ {
  constructor(e, r, n, s, i, o, c) {
    this.method = e, this.requestHeaders = r, this.request = n, this.headers = s, this.responses = i, this.status = o, this.trailers = c;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * You should first setup some listeners to the `request` to
   * see the actual messages the server replied with.
   */
  then(e, r) {
    return this.promiseFinished().then((n) => e ? Promise.resolve(e(n)) : n, (n) => r ? Promise.resolve(r(n)) : Promise.reject(n));
  }
  promiseFinished() {
    return Yk(this, void 0, void 0, function* () {
      let [e, r, n] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers: e,
        status: r,
        trailers: n
      };
    });
  }
}
var Jk = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function c(a) {
      try {
        A(n.next(a));
      } catch (u) {
        o(u);
      }
    }
    function l(a) {
      try {
        A(n.throw(a));
      } catch (u) {
        o(u);
      }
    }
    function A(a) {
      a.done ? i(a.value) : s(a.value).then(c, l);
    }
    A((n = n.apply(t, e || [])).next());
  });
};
class bQ {
  constructor(e, r, n, s, i, o, c) {
    this.method = e, this.requestHeaders = r, this.requests = n, this.headers = s, this.response = i, this.status = o, this.trailers = c;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(e, r) {
    return this.promiseFinished().then((n) => e ? Promise.resolve(e(n)) : n, (n) => r ? Promise.resolve(r(n)) : Promise.reject(n));
  }
  promiseFinished() {
    return Jk(this, void 0, void 0, function* () {
      let [e, r, n, s] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers: e,
        response: r,
        status: n,
        trailers: s
      };
    });
  }
}
var Vk = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function c(a) {
      try {
        A(n.next(a));
      } catch (u) {
        o(u);
      }
    }
    function l(a) {
      try {
        A(n.throw(a));
      } catch (u) {
        o(u);
      }
    }
    function A(a) {
      a.done ? i(a.value) : s(a.value).then(c, l);
    }
    A((n = n.apply(t, e || [])).next());
  });
};
class wQ {
  constructor(e, r, n, s, i, o, c) {
    this.method = e, this.requestHeaders = r, this.requests = n, this.headers = s, this.responses = i, this.status = o, this.trailers = c;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(e, r) {
    return this.promiseFinished().then((n) => e ? Promise.resolve(e(n)) : n, (n) => r ? Promise.resolve(r(n)) : Promise.reject(n));
  }
  promiseFinished() {
    return Vk(this, void 0, void 0, function* () {
      let [e, r, n] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers: e,
        status: r,
        trailers: n
      };
    });
  }
}
var Wk = function(t, e, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function c(a) {
      try {
        A(n.next(a));
      } catch (u) {
        o(u);
      }
    }
    function l(a) {
      try {
        A(n.throw(a));
      } catch (u) {
        o(u);
      }
    }
    function A(a) {
      a.done ? i(a.value) : s(a.value).then(c, l);
    }
    A((n = n.apply(t, e || [])).next());
  });
};
class vn {
  /**
   * Initialize with mock data. Omitted fields have default value.
   */
  constructor(e) {
    this.suppressUncaughtRejections = !0, this.headerDelay = 10, this.responseDelay = 50, this.betweenResponseDelay = 10, this.afterResponseDelay = 10, this.data = e ?? {};
  }
  /**
   * Sent message(s) during the last operation.
   */
  get sentMessages() {
    return this.lastInput instanceof Po ? this.lastInput.sent : typeof this.lastInput == "object" ? [this.lastInput.single] : [];
  }
  /**
   * Sending message(s) completed?
   */
  get sendComplete() {
    return this.lastInput instanceof Po ? this.lastInput.completed : typeof this.lastInput == "object";
  }
  // Creates a promise for response headers from the mock data.
  promiseHeaders() {
    var e;
    const r = (e = this.data.headers) !== null && e !== void 0 ? e : vn.defaultHeaders;
    return r instanceof Pr ? Promise.reject(r) : Promise.resolve(r);
  }
  // Creates a promise for a single, valid, message from the mock data.
  promiseSingleResponse(e) {
    if (this.data.response instanceof Pr)
      return Promise.reject(this.data.response);
    let r;
    return Array.isArray(this.data.response) ? (ze(this.data.response.length > 0), r = this.data.response[0]) : this.data.response !== void 0 ? r = this.data.response : r = e.O.create(), ze(e.O.is(r)), Promise.resolve(r);
  }
  /**
   * Pushes response messages from the mock data to the output stream.
   * If an error response, status or trailers are mocked, the stream is
   * closed with the respective error.
   * Otherwise, stream is completed successfully.
   *
   * The returned promise resolves when the stream is closed. It should
   * not reject. If it does, code is broken.
   */
  streamResponses(e, r, n) {
    return Wk(this, void 0, void 0, function* () {
      const s = [];
      if (this.data.response === void 0)
        s.push(e.O.create());
      else if (Array.isArray(this.data.response))
        for (let i of this.data.response)
          ze(e.O.is(i)), s.push(i);
      else this.data.response instanceof Pr || (ze(e.O.is(this.data.response)), s.push(this.data.response));
      try {
        yield jt(this.responseDelay, n)(void 0);
      } catch (i) {
        r.notifyError(i);
        return;
      }
      if (this.data.response instanceof Pr) {
        r.notifyError(this.data.response);
        return;
      }
      for (let i of s) {
        r.notifyMessage(i);
        try {
          yield jt(this.betweenResponseDelay, n)(void 0);
        } catch (o) {
          r.notifyError(o);
          return;
        }
      }
      if (this.data.status instanceof Pr) {
        r.notifyError(this.data.status);
        return;
      }
      if (this.data.trailers instanceof Pr) {
        r.notifyError(this.data.trailers);
        return;
      }
      r.notifyComplete();
    });
  }
  // Creates a promise for response status from the mock data.
  promiseStatus() {
    var e;
    const r = (e = this.data.status) !== null && e !== void 0 ? e : vn.defaultStatus;
    return r instanceof Pr ? Promise.reject(r) : Promise.resolve(r);
  }
  // Creates a promise for response trailers from the mock data.
  promiseTrailers() {
    var e;
    const r = (e = this.data.trailers) !== null && e !== void 0 ? e : vn.defaultTrailers;
    return r instanceof Pr ? Promise.reject(r) : Promise.resolve(r);
  }
  maybeSuppressUncaught(...e) {
    if (this.suppressUncaughtRejections)
      for (let r of e)
        r.catch(() => {
        });
  }
  mergeOptions(e) {
    return BQ({}, e);
  }
  unary(e, r, n) {
    var s;
    const i = (s = n.meta) !== null && s !== void 0 ? s : {}, o = this.promiseHeaders().then(jt(this.headerDelay, n.abort)), c = o.catch((a) => {
    }).then(jt(this.responseDelay, n.abort)).then((a) => this.promiseSingleResponse(e)), l = c.catch((a) => {
    }).then(jt(this.afterResponseDelay, n.abort)).then((a) => this.promiseStatus()), A = c.catch((a) => {
    }).then(jt(this.afterResponseDelay, n.abort)).then((a) => this.promiseTrailers());
    return this.maybeSuppressUncaught(l, A), this.lastInput = { single: r }, new yQ(e, i, r, o, c, l, A);
  }
  serverStreaming(e, r, n) {
    var s;
    const i = (s = n.meta) !== null && s !== void 0 ? s : {}, o = this.promiseHeaders().then(jt(this.headerDelay, n.abort)), c = new ru(), l = o.then(jt(this.responseDelay, n.abort)).catch(() => {
    }).then(() => this.streamResponses(e, c, n.abort)).then(jt(this.afterResponseDelay, n.abort)), A = l.then(() => this.promiseStatus()), a = l.then(() => this.promiseTrailers());
    return this.maybeSuppressUncaught(A, a), this.lastInput = { single: r }, new QQ(e, i, r, o, c, A, a);
  }
  clientStreaming(e, r) {
    var n;
    const s = (n = r.meta) !== null && n !== void 0 ? n : {}, i = this.promiseHeaders().then(jt(this.headerDelay, r.abort)), o = i.catch((A) => {
    }).then(jt(this.responseDelay, r.abort)).then((A) => this.promiseSingleResponse(e)), c = o.catch((A) => {
    }).then(jt(this.afterResponseDelay, r.abort)).then((A) => this.promiseStatus()), l = o.catch((A) => {
    }).then(jt(this.afterResponseDelay, r.abort)).then((A) => this.promiseTrailers());
    return this.maybeSuppressUncaught(c, l), this.lastInput = new Po(this.data, r.abort), new bQ(e, s, this.lastInput, i, o, c, l);
  }
  duplex(e, r) {
    var n;
    const s = (n = r.meta) !== null && n !== void 0 ? n : {}, i = this.promiseHeaders().then(jt(this.headerDelay, r.abort)), o = new ru(), c = i.then(jt(this.responseDelay, r.abort)).catch(() => {
    }).then(() => this.streamResponses(e, o, r.abort)).then(jt(this.afterResponseDelay, r.abort)), l = c.then(() => this.promiseStatus()), A = c.then(() => this.promiseTrailers());
    return this.maybeSuppressUncaught(l, A), this.lastInput = new Po(this.data, r.abort), new wQ(e, s, this.lastInput, i, o, l, A);
  }
}
vn.defaultHeaders = {
  responseHeader: "test"
};
vn.defaultStatus = {
  code: "OK",
  detail: "all good"
};
vn.defaultTrailers = {
  responseTrailer: "test"
};
function jt(t, e) {
  return (r) => new Promise((n, s) => {
    if (e?.aborted)
      s(new Pr("user cancel", "CANCELLED"));
    else {
      const i = setTimeout(() => n(r), t);
      e && e.addEventListener("abort", (o) => {
        clearTimeout(i), s(new Pr("user cancel", "CANCELLED"));
      });
    }
  });
}
class Po {
  constructor(e, r) {
    this._completed = !1, this._sent = [], this.data = e, this.abort = r;
  }
  get sent() {
    return this._sent;
  }
  get completed() {
    return this._completed;
  }
  send(e) {
    if (this.data.inputMessage instanceof Pr)
      return Promise.reject(this.data.inputMessage);
    const r = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
    return Promise.resolve(void 0).then(() => {
      this._sent.push(e);
    }).then(jt(r, this.abort));
  }
  complete() {
    if (this.data.inputComplete instanceof Pr)
      return Promise.reject(this.data.inputComplete);
    const e = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
    return Promise.resolve(void 0).then(() => {
      this._completed = !0;
    }).then(jt(e, this.abort));
  }
}
function go(t, e, r, n, s) {
  var i, o, c, l;
  if (t == "unary") {
    let A = (a, u, g) => e.unary(a, u, g);
    for (const a of ((i = n.interceptors) !== null && i !== void 0 ? i : []).filter((u) => u.interceptUnary).reverse()) {
      const u = A;
      A = (g, h, m) => a.interceptUnary(u, g, h, m);
    }
    return A(r, s, n);
  }
  if (t == "serverStreaming") {
    let A = (a, u, g) => e.serverStreaming(a, u, g);
    for (const a of ((o = n.interceptors) !== null && o !== void 0 ? o : []).filter((u) => u.interceptServerStreaming).reverse()) {
      const u = A;
      A = (g, h, m) => a.interceptServerStreaming(u, g, h, m);
    }
    return A(r, s, n);
  }
  if (t == "clientStreaming") {
    let A = (a, u) => e.clientStreaming(a, u);
    for (const a of ((c = n.interceptors) !== null && c !== void 0 ? c : []).filter((u) => u.interceptClientStreaming).reverse()) {
      const u = A;
      A = (g, h) => a.interceptClientStreaming(u, g, h);
    }
    return A(r, n);
  }
  if (t == "duplex") {
    let A = (a, u) => e.duplex(a, u);
    for (const a of ((l = n.interceptors) !== null && l !== void 0 ? l : []).filter((u) => u.interceptDuplex).reverse()) {
      const u = A;
      A = (g, h) => a.interceptDuplex(u, g, h);
    }
    return A(r, n);
  }
  rQ(t);
}
function jk(t, e, r, n) {
  return go("unary", t, e, n, r);
}
function $k(t, e, r, n) {
  return go("serverStreaming", t, e, n, r);
}
function Xk(t, e, r) {
  return go("clientStreaming", t, e, r);
}
function Kk(t, e, r) {
  return go("duplex", t, e, r);
}
class Zk {
  constructor(e, r, n, s, i = { code: "OK", detail: "" }) {
    this._cancelled = !1, this._listeners = [], this.method = e, this.headers = r, this.deadline = n, this.trailers = {}, this._sendRH = s, this.status = i;
  }
  /**
   * Set the call cancelled.
   *
   * Invokes all callbacks registered with onCancel() and
   * sets `cancelled = true`.
   */
  notifyCancelled() {
    if (!this._cancelled) {
      this._cancelled = !0;
      for (let e of this._listeners)
        e();
    }
  }
  /**
   * Send response headers.
   */
  sendResponseHeaders(e) {
    this._sendRH(e);
  }
  /**
   * Is the call cancelled?
   *
   * When the client closes the connection before the server
   * is done, the call is cancelled.
   *
   * If you want to cancel a request on the server, throw a
   * RpcError with the CANCELLED status code.
   */
  get cancelled() {
    return this._cancelled;
  }
  /**
   * Add a callback for cancellation.
   */
  onCancel(e) {
    const r = this._listeners;
    return r.push(e), () => {
      let n = r.indexOf(e);
      n >= 0 && r.splice(n, 1);
    };
  }
}
const eF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClientStreamingCall: bQ,
  Deferred: IQ,
  get DeferredState() {
    return Fr;
  },
  DuplexStreamingCall: wQ,
  RpcError: Pr,
  RpcOutputStreamController: ru,
  ServerCallContextController: Zk,
  ServerStreamingCall: QQ,
  ServiceType: Hk,
  TestTransport: vn,
  UnaryCall: yQ,
  mergeRpcOptions: BQ,
  readMethodOption: Gk,
  readMethodOptions: Ok,
  readServiceOption: qk,
  stackClientStreamingInterceptors: Xk,
  stackDuplexStreamingInterceptors: Kk,
  stackIntercept: go,
  stackServerStreamingInterceptors: $k,
  stackUnaryInterceptors: jk
}, Symbol.toStringTag, { value: "Module" })), tF = /* @__PURE__ */ rs(eF), pr = /* @__PURE__ */ rs(_k);
var Qi = {}, bi = {}, hp;
function rF() {
  if (hp) return bi;
  hp = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.CacheScope = void 0;
  const t = pr, e = pr, r = pr, n = pr, s = pr;
  class i extends s.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheScope", [
        {
          no: 1,
          name: "scope",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "permission",
          kind: "scalar",
          T: 3
          /*ScalarType.INT64*/
        }
      ]);
    }
    create(c) {
      const l = { scope: "", permission: "0" };
      return globalThis.Object.defineProperty(l, n.MESSAGE_TYPE, { enumerable: !1, value: this }), c !== void 0 && (0, r.reflectionMergePartial)(this, l, c), l;
    }
    internalBinaryRead(c, l, A, a) {
      let u = a ?? this.create(), g = c.pos + l;
      for (; c.pos < g; ) {
        let [h, m] = c.tag();
        switch (h) {
          case /* string scope */
          1:
            u.scope = c.string();
            break;
          case /* int64 permission */
          2:
            u.permission = c.int64().toString();
            break;
          default:
            let d = A.readUnknownField;
            if (d === "throw")
              throw new globalThis.Error(`Unknown field ${h} (wire type ${m}) for ${this.typeName}`);
            let p = c.skip(m);
            d !== !1 && (d === !0 ? e.UnknownFieldHandler.onRead : d)(this.typeName, u, h, m, p);
        }
      }
      return u;
    }
    internalBinaryWrite(c, l, A) {
      c.scope !== "" && l.tag(1, t.WireType.LengthDelimited).string(c.scope), c.permission !== "0" && l.tag(2, t.WireType.Varint).int64(c.permission);
      let a = A.writeUnknownFields;
      return a !== !1 && (a == !0 ? e.UnknownFieldHandler.onWrite : a)(this.typeName, c, l), l;
    }
  }
  return bi.CacheScope = new i(), bi;
}
var pp;
function nF() {
  if (pp) return Qi;
  pp = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.CacheMetadata = void 0;
  const t = pr, e = pr, r = pr, n = pr, s = pr, i = rF();
  class o extends s.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheMetadata", [
        {
          no: 1,
          name: "repository_id",
          kind: "scalar",
          T: 3
          /*ScalarType.INT64*/
        },
        { no: 2, name: "scope", kind: "message", repeat: 1, T: () => i.CacheScope }
      ]);
    }
    create(l) {
      const A = { repositoryId: "0", scope: [] };
      return globalThis.Object.defineProperty(A, n.MESSAGE_TYPE, { enumerable: !1, value: this }), l !== void 0 && (0, r.reflectionMergePartial)(this, A, l), A;
    }
    internalBinaryRead(l, A, a, u) {
      let g = u ?? this.create(), h = l.pos + A;
      for (; l.pos < h; ) {
        let [m, d] = l.tag();
        switch (m) {
          case /* int64 repository_id */
          1:
            g.repositoryId = l.int64().toString();
            break;
          case /* repeated github.actions.results.entities.v1.CacheScope scope */
          2:
            g.scope.push(i.CacheScope.internalBinaryRead(l, l.uint32(), a));
            break;
          default:
            let p = a.readUnknownField;
            if (p === "throw")
              throw new globalThis.Error(`Unknown field ${m} (wire type ${d}) for ${this.typeName}`);
            let E = l.skip(d);
            p !== !1 && (p === !0 ? e.UnknownFieldHandler.onRead : p)(this.typeName, g, m, d, E);
        }
      }
      return g;
    }
    internalBinaryWrite(l, A, a) {
      l.repositoryId !== "0" && A.tag(1, t.WireType.Varint).int64(l.repositoryId);
      for (let g = 0; g < l.scope.length; g++)
        i.CacheScope.internalBinaryWrite(l.scope[g], A.tag(2, t.WireType.LengthDelimited).fork(), a).join();
      let u = a.writeUnknownFields;
      return u !== !1 && (u == !0 ? e.UnknownFieldHandler.onWrite : u)(this.typeName, l, A), A;
    }
  }
  return Qi.CacheMetadata = new o(), Qi;
}
var fp;
function sF() {
  return fp || (fp = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CacheService = t.GetCacheEntryDownloadURLResponse = t.GetCacheEntryDownloadURLRequest = t.FinalizeCacheEntryUploadResponse = t.FinalizeCacheEntryUploadRequest = t.CreateCacheEntryResponse = t.CreateCacheEntryRequest = void 0;
    const e = tF, r = pr, n = pr, s = pr, i = pr, o = pr, c = nF();
    class l extends o.MessageType {
      constructor() {
        super("github.actions.results.api.v1.CreateCacheEntryRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => c.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(d) {
        const p = { key: "", version: "" };
        return globalThis.Object.defineProperty(p, i.MESSAGE_TYPE, { enumerable: !1, value: this }), d !== void 0 && (0, s.reflectionMergePartial)(this, p, d), p;
      }
      internalBinaryRead(d, p, E, B) {
        let y = B ?? this.create(), Q = d.pos + p;
        for (; d.pos < Q; ) {
          let [I, w] = d.tag();
          switch (I) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              y.metadata = c.CacheMetadata.internalBinaryRead(d, d.uint32(), E, y.metadata);
              break;
            case /* string key */
            2:
              y.key = d.string();
              break;
            case /* string version */
            3:
              y.version = d.string();
              break;
            default:
              let f = E.readUnknownField;
              if (f === "throw")
                throw new globalThis.Error(`Unknown field ${I} (wire type ${w}) for ${this.typeName}`);
              let C = d.skip(w);
              f !== !1 && (f === !0 ? n.UnknownFieldHandler.onRead : f)(this.typeName, y, I, w, C);
          }
        }
        return y;
      }
      internalBinaryWrite(d, p, E) {
        d.metadata && c.CacheMetadata.internalBinaryWrite(d.metadata, p.tag(1, r.WireType.LengthDelimited).fork(), E).join(), d.key !== "" && p.tag(2, r.WireType.LengthDelimited).string(d.key), d.version !== "" && p.tag(3, r.WireType.LengthDelimited).string(d.version);
        let B = E.writeUnknownFields;
        return B !== !1 && (B == !0 ? n.UnknownFieldHandler.onWrite : B)(this.typeName, d, p), p;
      }
    }
    t.CreateCacheEntryRequest = new l();
    class A extends o.MessageType {
      constructor() {
        super("github.actions.results.api.v1.CreateCacheEntryResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "signed_upload_url",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(d) {
        const p = { ok: !1, signedUploadUrl: "" };
        return globalThis.Object.defineProperty(p, i.MESSAGE_TYPE, { enumerable: !1, value: this }), d !== void 0 && (0, s.reflectionMergePartial)(this, p, d), p;
      }
      internalBinaryRead(d, p, E, B) {
        let y = B ?? this.create(), Q = d.pos + p;
        for (; d.pos < Q; ) {
          let [I, w] = d.tag();
          switch (I) {
            case /* bool ok */
            1:
              y.ok = d.bool();
              break;
            case /* string signed_upload_url */
            2:
              y.signedUploadUrl = d.string();
              break;
            default:
              let f = E.readUnknownField;
              if (f === "throw")
                throw new globalThis.Error(`Unknown field ${I} (wire type ${w}) for ${this.typeName}`);
              let C = d.skip(w);
              f !== !1 && (f === !0 ? n.UnknownFieldHandler.onRead : f)(this.typeName, y, I, w, C);
          }
        }
        return y;
      }
      internalBinaryWrite(d, p, E) {
        d.ok !== !1 && p.tag(1, r.WireType.Varint).bool(d.ok), d.signedUploadUrl !== "" && p.tag(2, r.WireType.LengthDelimited).string(d.signedUploadUrl);
        let B = E.writeUnknownFields;
        return B !== !1 && (B == !0 ? n.UnknownFieldHandler.onWrite : B)(this.typeName, d, p), p;
      }
    }
    t.CreateCacheEntryResponse = new A();
    class a extends o.MessageType {
      constructor() {
        super("github.actions.results.api.v1.FinalizeCacheEntryUploadRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => c.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "size_bytes",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          },
          {
            no: 4,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(d) {
        const p = { key: "", sizeBytes: "0", version: "" };
        return globalThis.Object.defineProperty(p, i.MESSAGE_TYPE, { enumerable: !1, value: this }), d !== void 0 && (0, s.reflectionMergePartial)(this, p, d), p;
      }
      internalBinaryRead(d, p, E, B) {
        let y = B ?? this.create(), Q = d.pos + p;
        for (; d.pos < Q; ) {
          let [I, w] = d.tag();
          switch (I) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              y.metadata = c.CacheMetadata.internalBinaryRead(d, d.uint32(), E, y.metadata);
              break;
            case /* string key */
            2:
              y.key = d.string();
              break;
            case /* int64 size_bytes */
            3:
              y.sizeBytes = d.int64().toString();
              break;
            case /* string version */
            4:
              y.version = d.string();
              break;
            default:
              let f = E.readUnknownField;
              if (f === "throw")
                throw new globalThis.Error(`Unknown field ${I} (wire type ${w}) for ${this.typeName}`);
              let C = d.skip(w);
              f !== !1 && (f === !0 ? n.UnknownFieldHandler.onRead : f)(this.typeName, y, I, w, C);
          }
        }
        return y;
      }
      internalBinaryWrite(d, p, E) {
        d.metadata && c.CacheMetadata.internalBinaryWrite(d.metadata, p.tag(1, r.WireType.LengthDelimited).fork(), E).join(), d.key !== "" && p.tag(2, r.WireType.LengthDelimited).string(d.key), d.sizeBytes !== "0" && p.tag(3, r.WireType.Varint).int64(d.sizeBytes), d.version !== "" && p.tag(4, r.WireType.LengthDelimited).string(d.version);
        let B = E.writeUnknownFields;
        return B !== !1 && (B == !0 ? n.UnknownFieldHandler.onWrite : B)(this.typeName, d, p), p;
      }
    }
    t.FinalizeCacheEntryUploadRequest = new a();
    class u extends o.MessageType {
      constructor() {
        super("github.actions.results.api.v1.FinalizeCacheEntryUploadResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "entry_id",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          }
        ]);
      }
      create(d) {
        const p = { ok: !1, entryId: "0" };
        return globalThis.Object.defineProperty(p, i.MESSAGE_TYPE, { enumerable: !1, value: this }), d !== void 0 && (0, s.reflectionMergePartial)(this, p, d), p;
      }
      internalBinaryRead(d, p, E, B) {
        let y = B ?? this.create(), Q = d.pos + p;
        for (; d.pos < Q; ) {
          let [I, w] = d.tag();
          switch (I) {
            case /* bool ok */
            1:
              y.ok = d.bool();
              break;
            case /* int64 entry_id */
            2:
              y.entryId = d.int64().toString();
              break;
            default:
              let f = E.readUnknownField;
              if (f === "throw")
                throw new globalThis.Error(`Unknown field ${I} (wire type ${w}) for ${this.typeName}`);
              let C = d.skip(w);
              f !== !1 && (f === !0 ? n.UnknownFieldHandler.onRead : f)(this.typeName, y, I, w, C);
          }
        }
        return y;
      }
      internalBinaryWrite(d, p, E) {
        d.ok !== !1 && p.tag(1, r.WireType.Varint).bool(d.ok), d.entryId !== "0" && p.tag(2, r.WireType.Varint).int64(d.entryId);
        let B = E.writeUnknownFields;
        return B !== !1 && (B == !0 ? n.UnknownFieldHandler.onWrite : B)(this.typeName, d, p), p;
      }
    }
    t.FinalizeCacheEntryUploadResponse = new u();
    class g extends o.MessageType {
      constructor() {
        super("github.actions.results.api.v1.GetCacheEntryDownloadURLRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => c.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "restore_keys",
            kind: "scalar",
            repeat: 2,
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 4,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(d) {
        const p = { key: "", restoreKeys: [], version: "" };
        return globalThis.Object.defineProperty(p, i.MESSAGE_TYPE, { enumerable: !1, value: this }), d !== void 0 && (0, s.reflectionMergePartial)(this, p, d), p;
      }
      internalBinaryRead(d, p, E, B) {
        let y = B ?? this.create(), Q = d.pos + p;
        for (; d.pos < Q; ) {
          let [I, w] = d.tag();
          switch (I) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              y.metadata = c.CacheMetadata.internalBinaryRead(d, d.uint32(), E, y.metadata);
              break;
            case /* string key */
            2:
              y.key = d.string();
              break;
            case /* repeated string restore_keys */
            3:
              y.restoreKeys.push(d.string());
              break;
            case /* string version */
            4:
              y.version = d.string();
              break;
            default:
              let f = E.readUnknownField;
              if (f === "throw")
                throw new globalThis.Error(`Unknown field ${I} (wire type ${w}) for ${this.typeName}`);
              let C = d.skip(w);
              f !== !1 && (f === !0 ? n.UnknownFieldHandler.onRead : f)(this.typeName, y, I, w, C);
          }
        }
        return y;
      }
      internalBinaryWrite(d, p, E) {
        d.metadata && c.CacheMetadata.internalBinaryWrite(d.metadata, p.tag(1, r.WireType.LengthDelimited).fork(), E).join(), d.key !== "" && p.tag(2, r.WireType.LengthDelimited).string(d.key);
        for (let y = 0; y < d.restoreKeys.length; y++)
          p.tag(3, r.WireType.LengthDelimited).string(d.restoreKeys[y]);
        d.version !== "" && p.tag(4, r.WireType.LengthDelimited).string(d.version);
        let B = E.writeUnknownFields;
        return B !== !1 && (B == !0 ? n.UnknownFieldHandler.onWrite : B)(this.typeName, d, p), p;
      }
    }
    t.GetCacheEntryDownloadURLRequest = new g();
    class h extends o.MessageType {
      constructor() {
        super("github.actions.results.api.v1.GetCacheEntryDownloadURLResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "signed_download_url",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "matched_key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(d) {
        const p = { ok: !1, signedDownloadUrl: "", matchedKey: "" };
        return globalThis.Object.defineProperty(p, i.MESSAGE_TYPE, { enumerable: !1, value: this }), d !== void 0 && (0, s.reflectionMergePartial)(this, p, d), p;
      }
      internalBinaryRead(d, p, E, B) {
        let y = B ?? this.create(), Q = d.pos + p;
        for (; d.pos < Q; ) {
          let [I, w] = d.tag();
          switch (I) {
            case /* bool ok */
            1:
              y.ok = d.bool();
              break;
            case /* string signed_download_url */
            2:
              y.signedDownloadUrl = d.string();
              break;
            case /* string matched_key */
            3:
              y.matchedKey = d.string();
              break;
            default:
              let f = E.readUnknownField;
              if (f === "throw")
                throw new globalThis.Error(`Unknown field ${I} (wire type ${w}) for ${this.typeName}`);
              let C = d.skip(w);
              f !== !1 && (f === !0 ? n.UnknownFieldHandler.onRead : f)(this.typeName, y, I, w, C);
          }
        }
        return y;
      }
      internalBinaryWrite(d, p, E) {
        d.ok !== !1 && p.tag(1, r.WireType.Varint).bool(d.ok), d.signedDownloadUrl !== "" && p.tag(2, r.WireType.LengthDelimited).string(d.signedDownloadUrl), d.matchedKey !== "" && p.tag(3, r.WireType.LengthDelimited).string(d.matchedKey);
        let B = E.writeUnknownFields;
        return B !== !1 && (B == !0 ? n.UnknownFieldHandler.onWrite : B)(this.typeName, d, p), p;
      }
    }
    t.GetCacheEntryDownloadURLResponse = new h(), t.CacheService = new e.ServiceType("github.actions.results.api.v1.CacheService", [
      { name: "CreateCacheEntry", options: {}, I: t.CreateCacheEntryRequest, O: t.CreateCacheEntryResponse },
      { name: "FinalizeCacheEntryUpload", options: {}, I: t.FinalizeCacheEntryUploadRequest, O: t.FinalizeCacheEntryUploadResponse },
      { name: "GetCacheEntryDownloadURL", options: {}, I: t.GetCacheEntryDownloadURLRequest, O: t.GetCacheEntryDownloadURLResponse }
    ]);
  }(Oc)), Oc;
}
var Ep;
function iF() {
  if (Ep) return Wn;
  Ep = 1, Object.defineProperty(Wn, "__esModule", { value: !0 }), Wn.CacheServiceClientProtobuf = Wn.CacheServiceClientJSON = void 0;
  const t = sF();
  class e {
    constructor(s) {
      this.rpc = s, this.CreateCacheEntry.bind(this), this.FinalizeCacheEntryUpload.bind(this), this.GetCacheEntryDownloadURL.bind(this);
    }
    CreateCacheEntry(s) {
      const i = t.CreateCacheEntryRequest.toJson(s, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/json", i).then((c) => t.CreateCacheEntryResponse.fromJson(c, {
        ignoreUnknownFields: !0
      }));
    }
    FinalizeCacheEntryUpload(s) {
      const i = t.FinalizeCacheEntryUploadRequest.toJson(s, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/json", i).then((c) => t.FinalizeCacheEntryUploadResponse.fromJson(c, {
        ignoreUnknownFields: !0
      }));
    }
    GetCacheEntryDownloadURL(s) {
      const i = t.GetCacheEntryDownloadURLRequest.toJson(s, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/json", i).then((c) => t.GetCacheEntryDownloadURLResponse.fromJson(c, {
        ignoreUnknownFields: !0
      }));
    }
  }
  Wn.CacheServiceClientJSON = e;
  class r {
    constructor(s) {
      this.rpc = s, this.CreateCacheEntry.bind(this), this.FinalizeCacheEntryUpload.bind(this), this.GetCacheEntryDownloadURL.bind(this);
    }
    CreateCacheEntry(s) {
      const i = t.CreateCacheEntryRequest.toBinary(s);
      return this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/protobuf", i).then((c) => t.CreateCacheEntryResponse.fromBinary(c));
    }
    FinalizeCacheEntryUpload(s) {
      const i = t.FinalizeCacheEntryUploadRequest.toBinary(s);
      return this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/protobuf", i).then((c) => t.FinalizeCacheEntryUploadResponse.fromBinary(c));
    }
    GetCacheEntryDownloadURL(s) {
      const i = t.GetCacheEntryDownloadURLRequest.toBinary(s);
      return this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/protobuf", i).then((c) => t.GetCacheEntryDownloadURLResponse.fromBinary(c));
    }
  }
  return Wn.CacheServiceClientProtobuf = r, Wn;
}
var jn = {}, Cp;
function oF() {
  if (Cp) return jn;
  Cp = 1, Object.defineProperty(jn, "__esModule", { value: !0 }), jn.maskSecretUrls = jn.maskSigUrl = void 0;
  const t = ir();
  function e(n) {
    if (n)
      try {
        const i = new URL(n).searchParams.get("sig");
        i && ((0, t.setSecret)(i), (0, t.setSecret)(encodeURIComponent(i)));
      } catch (s) {
        (0, t.debug)(`Failed to parse URL: ${n} ${s instanceof Error ? s.message : String(s)}`);
      }
  }
  jn.maskSigUrl = e;
  function r(n) {
    if (typeof n != "object" || n === null) {
      (0, t.debug)("body is not an object or is null");
      return;
    }
    "signed_upload_url" in n && typeof n.signed_upload_url == "string" && e(n.signed_upload_url), "signed_download_url" in n && typeof n.signed_download_url == "string" && e(n.signed_download_url);
  }
  return jn.maskSecretUrls = r, jn;
}
var Bp;
function aF() {
  if (Bp) return Vn;
  Bp = 1;
  var t = Vn && Vn.__awaiter || function(g, h, m, d) {
    function p(E) {
      return E instanceof m ? E : new m(function(B) {
        B(E);
      });
    }
    return new (m || (m = Promise))(function(E, B) {
      function y(w) {
        try {
          I(d.next(w));
        } catch (f) {
          B(f);
        }
      }
      function Q(w) {
        try {
          I(d.throw(w));
        } catch (f) {
          B(f);
        }
      }
      function I(w) {
        w.done ? E(w.value) : p(w.value).then(y, Q);
      }
      I((d = d.apply(g, h || [])).next());
    });
  };
  Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.internalCacheTwirpClient = void 0;
  const e = ir(), r = Yy(), n = qy(), s = ld(), i = so(), o = fu(), c = kn(), l = iF(), A = oF();
  class a {
    constructor(h, m, d, p) {
      this.maxAttempts = 5, this.baseRetryIntervalMilliseconds = 3e3, this.retryMultiplier = 1.5;
      const E = (0, i.getRuntimeToken)();
      this.baseUrl = (0, s.getCacheServiceURL)(), m && (this.maxAttempts = m), d && (this.baseRetryIntervalMilliseconds = d), p && (this.retryMultiplier = p), this.httpClient = new c.HttpClient(h, [
        new o.BearerCredentialHandler(E)
      ]);
    }
    // This function satisfies the Rpc interface. It is compatible with the JSON
    // JSON generated client.
    request(h, m, d, p) {
      return t(this, void 0, void 0, function* () {
        const E = new URL(`/twirp/${h}/${m}`, this.baseUrl).href;
        (0, e.debug)(`[Request] ${m} ${E}`);
        const B = {
          "Content-Type": d
        };
        try {
          const { body: y } = yield this.retryableRequest(() => t(this, void 0, void 0, function* () {
            return this.httpClient.post(E, JSON.stringify(p), B);
          }));
          return y;
        } catch (y) {
          throw new Error(`Failed to ${m}: ${y.message}`);
        }
      });
    }
    retryableRequest(h) {
      return t(this, void 0, void 0, function* () {
        let m = 0, d = "", p = "";
        for (; m < this.maxAttempts; ) {
          let E = !1;
          try {
            const y = yield h(), Q = y.message.statusCode;
            p = yield y.readBody(), (0, e.debug)(`[Response] - ${y.message.statusCode}`), (0, e.debug)(`Headers: ${JSON.stringify(y.message.headers, null, 2)}`);
            const I = JSON.parse(p);
            if ((0, A.maskSecretUrls)(I), (0, e.debug)(`Body: ${JSON.stringify(I, null, 2)}`), this.isSuccessStatusCode(Q))
              return { response: y, body: I };
            if (E = this.isRetryableHttpStatusCode(Q), d = `Failed request: (${Q}) ${y.message.statusMessage}`, I.msg) {
              if (n.UsageError.isUsageErrorMessage(I.msg))
                throw new n.UsageError();
              d = `${d}: ${I.msg}`;
            }
          } catch (y) {
            if (y instanceof SyntaxError && (0, e.debug)(`Raw Body: ${p}`), y instanceof n.UsageError)
              throw y;
            if (n.NetworkError.isNetworkErrorCode(y?.code))
              throw new n.NetworkError(y?.code);
            E = !0, d = y.message;
          }
          if (!E)
            throw new Error(`Received non-retryable error: ${d}`);
          if (m + 1 === this.maxAttempts)
            throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${d}`);
          const B = this.getExponentialRetryTimeMilliseconds(m);
          (0, e.info)(`Attempt ${m + 1} of ${this.maxAttempts} failed with error: ${d}. Retrying request in ${B} ms...`), yield this.sleep(B), m++;
        }
        throw new Error("Request failed");
      });
    }
    isSuccessStatusCode(h) {
      return h ? h >= 200 && h < 300 : !1;
    }
    isRetryableHttpStatusCode(h) {
      return h ? [
        c.HttpCodes.BadGateway,
        c.HttpCodes.GatewayTimeout,
        c.HttpCodes.InternalServerError,
        c.HttpCodes.ServiceUnavailable,
        c.HttpCodes.TooManyRequests
      ].includes(h) : !1;
    }
    sleep(h) {
      return t(this, void 0, void 0, function* () {
        return new Promise((m) => setTimeout(m, h));
      });
    }
    getExponentialRetryTimeMilliseconds(h) {
      if (h < 0)
        throw new Error("attempt should be a positive integer");
      if (h === 0)
        return this.baseRetryIntervalMilliseconds;
      const m = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, h), d = m * this.retryMultiplier;
      return Math.trunc(Math.random() * (d - m) + m);
    }
  }
  function u(g) {
    const h = new a((0, r.getUserAgentString)(), g?.maxAttempts, g?.retryIntervalMs, g?.retryMultiplier);
    return new l.CacheServiceClientJSON(h);
  }
  return Vn.internalCacheTwirpClient = u, Vn;
}
var tr = {}, Ip;
function AF() {
  if (Ip) return tr;
  Ip = 1;
  var t = tr && tr.__createBinding || (Object.create ? function(I, w, f, C) {
    C === void 0 && (C = f);
    var b = Object.getOwnPropertyDescriptor(w, f);
    (!b || ("get" in b ? !w.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return w[f];
    } }), Object.defineProperty(I, C, b);
  } : function(I, w, f, C) {
    C === void 0 && (C = f), I[C] = w[f];
  }), e = tr && tr.__setModuleDefault || (Object.create ? function(I, w) {
    Object.defineProperty(I, "default", { enumerable: !0, value: w });
  } : function(I, w) {
    I.default = w;
  }), r = tr && tr.__importStar || function(I) {
    if (I && I.__esModule) return I;
    var w = {};
    if (I != null) for (var f in I) f !== "default" && Object.prototype.hasOwnProperty.call(I, f) && t(w, I, f);
    return e(w, I), w;
  }, n = tr && tr.__awaiter || function(I, w, f, C) {
    function b(N) {
      return N instanceof f ? N : new f(function(v) {
        v(N);
      });
    }
    return new (f || (f = Promise))(function(N, v) {
      function R(D) {
        try {
          S(C.next(D));
        } catch (T) {
          v(T);
        }
      }
      function x(D) {
        try {
          S(C.throw(D));
        } catch (T) {
          v(T);
        }
      }
      function S(D) {
        D.done ? N(D.value) : b(D.value).then(R, x);
      }
      S((C = C.apply(I, w || [])).next());
    });
  };
  Object.defineProperty(tr, "__esModule", { value: !0 }), tr.createTar = tr.extractTar = tr.listTar = void 0;
  const s = ro(), i = r(to()), o = Zr, c = r(yr), l = r(so()), A = no(), a = process.platform === "win32";
  function u() {
    return n(this, void 0, void 0, function* () {
      switch (process.platform) {
        case "win32": {
          const I = yield l.getGnuTarPathOnWindows(), w = A.SystemTarPathOnWindows;
          if (I)
            return { path: I, type: A.ArchiveToolType.GNU };
          if ((0, o.existsSync)(w))
            return { path: w, type: A.ArchiveToolType.BSD };
          break;
        }
        case "darwin": {
          const I = yield i.which("gtar", !1);
          return I ? { path: I, type: A.ArchiveToolType.GNU } : {
            path: yield i.which("tar", !0),
            type: A.ArchiveToolType.BSD
          };
        }
      }
      return {
        path: yield i.which("tar", !0),
        type: A.ArchiveToolType.GNU
      };
    });
  }
  function g(I, w, f, C = "") {
    return n(this, void 0, void 0, function* () {
      const b = [`"${I.path}"`], N = l.getCacheFileName(w), v = "cache.tar", R = m(), x = I.type === A.ArchiveToolType.BSD && w !== A.CompressionMethod.Gzip && a;
      switch (f) {
        case "create":
          b.push("--posix", "-cf", x ? v : N.replace(new RegExp(`\\${c.sep}`, "g"), "/"), "--exclude", x ? v : N.replace(new RegExp(`\\${c.sep}`, "g"), "/"), "-P", "-C", R.replace(new RegExp(`\\${c.sep}`, "g"), "/"), "--files-from", A.ManifestFilename);
          break;
        case "extract":
          b.push("-xf", x ? v : C.replace(new RegExp(`\\${c.sep}`, "g"), "/"), "-P", "-C", R.replace(new RegExp(`\\${c.sep}`, "g"), "/"));
          break;
        case "list":
          b.push("-tf", x ? v : C.replace(new RegExp(`\\${c.sep}`, "g"), "/"), "-P");
          break;
      }
      if (I.type === A.ArchiveToolType.GNU)
        switch (process.platform) {
          case "win32":
            b.push("--force-local");
            break;
          case "darwin":
            b.push("--delay-directory-restore");
            break;
        }
      return b;
    });
  }
  function h(I, w, f = "") {
    return n(this, void 0, void 0, function* () {
      let C;
      const b = yield u(), N = yield g(b, I, w, f), v = w !== "create" ? yield d(b, I, f) : yield p(b, I), R = b.type === A.ArchiveToolType.BSD && I !== A.CompressionMethod.Gzip && a;
      return R && w !== "create" ? C = [[...v].join(" "), [...N].join(" ")] : C = [[...N].join(" "), [...v].join(" ")], R ? C : [C.join(" ")];
    });
  }
  function m() {
    var I;
    return (I = process.env.GITHUB_WORKSPACE) !== null && I !== void 0 ? I : process.cwd();
  }
  function d(I, w, f) {
    return n(this, void 0, void 0, function* () {
      const C = I.type === A.ArchiveToolType.BSD && w !== A.CompressionMethod.Gzip && a;
      switch (w) {
        case A.CompressionMethod.Zstd:
          return C ? [
            "zstd -d --long=30 --force -o",
            A.TarFilename,
            f.replace(new RegExp(`\\${c.sep}`, "g"), "/")
          ] : [
            "--use-compress-program",
            a ? '"zstd -d --long=30"' : "unzstd --long=30"
          ];
        case A.CompressionMethod.ZstdWithoutLong:
          return C ? [
            "zstd -d --force -o",
            A.TarFilename,
            f.replace(new RegExp(`\\${c.sep}`, "g"), "/")
          ] : ["--use-compress-program", a ? '"zstd -d"' : "unzstd"];
        default:
          return ["-z"];
      }
    });
  }
  function p(I, w) {
    return n(this, void 0, void 0, function* () {
      const f = l.getCacheFileName(w), C = I.type === A.ArchiveToolType.BSD && w !== A.CompressionMethod.Gzip && a;
      switch (w) {
        case A.CompressionMethod.Zstd:
          return C ? [
            "zstd -T0 --long=30 --force -o",
            f.replace(new RegExp(`\\${c.sep}`, "g"), "/"),
            A.TarFilename
          ] : [
            "--use-compress-program",
            a ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
          ];
        case A.CompressionMethod.ZstdWithoutLong:
          return C ? [
            "zstd -T0 --force -o",
            f.replace(new RegExp(`\\${c.sep}`, "g"), "/"),
            A.TarFilename
          ] : ["--use-compress-program", a ? '"zstd -T0"' : "zstdmt"];
        default:
          return ["-z"];
      }
    });
  }
  function E(I, w) {
    return n(this, void 0, void 0, function* () {
      for (const f of I)
        try {
          yield (0, s.exec)(f, void 0, {
            cwd: w,
            env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
          });
        } catch (C) {
          throw new Error(`${f.split(" ")[0]} failed with error: ${C?.message}`);
        }
    });
  }
  function B(I, w) {
    return n(this, void 0, void 0, function* () {
      const f = yield h(w, "list", I);
      yield E(f);
    });
  }
  tr.listTar = B;
  function y(I, w) {
    return n(this, void 0, void 0, function* () {
      const f = m();
      yield i.mkdirP(f);
      const C = yield h(w, "extract", I);
      yield E(C);
    });
  }
  tr.extractTar = y;
  function Q(I, w, f) {
    return n(this, void 0, void 0, function* () {
      (0, o.writeFileSync)(c.join(I, A.ManifestFilename), w.join(`
`));
      const C = yield h(f, "create");
      yield E(C, I);
    });
  }
  return tr.createTar = Q, tr;
}
var yp;
function cF() {
  if (yp) return _t;
  yp = 1;
  var t = _t && _t.__createBinding || (Object.create ? function(f, C, b, N) {
    N === void 0 && (N = b);
    var v = Object.getOwnPropertyDescriptor(C, b);
    (!v || ("get" in v ? !C.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return C[b];
    } }), Object.defineProperty(f, N, v);
  } : function(f, C, b, N) {
    N === void 0 && (N = b), f[N] = C[b];
  }), e = _t && _t.__setModuleDefault || (Object.create ? function(f, C) {
    Object.defineProperty(f, "default", { enumerable: !0, value: C });
  } : function(f, C) {
    f.default = C;
  }), r = _t && _t.__importStar || function(f) {
    if (f && f.__esModule) return f;
    var C = {};
    if (f != null) for (var b in f) b !== "default" && Object.prototype.hasOwnProperty.call(f, b) && t(C, f, b);
    return e(C, f), C;
  }, n = _t && _t.__awaiter || function(f, C, b, N) {
    function v(R) {
      return R instanceof b ? R : new b(function(x) {
        x(R);
      });
    }
    return new (b || (b = Promise))(function(R, x) {
      function S(k) {
        try {
          T(N.next(k));
        } catch (L) {
          x(L);
        }
      }
      function D(k) {
        try {
          T(N.throw(k));
        } catch (L) {
          x(L);
        }
      }
      function T(k) {
        k.done ? R(k.value) : v(k.value).then(S, D);
      }
      T((N = N.apply(f, C || [])).next());
    });
  };
  Object.defineProperty(_t, "__esModule", { value: !0 }), _t.saveCache = _t.restoreCache = _t.isFeatureAvailable = _t.ReserveCacheError = _t.ValidationError = void 0;
  const s = r(ir()), i = r(yr), o = r(so()), c = r(pk()), l = r(aF()), A = ld(), a = AF(), u = no();
  class g extends Error {
    constructor(C) {
      super(C), this.name = "ValidationError", Object.setPrototypeOf(this, g.prototype);
    }
  }
  _t.ValidationError = g;
  class h extends Error {
    constructor(C) {
      super(C), this.name = "ReserveCacheError", Object.setPrototypeOf(this, h.prototype);
    }
  }
  _t.ReserveCacheError = h;
  function m(f) {
    if (!f || f.length === 0)
      throw new g("Path Validation Error: At least one directory or file path is required");
  }
  function d(f) {
    if (f.length > 512)
      throw new g(`Key Validation Error: ${f} cannot be larger than 512 characters.`);
    if (!/^[^,]*$/.test(f))
      throw new g(`Key Validation Error: ${f} cannot contain commas.`);
  }
  function p() {
    return !!process.env.ACTIONS_CACHE_URL;
  }
  _t.isFeatureAvailable = p;
  function E(f, C, b, N, v = !1) {
    return n(this, void 0, void 0, function* () {
      const R = (0, A.getCacheServiceVersion)();
      switch (s.debug(`Cache service version: ${R}`), m(f), R) {
        case "v2":
          return yield y(f, C, b, N, v);
        case "v1":
        default:
          return yield B(f, C, b, N, v);
      }
    });
  }
  _t.restoreCache = E;
  function B(f, C, b, N, v = !1) {
    return n(this, void 0, void 0, function* () {
      b = b || [];
      const R = [C, ...b];
      if (s.debug("Resolved Keys:"), s.debug(JSON.stringify(R)), R.length > 10)
        throw new g("Key Validation Error: Keys are limited to a maximum of 10.");
      for (const D of R)
        d(D);
      const x = yield o.getCompressionMethod();
      let S = "";
      try {
        const D = yield c.getCacheEntry(R, f, {
          compressionMethod: x,
          enableCrossOsArchive: v
        });
        if (!D?.archiveLocation)
          return;
        if (N?.lookupOnly)
          return s.info("Lookup only - skipping download"), D.cacheKey;
        S = i.join(yield o.createTempDirectory(), o.getCacheFileName(x)), s.debug(`Archive Path: ${S}`), yield c.downloadCache(D.archiveLocation, S, N), s.isDebug() && (yield (0, a.listTar)(S, x));
        const T = o.getArchiveFileSizeInBytes(S);
        return s.info(`Cache Size: ~${Math.round(T / (1024 * 1024))} MB (${T} B)`), yield (0, a.extractTar)(S, x), s.info("Cache restored successfully"), D.cacheKey;
      } catch (D) {
        if (D.name === g.name)
          throw D;
        s.warning(`Failed to restore: ${D.message}`);
      } finally {
        try {
          yield o.unlinkFile(S);
        } catch (D) {
          s.debug(`Failed to delete archive: ${D}`);
        }
      }
    });
  }
  function y(f, C, b, N, v = !1) {
    return n(this, void 0, void 0, function* () {
      N = Object.assign(Object.assign({}, N), { useAzureSdk: !0 }), b = b || [];
      const R = [C, ...b];
      if (s.debug("Resolved Keys:"), s.debug(JSON.stringify(R)), R.length > 10)
        throw new g("Key Validation Error: Keys are limited to a maximum of 10.");
      for (const S of R)
        d(S);
      let x = "";
      try {
        const S = l.internalCacheTwirpClient(), D = yield o.getCompressionMethod(), T = {
          key: C,
          restoreKeys: b,
          version: o.getCacheVersion(f, D, v)
        }, k = yield S.GetCacheEntryDownloadURL(T);
        if (!k.ok) {
          s.debug(`Cache not found for version ${T.version} of keys: ${R.join(", ")}`);
          return;
        }
        if (s.info(`Cache hit for: ${T.key}`), N?.lookupOnly)
          return s.info("Lookup only - skipping download"), k.matchedKey;
        x = i.join(yield o.createTempDirectory(), o.getCacheFileName(D)), s.debug(`Archive path: ${x}`), s.debug(`Starting download of archive to: ${x}`), yield c.downloadCache(k.signedDownloadUrl, x, N);
        const L = o.getArchiveFileSizeInBytes(x);
        return s.info(`Cache Size: ~${Math.round(L / (1024 * 1024))} MB (${L} B)`), s.isDebug() && (yield (0, a.listTar)(x, D)), yield (0, a.extractTar)(x, D), s.info("Cache restored successfully"), k.matchedKey;
      } catch (S) {
        if (S.name === g.name)
          throw S;
        s.warning(`Failed to restore: ${S.message}`);
      } finally {
        try {
          x && (yield o.unlinkFile(x));
        } catch (S) {
          s.debug(`Failed to delete archive: ${S}`);
        }
      }
    });
  }
  function Q(f, C, b, N = !1) {
    return n(this, void 0, void 0, function* () {
      const v = (0, A.getCacheServiceVersion)();
      switch (s.debug(`Cache service version: ${v}`), m(f), d(C), v) {
        case "v2":
          return yield w(f, C, b, N);
        case "v1":
        default:
          return yield I(f, C, b, N);
      }
    });
  }
  _t.saveCache = Q;
  function I(f, C, b, N = !1) {
    var v, R, x, S, D;
    return n(this, void 0, void 0, function* () {
      const T = yield o.getCompressionMethod();
      let k = -1;
      const L = yield o.resolvePaths(f);
      if (s.debug("Cache Paths:"), s.debug(`${JSON.stringify(L)}`), L.length === 0)
        throw new Error("Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.");
      const W = yield o.createTempDirectory(), O = i.join(W, o.getCacheFileName(T));
      s.debug(`Archive Path: ${O}`);
      try {
        yield (0, a.createTar)(W, L, T), s.isDebug() && (yield (0, a.listTar)(O, T));
        const _ = 10 * 1024 * 1024 * 1024, M = o.getArchiveFileSizeInBytes(O);
        if (s.debug(`File Size: ${M}`), M > _ && !(0, A.isGhes)())
          throw new Error(`Cache size of ~${Math.round(M / (1024 * 1024))} MB (${M} B) is over the 10GB limit, not saving cache.`);
        s.debug("Reserving Cache");
        const $ = yield c.reserveCache(C, f, {
          compressionMethod: T,
          enableCrossOsArchive: N,
          cacheSize: M
        });
        if (!((v = $?.result) === null || v === void 0) && v.cacheId)
          k = (R = $?.result) === null || R === void 0 ? void 0 : R.cacheId;
        else throw $?.statusCode === 400 ? new Error((S = (x = $?.error) === null || x === void 0 ? void 0 : x.message) !== null && S !== void 0 ? S : `Cache size of ~${Math.round(M / (1024 * 1024))} MB (${M} B) is over the data cap limit, not saving cache.`) : new h(`Unable to reserve cache with key ${C}, another job may be creating this cache. More details: ${(D = $?.error) === null || D === void 0 ? void 0 : D.message}`);
        s.debug(`Saving Cache (ID: ${k})`), yield c.saveCache(k, O, "", b);
      } catch (_) {
        const M = _;
        if (M.name === g.name)
          throw _;
        M.name === h.name ? s.info(`Failed to save: ${M.message}`) : s.warning(`Failed to save: ${M.message}`);
      } finally {
        try {
          yield o.unlinkFile(O);
        } catch (_) {
          s.debug(`Failed to delete archive: ${_}`);
        }
      }
      return k;
    });
  }
  function w(f, C, b, N = !1) {
    return n(this, void 0, void 0, function* () {
      b = Object.assign(Object.assign({}, b), { uploadChunkSize: 64 * 1024 * 1024, uploadConcurrency: 8, useAzureSdk: !0 });
      const v = yield o.getCompressionMethod(), R = l.internalCacheTwirpClient();
      let x = -1;
      const S = yield o.resolvePaths(f);
      if (s.debug("Cache Paths:"), s.debug(`${JSON.stringify(S)}`), S.length === 0)
        throw new Error("Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.");
      const D = yield o.createTempDirectory(), T = i.join(D, o.getCacheFileName(v));
      s.debug(`Archive Path: ${T}`);
      try {
        yield (0, a.createTar)(D, S, v), s.isDebug() && (yield (0, a.listTar)(T, v));
        const k = o.getArchiveFileSizeInBytes(T);
        if (s.debug(`File Size: ${k}`), k > u.CacheFileSizeLimit && !(0, A.isGhes)())
          throw new Error(`Cache size of ~${Math.round(k / (1024 * 1024))} MB (${k} B) is over the 10GB limit, not saving cache.`);
        b.archiveSizeBytes = k, s.debug("Reserving Cache");
        const L = o.getCacheVersion(f, v, N), W = {
          key: C,
          version: L
        };
        let O;
        try {
          const $ = yield R.CreateCacheEntry(W);
          if (!$.ok)
            throw new Error("Response was not ok");
          O = $.signedUploadUrl;
        } catch ($) {
          throw s.debug(`Failed to reserve cache: ${$}`), new h(`Unable to reserve cache with key ${C}, another job may be creating this cache.`);
        }
        s.debug(`Attempting to upload cache located at: ${T}`), yield c.saveCache(x, T, O, b);
        const _ = {
          key: C,
          version: L,
          sizeBytes: `${k}`
        }, M = yield R.FinalizeCacheEntryUpload(_);
        if (s.debug(`FinalizeCacheEntryUploadResponse: ${M.ok}`), !M.ok)
          throw new Error(`Unable to finalize cache with key ${C}, another job may be finalizing this cache.`);
        x = parseInt(M.entryId);
      } catch (k) {
        const L = k;
        if (L.name === g.name)
          throw k;
        L.name === h.name ? s.info(`Failed to save: ${L.message}`) : s.warning(`Failed to save: ${L.message}`);
      } finally {
        try {
          yield o.unlinkFile(T);
        } catch (k) {
          s.debug(`Failed to delete archive: ${k}`);
        }
      }
      return x;
    });
  }
  return _t;
}
var Uo = cF(), nu = to(), lF = kn();
async function uF(t) {
  var e;
  const r = `https://crates.io/api/v1/crates/${t}`, s = await new lF.HttpClient("@actions-rs-plus (https://github.com/actions-rs-plus/)").getJson(r);
  if (s.result === null)
    throw new Error(`Unable to fetch latest crate version of "${t}"`);
  if ("errors" in s.result)
    throw new Error(
      `Unable to fetch latest crate version of "${t}", server returned ${JSON.stringify(s.result, null, 2)}`
    );
  if (((e = s.result.crate) == null ? void 0 : e.newest_version) === void 0)
    throw new Error(`Unable to fetch latest crate version of "${t}"`);
  return s.result.crate.newest_version;
}
class ba extends cE {
  constructor(e) {
    super(e);
  }
  static async get() {
    try {
      const e = await nu.which("cargo", !0);
      return new ba(e);
    } catch (e) {
      throw mt.error(
        "cargo is not installed by default for some virtual environments, see https://help.github.com/en/articles/software-in-virtual-environments-for-github-actions"
      ), mt.error("To install it, use this action: https://github.com/actions-rs/toolchain"), e;
    }
  }
  /**
   * Executes `cargo install ${program}`.
   *
   * TODO: Caching ability implementation is blocked,
   * see https://github.com/actions-rs/core/issues/31
   * As for now it acts just like an stub and simply installs the program
   * on each call.
   *
   * `version` argument could be either actual program version or `"latest"` string,
   * which can be provided by user input.
   *
   * If `version` is `undefined` or `"latest"`, this method could call the Crates.io API,
   * fetch the latest version and search for it in cache.
   * TODO: Actually implement this.
   *
   * ## Returns
   *
   * Path to the installed program.
   * As the $PATH should be already tuned properly at this point,
   * returned value at the moment is simply equal to the `program` argument.
   */
  async installCached(e, r, n, s = []) {
    if (r === "latest" && (r = await uF(e)), n === void 0)
      return this.install(e, r);
    const i = [Is.join(Is.dirname(this.path), e)], o = r === void 0 ? "" : `-${r}`, c = `${e}${o}-${n}`, l = s.map((u) => `${e}${o}-${u}`), A = await Uo.restoreCache(i, c, l);
    if (A !== void 0)
      return mt.info(`Using cached \`${e}\` with version ${r ?? "installed-version"} from ${A}`), e;
    const a = await this.install(e, r);
    try {
      mt.info(`Caching \`${e}\` with key ${c}`), await Uo.saveCache(i, c);
    } catch (u) {
      if (u instanceof Error) {
        if (u.name === Uo.ValidationError.name)
          throw u;
        u.name === Uo.ReserveCacheError.name && mt.warning(u.message);
      } else if (typeof u == "string")
        mt.warning(u);
      else
        throw u;
    }
    return a;
  }
  async install(e, r) {
    const n = ["install"];
    r !== void 0 && r !== "latest" && n.push("--version", r), n.push(e);
    try {
      mt.startGroup(`Installing "${e} = ${r ?? "latest"}"`), await this.call(n);
    } finally {
      mt.endGroup();
    }
    return e;
  }
  /**
   * Find the cargo sub-command or install it
   */
  async findOrInstall(e, r) {
    try {
      return await nu.which(e, !0), e;
    } catch {
      mt.info(`${e} is not installed, installing it now`);
    }
    return this.installCached(e, r);
  }
}
class Bs extends cE {
  constructor(e) {
    super(e);
  }
  static async getOrInstall() {
    try {
      return await Bs.get();
    } catch (e) {
      return mt.debug(String(e)), Bs.install();
    }
  }
  static async get() {
    const e = await nu.which("cross", !0);
    return new Bs(e);
  }
  static async install(e) {
    const r = await ba.get(), n = process.cwd();
    process.chdir(_Q.tmpdir());
    try {
      const s = await r.installCached("cross", e);
      return new Bs(s);
    } finally {
      process.chdir(n);
    }
  }
}
var Xe = {}, Si = { exports: {} }, Rn = Si.exports, Qp;
function dF() {
  return Qp || (Qp = 1, function(t, e) {
    var r = Rn && Rn.__createBinding || (Object.create ? function(m, d, p, E) {
      E === void 0 && (E = p);
      var B = Object.getOwnPropertyDescriptor(d, p);
      (!B || ("get" in B ? !d.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
        return d[p];
      } }), Object.defineProperty(m, E, B);
    } : function(m, d, p, E) {
      E === void 0 && (E = p), m[E] = d[p];
    }), n = Rn && Rn.__setModuleDefault || (Object.create ? function(m, d) {
      Object.defineProperty(m, "default", { enumerable: !0, value: d });
    } : function(m, d) {
      m.default = d;
    }), s = Rn && Rn.__importStar || function(m) {
      if (m && m.__esModule) return m;
      var d = {};
      if (m != null) for (var p in m) p !== "default" && Object.prototype.hasOwnProperty.call(m, p) && r(d, m, p);
      return n(d, m), d;
    }, i = Rn && Rn.__awaiter || function(m, d, p, E) {
      function B(y) {
        return y instanceof p ? y : new p(function(Q) {
          Q(y);
        });
      }
      return new (p || (p = Promise))(function(y, Q) {
        function I(C) {
          try {
            f(E.next(C));
          } catch (b) {
            Q(b);
          }
        }
        function w(C) {
          try {
            f(E.throw(C));
          } catch (b) {
            Q(b);
          }
        }
        function f(C) {
          C.done ? y(C.value) : B(C.value).then(I, w);
        }
        f((E = E.apply(m, d || [])).next());
      });
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e._readLinuxVersionFile = e._getOsVersion = e._findMatch = void 0;
    const o = s(yu()), c = ir(), l = cn, A = Nf, a = Zr;
    function u(m, d, p, E) {
      return i(this, void 0, void 0, function* () {
        const B = l.platform();
        let y, Q, I;
        for (const w of p) {
          const f = w.version;
          if ((0, c.debug)(`check ${f} satisfies ${m}`), o.satisfies(f, m) && (!d || w.stable === d) && (I = w.files.find((C) => {
            (0, c.debug)(`${C.arch}===${E} && ${C.platform}===${B}`);
            let b = C.arch === E && C.platform === B;
            if (b && C.platform_version) {
              const N = t.exports._getOsVersion();
              N === C.platform_version ? b = !0 : b = o.satisfies(N, C.platform_version);
            }
            return b;
          }), I)) {
            (0, c.debug)(`matched ${w.version}`), Q = w;
            break;
          }
        }
        return Q && I && (y = Object.assign({}, Q), y.files = [I]), y;
      });
    }
    e._findMatch = u;
    function g() {
      const m = l.platform();
      let d = "";
      if (m === "darwin")
        d = A.execSync("sw_vers -productVersion").toString();
      else if (m === "linux") {
        const p = t.exports._readLinuxVersionFile();
        if (p) {
          const E = p.split(`
`);
          for (const B of E) {
            const y = B.split("=");
            if (y.length === 2 && (y[0].trim() === "VERSION_ID" || y[0].trim() === "DISTRIB_RELEASE")) {
              d = y[1].trim().replace(/^"/, "").replace(/"$/, "");
              break;
            }
          }
        }
      }
      return d;
    }
    e._getOsVersion = g;
    function h() {
      const m = "/etc/lsb-release", d = "/etc/os-release";
      let p = "";
      return a.existsSync(m) ? p = a.readFileSync(m).toString() : a.existsSync(d) && (p = a.readFileSync(d).toString()), p;
    }
    e._readLinuxVersionFile = h;
  }(Si, Si.exports)), Si.exports;
}
var Tr = {}, bp;
function gF() {
  if (bp) return Tr;
  bp = 1;
  var t = Tr && Tr.__createBinding || (Object.create ? function(o, c, l, A) {
    A === void 0 && (A = l);
    var a = Object.getOwnPropertyDescriptor(c, l);
    (!a || ("get" in a ? !c.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return c[l];
    } }), Object.defineProperty(o, A, a);
  } : function(o, c, l, A) {
    A === void 0 && (A = l), o[A] = c[l];
  }), e = Tr && Tr.__setModuleDefault || (Object.create ? function(o, c) {
    Object.defineProperty(o, "default", { enumerable: !0, value: c });
  } : function(o, c) {
    o.default = c;
  }), r = Tr && Tr.__importStar || function(o) {
    if (o && o.__esModule) return o;
    var c = {};
    if (o != null) for (var l in o) l !== "default" && Object.prototype.hasOwnProperty.call(o, l) && t(c, o, l);
    return e(c, o), c;
  }, n = Tr && Tr.__awaiter || function(o, c, l, A) {
    function a(u) {
      return u instanceof l ? u : new l(function(g) {
        g(u);
      });
    }
    return new (l || (l = Promise))(function(u, g) {
      function h(p) {
        try {
          d(A.next(p));
        } catch (E) {
          g(E);
        }
      }
      function m(p) {
        try {
          d(A.throw(p));
        } catch (E) {
          g(E);
        }
      }
      function d(p) {
        p.done ? u(p.value) : a(p.value).then(h, m);
      }
      d((A = A.apply(o, c || [])).next());
    });
  };
  Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.RetryHelper = void 0;
  const s = r(ir());
  class i {
    constructor(c, l, A) {
      if (c < 1)
        throw new Error("max attempts should be greater than or equal to 1");
      if (this.maxAttempts = c, this.minSeconds = Math.floor(l), this.maxSeconds = Math.floor(A), this.minSeconds > this.maxSeconds)
        throw new Error("min seconds should be less than or equal to max seconds");
    }
    execute(c, l) {
      return n(this, void 0, void 0, function* () {
        let A = 1;
        for (; A < this.maxAttempts; ) {
          try {
            return yield c();
          } catch (u) {
            if (l && !l(u))
              throw u;
            s.info(u.message);
          }
          const a = this.getSleepAmount();
          s.info(`Waiting ${a} seconds before trying again`), yield this.sleep(a), A++;
        }
        return yield c();
      });
    }
    getSleepAmount() {
      return Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) + this.minSeconds;
    }
    sleep(c) {
      return n(this, void 0, void 0, function* () {
        return new Promise((l) => setTimeout(l, c * 1e3));
      });
    }
  }
  return Tr.RetryHelper = i, Tr;
}
var wp;
function mF() {
  if (wp) return Xe;
  wp = 1;
  var t = Xe && Xe.__createBinding || (Object.create ? function(G, q, Z, se) {
    se === void 0 && (se = Z);
    var F = Object.getOwnPropertyDescriptor(q, Z);
    (!F || ("get" in F ? !q.__esModule : F.writable || F.configurable)) && (F = { enumerable: !0, get: function() {
      return q[Z];
    } }), Object.defineProperty(G, se, F);
  } : function(G, q, Z, se) {
    se === void 0 && (se = Z), G[se] = q[Z];
  }), e = Xe && Xe.__setModuleDefault || (Object.create ? function(G, q) {
    Object.defineProperty(G, "default", { enumerable: !0, value: q });
  } : function(G, q) {
    G.default = q;
  }), r = Xe && Xe.__importStar || function(G) {
    if (G && G.__esModule) return G;
    var q = {};
    if (G != null) for (var Z in G) Z !== "default" && Object.prototype.hasOwnProperty.call(G, Z) && t(q, G, Z);
    return e(q, G), q;
  }, n = Xe && Xe.__awaiter || function(G, q, Z, se) {
    function F(ne) {
      return ne instanceof Z ? ne : new Z(function(de) {
        de(ne);
      });
    }
    return new (Z || (Z = Promise))(function(ne, de) {
      function ve(xe) {
        try {
          Qe(se.next(xe));
        } catch (_e) {
          de(_e);
        }
      }
      function Ce(xe) {
        try {
          Qe(se.throw(xe));
        } catch (_e) {
          de(_e);
        }
      }
      function Qe(xe) {
        xe.done ? ne(xe.value) : F(xe.value).then(ve, Ce);
      }
      Qe((se = se.apply(G, q || [])).next());
    });
  };
  Object.defineProperty(Xe, "__esModule", { value: !0 }), Xe.evaluateVersions = Xe.isExplicitVersion = Xe.findFromManifest = Xe.getManifestFromRepo = Xe.findAllVersions = Xe.find = Xe.cacheFile = Xe.cacheDir = Xe.extractZip = Xe.extractXar = Xe.extractTar = Xe.extract7z = Xe.downloadTool = Xe.HTTPError = void 0;
  const s = r(ir()), i = r(to()), o = r(su), c = r(Zr), l = r(dF()), A = r(cn), a = r(yr), u = r(kn()), g = r(yu()), h = r(ln), m = r(Qr), d = bt, p = ro(), E = gF();
  class B extends Error {
    constructor(q) {
      super(`Unexpected HTTP response: ${q}`), this.httpStatusCode = q, Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  Xe.HTTPError = B;
  const y = process.platform === "win32", Q = process.platform === "darwin", I = "actions/tool-cache";
  function w(G, q, Z, se) {
    return n(this, void 0, void 0, function* () {
      q = q || a.join(j(), o.randomUUID()), yield i.mkdirP(a.dirname(q)), s.debug(`Downloading ${G}`), s.debug(`Destination ${q}`);
      const F = 3, ne = te("TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS", 10), de = te("TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS", 20);
      return yield new E.RetryHelper(F, ne, de).execute(() => n(this, void 0, void 0, function* () {
        return yield f(G, q || "", Z, se);
      }), (Ce) => !(Ce instanceof B && Ce.httpStatusCode && Ce.httpStatusCode < 500 && Ce.httpStatusCode !== 408 && Ce.httpStatusCode !== 429));
    });
  }
  Xe.downloadTool = w;
  function f(G, q, Z, se) {
    return n(this, void 0, void 0, function* () {
      if (c.existsSync(q))
        throw new Error(`Destination file path ${q} already exists`);
      const F = new u.HttpClient(I, [], {
        allowRetries: !1
      });
      Z && (s.debug("set auth"), se === void 0 && (se = {}), se.authorization = Z);
      const ne = yield F.get(G, se);
      if (ne.message.statusCode !== 200) {
        const xe = new B(ne.message.statusCode);
        throw s.debug(`Failed to download from "${G}". Code(${ne.message.statusCode}) Message(${ne.message.statusMessage})`), xe;
      }
      const de = m.promisify(h.pipeline), Ce = te("TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY", () => ne.message)();
      let Qe = !1;
      try {
        return yield de(Ce, c.createWriteStream(q)), s.debug("download complete"), Qe = !0, q;
      } finally {
        if (!Qe) {
          s.debug("download failed");
          try {
            yield i.rmRF(q);
          } catch (xe) {
            s.debug(`Failed to delete '${q}'. ${xe.message}`);
          }
        }
      }
    });
  }
  function C(G, q, Z) {
    return n(this, void 0, void 0, function* () {
      (0, d.ok)(y, "extract7z() not supported on current OS"), (0, d.ok)(G, 'parameter "file" is required'), q = yield O(q);
      const se = process.cwd();
      if (process.chdir(q), Z)
        try {
          const ne = [
            "x",
            s.isDebug() ? "-bb1" : "-bb0",
            "-bd",
            "-sccUTF-8",
            G
          ], de = {
            silent: !0
          };
          yield (0, p.exec)(`"${Z}"`, ne, de);
        } finally {
          process.chdir(se);
        }
      else {
        const F = a.join(__dirname, "..", "scripts", "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, ""), ne = G.replace(/'/g, "''").replace(/"|\n|\r/g, ""), de = q.replace(/'/g, "''").replace(/"|\n|\r/g, ""), Ce = [
          "-NoLogo",
          "-Sta",
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Unrestricted",
          "-Command",
          `& '${F}' -Source '${ne}' -Target '${de}'`
        ], Qe = {
          silent: !0
        };
        try {
          const xe = yield i.which("powershell", !0);
          yield (0, p.exec)(`"${xe}"`, Ce, Qe);
        } finally {
          process.chdir(se);
        }
      }
      return q;
    });
  }
  Xe.extract7z = C;
  function b(G, q, Z = "xz") {
    return n(this, void 0, void 0, function* () {
      if (!G)
        throw new Error("parameter 'file' is required");
      q = yield O(q), s.debug("Checking tar --version");
      let se = "";
      yield (0, p.exec)("tar --version", [], {
        ignoreReturnCode: !0,
        silent: !0,
        listeners: {
          stdout: (Ce) => se += Ce.toString(),
          stderr: (Ce) => se += Ce.toString()
        }
      }), s.debug(se.trim());
      const F = se.toUpperCase().includes("GNU TAR");
      let ne;
      Z instanceof Array ? ne = Z : ne = [Z], s.isDebug() && !Z.includes("v") && ne.push("-v");
      let de = q, ve = G;
      return y && F && (ne.push("--force-local"), de = q.replace(/\\/g, "/"), ve = G.replace(/\\/g, "/")), F && (ne.push("--warning=no-unknown-keyword"), ne.push("--overwrite")), ne.push("-C", de, "-f", ve), yield (0, p.exec)("tar", ne), q;
    });
  }
  Xe.extractTar = b;
  function N(G, q, Z = []) {
    return n(this, void 0, void 0, function* () {
      (0, d.ok)(Q, "extractXar() not supported on current OS"), (0, d.ok)(G, 'parameter "file" is required'), q = yield O(q);
      let se;
      Z instanceof Array ? se = Z : se = [Z], se.push("-x", "-C", q, "-f", G), s.isDebug() && se.push("-v");
      const F = yield i.which("xar", !0);
      return yield (0, p.exec)(`"${F}"`, ie(se)), q;
    });
  }
  Xe.extractXar = N;
  function v(G, q) {
    return n(this, void 0, void 0, function* () {
      if (!G)
        throw new Error("parameter 'file' is required");
      return q = yield O(q), y ? yield R(G, q) : yield x(G, q), q;
    });
  }
  Xe.extractZip = v;
  function R(G, q) {
    return n(this, void 0, void 0, function* () {
      const Z = G.replace(/'/g, "''").replace(/"|\n|\r/g, ""), se = q.replace(/'/g, "''").replace(/"|\n|\r/g, ""), F = yield i.which("pwsh", !1);
      if (F) {
        const de = [
          "-NoLogo",
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Unrestricted",
          "-Command",
          [
            "$ErrorActionPreference = 'Stop' ;",
            "try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;",
            `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${Z}', '${se}', $true) }`,
            `catch { if (($_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or ($_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${Z}' -DestinationPath '${se}' -Force } else { throw $_ } } ;`
          ].join(" ")
        ];
        s.debug(`Using pwsh at path: ${F}`), yield (0, p.exec)(`"${F}"`, de);
      } else {
        const de = [
          "-NoLogo",
          "-Sta",
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Unrestricted",
          "-Command",
          [
            "$ErrorActionPreference = 'Stop' ;",
            "try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;",
            `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${Z}' -DestinationPath '${se}' -Force }`,
            `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${Z}', '${se}', $true) }`
          ].join(" ")
        ], ve = yield i.which("powershell", !0);
        s.debug(`Using powershell at path: ${ve}`), yield (0, p.exec)(`"${ve}"`, de);
      }
    });
  }
  function x(G, q) {
    return n(this, void 0, void 0, function* () {
      const Z = yield i.which("unzip", !0), se = [G];
      s.isDebug() || se.unshift("-q"), se.unshift("-o"), yield (0, p.exec)(`"${Z}"`, se, { cwd: q });
    });
  }
  function S(G, q, Z, se) {
    return n(this, void 0, void 0, function* () {
      if (Z = g.clean(Z) || Z, se = se || A.arch(), s.debug(`Caching tool ${q} ${Z} ${se}`), s.debug(`source dir: ${G}`), !c.statSync(G).isDirectory())
        throw new Error("sourceDir is not a directory");
      const F = yield _(q, Z, se);
      for (const ne of c.readdirSync(G)) {
        const de = a.join(G, ne);
        yield i.cp(de, F, { recursive: !0 });
      }
      return M(q, Z, se), F;
    });
  }
  Xe.cacheDir = S;
  function D(G, q, Z, se, F) {
    return n(this, void 0, void 0, function* () {
      if (se = g.clean(se) || se, F = F || A.arch(), s.debug(`Caching tool ${Z} ${se} ${F}`), s.debug(`source file: ${G}`), !c.statSync(G).isFile())
        throw new Error("sourceFile is not a file");
      const ne = yield _(Z, se, F), de = a.join(ne, q);
      return s.debug(`destination file ${de}`), yield i.cp(G, de), M(Z, se, F), ne;
    });
  }
  Xe.cacheFile = D;
  function T(G, q, Z) {
    if (!G)
      throw new Error("toolName parameter is required");
    if (!q)
      throw new Error("versionSpec parameter is required");
    if (Z = Z || A.arch(), !$(q)) {
      const F = k(G, Z);
      q = U(F, q);
    }
    let se = "";
    if (q) {
      q = g.clean(q) || "";
      const F = a.join(J(), G, q, Z);
      s.debug(`checking cache: ${F}`), c.existsSync(F) && c.existsSync(`${F}.complete`) ? (s.debug(`Found tool in cache ${G} ${q} ${Z}`), se = F) : s.debug("not found");
    }
    return se;
  }
  Xe.find = T;
  function k(G, q) {
    const Z = [];
    q = q || A.arch();
    const se = a.join(J(), G);
    if (c.existsSync(se)) {
      const F = c.readdirSync(se);
      for (const ne of F)
        if ($(ne)) {
          const de = a.join(se, ne, q || "");
          c.existsSync(de) && c.existsSync(`${de}.complete`) && Z.push(ne);
        }
    }
    return Z;
  }
  Xe.findAllVersions = k;
  function L(G, q, Z, se = "master") {
    return n(this, void 0, void 0, function* () {
      let F = [];
      const ne = `https://api.github.com/repos/${G}/${q}/git/trees/${se}`, de = new u.HttpClient("tool-cache"), ve = {};
      Z && (s.debug("set auth"), ve.authorization = Z);
      const Ce = yield de.getJson(ne, ve);
      if (!Ce.result)
        return F;
      let Qe = "";
      for (const _e of Ce.result.tree)
        if (_e.path === "versions-manifest.json") {
          Qe = _e.url;
          break;
        }
      ve.accept = "application/vnd.github.VERSION.raw";
      let xe = yield (yield de.get(Qe, ve)).readBody();
      if (xe) {
        xe = xe.replace(/^\uFEFF/, "");
        try {
          F = JSON.parse(xe);
        } catch {
          s.debug("Invalid json");
        }
      }
      return F;
    });
  }
  Xe.getManifestFromRepo = L;
  function W(G, q, Z, se = A.arch()) {
    return n(this, void 0, void 0, function* () {
      return yield l._findMatch(G, q, Z, se);
    });
  }
  Xe.findFromManifest = W;
  function O(G) {
    return n(this, void 0, void 0, function* () {
      return G || (G = a.join(j(), o.randomUUID())), yield i.mkdirP(G), G;
    });
  }
  function _(G, q, Z) {
    return n(this, void 0, void 0, function* () {
      const se = a.join(J(), G, g.clean(q) || q, Z || "");
      s.debug(`destination ${se}`);
      const F = `${se}.complete`;
      return yield i.rmRF(se), yield i.rmRF(F), yield i.mkdirP(se), se;
    });
  }
  function M(G, q, Z) {
    const F = `${a.join(J(), G, g.clean(q) || q, Z || "")}.complete`;
    c.writeFileSync(F, ""), s.debug("finished caching tool");
  }
  function $(G) {
    const q = g.clean(G) || "";
    s.debug(`isExplicit: ${q}`);
    const Z = g.valid(q) != null;
    return s.debug(`explicit? ${Z}`), Z;
  }
  Xe.isExplicitVersion = $;
  function U(G, q) {
    let Z = "";
    s.debug(`evaluating ${G.length} versions`), G = G.sort((se, F) => g.gt(se, F) ? 1 : -1);
    for (let se = G.length - 1; se >= 0; se--) {
      const F = G[se];
      if (g.satisfies(F, q)) {
        Z = F;
        break;
      }
    }
    return Z ? s.debug(`matched: ${Z}`) : s.debug("match not found"), Z;
  }
  Xe.evaluateVersions = U;
  function J() {
    const G = process.env.RUNNER_TOOL_CACHE || "";
    return (0, d.ok)(G, "Expected RUNNER_TOOL_CACHE to be defined"), G;
  }
  function j() {
    const G = process.env.RUNNER_TEMP || "";
    return (0, d.ok)(G, "Expected RUNNER_TEMP to be defined"), G;
  }
  function te(G, q) {
    const Z = Ui[G];
    return Z !== void 0 ? Z : q;
  }
  function ie(G) {
    return Array.from(new Set(G));
  }
  return Xe;
}
mF();
var Lo = { exports: {} }, Hc, Np;
function wa() {
  if (Np) return Hc;
  Np = 1;
  const t = "2.0.0", e = 256, r = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, n = 16, s = e - 6;
  return Hc = {
    MAX_LENGTH: e,
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: s,
    MAX_SAFE_INTEGER: r,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: t,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, Hc;
}
var zc, Rp;
function Na() {
  return Rp || (Rp = 1, zc = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
  }), zc;
}
var Sp;
function mo() {
  return Sp || (Sp = 1, function(t, e) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: r,
      MAX_SAFE_BUILD_LENGTH: n,
      MAX_LENGTH: s
    } = wa(), i = Na();
    e = t.exports = {};
    const o = e.re = [], c = e.safeRe = [], l = e.src = [], A = e.safeSrc = [], a = e.t = {};
    let u = 0;
    const g = "[a-zA-Z0-9-]", h = [
      ["\\s", 1],
      ["\\d", s],
      [g, n]
    ], m = (p) => {
      for (const [E, B] of h)
        p = p.split(`${E}*`).join(`${E}{0,${B}}`).split(`${E}+`).join(`${E}{1,${B}}`);
      return p;
    }, d = (p, E, B) => {
      const y = m(E), Q = u++;
      i(p, Q, E), a[p] = Q, l[Q] = E, A[Q] = y, o[Q] = new RegExp(E, B ? "g" : void 0), c[Q] = new RegExp(y, B ? "g" : void 0);
    };
    d("NUMERICIDENTIFIER", "0|[1-9]\\d*"), d("NUMERICIDENTIFIERLOOSE", "\\d+"), d("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${g}*`), d("MAINVERSION", `(${l[a.NUMERICIDENTIFIER]})\\.(${l[a.NUMERICIDENTIFIER]})\\.(${l[a.NUMERICIDENTIFIER]})`), d("MAINVERSIONLOOSE", `(${l[a.NUMERICIDENTIFIERLOOSE]})\\.(${l[a.NUMERICIDENTIFIERLOOSE]})\\.(${l[a.NUMERICIDENTIFIERLOOSE]})`), d("PRERELEASEIDENTIFIER", `(?:${l[a.NONNUMERICIDENTIFIER]}|${l[a.NUMERICIDENTIFIER]})`), d("PRERELEASEIDENTIFIERLOOSE", `(?:${l[a.NONNUMERICIDENTIFIER]}|${l[a.NUMERICIDENTIFIERLOOSE]})`), d("PRERELEASE", `(?:-(${l[a.PRERELEASEIDENTIFIER]}(?:\\.${l[a.PRERELEASEIDENTIFIER]})*))`), d("PRERELEASELOOSE", `(?:-?(${l[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[a.PRERELEASEIDENTIFIERLOOSE]})*))`), d("BUILDIDENTIFIER", `${g}+`), d("BUILD", `(?:\\+(${l[a.BUILDIDENTIFIER]}(?:\\.${l[a.BUILDIDENTIFIER]})*))`), d("FULLPLAIN", `v?${l[a.MAINVERSION]}${l[a.PRERELEASE]}?${l[a.BUILD]}?`), d("FULL", `^${l[a.FULLPLAIN]}$`), d("LOOSEPLAIN", `[v=\\s]*${l[a.MAINVERSIONLOOSE]}${l[a.PRERELEASELOOSE]}?${l[a.BUILD]}?`), d("LOOSE", `^${l[a.LOOSEPLAIN]}$`), d("GTLT", "((?:<|>)?=?)"), d("XRANGEIDENTIFIERLOOSE", `${l[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), d("XRANGEIDENTIFIER", `${l[a.NUMERICIDENTIFIER]}|x|X|\\*`), d("XRANGEPLAIN", `[v=\\s]*(${l[a.XRANGEIDENTIFIER]})(?:\\.(${l[a.XRANGEIDENTIFIER]})(?:\\.(${l[a.XRANGEIDENTIFIER]})(?:${l[a.PRERELEASE]})?${l[a.BUILD]}?)?)?`), d("XRANGEPLAINLOOSE", `[v=\\s]*(${l[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[a.XRANGEIDENTIFIERLOOSE]})(?:${l[a.PRERELEASELOOSE]})?${l[a.BUILD]}?)?)?`), d("XRANGE", `^${l[a.GTLT]}\\s*${l[a.XRANGEPLAIN]}$`), d("XRANGELOOSE", `^${l[a.GTLT]}\\s*${l[a.XRANGEPLAINLOOSE]}$`), d("COERCEPLAIN", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`), d("COERCE", `${l[a.COERCEPLAIN]}(?:$|[^\\d])`), d("COERCEFULL", l[a.COERCEPLAIN] + `(?:${l[a.PRERELEASE]})?(?:${l[a.BUILD]})?(?:$|[^\\d])`), d("COERCERTL", l[a.COERCE], !0), d("COERCERTLFULL", l[a.COERCEFULL], !0), d("LONETILDE", "(?:~>?)"), d("TILDETRIM", `(\\s*)${l[a.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", d("TILDE", `^${l[a.LONETILDE]}${l[a.XRANGEPLAIN]}$`), d("TILDELOOSE", `^${l[a.LONETILDE]}${l[a.XRANGEPLAINLOOSE]}$`), d("LONECARET", "(?:\\^)"), d("CARETTRIM", `(\\s*)${l[a.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", d("CARET", `^${l[a.LONECARET]}${l[a.XRANGEPLAIN]}$`), d("CARETLOOSE", `^${l[a.LONECARET]}${l[a.XRANGEPLAINLOOSE]}$`), d("COMPARATORLOOSE", `^${l[a.GTLT]}\\s*(${l[a.LOOSEPLAIN]})$|^$`), d("COMPARATOR", `^${l[a.GTLT]}\\s*(${l[a.FULLPLAIN]})$|^$`), d("COMPARATORTRIM", `(\\s*)${l[a.GTLT]}\\s*(${l[a.LOOSEPLAIN]}|${l[a.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", d("HYPHENRANGE", `^\\s*(${l[a.XRANGEPLAIN]})\\s+-\\s+(${l[a.XRANGEPLAIN]})\\s*$`), d("HYPHENRANGELOOSE", `^\\s*(${l[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[a.XRANGEPLAINLOOSE]})\\s*$`), d("STAR", "(<|>)?=?\\s*\\*"), d("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), d("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }(Lo, Lo.exports)), Lo.exports;
}
var Yc, vp;
function gd() {
  if (vp) return Yc;
  vp = 1;
  const t = Object.freeze({ loose: !0 }), e = Object.freeze({});
  return Yc = (n) => n ? typeof n != "object" ? t : n : e, Yc;
}
var Jc, xp;
function NQ() {
  if (xp) return Jc;
  xp = 1;
  const t = /^[0-9]+$/, e = (n, s) => {
    const i = t.test(n), o = t.test(s);
    return i && o && (n = +n, s = +s), n === s ? 0 : i && !o ? -1 : o && !i ? 1 : n < s ? -1 : 1;
  };
  return Jc = {
    compareIdentifiers: e,
    rcompareIdentifiers: (n, s) => e(s, n)
  }, Jc;
}
var Vc, Dp;
function fr() {
  if (Dp) return Vc;
  Dp = 1;
  const t = Na(), { MAX_LENGTH: e, MAX_SAFE_INTEGER: r } = wa(), { safeRe: n, t: s } = mo(), i = gd(), { compareIdentifiers: o } = NQ();
  class c {
    constructor(A, a) {
      if (a = i(a), A instanceof c) {
        if (A.loose === !!a.loose && A.includePrerelease === !!a.includePrerelease)
          return A;
        A = A.version;
      } else if (typeof A != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof A}".`);
      if (A.length > e)
        throw new TypeError(
          `version is longer than ${e} characters`
        );
      t("SemVer", A, a), this.options = a, this.loose = !!a.loose, this.includePrerelease = !!a.includePrerelease;
      const u = A.trim().match(a.loose ? n[s.LOOSE] : n[s.FULL]);
      if (!u)
        throw new TypeError(`Invalid Version: ${A}`);
      if (this.raw = A, this.major = +u[1], this.minor = +u[2], this.patch = +u[3], this.major > r || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > r || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > r || this.patch < 0)
        throw new TypeError("Invalid patch version");
      u[4] ? this.prerelease = u[4].split(".").map((g) => {
        if (/^[0-9]+$/.test(g)) {
          const h = +g;
          if (h >= 0 && h < r)
            return h;
        }
        return g;
      }) : this.prerelease = [], this.build = u[5] ? u[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(A) {
      if (t("SemVer.compare", this.version, this.options, A), !(A instanceof c)) {
        if (typeof A == "string" && A === this.version)
          return 0;
        A = new c(A, this.options);
      }
      return A.version === this.version ? 0 : this.compareMain(A) || this.comparePre(A);
    }
    compareMain(A) {
      return A instanceof c || (A = new c(A, this.options)), o(this.major, A.major) || o(this.minor, A.minor) || o(this.patch, A.patch);
    }
    comparePre(A) {
      if (A instanceof c || (A = new c(A, this.options)), this.prerelease.length && !A.prerelease.length)
        return -1;
      if (!this.prerelease.length && A.prerelease.length)
        return 1;
      if (!this.prerelease.length && !A.prerelease.length)
        return 0;
      let a = 0;
      do {
        const u = this.prerelease[a], g = A.prerelease[a];
        if (t("prerelease compare", a, u, g), u === void 0 && g === void 0)
          return 0;
        if (g === void 0)
          return 1;
        if (u === void 0)
          return -1;
        if (u === g)
          continue;
        return o(u, g);
      } while (++a);
    }
    compareBuild(A) {
      A instanceof c || (A = new c(A, this.options));
      let a = 0;
      do {
        const u = this.build[a], g = A.build[a];
        if (t("build compare", a, u, g), u === void 0 && g === void 0)
          return 0;
        if (g === void 0)
          return 1;
        if (u === void 0)
          return -1;
        if (u === g)
          continue;
        return o(u, g);
      } while (++a);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(A, a, u) {
      if (A.startsWith("pre")) {
        if (!a && u === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (a) {
          const g = `-${a}`.match(this.options.loose ? n[s.PRERELEASELOOSE] : n[s.PRERELEASE]);
          if (!g || g[1] !== a)
            throw new Error(`invalid identifier: ${a}`);
        }
      }
      switch (A) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", a, u);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", a, u);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", a, u), this.inc("pre", a, u);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", a, u), this.inc("pre", a, u);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const g = Number(u) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [g];
          else {
            let h = this.prerelease.length;
            for (; --h >= 0; )
              typeof this.prerelease[h] == "number" && (this.prerelease[h]++, h = -2);
            if (h === -1) {
              if (a === this.prerelease.join(".") && u === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(g);
            }
          }
          if (a) {
            let h = [a, g];
            u === !1 && (h = [a]), o(this.prerelease[0], a) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = h) : this.prerelease = h;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${A}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return Vc = c, Vc;
}
var Wc, Tp;
function ii() {
  if (Tp) return Wc;
  Tp = 1;
  const t = fr();
  return Wc = (r, n, s = !1) => {
    if (r instanceof t)
      return r;
    try {
      return new t(r, n);
    } catch (i) {
      if (!s)
        return null;
      throw i;
    }
  }, Wc;
}
var jc, kp;
function hF() {
  if (kp) return jc;
  kp = 1;
  const t = ii();
  return jc = (r, n) => {
    const s = t(r, n);
    return s ? s.version : null;
  }, jc;
}
var $c, Fp;
function pF() {
  if (Fp) return $c;
  Fp = 1;
  const t = ii();
  return $c = (r, n) => {
    const s = t(r.trim().replace(/^[=v]+/, ""), n);
    return s ? s.version : null;
  }, $c;
}
var Xc, Pp;
function fF() {
  if (Pp) return Xc;
  Pp = 1;
  const t = fr();
  return Xc = (r, n, s, i, o) => {
    typeof s == "string" && (o = i, i = s, s = void 0);
    try {
      return new t(
        r instanceof t ? r.version : r,
        s
      ).inc(n, i, o).version;
    } catch {
      return null;
    }
  }, Xc;
}
var Kc, Up;
function EF() {
  if (Up) return Kc;
  Up = 1;
  const t = ii();
  return Kc = (r, n) => {
    const s = t(r, null, !0), i = t(n, null, !0), o = s.compare(i);
    if (o === 0)
      return null;
    const c = o > 0, l = c ? s : i, A = c ? i : s, a = !!l.prerelease.length;
    if (!!A.prerelease.length && !a) {
      if (!A.patch && !A.minor)
        return "major";
      if (A.compareMain(l) === 0)
        return A.minor && !A.patch ? "minor" : "patch";
    }
    const g = a ? "pre" : "";
    return s.major !== i.major ? g + "major" : s.minor !== i.minor ? g + "minor" : s.patch !== i.patch ? g + "patch" : "prerelease";
  }, Kc;
}
var Zc, Lp;
function CF() {
  if (Lp) return Zc;
  Lp = 1;
  const t = fr();
  return Zc = (r, n) => new t(r, n).major, Zc;
}
var el, _p;
function BF() {
  if (_p) return el;
  _p = 1;
  const t = fr();
  return el = (r, n) => new t(r, n).minor, el;
}
var tl, Mp;
function IF() {
  if (Mp) return tl;
  Mp = 1;
  const t = fr();
  return tl = (r, n) => new t(r, n).patch, tl;
}
var rl, Op;
function yF() {
  if (Op) return rl;
  Op = 1;
  const t = ii();
  return rl = (r, n) => {
    const s = t(r, n);
    return s && s.prerelease.length ? s.prerelease : null;
  }, rl;
}
var nl, Gp;
function rn() {
  if (Gp) return nl;
  Gp = 1;
  const t = fr();
  return nl = (r, n, s) => new t(r, s).compare(new t(n, s)), nl;
}
var sl, qp;
function QF() {
  if (qp) return sl;
  qp = 1;
  const t = rn();
  return sl = (r, n, s) => t(n, r, s), sl;
}
var il, Hp;
function bF() {
  if (Hp) return il;
  Hp = 1;
  const t = rn();
  return il = (r, n) => t(r, n, !0), il;
}
var ol, zp;
function md() {
  if (zp) return ol;
  zp = 1;
  const t = fr();
  return ol = (r, n, s) => {
    const i = new t(r, s), o = new t(n, s);
    return i.compare(o) || i.compareBuild(o);
  }, ol;
}
var al, Yp;
function wF() {
  if (Yp) return al;
  Yp = 1;
  const t = md();
  return al = (r, n) => r.sort((s, i) => t(s, i, n)), al;
}
var Al, Jp;
function NF() {
  if (Jp) return Al;
  Jp = 1;
  const t = md();
  return Al = (r, n) => r.sort((s, i) => t(i, s, n)), Al;
}
var cl, Vp;
function Ra() {
  if (Vp) return cl;
  Vp = 1;
  const t = rn();
  return cl = (r, n, s) => t(r, n, s) > 0, cl;
}
var ll, Wp;
function hd() {
  if (Wp) return ll;
  Wp = 1;
  const t = rn();
  return ll = (r, n, s) => t(r, n, s) < 0, ll;
}
var ul, jp;
function RQ() {
  if (jp) return ul;
  jp = 1;
  const t = rn();
  return ul = (r, n, s) => t(r, n, s) === 0, ul;
}
var dl, $p;
function SQ() {
  if ($p) return dl;
  $p = 1;
  const t = rn();
  return dl = (r, n, s) => t(r, n, s) !== 0, dl;
}
var gl, Xp;
function pd() {
  if (Xp) return gl;
  Xp = 1;
  const t = rn();
  return gl = (r, n, s) => t(r, n, s) >= 0, gl;
}
var ml, Kp;
function fd() {
  if (Kp) return ml;
  Kp = 1;
  const t = rn();
  return ml = (r, n, s) => t(r, n, s) <= 0, ml;
}
var hl, Zp;
function vQ() {
  if (Zp) return hl;
  Zp = 1;
  const t = RQ(), e = SQ(), r = Ra(), n = pd(), s = hd(), i = fd();
  return hl = (c, l, A, a) => {
    switch (l) {
      case "===":
        return typeof c == "object" && (c = c.version), typeof A == "object" && (A = A.version), c === A;
      case "!==":
        return typeof c == "object" && (c = c.version), typeof A == "object" && (A = A.version), c !== A;
      case "":
      case "=":
      case "==":
        return t(c, A, a);
      case "!=":
        return e(c, A, a);
      case ">":
        return r(c, A, a);
      case ">=":
        return n(c, A, a);
      case "<":
        return s(c, A, a);
      case "<=":
        return i(c, A, a);
      default:
        throw new TypeError(`Invalid operator: ${l}`);
    }
  }, hl;
}
var pl, ef;
function RF() {
  if (ef) return pl;
  ef = 1;
  const t = fr(), e = ii(), { safeRe: r, t: n } = mo();
  return pl = (i, o) => {
    if (i instanceof t)
      return i;
    if (typeof i == "number" && (i = String(i)), typeof i != "string")
      return null;
    o = o || {};
    let c = null;
    if (!o.rtl)
      c = i.match(o.includePrerelease ? r[n.COERCEFULL] : r[n.COERCE]);
    else {
      const h = o.includePrerelease ? r[n.COERCERTLFULL] : r[n.COERCERTL];
      let m;
      for (; (m = h.exec(i)) && (!c || c.index + c[0].length !== i.length); )
        (!c || m.index + m[0].length !== c.index + c[0].length) && (c = m), h.lastIndex = m.index + m[1].length + m[2].length;
      h.lastIndex = -1;
    }
    if (c === null)
      return null;
    const l = c[2], A = c[3] || "0", a = c[4] || "0", u = o.includePrerelease && c[5] ? `-${c[5]}` : "", g = o.includePrerelease && c[6] ? `+${c[6]}` : "";
    return e(`${l}.${A}.${a}${u}${g}`, o);
  }, pl;
}
var fl, tf;
function SF() {
  if (tf) return fl;
  tf = 1;
  class t {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(r) {
      const n = this.map.get(r);
      if (n !== void 0)
        return this.map.delete(r), this.map.set(r, n), n;
    }
    delete(r) {
      return this.map.delete(r);
    }
    set(r, n) {
      if (!this.delete(r) && n !== void 0) {
        if (this.map.size >= this.max) {
          const i = this.map.keys().next().value;
          this.delete(i);
        }
        this.map.set(r, n);
      }
      return this;
    }
  }
  return fl = t, fl;
}
var El, rf;
function nn() {
  if (rf) return El;
  rf = 1;
  const t = /\s+/g;
  class e {
    constructor(D, T) {
      if (T = s(T), D instanceof e)
        return D.loose === !!T.loose && D.includePrerelease === !!T.includePrerelease ? D : new e(D.raw, T);
      if (D instanceof i)
        return this.raw = D.value, this.set = [[D]], this.formatted = void 0, this;
      if (this.options = T, this.loose = !!T.loose, this.includePrerelease = !!T.includePrerelease, this.raw = D.trim().replace(t, " "), this.set = this.raw.split("||").map((k) => this.parseRange(k.trim())).filter((k) => k.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const k = this.set[0];
        if (this.set = this.set.filter((L) => !d(L[0])), this.set.length === 0)
          this.set = [k];
        else if (this.set.length > 1) {
          for (const L of this.set)
            if (L.length === 1 && p(L[0])) {
              this.set = [L];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let D = 0; D < this.set.length; D++) {
          D > 0 && (this.formatted += "||");
          const T = this.set[D];
          for (let k = 0; k < T.length; k++)
            k > 0 && (this.formatted += " "), this.formatted += T[k].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(D) {
      const k = ((this.options.includePrerelease && h) | (this.options.loose && m)) + ":" + D, L = n.get(k);
      if (L)
        return L;
      const W = this.options.loose, O = W ? l[A.HYPHENRANGELOOSE] : l[A.HYPHENRANGE];
      D = D.replace(O, R(this.options.includePrerelease)), o("hyphen replace", D), D = D.replace(l[A.COMPARATORTRIM], a), o("comparator trim", D), D = D.replace(l[A.TILDETRIM], u), o("tilde trim", D), D = D.replace(l[A.CARETTRIM], g), o("caret trim", D);
      let _ = D.split(" ").map((J) => B(J, this.options)).join(" ").split(/\s+/).map((J) => v(J, this.options));
      W && (_ = _.filter((J) => (o("loose invalid filter", J, this.options), !!J.match(l[A.COMPARATORLOOSE])))), o("range list", _);
      const M = /* @__PURE__ */ new Map(), $ = _.map((J) => new i(J, this.options));
      for (const J of $) {
        if (d(J))
          return [J];
        M.set(J.value, J);
      }
      M.size > 1 && M.has("") && M.delete("");
      const U = [...M.values()];
      return n.set(k, U), U;
    }
    intersects(D, T) {
      if (!(D instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((k) => E(k, T) && D.set.some((L) => E(L, T) && k.every((W) => L.every((O) => W.intersects(O, T)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(D) {
      if (!D)
        return !1;
      if (typeof D == "string")
        try {
          D = new c(D, this.options);
        } catch {
          return !1;
        }
      for (let T = 0; T < this.set.length; T++)
        if (x(this.set[T], D, this.options))
          return !0;
      return !1;
    }
  }
  El = e;
  const r = SF(), n = new r(), s = gd(), i = Sa(), o = Na(), c = fr(), {
    safeRe: l,
    t: A,
    comparatorTrimReplace: a,
    tildeTrimReplace: u,
    caretTrimReplace: g
  } = mo(), { FLAG_INCLUDE_PRERELEASE: h, FLAG_LOOSE: m } = wa(), d = (S) => S.value === "<0.0.0-0", p = (S) => S.value === "", E = (S, D) => {
    let T = !0;
    const k = S.slice();
    let L = k.pop();
    for (; T && k.length; )
      T = k.every((W) => L.intersects(W, D)), L = k.pop();
    return T;
  }, B = (S, D) => (o("comp", S, D), S = w(S, D), o("caret", S), S = Q(S, D), o("tildes", S), S = C(S, D), o("xrange", S), S = N(S, D), o("stars", S), S), y = (S) => !S || S.toLowerCase() === "x" || S === "*", Q = (S, D) => S.trim().split(/\s+/).map((T) => I(T, D)).join(" "), I = (S, D) => {
    const T = D.loose ? l[A.TILDELOOSE] : l[A.TILDE];
    return S.replace(T, (k, L, W, O, _) => {
      o("tilde", S, k, L, W, O, _);
      let M;
      return y(L) ? M = "" : y(W) ? M = `>=${L}.0.0 <${+L + 1}.0.0-0` : y(O) ? M = `>=${L}.${W}.0 <${L}.${+W + 1}.0-0` : _ ? (o("replaceTilde pr", _), M = `>=${L}.${W}.${O}-${_} <${L}.${+W + 1}.0-0`) : M = `>=${L}.${W}.${O} <${L}.${+W + 1}.0-0`, o("tilde return", M), M;
    });
  }, w = (S, D) => S.trim().split(/\s+/).map((T) => f(T, D)).join(" "), f = (S, D) => {
    o("caret", S, D);
    const T = D.loose ? l[A.CARETLOOSE] : l[A.CARET], k = D.includePrerelease ? "-0" : "";
    return S.replace(T, (L, W, O, _, M) => {
      o("caret", S, L, W, O, _, M);
      let $;
      return y(W) ? $ = "" : y(O) ? $ = `>=${W}.0.0${k} <${+W + 1}.0.0-0` : y(_) ? W === "0" ? $ = `>=${W}.${O}.0${k} <${W}.${+O + 1}.0-0` : $ = `>=${W}.${O}.0${k} <${+W + 1}.0.0-0` : M ? (o("replaceCaret pr", M), W === "0" ? O === "0" ? $ = `>=${W}.${O}.${_}-${M} <${W}.${O}.${+_ + 1}-0` : $ = `>=${W}.${O}.${_}-${M} <${W}.${+O + 1}.0-0` : $ = `>=${W}.${O}.${_}-${M} <${+W + 1}.0.0-0`) : (o("no pr"), W === "0" ? O === "0" ? $ = `>=${W}.${O}.${_}${k} <${W}.${O}.${+_ + 1}-0` : $ = `>=${W}.${O}.${_}${k} <${W}.${+O + 1}.0-0` : $ = `>=${W}.${O}.${_} <${+W + 1}.0.0-0`), o("caret return", $), $;
    });
  }, C = (S, D) => (o("replaceXRanges", S, D), S.split(/\s+/).map((T) => b(T, D)).join(" ")), b = (S, D) => {
    S = S.trim();
    const T = D.loose ? l[A.XRANGELOOSE] : l[A.XRANGE];
    return S.replace(T, (k, L, W, O, _, M) => {
      o("xRange", S, k, L, W, O, _, M);
      const $ = y(W), U = $ || y(O), J = U || y(_), j = J;
      return L === "=" && j && (L = ""), M = D.includePrerelease ? "-0" : "", $ ? L === ">" || L === "<" ? k = "<0.0.0-0" : k = "*" : L && j ? (U && (O = 0), _ = 0, L === ">" ? (L = ">=", U ? (W = +W + 1, O = 0, _ = 0) : (O = +O + 1, _ = 0)) : L === "<=" && (L = "<", U ? W = +W + 1 : O = +O + 1), L === "<" && (M = "-0"), k = `${L + W}.${O}.${_}${M}`) : U ? k = `>=${W}.0.0${M} <${+W + 1}.0.0-0` : J && (k = `>=${W}.${O}.0${M} <${W}.${+O + 1}.0-0`), o("xRange return", k), k;
    });
  }, N = (S, D) => (o("replaceStars", S, D), S.trim().replace(l[A.STAR], "")), v = (S, D) => (o("replaceGTE0", S, D), S.trim().replace(l[D.includePrerelease ? A.GTE0PRE : A.GTE0], "")), R = (S) => (D, T, k, L, W, O, _, M, $, U, J, j) => (y(k) ? T = "" : y(L) ? T = `>=${k}.0.0${S ? "-0" : ""}` : y(W) ? T = `>=${k}.${L}.0${S ? "-0" : ""}` : O ? T = `>=${T}` : T = `>=${T}${S ? "-0" : ""}`, y($) ? M = "" : y(U) ? M = `<${+$ + 1}.0.0-0` : y(J) ? M = `<${$}.${+U + 1}.0-0` : j ? M = `<=${$}.${U}.${J}-${j}` : S ? M = `<${$}.${U}.${+J + 1}-0` : M = `<=${M}`, `${T} ${M}`.trim()), x = (S, D, T) => {
    for (let k = 0; k < S.length; k++)
      if (!S[k].test(D))
        return !1;
    if (D.prerelease.length && !T.includePrerelease) {
      for (let k = 0; k < S.length; k++)
        if (o(S[k].semver), S[k].semver !== i.ANY && S[k].semver.prerelease.length > 0) {
          const L = S[k].semver;
          if (L.major === D.major && L.minor === D.minor && L.patch === D.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return El;
}
var Cl, nf;
function Sa() {
  if (nf) return Cl;
  nf = 1;
  const t = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return t;
    }
    constructor(a, u) {
      if (u = r(u), a instanceof e) {
        if (a.loose === !!u.loose)
          return a;
        a = a.value;
      }
      a = a.trim().split(/\s+/).join(" "), o("comparator", a, u), this.options = u, this.loose = !!u.loose, this.parse(a), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(a) {
      const u = this.options.loose ? n[s.COMPARATORLOOSE] : n[s.COMPARATOR], g = a.match(u);
      if (!g)
        throw new TypeError(`Invalid comparator: ${a}`);
      this.operator = g[1] !== void 0 ? g[1] : "", this.operator === "=" && (this.operator = ""), g[2] ? this.semver = new c(g[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(a) {
      if (o("Comparator.test", a, this.options.loose), this.semver === t || a === t)
        return !0;
      if (typeof a == "string")
        try {
          a = new c(a, this.options);
        } catch {
          return !1;
        }
      return i(a, this.operator, this.semver, this.options);
    }
    intersects(a, u) {
      if (!(a instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new l(a.value, u).test(this.value) : a.operator === "" ? a.value === "" ? !0 : new l(this.value, u).test(a.semver) : (u = r(u), u.includePrerelease && (this.value === "<0.0.0-0" || a.value === "<0.0.0-0") || !u.includePrerelease && (this.value.startsWith("<0.0.0") || a.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && a.operator.startsWith(">") || this.operator.startsWith("<") && a.operator.startsWith("<") || this.semver.version === a.semver.version && this.operator.includes("=") && a.operator.includes("=") || i(this.semver, "<", a.semver, u) && this.operator.startsWith(">") && a.operator.startsWith("<") || i(this.semver, ">", a.semver, u) && this.operator.startsWith("<") && a.operator.startsWith(">")));
    }
  }
  Cl = e;
  const r = gd(), { safeRe: n, t: s } = mo(), i = vQ(), o = Na(), c = fr(), l = nn();
  return Cl;
}
var Bl, sf;
function va() {
  if (sf) return Bl;
  sf = 1;
  const t = nn();
  return Bl = (r, n, s) => {
    try {
      n = new t(n, s);
    } catch {
      return !1;
    }
    return n.test(r);
  }, Bl;
}
var Il, of;
function vF() {
  if (of) return Il;
  of = 1;
  const t = nn();
  return Il = (r, n) => new t(r, n).set.map((s) => s.map((i) => i.value).join(" ").trim().split(" ")), Il;
}
var yl, af;
function xF() {
  if (af) return yl;
  af = 1;
  const t = fr(), e = nn();
  return yl = (n, s, i) => {
    let o = null, c = null, l = null;
    try {
      l = new e(s, i);
    } catch {
      return null;
    }
    return n.forEach((A) => {
      l.test(A) && (!o || c.compare(A) === -1) && (o = A, c = new t(o, i));
    }), o;
  }, yl;
}
var Ql, Af;
function DF() {
  if (Af) return Ql;
  Af = 1;
  const t = fr(), e = nn();
  return Ql = (n, s, i) => {
    let o = null, c = null, l = null;
    try {
      l = new e(s, i);
    } catch {
      return null;
    }
    return n.forEach((A) => {
      l.test(A) && (!o || c.compare(A) === 1) && (o = A, c = new t(o, i));
    }), o;
  }, Ql;
}
var bl, cf;
function TF() {
  if (cf) return bl;
  cf = 1;
  const t = fr(), e = nn(), r = Ra();
  return bl = (s, i) => {
    s = new e(s, i);
    let o = new t("0.0.0");
    if (s.test(o) || (o = new t("0.0.0-0"), s.test(o)))
      return o;
    o = null;
    for (let c = 0; c < s.set.length; ++c) {
      const l = s.set[c];
      let A = null;
      l.forEach((a) => {
        const u = new t(a.semver.version);
        switch (a.operator) {
          case ">":
            u.prerelease.length === 0 ? u.patch++ : u.prerelease.push(0), u.raw = u.format();
          /* fallthrough */
          case "":
          case ">=":
            (!A || r(u, A)) && (A = u);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${a.operator}`);
        }
      }), A && (!o || r(o, A)) && (o = A);
    }
    return o && s.test(o) ? o : null;
  }, bl;
}
var wl, lf;
function kF() {
  if (lf) return wl;
  lf = 1;
  const t = nn();
  return wl = (r, n) => {
    try {
      return new t(r, n).range || "*";
    } catch {
      return null;
    }
  }, wl;
}
var Nl, uf;
function Ed() {
  if (uf) return Nl;
  uf = 1;
  const t = fr(), e = Sa(), { ANY: r } = e, n = nn(), s = va(), i = Ra(), o = hd(), c = fd(), l = pd();
  return Nl = (a, u, g, h) => {
    a = new t(a, h), u = new n(u, h);
    let m, d, p, E, B;
    switch (g) {
      case ">":
        m = i, d = c, p = o, E = ">", B = ">=";
        break;
      case "<":
        m = o, d = l, p = i, E = "<", B = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (s(a, u, h))
      return !1;
    for (let y = 0; y < u.set.length; ++y) {
      const Q = u.set[y];
      let I = null, w = null;
      if (Q.forEach((f) => {
        f.semver === r && (f = new e(">=0.0.0")), I = I || f, w = w || f, m(f.semver, I.semver, h) ? I = f : p(f.semver, w.semver, h) && (w = f);
      }), I.operator === E || I.operator === B || (!w.operator || w.operator === E) && d(a, w.semver))
        return !1;
      if (w.operator === B && p(a, w.semver))
        return !1;
    }
    return !0;
  }, Nl;
}
var Rl, df;
function FF() {
  if (df) return Rl;
  df = 1;
  const t = Ed();
  return Rl = (r, n, s) => t(r, n, ">", s), Rl;
}
var Sl, gf;
function PF() {
  if (gf) return Sl;
  gf = 1;
  const t = Ed();
  return Sl = (r, n, s) => t(r, n, "<", s), Sl;
}
var vl, mf;
function UF() {
  if (mf) return vl;
  mf = 1;
  const t = nn();
  return vl = (r, n, s) => (r = new t(r, s), n = new t(n, s), r.intersects(n, s)), vl;
}
var xl, hf;
function LF() {
  if (hf) return xl;
  hf = 1;
  const t = va(), e = rn();
  return xl = (r, n, s) => {
    const i = [];
    let o = null, c = null;
    const l = r.sort((g, h) => e(g, h, s));
    for (const g of l)
      t(g, n, s) ? (c = g, o || (o = g)) : (c && i.push([o, c]), c = null, o = null);
    o && i.push([o, null]);
    const A = [];
    for (const [g, h] of i)
      g === h ? A.push(g) : !h && g === l[0] ? A.push("*") : h ? g === l[0] ? A.push(`<=${h}`) : A.push(`${g} - ${h}`) : A.push(`>=${g}`);
    const a = A.join(" || "), u = typeof n.raw == "string" ? n.raw : String(n);
    return a.length < u.length ? a : n;
  }, xl;
}
var Dl, pf;
function _F() {
  if (pf) return Dl;
  pf = 1;
  const t = nn(), e = Sa(), { ANY: r } = e, n = va(), s = rn(), i = (u, g, h = {}) => {
    if (u === g)
      return !0;
    u = new t(u, h), g = new t(g, h);
    let m = !1;
    e: for (const d of u.set) {
      for (const p of g.set) {
        const E = l(d, p, h);
        if (m = m || E !== null, E)
          continue e;
      }
      if (m)
        return !1;
    }
    return !0;
  }, o = [new e(">=0.0.0-0")], c = [new e(">=0.0.0")], l = (u, g, h) => {
    if (u === g)
      return !0;
    if (u.length === 1 && u[0].semver === r) {
      if (g.length === 1 && g[0].semver === r)
        return !0;
      h.includePrerelease ? u = o : u = c;
    }
    if (g.length === 1 && g[0].semver === r) {
      if (h.includePrerelease)
        return !0;
      g = c;
    }
    const m = /* @__PURE__ */ new Set();
    let d, p;
    for (const C of u)
      C.operator === ">" || C.operator === ">=" ? d = A(d, C, h) : C.operator === "<" || C.operator === "<=" ? p = a(p, C, h) : m.add(C.semver);
    if (m.size > 1)
      return null;
    let E;
    if (d && p) {
      if (E = s(d.semver, p.semver, h), E > 0)
        return null;
      if (E === 0 && (d.operator !== ">=" || p.operator !== "<="))
        return null;
    }
    for (const C of m) {
      if (d && !n(C, String(d), h) || p && !n(C, String(p), h))
        return null;
      for (const b of g)
        if (!n(C, String(b), h))
          return !1;
      return !0;
    }
    let B, y, Q, I, w = p && !h.includePrerelease && p.semver.prerelease.length ? p.semver : !1, f = d && !h.includePrerelease && d.semver.prerelease.length ? d.semver : !1;
    w && w.prerelease.length === 1 && p.operator === "<" && w.prerelease[0] === 0 && (w = !1);
    for (const C of g) {
      if (I = I || C.operator === ">" || C.operator === ">=", Q = Q || C.operator === "<" || C.operator === "<=", d) {
        if (f && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === f.major && C.semver.minor === f.minor && C.semver.patch === f.patch && (f = !1), C.operator === ">" || C.operator === ">=") {
          if (B = A(d, C, h), B === C && B !== d)
            return !1;
        } else if (d.operator === ">=" && !n(d.semver, String(C), h))
          return !1;
      }
      if (p) {
        if (w && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === w.major && C.semver.minor === w.minor && C.semver.patch === w.patch && (w = !1), C.operator === "<" || C.operator === "<=") {
          if (y = a(p, C, h), y === C && y !== p)
            return !1;
        } else if (p.operator === "<=" && !n(p.semver, String(C), h))
          return !1;
      }
      if (!C.operator && (p || d) && E !== 0)
        return !1;
    }
    return !(d && Q && !p && E !== 0 || p && I && !d && E !== 0 || f || w);
  }, A = (u, g, h) => {
    if (!u)
      return g;
    const m = s(u.semver, g.semver, h);
    return m > 0 ? u : m < 0 || g.operator === ">" && u.operator === ">=" ? g : u;
  }, a = (u, g, h) => {
    if (!u)
      return g;
    const m = s(u.semver, g.semver, h);
    return m < 0 ? u : m > 0 || g.operator === "<" && u.operator === "<=" ? g : u;
  };
  return Dl = i, Dl;
}
var Tl, ff;
function MF() {
  if (ff) return Tl;
  ff = 1;
  const t = mo(), e = wa(), r = fr(), n = NQ(), s = ii(), i = hF(), o = pF(), c = fF(), l = EF(), A = CF(), a = BF(), u = IF(), g = yF(), h = rn(), m = QF(), d = bF(), p = md(), E = wF(), B = NF(), y = Ra(), Q = hd(), I = RQ(), w = SQ(), f = pd(), C = fd(), b = vQ(), N = RF(), v = Sa(), R = nn(), x = va(), S = vF(), D = xF(), T = DF(), k = TF(), L = kF(), W = Ed(), O = FF(), _ = PF(), M = UF(), $ = LF(), U = _F();
  return Tl = {
    parse: s,
    valid: i,
    clean: o,
    inc: c,
    diff: l,
    major: A,
    minor: a,
    patch: u,
    prerelease: g,
    compare: h,
    rcompare: m,
    compareLoose: d,
    compareBuild: p,
    sort: E,
    rsort: B,
    gt: y,
    lt: Q,
    eq: I,
    neq: w,
    gte: f,
    lte: C,
    cmp: b,
    coerce: N,
    Comparator: v,
    Range: R,
    satisfies: x,
    toComparators: S,
    maxSatisfying: D,
    minSatisfying: T,
    minVersion: k,
    validRange: L,
    outside: W,
    gtr: O,
    ltr: _,
    intersects: M,
    simplifyRange: $,
    subset: U,
    SemVer: r,
    re: t.re,
    src: t.src,
    tokens: t.t,
    SEMVER_SPEC_VERSION: e.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: e.RELEASE_TYPES,
    compareIdentifiers: n.compareIdentifiers,
    rcompareIdentifiers: n.rcompareIdentifiers
  }, Tl;
}
MF();
function qo(t, e) {
  const r = t.replaceAll("-", "_"), n = mt.getInput(r, e);
  return n.length > 0 ? n : mt.getInput(t, e);
}
function OF(t, e) {
  const r = qo(t, e);
  return r === "true" || r === "1";
}
var ts = /* @__PURE__ */ ((t) => (t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Notice = 2] = "Notice", t))(ts || {});
class Pi {
  _workingDirectory;
  _uniqueAnnotations;
  _stats;
  constructor(e) {
    this._workingDirectory = e ?? null, this._uniqueAnnotations = /* @__PURE__ */ new Map(), this._stats = {
      ice: 0,
      error: 0,
      warning: 0,
      note: 0,
      help: 0
    };
  }
  get stats() {
    return this._stats;
  }
  get annotations() {
    return [...this._uniqueAnnotations.values()];
  }
  static parseCargoJson(e) {
    try {
      return JSON.parse(e);
    } catch {
      return null;
    }
  }
  static validateMessageIsCargoMessage(e) {
    return e.reason !== "compiler-message" ? (mt.debug(`Unexpected reason field, ignoring it: ${e.reason}`), !1) : e.message?.code === void 0 || e.message.code === null ? (mt.debug("Message code is missing, ignoring it"), !1) : !0;
  }
  static parseLevel(e) {
    switch (e) {
      case "help":
      case "note":
        return ts.Notice;
      case "warning":
        return ts.Warning;
      default:
        return ts.Error;
    }
  }
  tryParseClippyLine(e) {
    const r = Pi.parseCargoJson(e);
    if (r === null) {
      mt.debug("Not valid JSON or null, ignoring it");
      return;
    }
    if (!Pi.validateMessageIsCargoMessage(r))
      return;
    const n = this.makeAnnotation(r), s = JSON.stringify(n);
    if (!this._uniqueAnnotations.has(s)) {
      switch (r.message.level) {
        case "help": {
          this._stats.help += 1;
          break;
        }
        case "note": {
          this._stats.note += 1;
          break;
        }
        case "warning": {
          this._stats.warning += 1;
          break;
        }
        case "error": {
          this._stats.error += 1;
          break;
        }
        case "error: internal compiler error": {
          this._stats.ice += 1;
          break;
        }
      }
      this._uniqueAnnotations.set(s, n);
    }
  }
  /// Convert parsed JSON line into the GH annotation object
  ///
  /// https://developer.github.com/v3/checks/runs/#annotations-object
  makeAnnotation(e) {
    const r = e.message.spans.find((i) => i.is_primary);
    if (r === void 0)
      throw new Error("Unable to find primary span for message");
    let n = r.file_name;
    this._workingDirectory !== null && (n = Is.join(this._workingDirectory, n)), MQ.platform() === "win32" && (n = n.split(Is.win32.sep).join(Is.posix.sep));
    const s = {
      level: Pi.parseLevel(e.message.level),
      message: e.message.rendered,
      properties: {
        file: n,
        startLine: r.line_start,
        endLine: r.line_end,
        title: e.message.message
      }
    };
    return r.line_start === r.line_end && (s.properties.startColumn = r.column_start, s.properties.endColumn = r.column_end), s;
  }
}
async function GF(t, e, r) {
  for (const n of e)
    switch (n.level) {
      case ts.Error: {
        mt.error(n.message, n.properties);
        break;
      }
      case ts.Notice: {
        mt.notice(n.message, n.properties);
        break;
      }
      case ts.Warning: {
        mt.warning(n.message, n.properties);
        break;
      }
    }
  mt.summary.addHeading("Clippy summary", 2), mt.summary.addTable([
    [
      {
        header: !0,
        data: "Message level"
      },
      {
        header: !0,
        data: "Amount"
      }
    ],
    [
      {
        data: "Internal compiler error"
      },
      {
        data: t.ice.toString()
      }
    ],
    [
      {
        data: "Error"
      },
      {
        data: t.error.toString()
      }
    ],
    [
      {
        data: "Warning"
      },
      {
        data: t.warning.toString()
      }
    ],
    [
      {
        data: "Note"
      },
      {
        data: t.note.toString()
      }
    ],
    [
      {
        data: "Help"
      },
      {
        data: t.help.toString()
      }
    ]
  ]), mt.summary.addHeading("Versions", 2), mt.summary.addList([r.rustc, r.cargo, r.clippy]), await mt.summary.write();
}
async function qF(t, e) {
  const r = {
    cargo: "",
    clippy: "",
    rustc: ""
  };
  return await Promise.all([
    Vf.exec("rustc", Ho(e, ["-V"]), {
      listeners: {
        stdout: (n) => r.rustc = n.toString().trim()
      },
      silent: !1
    }),
    t.call(Ho(e, ["-V"]), {
      listeners: {
        stdout: (n) => r.cargo = n.toString().trim()
      },
      silent: !1
    }),
    t.call(Ho(e, ["clippy", "-V"]), {
      listeners: {
        stdout: (n) => r.clippy = n.toString().trim()
      },
      silent: !1
    })
  ]), r;
}
function HF(t, e, r) {
  const n = `
`;
  let s = e + t.toString(), i = s.indexOf(n);
  for (; i > -1; ) {
    const o = s.slice(0, Math.max(0, i));
    r(o), s = s.slice(Math.max(0, i + n.length)), i = s.indexOf(n);
  }
  return s;
}
async function zF(t, e) {
  const r = VF(t), n = new Pi();
  let s = "";
  const i = {
    failOnStdErr: !1,
    ignoreReturnCode: !0,
    listeners: {
      stdout: (c) => {
        s = HF(c, s, (l) => {
          n.tryParseClippyLine(l);
        });
      }
    }
  };
  t.workingDirectory !== void 0 && t.workingDirectory !== "" && (i.cwd = Is.join(process.cwd(), t.workingDirectory));
  let o = 0;
  try {
    mt.startGroup("Executing cargo clippy (JSON output)"), o = await e.call(r, i);
  } finally {
    mt.endGroup();
  }
  return {
    stats: n.stats,
    annotations: n.annotations,
    exitCode: o
  };
}
function YF(t) {
  return t ? Bs.getOrInstall() : ba.get();
}
async function JF(t) {
  const e = await YF(t.useCross), r = await qF(e, t.toolchain), { stats: n, annotations: s, exitCode: i } = await zF(t, e);
  if (await GF(n, s, r), i !== 0)
    throw new Error(`Clippy had exited with the ${i} exit code`);
}
function Ho(t, e) {
  const r = [];
  return t !== void 0 && t !== "" && r.push(`+${t}`), r.push(...e), r;
}
function VF(t) {
  return Ho(t.toolchain, [
    "clippy",
    // `--message-format=json` should just right after the `cargo clippy`
    // because usually people are adding the `-- -D warnings` at the end
    // of arguments and it will mess up the output.
    "--message-format=json",
    // and the rest
    ...t.args
  ]);
}
function WF(t, e, r) {
  var n = /([^\s'"]([^\s'"]*(['"])([^\3]*?)\3)+[^\s'"]*)|[^\s'"]+|(['"])([^\5]*?)\5/gi, s = t, i = [], o;
  do
    o = n.exec(s), o !== null && i.push(jF(o[1], o[6], o[0]));
  while (o !== null);
  return i;
}
function jF() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    if (typeof n == "string")
      return n;
  }
}
function $F() {
  let t = qo("toolchain");
  t.startsWith("+") && (t = t.slice(1));
  const e = qo("working-directory");
  return {
    args: WF(qo("args")),
    useCross: OF("use-cross"),
    workingDirectory: e === "" ? void 0 : e,
    toolchain: t === "" ? void 0 : t
  };
}
async function XF() {
  try {
    const t = $F();
    await JF(t);
  } catch (t) {
    t instanceof Error ? mt.setFailed(t.message) : mt.setFailed(String(t));
  }
}
await XF();
//# sourceMappingURL=clippy-check.js.map
