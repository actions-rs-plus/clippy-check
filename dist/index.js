import require$$0$3 from "os";
import require$$0$4 from "crypto";
import require$$1$2 from "fs";
import require$$1$7 from "path";
import require$$2 from "http";
import require$$1$3 from "https";
import require$$1$4 from "tls";
import require$$0$6 from "events";
import require$$0$5 from "util";
import require$$0$7 from "assert";
import require$$0$8 from "net";
import require$$0$9 from "stream";
import require$$7 from "buffer";
import require$$8 from "querystring";
import require$$14 from "stream/web";
import require$$0$b from "node:stream";
import require$$1$5 from "node:util";
import require$$0$a from "node:events";
import require$$0$c from "worker_threads";
import require$$2$1 from "perf_hooks";
import require$$5 from "util/types";
import require$$4 from "async_hooks";
import require$$1$6 from "console";
import require$$5$1 from "url";
import require$$3 from "zlib";
import require$$6 from "string_decoder";
import require$$0$d from "diagnostics_channel";
import require$$2$2 from "child_process";
import require$$6$1 from "timers";
import path from "node:path";
import * as require$$1$1 from "node:os";
import require$$1__default from "node:os";
import require$$2$3 from "node:process";
import require$$0$e from "node:crypto";
import require$$1$8 from "node:http";
import require$$2$4 from "node:https";
import require$$3$1 from "node:zlib";
import require$$1$9 from "tty";
import require$$2$5 from "node:buffer";
import require$$1$a from "node:fs";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var core = {};
var command = {};
var utils$3 = {};
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  Object.defineProperty(utils$3, "__esModule", { value: true });
  utils$3.toCommandProperties = utils$3.toCommandValue = void 0;
  function toCommandValue(input) {
    if (input === null || input === void 0) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  utils$3.toCommandValue = toCommandValue;
  function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
      return {};
    }
    return {
      title: annotationProperties.title,
      file: annotationProperties.file,
      line: annotationProperties.startLine,
      endLine: annotationProperties.endLine,
      col: annotationProperties.startColumn,
      endColumn: annotationProperties.endColumn
    };
  }
  utils$3.toCommandProperties = toCommandProperties;
  return utils$3;
}
var hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command;
  hasRequiredCommand = 1;
  var __createBinding2 = command && command.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = command && command.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = command && command.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(command, "__esModule", { value: true });
  command.issue = command.issueCommand = void 0;
  const os = __importStar2(require$$0$3);
  const utils_1 = /* @__PURE__ */ requireUtils$3();
  function issueCommand(command2, properties, message) {
    const cmd = new Command(command2, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  command.issueCommand = issueCommand;
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  command.issue = issue;
  const CMD_STRING = "::";
  class Command {
    constructor(command2, properties, message) {
      if (!command2) {
        command2 = "missing.command";
      }
      this.command = command2;
      this.properties = properties;
      this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val = this.properties[key];
            if (val) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  }
  function escapeData(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
  return command;
}
var fileCommand = {};
var hasRequiredFileCommand;
function requireFileCommand() {
  if (hasRequiredFileCommand) return fileCommand;
  hasRequiredFileCommand = 1;
  var __createBinding2 = fileCommand && fileCommand.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = fileCommand && fileCommand.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = fileCommand && fileCommand.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(fileCommand, "__esModule", { value: true });
  fileCommand.prepareKeyValueMessage = fileCommand.issueFileCommand = void 0;
  const crypto = __importStar2(require$$0$4);
  const fs = __importStar2(require$$1$2);
  const os = __importStar2(require$$0$3);
  const utils_1 = /* @__PURE__ */ requireUtils$3();
  function issueFileCommand(command2, message) {
    const filePath = process.env[`GITHUB_${command2}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command2}`);
    }
    if (!fs.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  fileCommand.issueFileCommand = issueFileCommand;
  function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
    const convertedValue = (0, utils_1.toCommandValue)(value);
    if (key.includes(delimiter)) {
      throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
      throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
  }
  fileCommand.prepareKeyValueMessage = prepareKeyValueMessage;
  return fileCommand;
}
var oidcUtils = {};
var lib$1 = {};
var proxy$1 = {};
var hasRequiredProxy$1;
function requireProxy$1() {
  if (hasRequiredProxy$1) return proxy$1;
  hasRequiredProxy$1 = 1;
  Object.defineProperty(proxy$1, "__esModule", { value: true });
  proxy$1.checkBypass = proxy$1.getProxyUrl = void 0;
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return void 0;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return void 0;
    }
  }
  proxy$1.getProxyUrl = getProxyUrl;
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  proxy$1.checkBypass = checkBypass;
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }
  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
  return proxy$1;
}
var tunnel$1 = {};
var hasRequiredTunnel$1;
function requireTunnel$1() {
  if (hasRequiredTunnel$1) return tunnel$1;
  hasRequiredTunnel$1 = 1;
  var tls = require$$1$4;
  var http = require$$2;
  var https = require$$1$3;
  var events2 = require$$0$6;
  var util2 = require$$0$5;
  tunnel$1.httpOverHttp = httpOverHttp;
  tunnel$1.httpsOverHttp = httpsOverHttp;
  tunnel$1.httpOverHttps = httpOverHttps;
  tunnel$1.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options2) {
    var agent2 = new TunnelingAgent(options2);
    agent2.request = http.request;
    return agent2;
  }
  function httpsOverHttp(options2) {
    var agent2 = new TunnelingAgent(options2);
    agent2.request = http.request;
    agent2.createSocket = createSecureSocket;
    agent2.defaultPort = 443;
    return agent2;
  }
  function httpOverHttps(options2) {
    var agent2 = new TunnelingAgent(options2);
    agent2.request = https.request;
    return agent2;
  }
  function httpsOverHttps(options2) {
    var agent2 = new TunnelingAgent(options2);
    agent2.request = https.request;
    agent2.createSocket = createSecureSocket;
    agent2.defaultPort = 443;
    return agent2;
  }
  function TunnelingAgent(options2) {
    var self2 = this;
    self2.options = options2 || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port, localAddress) {
      var options3 = toOptions(host, port, localAddress);
      for (var i = 0, len = self2.requests.length; i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === options3.host && pending.port === options3.port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util2.inherits(TunnelingAgent, events2.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self2 = this;
    var options2 = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push(options2);
      return;
    }
    self2.createSocket(options2, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      req.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, options2);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options2, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options2.host + ":" + options2.port,
      agent: false,
      headers: {
        host: options2.host + ":" + options2.port
      }
    });
    if (options2.localAddress) {
      connectOptions.localAddress = options2.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    }
    debug2("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode !== 200) {
        debug2(
          "tunneling socket could not be established, statusCode=%d",
          res.statusCode
        );
        socket.destroy();
        var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
        error2.code = "ECONNRESET";
        options2.request.emit("error", error2);
        self2.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug2("got illegal response body from proxy");
        socket.destroy();
        var error2 = new Error("got illegal response body from proxy");
        error2.code = "ECONNRESET";
        options2.request.emit("error", error2);
        self2.removeSocket(placeholder);
        return;
      }
      debug2("tunneling connection has established");
      self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug2(
        "tunneling socket could not be established, cause=%s\n",
        cause.message,
        cause.stack
      );
      var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
      error2.code = "ECONNRESET";
      options2.request.emit("error", error2);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  };
  function createSecureSocket(options2, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options2, function(socket) {
      var hostHeader = options2.request.getHeader("host");
      var tlsOptions = mergeOptions({}, self2.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options2.host
      });
      var secureSocket = tls.connect(0, tlsOptions);
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string") {
      return {
        host,
        port,
        localAddress
      };
    }
    return host;
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== void 0) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug2;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug2 = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug2 = function() {
    };
  }
  tunnel$1.debug = debug2;
  return tunnel$1;
}
var tunnel;
var hasRequiredTunnel;
function requireTunnel() {
  if (hasRequiredTunnel) return tunnel;
  hasRequiredTunnel = 1;
  tunnel = /* @__PURE__ */ requireTunnel$1();
  return tunnel;
}
var undici = {};
var symbols$4;
var hasRequiredSymbols$4;
function requireSymbols$4() {
  if (hasRequiredSymbols$4) return symbols$4;
  hasRequiredSymbols$4 = 1;
  symbols$4 = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable")
  };
  return symbols$4;
}
var errors$1;
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }
  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ConnectTimeoutError);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }
  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }
  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersOverflowError);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }
  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }
  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers2, body2) {
      super(message);
      Error.captureStackTrace(this, ResponseStatusCodeError);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body2;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers2;
    }
  }
  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }
  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }
  class RequestAbortedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }
  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }
  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestContentLengthMismatchError);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }
  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }
  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }
  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }
  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }
  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }
  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }
  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      Error.captureStackTrace(this, HTTPParserError);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : void 0;
      this.data = data ? data.toString() : void 0;
    }
  }
  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }
  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers: headers2, data }) {
      super(message);
      Error.captureStackTrace(this, RequestRetryError);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers2;
    }
  }
  errors$1 = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError
  };
  return errors$1;
}
var constants$a;
var hasRequiredConstants$a;
function requireConstants$a() {
  if (hasRequiredConstants$a) return constants$a;
  hasRequiredConstants$a = 1;
  const headerNameLowerCasedRecord = {};
  const wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0; i < wellknownHeaderNames.length; ++i) {
    const key = wellknownHeaderNames[i];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  constants$a = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
  return constants$a;
}
var util$8;
var hasRequiredUtil$8;
function requireUtil$8() {
  if (hasRequiredUtil$8) return util$8;
  hasRequiredUtil$8 = 1;
  const assert2 = require$$0$7;
  const { kDestroyed, kBodyUsed } = /* @__PURE__ */ requireSymbols$4();
  const { IncomingMessage } = require$$2;
  const stream = require$$0$9;
  const net = require$$0$8;
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  const { Blob: Blob2 } = require$$7;
  const nodeUtil = require$$0$5;
  const { stringify } = require$$8;
  const { headerNameLowerCasedRecord } = /* @__PURE__ */ requireConstants$a();
  const [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  function nop() {
  }
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object2) {
    return Blob2 && object2 instanceof Blob2 || object2 && typeof object2 === "object" && (typeof object2.stream === "function" || typeof object2.arrayBuffer === "function") && /^(Blob|File)$/.test(object2[Symbol.toStringTag]);
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!/^https?:/.test(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
      let path2 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/")) {
        origin = origin.substring(0, origin.length - 1);
      }
      if (path2 && !path2.startsWith("/")) {
        path2 = `/${path2}`;
      }
      url = new URL(origin + path2);
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert2(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1) return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert2.strictEqual(typeof host, "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body2) {
    if (body2 == null) {
      return 0;
    } else if (isStream(body2)) {
      const state2 = body2._readableState;
      return state2 && state2.objectMode === false && state2.ended === true && Number.isFinite(state2.length) ? state2.length : null;
    } else if (isBlobLike(body2)) {
      return body2.size != null ? body2.size : null;
    } else if (isBuffer(body2)) {
      return body2.byteLength;
    }
    return null;
  }
  function isDestroyed(stream2) {
    return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
  }
  function isReadableAborted(stream2) {
    const state2 = stream2 && stream2._readableState;
    return isDestroyed(stream2) && state2 && !state2.endEmitted;
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err);
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1e3 : null;
  }
  function headerNameToString(value) {
    return headerNameLowerCasedRecord[value] || value.toLowerCase();
  }
  function parseHeaders(headers2, obj = {}) {
    if (!Array.isArray(headers2)) return headers2;
    for (let i = 0; i < headers2.length; i += 2) {
      const key = headers2[i].toString().toLowerCase();
      let val = obj[key];
      if (!val) {
        if (Array.isArray(headers2[i + 1])) {
          obj[key] = headers2[i + 1].map((x) => x.toString("utf8"));
        } else {
          obj[key] = headers2[i + 1].toString("utf8");
        }
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers2[i + 1].toString("utf8"));
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers2) {
    const ret = [];
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    for (let n = 0; n < headers2.length; n += 2) {
      const key = headers2[n + 0].toString();
      const val = headers2[n + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
        ret.push(key, val);
        hasContentLength = true;
      } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = ret.push(key, val) - 1;
      } else {
        ret.push(key, val);
      }
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body2) {
    return !!(body2 && (stream.isDisturbed ? stream.isDisturbed(body2) || body2[kBodyUsed] : body2[kBodyUsed] || body2.readableDidRead || body2._readableState && body2._readableState.dataEmitted || isReadableAborted(body2)));
  }
  function isErrored(body2) {
    return !!(body2 && (stream.isErrored ? stream.isErrored(body2) : /state: 'errored'/.test(
      nodeUtil.inspect(body2)
    )));
  }
  function isReadable(body2) {
    return !!(body2 && (stream.isReadable ? stream.isReadable(body2) : /state: 'readable'/.test(
      nodeUtil.inspect(body2)
    )));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  async function* convertIterableToBuffer(iterable) {
    for await (const chunk of iterable) {
      yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    }
  }
  let ReadableStream2;
  function ReadableStreamFrom(iterable) {
    if (!ReadableStream2) {
      ReadableStream2 = require$$14.ReadableStream;
    }
    if (ReadableStream2.from) {
      return ReadableStream2.from(convertIterableToBuffer(iterable));
    }
    let iterator;
    return new ReadableStream2(
      {
        async start() {
          iterator = iterable[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
            controller.enqueue(new Uint8Array(buf));
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        }
      },
      0
    );
  }
  function isFormDataLike(object2) {
    return object2 && typeof object2 === "object" && typeof object2.append === "function" && typeof object2.delete === "function" && typeof object2.get === "function" && typeof object2.getAll === "function" && typeof object2.has === "function" && typeof object2.set === "function" && object2[Symbol.toStringTag] === "FormData";
  }
  function throwIfAborted(signal) {
    if (!signal) {
      return;
    }
    if (typeof signal.throwIfAborted === "function") {
      signal.throwIfAborted();
    } else {
      if (signal.aborted) {
        const err = new Error("The operation was aborted");
        err.name = "AbortError";
        throw err;
      }
    }
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.addListener("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  const hasToWellFormed = !!String.prototype.toWellFormed;
  function toUSVString(val) {
    if (hasToWellFormed) {
      return `${val}`.toWellFormed();
    } else if (nodeUtil.toUSVString) {
      return nodeUtil.toUSVString(val);
    }
    return `${val}`;
  }
  function parseRangeHeader(range) {
    if (range == null || range === "") return { start: 0, end: null, size: null };
    const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  const kEnumerableProperty = /* @__PURE__ */ Object.create(null);
  kEnumerableProperty.enumerable = true;
  util$8 = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    addAbortListener,
    parseRangeHeader,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
  };
  return util$8;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  let fastNow = Date.now();
  let fastNowTimeout;
  const fastTimers = [];
  function onTimeout() {
    fastNow = Date.now();
    let len = fastTimers.length;
    let idx = 0;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer.state === 0) {
        timer.state = fastNow + timer.delay;
      } else if (timer.state > 0 && fastNow >= timer.state) {
        timer.state = -1;
        timer.callback(timer.opaque);
      }
      if (timer.state === -1) {
        timer.state = -2;
        if (idx !== len - 1) {
          fastTimers[idx] = fastTimers.pop();
        } else {
          fastTimers.pop();
        }
        len -= 1;
      } else {
        idx += 1;
      }
    }
    if (fastTimers.length > 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout && fastNowTimeout.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTimeout, 1e3);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  }
  class Timeout {
    constructor(callback, delay2, opaque) {
      this.callback = callback;
      this.delay = delay2;
      this.opaque = opaque;
      this.state = -2;
      this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        fastTimers.push(this);
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  timers = {
    setTimeout(callback, delay2, opaque) {
      return delay2 < 1e3 ? setTimeout(callback, delay2, opaque) : new Timeout(callback, delay2, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    }
  };
  return timers;
}
var main$1 = { exports: {} };
var sbmh;
var hasRequiredSbmh;
function requireSbmh() {
  if (hasRequiredSbmh) return sbmh;
  hasRequiredSbmh = 1;
  const EventEmitter = require$$0$a.EventEmitter;
  const inherits = require$$1$5.inherits;
  function SBMH(needle) {
    if (typeof needle === "string") {
      needle = Buffer.from(needle);
    }
    if (!Buffer.isBuffer(needle)) {
      throw new TypeError("The needle has to be a String or a Buffer.");
    }
    const needleLength = needle.length;
    if (needleLength === 0) {
      throw new Error("The needle cannot be an empty String/Buffer.");
    }
    if (needleLength > 256) {
      throw new Error("The needle cannot have a length bigger than 256.");
    }
    this.maxMatches = Infinity;
    this.matches = 0;
    this._occ = new Array(256).fill(needleLength);
    this._lookbehind_size = 0;
    this._needle = needle;
    this._bufpos = 0;
    this._lookbehind = Buffer.alloc(needleLength);
    for (var i = 0; i < needleLength - 1; ++i) {
      this._occ[needle[i]] = needleLength - 1 - i;
    }
  }
  inherits(SBMH, EventEmitter);
  SBMH.prototype.reset = function() {
    this._lookbehind_size = 0;
    this.matches = 0;
    this._bufpos = 0;
  };
  SBMH.prototype.push = function(chunk, pos) {
    if (!Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, "binary");
    }
    const chlen = chunk.length;
    this._bufpos = pos || 0;
    let r;
    while (r !== chlen && this.matches < this.maxMatches) {
      r = this._sbmh_feed(chunk);
    }
    return r;
  };
  SBMH.prototype._sbmh_feed = function(data) {
    const len = data.length;
    const needle = this._needle;
    const needleLength = needle.length;
    const lastNeedleChar = needle[needleLength - 1];
    let pos = -this._lookbehind_size;
    let ch;
    if (pos < 0) {
      while (pos < 0 && pos <= len - needleLength) {
        ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
        if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
          this._lookbehind_size = 0;
          ++this.matches;
          this.emit("info", true);
          return this._bufpos = pos + needleLength;
        }
        pos += this._occ[ch];
      }
      if (pos < 0) {
        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
          ++pos;
        }
      }
      if (pos >= 0) {
        this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
        this._lookbehind_size = 0;
      } else {
        const bytesToCutOff = this._lookbehind_size + pos;
        if (bytesToCutOff > 0) {
          this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
        }
        this._lookbehind.copy(
          this._lookbehind,
          0,
          bytesToCutOff,
          this._lookbehind_size - bytesToCutOff
        );
        this._lookbehind_size -= bytesToCutOff;
        data.copy(this._lookbehind, this._lookbehind_size);
        this._lookbehind_size += len;
        this._bufpos = len;
        return len;
      }
    }
    pos += (pos >= 0) * this._bufpos;
    if (data.indexOf(needle, pos) !== -1) {
      pos = data.indexOf(needle, pos);
      ++this.matches;
      if (pos > 0) {
        this.emit("info", true, data, this._bufpos, pos);
      } else {
        this.emit("info", true);
      }
      return this._bufpos = pos + needleLength;
    } else {
      pos = len - needleLength;
    }
    while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
      data.subarray(pos, pos + len - pos),
      needle.subarray(0, len - pos)
    ) !== 0)) {
      ++pos;
    }
    if (pos < len) {
      data.copy(this._lookbehind, 0, pos, pos + (len - pos));
      this._lookbehind_size = len - pos;
    }
    if (pos > 0) {
      this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
    }
    this._bufpos = len;
    return len;
  };
  SBMH.prototype._sbmh_lookup_char = function(data, pos) {
    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
  };
  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
    for (var i = 0; i < len; ++i) {
      if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
        return false;
      }
    }
    return true;
  };
  sbmh = SBMH;
  return sbmh;
}
var PartStream_1;
var hasRequiredPartStream;
function requirePartStream() {
  if (hasRequiredPartStream) return PartStream_1;
  hasRequiredPartStream = 1;
  const inherits = require$$1$5.inherits;
  const ReadableStream2 = require$$0$b.Readable;
  function PartStream(opts) {
    ReadableStream2.call(this, opts);
  }
  inherits(PartStream, ReadableStream2);
  PartStream.prototype._read = function(n) {
  };
  PartStream_1 = PartStream;
  return PartStream_1;
}
var getLimit;
var hasRequiredGetLimit;
function requireGetLimit() {
  if (hasRequiredGetLimit) return getLimit;
  hasRequiredGetLimit = 1;
  getLimit = function getLimit2(limits, name, defaultLimit) {
    if (!limits || limits[name] === void 0 || limits[name] === null) {
      return defaultLimit;
    }
    if (typeof limits[name] !== "number" || isNaN(limits[name])) {
      throw new TypeError("Limit " + name + " is not a valid number");
    }
    return limits[name];
  };
  return getLimit;
}
var HeaderParser_1;
var hasRequiredHeaderParser;
function requireHeaderParser() {
  if (hasRequiredHeaderParser) return HeaderParser_1;
  hasRequiredHeaderParser = 1;
  const EventEmitter = require$$0$a.EventEmitter;
  const inherits = require$$1$5.inherits;
  const getLimit2 = /* @__PURE__ */ requireGetLimit();
  const StreamSearch = /* @__PURE__ */ requireSbmh();
  const B_DCRLF = Buffer.from("\r\n\r\n");
  const RE_CRLF = /\r\n/g;
  const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function HeaderParser(cfg) {
    EventEmitter.call(this);
    cfg = cfg || {};
    const self2 = this;
    this.nread = 0;
    this.maxed = false;
    this.npairs = 0;
    this.maxHeaderPairs = getLimit2(cfg, "maxHeaderPairs", 2e3);
    this.maxHeaderSize = getLimit2(cfg, "maxHeaderSize", 80 * 1024);
    this.buffer = "";
    this.header = {};
    this.finished = false;
    this.ss = new StreamSearch(B_DCRLF);
    this.ss.on("info", function(isMatch, data, start, end) {
      if (data && !self2.maxed) {
        if (self2.nread + end - start >= self2.maxHeaderSize) {
          end = self2.maxHeaderSize - self2.nread + start;
          self2.nread = self2.maxHeaderSize;
          self2.maxed = true;
        } else {
          self2.nread += end - start;
        }
        self2.buffer += data.toString("binary", start, end);
      }
      if (isMatch) {
        self2._finish();
      }
    });
  }
  inherits(HeaderParser, EventEmitter);
  HeaderParser.prototype.push = function(data) {
    const r = this.ss.push(data);
    if (this.finished) {
      return r;
    }
  };
  HeaderParser.prototype.reset = function() {
    this.finished = false;
    this.buffer = "";
    this.header = {};
    this.ss.reset();
  };
  HeaderParser.prototype._finish = function() {
    if (this.buffer) {
      this._parseHeader();
    }
    this.ss.matches = this.ss.maxMatches;
    const header = this.header;
    this.header = {};
    this.buffer = "";
    this.finished = true;
    this.nread = this.npairs = 0;
    this.maxed = false;
    this.emit("header", header);
  };
  HeaderParser.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs) {
      return;
    }
    const lines = this.buffer.split(RE_CRLF);
    const len = lines.length;
    let m, h;
    for (var i = 0; i < len; ++i) {
      if (lines[i].length === 0) {
        continue;
      }
      if (lines[i][0] === "	" || lines[i][0] === " ") {
        if (h) {
          this.header[h][this.header[h].length - 1] += lines[i];
          continue;
        }
      }
      const posColon = lines[i].indexOf(":");
      if (posColon === -1 || posColon === 0) {
        return;
      }
      m = RE_HDR.exec(lines[i]);
      h = m[1].toLowerCase();
      this.header[h] = this.header[h] || [];
      this.header[h].push(m[2] || "");
      if (++this.npairs === this.maxHeaderPairs) {
        break;
      }
    }
  };
  HeaderParser_1 = HeaderParser;
  return HeaderParser_1;
}
var Dicer_1;
var hasRequiredDicer;
function requireDicer() {
  if (hasRequiredDicer) return Dicer_1;
  hasRequiredDicer = 1;
  const WritableStream = require$$0$b.Writable;
  const inherits = require$$1$5.inherits;
  const StreamSearch = /* @__PURE__ */ requireSbmh();
  const PartStream = /* @__PURE__ */ requirePartStream();
  const HeaderParser = /* @__PURE__ */ requireHeaderParser();
  const DASH = 45;
  const B_ONEDASH = Buffer.from("-");
  const B_CRLF = Buffer.from("\r\n");
  const EMPTY_FN = function() {
  };
  function Dicer(cfg) {
    if (!(this instanceof Dicer)) {
      return new Dicer(cfg);
    }
    WritableStream.call(this, cfg);
    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
      throw new TypeError("Boundary required");
    }
    if (typeof cfg.boundary === "string") {
      this.setBoundary(cfg.boundary);
    } else {
      this._bparser = void 0;
    }
    this._headerFirst = cfg.headerFirst;
    this._dashes = 0;
    this._parts = 0;
    this._finished = false;
    this._realFinish = false;
    this._isPreamble = true;
    this._justMatched = false;
    this._firstWrite = true;
    this._inHeader = true;
    this._part = void 0;
    this._cb = void 0;
    this._ignoreData = false;
    this._partOpts = { highWaterMark: cfg.partHwm };
    this._pause = false;
    const self2 = this;
    this._hparser = new HeaderParser(cfg);
    this._hparser.on("header", function(header) {
      self2._inHeader = false;
      self2._part.emit("header", header);
    });
  }
  inherits(Dicer, WritableStream);
  Dicer.prototype.emit = function(ev) {
    if (ev === "finish" && !this._realFinish) {
      if (!this._finished) {
        const self2 = this;
        process.nextTick(function() {
          self2.emit("error", new Error("Unexpected end of multipart data"));
          if (self2._part && !self2._ignoreData) {
            const type = self2._isPreamble ? "Preamble" : "Part";
            self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
            self2._part.push(null);
            process.nextTick(function() {
              self2._realFinish = true;
              self2.emit("finish");
              self2._realFinish = false;
            });
            return;
          }
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        });
      }
    } else {
      WritableStream.prototype.emit.apply(this, arguments);
    }
  };
  Dicer.prototype._write = function(data, encoding2, cb) {
    if (!this._hparser && !this._bparser) {
      return cb();
    }
    if (this._headerFirst && this._isPreamble) {
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        if (this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else {
          this._ignore();
        }
      }
      const r = this._hparser.push(data);
      if (!this._inHeader && r !== void 0 && r < data.length) {
        data = data.slice(r);
      } else {
        return cb();
      }
    }
    if (this._firstWrite) {
      this._bparser.push(B_CRLF);
      this._firstWrite = false;
    }
    this._bparser.push(data);
    if (this._pause) {
      this._cb = cb;
    } else {
      cb();
    }
  };
  Dicer.prototype.reset = function() {
    this._part = void 0;
    this._bparser = void 0;
    this._hparser = void 0;
  };
  Dicer.prototype.setBoundary = function(boundary) {
    const self2 = this;
    this._bparser = new StreamSearch("\r\n--" + boundary);
    this._bparser.on("info", function(isMatch, data, start, end) {
      self2._oninfo(isMatch, data, start, end);
    });
  };
  Dicer.prototype._ignore = function() {
    if (this._part && !this._ignoreData) {
      this._ignoreData = true;
      this._part.on("error", EMPTY_FN);
      this._part.resume();
    }
  };
  Dicer.prototype._oninfo = function(isMatch, data, start, end) {
    let buf;
    const self2 = this;
    let i = 0;
    let r;
    let shouldWriteMore = true;
    if (!this._part && this._justMatched && data) {
      while (this._dashes < 2 && start + i < end) {
        if (data[start + i] === DASH) {
          ++i;
          ++this._dashes;
        } else {
          if (this._dashes) {
            buf = B_ONEDASH;
          }
          this._dashes = 0;
          break;
        }
      }
      if (this._dashes === 2) {
        if (start + i < end && this.listenerCount("trailer") !== 0) {
          this.emit("trailer", data.slice(start + i, end));
        }
        this.reset();
        this._finished = true;
        if (self2._parts === 0) {
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        }
      }
      if (this._dashes) {
        return;
      }
    }
    if (this._justMatched) {
      this._justMatched = false;
    }
    if (!this._part) {
      this._part = new PartStream(this._partOpts);
      this._part._read = function(n) {
        self2._unpause();
      };
      if (this._isPreamble && this.listenerCount("preamble") !== 0) {
        this.emit("preamble", this._part);
      } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
        this.emit("part", this._part);
      } else {
        this._ignore();
      }
      if (!this._isPreamble) {
        this._inHeader = true;
      }
    }
    if (data && start < end && !this._ignoreData) {
      if (this._isPreamble || !this._inHeader) {
        if (buf) {
          shouldWriteMore = this._part.push(buf);
        }
        shouldWriteMore = this._part.push(data.slice(start, end));
        if (!shouldWriteMore) {
          this._pause = true;
        }
      } else if (!this._isPreamble && this._inHeader) {
        if (buf) {
          this._hparser.push(buf);
        }
        r = this._hparser.push(data.slice(start, end));
        if (!this._inHeader && r !== void 0 && r < end) {
          this._oninfo(false, data, start + r, end);
        }
      }
    }
    if (isMatch) {
      this._hparser.reset();
      if (this._isPreamble) {
        this._isPreamble = false;
      } else {
        if (start !== end) {
          ++this._parts;
          this._part.on("end", function() {
            if (--self2._parts === 0) {
              if (self2._finished) {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              } else {
                self2._unpause();
              }
            }
          });
        }
      }
      this._part.push(null);
      this._part = void 0;
      this._ignoreData = false;
      this._justMatched = true;
      this._dashes = 0;
    }
  };
  Dicer.prototype._unpause = function() {
    if (!this._pause) {
      return;
    }
    this._pause = false;
    if (this._cb) {
      const cb = this._cb;
      this._cb = void 0;
      cb();
    }
  };
  Dicer_1 = Dicer;
  return Dicer_1;
}
var decodeText_1;
var hasRequiredDecodeText;
function requireDecodeText() {
  if (hasRequiredDecodeText) return decodeText_1;
  hasRequiredDecodeText = 1;
  const utf8Decoder = new TextDecoder("utf-8");
  const textDecoders = /* @__PURE__ */ new Map([
    ["utf-8", utf8Decoder],
    ["utf8", utf8Decoder]
  ]);
  function getDecoder(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        // TODO: Make these a separate, strict decoder?
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === void 0) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  }
  const decoders = {
    utf8: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        return data;
      }
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.base64Slice(0, data.length);
    },
    other: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      if (textDecoders.has(this.toString())) {
        try {
          return textDecoders.get(this).decode(data);
        } catch {
        }
      }
      return typeof data === "string" ? data : data.toString();
    }
  };
  function decodeText(text, sourceEncoding, destEncoding) {
    if (text) {
      return getDecoder(destEncoding)(text, sourceEncoding);
    }
    return text;
  }
  decodeText_1 = decodeText;
  return decodeText_1;
}
var parseParams_1;
var hasRequiredParseParams;
function requireParseParams() {
  if (hasRequiredParseParams) return parseParams_1;
  hasRequiredParseParams = 1;
  const decodeText = /* @__PURE__ */ requireDecodeText();
  const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
  const EncodedLookup = {
    "%00": "\0",
    "%01": "",
    "%02": "",
    "%03": "",
    "%04": "",
    "%05": "",
    "%06": "",
    "%07": "\x07",
    "%08": "\b",
    "%09": "	",
    "%0a": "\n",
    "%0A": "\n",
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": "\r",
    "%0D": "\r",
    "%0e": "",
    "%0E": "",
    "%0f": "",
    "%0F": "",
    "%10": "",
    "%11": "",
    "%12": "",
    "%13": "",
    "%14": "",
    "%15": "",
    "%16": "",
    "%17": "",
    "%18": "",
    "%19": "",
    "%1a": "",
    "%1A": "",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "",
    "%1C": "",
    "%1d": "",
    "%1D": "",
    "%1e": "",
    "%1E": "",
    "%1f": "",
    "%1F": "",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "",
    "%7F": "",
    "%80": "",
    "%81": "",
    "%82": "",
    "%83": "",
    "%84": "",
    "%85": "",
    "%86": "",
    "%87": "",
    "%88": "",
    "%89": "",
    "%8a": "",
    "%8A": "",
    "%8b": "",
    "%8B": "",
    "%8c": "",
    "%8C": "",
    "%8d": "",
    "%8D": "",
    "%8e": "",
    "%8E": "",
    "%8f": "",
    "%8F": "",
    "%90": "",
    "%91": "",
    "%92": "",
    "%93": "",
    "%94": "",
    "%95": "",
    "%96": "",
    "%97": "",
    "%98": "",
    "%99": "",
    "%9a": "",
    "%9A": "",
    "%9b": "",
    "%9B": "",
    "%9c": "",
    "%9C": "",
    "%9d": "",
    "%9D": "",
    "%9e": "",
    "%9E": "",
    "%9f": "",
    "%9F": "",
    "%a0": " ",
    "%A0": " ",
    "%a1": "¡",
    "%A1": "¡",
    "%a2": "¢",
    "%A2": "¢",
    "%a3": "£",
    "%A3": "£",
    "%a4": "¤",
    "%A4": "¤",
    "%a5": "¥",
    "%A5": "¥",
    "%a6": "¦",
    "%A6": "¦",
    "%a7": "§",
    "%A7": "§",
    "%a8": "¨",
    "%A8": "¨",
    "%a9": "©",
    "%A9": "©",
    "%aa": "ª",
    "%Aa": "ª",
    "%aA": "ª",
    "%AA": "ª",
    "%ab": "«",
    "%Ab": "«",
    "%aB": "«",
    "%AB": "«",
    "%ac": "¬",
    "%Ac": "¬",
    "%aC": "¬",
    "%AC": "¬",
    "%ad": "­",
    "%Ad": "­",
    "%aD": "­",
    "%AD": "­",
    "%ae": "®",
    "%Ae": "®",
    "%aE": "®",
    "%AE": "®",
    "%af": "¯",
    "%Af": "¯",
    "%aF": "¯",
    "%AF": "¯",
    "%b0": "°",
    "%B0": "°",
    "%b1": "±",
    "%B1": "±",
    "%b2": "²",
    "%B2": "²",
    "%b3": "³",
    "%B3": "³",
    "%b4": "´",
    "%B4": "´",
    "%b5": "µ",
    "%B5": "µ",
    "%b6": "¶",
    "%B6": "¶",
    "%b7": "·",
    "%B7": "·",
    "%b8": "¸",
    "%B8": "¸",
    "%b9": "¹",
    "%B9": "¹",
    "%ba": "º",
    "%Ba": "º",
    "%bA": "º",
    "%BA": "º",
    "%bb": "»",
    "%Bb": "»",
    "%bB": "»",
    "%BB": "»",
    "%bc": "¼",
    "%Bc": "¼",
    "%bC": "¼",
    "%BC": "¼",
    "%bd": "½",
    "%Bd": "½",
    "%bD": "½",
    "%BD": "½",
    "%be": "¾",
    "%Be": "¾",
    "%bE": "¾",
    "%BE": "¾",
    "%bf": "¿",
    "%Bf": "¿",
    "%bF": "¿",
    "%BF": "¿",
    "%c0": "À",
    "%C0": "À",
    "%c1": "Á",
    "%C1": "Á",
    "%c2": "Â",
    "%C2": "Â",
    "%c3": "Ã",
    "%C3": "Ã",
    "%c4": "Ä",
    "%C4": "Ä",
    "%c5": "Å",
    "%C5": "Å",
    "%c6": "Æ",
    "%C6": "Æ",
    "%c7": "Ç",
    "%C7": "Ç",
    "%c8": "È",
    "%C8": "È",
    "%c9": "É",
    "%C9": "É",
    "%ca": "Ê",
    "%Ca": "Ê",
    "%cA": "Ê",
    "%CA": "Ê",
    "%cb": "Ë",
    "%Cb": "Ë",
    "%cB": "Ë",
    "%CB": "Ë",
    "%cc": "Ì",
    "%Cc": "Ì",
    "%cC": "Ì",
    "%CC": "Ì",
    "%cd": "Í",
    "%Cd": "Í",
    "%cD": "Í",
    "%CD": "Í",
    "%ce": "Î",
    "%Ce": "Î",
    "%cE": "Î",
    "%CE": "Î",
    "%cf": "Ï",
    "%Cf": "Ï",
    "%cF": "Ï",
    "%CF": "Ï",
    "%d0": "Ð",
    "%D0": "Ð",
    "%d1": "Ñ",
    "%D1": "Ñ",
    "%d2": "Ò",
    "%D2": "Ò",
    "%d3": "Ó",
    "%D3": "Ó",
    "%d4": "Ô",
    "%D4": "Ô",
    "%d5": "Õ",
    "%D5": "Õ",
    "%d6": "Ö",
    "%D6": "Ö",
    "%d7": "×",
    "%D7": "×",
    "%d8": "Ø",
    "%D8": "Ø",
    "%d9": "Ù",
    "%D9": "Ù",
    "%da": "Ú",
    "%Da": "Ú",
    "%dA": "Ú",
    "%DA": "Ú",
    "%db": "Û",
    "%Db": "Û",
    "%dB": "Û",
    "%DB": "Û",
    "%dc": "Ü",
    "%Dc": "Ü",
    "%dC": "Ü",
    "%DC": "Ü",
    "%dd": "Ý",
    "%Dd": "Ý",
    "%dD": "Ý",
    "%DD": "Ý",
    "%de": "Þ",
    "%De": "Þ",
    "%dE": "Þ",
    "%DE": "Þ",
    "%df": "ß",
    "%Df": "ß",
    "%dF": "ß",
    "%DF": "ß",
    "%e0": "à",
    "%E0": "à",
    "%e1": "á",
    "%E1": "á",
    "%e2": "â",
    "%E2": "â",
    "%e3": "ã",
    "%E3": "ã",
    "%e4": "ä",
    "%E4": "ä",
    "%e5": "å",
    "%E5": "å",
    "%e6": "æ",
    "%E6": "æ",
    "%e7": "ç",
    "%E7": "ç",
    "%e8": "è",
    "%E8": "è",
    "%e9": "é",
    "%E9": "é",
    "%ea": "ê",
    "%Ea": "ê",
    "%eA": "ê",
    "%EA": "ê",
    "%eb": "ë",
    "%Eb": "ë",
    "%eB": "ë",
    "%EB": "ë",
    "%ec": "ì",
    "%Ec": "ì",
    "%eC": "ì",
    "%EC": "ì",
    "%ed": "í",
    "%Ed": "í",
    "%eD": "í",
    "%ED": "í",
    "%ee": "î",
    "%Ee": "î",
    "%eE": "î",
    "%EE": "î",
    "%ef": "ï",
    "%Ef": "ï",
    "%eF": "ï",
    "%EF": "ï",
    "%f0": "ð",
    "%F0": "ð",
    "%f1": "ñ",
    "%F1": "ñ",
    "%f2": "ò",
    "%F2": "ò",
    "%f3": "ó",
    "%F3": "ó",
    "%f4": "ô",
    "%F4": "ô",
    "%f5": "õ",
    "%F5": "õ",
    "%f6": "ö",
    "%F6": "ö",
    "%f7": "÷",
    "%F7": "÷",
    "%f8": "ø",
    "%F8": "ø",
    "%f9": "ù",
    "%F9": "ù",
    "%fa": "ú",
    "%Fa": "ú",
    "%fA": "ú",
    "%FA": "ú",
    "%fb": "û",
    "%Fb": "û",
    "%fB": "û",
    "%FB": "û",
    "%fc": "ü",
    "%Fc": "ü",
    "%fC": "ü",
    "%FC": "ü",
    "%fd": "ý",
    "%Fd": "ý",
    "%fD": "ý",
    "%FD": "ý",
    "%fe": "þ",
    "%Fe": "þ",
    "%fE": "þ",
    "%FE": "þ",
    "%ff": "ÿ",
    "%Ff": "ÿ",
    "%fF": "ÿ",
    "%FF": "ÿ"
  };
  function encodedReplacer(match) {
    return EncodedLookup[match];
  }
  const STATE_KEY = 0;
  const STATE_VALUE = 1;
  const STATE_CHARSET = 2;
  const STATE_LANG = 3;
  function parseParams(str) {
    const res = [];
    let state2 = STATE_KEY;
    let charset = "";
    let inquote = false;
    let escaping = false;
    let p = 0;
    let tmp = "";
    const len = str.length;
    for (var i = 0; i < len; ++i) {
      const char = str[i];
      if (char === "\\" && inquote) {
        if (escaping) {
          escaping = false;
        } else {
          escaping = true;
          continue;
        }
      } else if (char === '"') {
        if (!escaping) {
          if (inquote) {
            inquote = false;
            state2 = STATE_KEY;
          } else {
            inquote = true;
          }
          continue;
        } else {
          escaping = false;
        }
      } else {
        if (escaping && inquote) {
          tmp += "\\";
        }
        escaping = false;
        if ((state2 === STATE_CHARSET || state2 === STATE_LANG) && char === "'") {
          if (state2 === STATE_CHARSET) {
            state2 = STATE_LANG;
            charset = tmp.substring(1);
          } else {
            state2 = STATE_VALUE;
          }
          tmp = "";
          continue;
        } else if (state2 === STATE_KEY && (char === "*" || char === "=") && res.length) {
          state2 = char === "*" ? STATE_CHARSET : STATE_VALUE;
          res[p] = [tmp, void 0];
          tmp = "";
          continue;
        } else if (!inquote && char === ";") {
          state2 = STATE_KEY;
          if (charset) {
            if (tmp.length) {
              tmp = decodeText(
                tmp.replace(RE_ENCODED, encodedReplacer),
                "binary",
                charset
              );
            }
            charset = "";
          } else if (tmp.length) {
            tmp = decodeText(tmp, "binary", "utf8");
          }
          if (res[p] === void 0) {
            res[p] = tmp;
          } else {
            res[p][1] = tmp;
          }
          tmp = "";
          ++p;
          continue;
        } else if (!inquote && (char === " " || char === "	")) {
          continue;
        }
      }
      tmp += char;
    }
    if (charset && tmp.length) {
      tmp = decodeText(
        tmp.replace(RE_ENCODED, encodedReplacer),
        "binary",
        charset
      );
    } else if (tmp) {
      tmp = decodeText(tmp, "binary", "utf8");
    }
    if (res[p] === void 0) {
      if (tmp) {
        res[p] = tmp;
      }
    } else {
      res[p][1] = tmp;
    }
    return res;
  }
  parseParams_1 = parseParams;
  return parseParams_1;
}
var basename;
var hasRequiredBasename;
function requireBasename() {
  if (hasRequiredBasename) return basename;
  hasRequiredBasename = 1;
  basename = function basename2(path2) {
    if (typeof path2 !== "string") {
      return "";
    }
    for (var i = path2.length - 1; i >= 0; --i) {
      switch (path2.charCodeAt(i)) {
        case 47:
        // '/'
        case 92:
          path2 = path2.slice(i + 1);
          return path2 === ".." || path2 === "." ? "" : path2;
      }
    }
    return path2 === ".." || path2 === "." ? "" : path2;
  };
  return basename;
}
var multipart$1;
var hasRequiredMultipart$1;
function requireMultipart$1() {
  if (hasRequiredMultipart$1) return multipart$1;
  hasRequiredMultipart$1 = 1;
  const { Readable } = require$$0$b;
  const { inherits } = require$$1$5;
  const Dicer = /* @__PURE__ */ requireDicer();
  const parseParams = /* @__PURE__ */ requireParseParams();
  const decodeText = /* @__PURE__ */ requireDecodeText();
  const basename2 = /* @__PURE__ */ requireBasename();
  const getLimit2 = /* @__PURE__ */ requireGetLimit();
  const RE_BOUNDARY = /^boundary$/i;
  const RE_FIELD = /^form-data$/i;
  const RE_CHARSET = /^charset$/i;
  const RE_FILENAME = /^filename$/i;
  const RE_NAME = /^name$/i;
  Multipart.detect = /^multipart\/form-data/i;
  function Multipart(boy, cfg) {
    let i;
    let len;
    const self2 = this;
    let boundary;
    const limits = cfg.limits;
    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
    const parsedConType = cfg.parsedConType || [];
    const defCharset = cfg.defCharset || "utf8";
    const preservePath = cfg.preservePath;
    const fileOpts = { highWaterMark: cfg.fileHwm };
    for (i = 0, len = parsedConType.length; i < len; ++i) {
      if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
        boundary = parsedConType[i][1];
        break;
      }
    }
    function checkFinished() {
      if (nends === 0 && finished && !boy._done) {
        finished = false;
        self2.end();
      }
    }
    if (typeof boundary !== "string") {
      throw new Error("Multipart: Boundary not found");
    }
    const fieldSizeLimit = getLimit2(limits, "fieldSize", 1 * 1024 * 1024);
    const fileSizeLimit = getLimit2(limits, "fileSize", Infinity);
    const filesLimit = getLimit2(limits, "files", Infinity);
    const fieldsLimit = getLimit2(limits, "fields", Infinity);
    const partsLimit = getLimit2(limits, "parts", Infinity);
    const headerPairsLimit = getLimit2(limits, "headerPairs", 2e3);
    const headerSizeLimit = getLimit2(limits, "headerSize", 80 * 1024);
    let nfiles = 0;
    let nfields = 0;
    let nends = 0;
    let curFile;
    let curField;
    let finished = false;
    this._needDrain = false;
    this._pause = false;
    this._cb = void 0;
    this._nparts = 0;
    this._boy = boy;
    const parserCfg = {
      boundary,
      maxHeaderPairs: headerPairsLimit,
      maxHeaderSize: headerSizeLimit,
      partHwm: fileOpts.highWaterMark,
      highWaterMark: cfg.highWaterMark
    };
    this.parser = new Dicer(parserCfg);
    this.parser.on("drain", function() {
      self2._needDrain = false;
      if (self2._cb && !self2._pause) {
        const cb = self2._cb;
        self2._cb = void 0;
        cb();
      }
    }).on("part", function onPart(part) {
      if (++self2._nparts > partsLimit) {
        self2.parser.removeListener("part", onPart);
        self2.parser.on("part", skipPart);
        boy.hitPartsLimit = true;
        boy.emit("partsLimit");
        return skipPart(part);
      }
      if (curField) {
        const field = curField;
        field.emit("end");
        field.removeAllListeners("end");
      }
      part.on("header", function(header) {
        let contype;
        let fieldname;
        let parsed;
        let charset;
        let encoding2;
        let filename;
        let nsize = 0;
        if (header["content-type"]) {
          parsed = parseParams(header["content-type"][0]);
          if (parsed[0]) {
            contype = parsed[0].toLowerCase();
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_CHARSET.test(parsed[i][0])) {
                charset = parsed[i][1].toLowerCase();
                break;
              }
            }
          }
        }
        if (contype === void 0) {
          contype = "text/plain";
        }
        if (charset === void 0) {
          charset = defCharset;
        }
        if (header["content-disposition"]) {
          parsed = parseParams(header["content-disposition"][0]);
          if (!RE_FIELD.test(parsed[0])) {
            return skipPart(part);
          }
          for (i = 0, len = parsed.length; i < len; ++i) {
            if (RE_NAME.test(parsed[i][0])) {
              fieldname = parsed[i][1];
            } else if (RE_FILENAME.test(parsed[i][0])) {
              filename = parsed[i][1];
              if (!preservePath) {
                filename = basename2(filename);
              }
            }
          }
        } else {
          return skipPart(part);
        }
        if (header["content-transfer-encoding"]) {
          encoding2 = header["content-transfer-encoding"][0].toLowerCase();
        } else {
          encoding2 = "7bit";
        }
        let onData, onEnd;
        if (isPartAFile(fieldname, contype, filename)) {
          if (nfiles === filesLimit) {
            if (!boy.hitFilesLimit) {
              boy.hitFilesLimit = true;
              boy.emit("filesLimit");
            }
            return skipPart(part);
          }
          ++nfiles;
          if (boy.listenerCount("file") === 0) {
            self2.parser._ignore();
            return;
          }
          ++nends;
          const file2 = new FileStream(fileOpts);
          curFile = file2;
          file2.on("end", function() {
            --nends;
            self2._pause = false;
            checkFinished();
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = void 0;
              cb();
            }
          });
          file2._read = function(n) {
            if (!self2._pause) {
              return;
            }
            self2._pause = false;
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = void 0;
              cb();
            }
          };
          boy.emit("file", fieldname, file2, filename, encoding2, contype);
          onData = function(data) {
            if ((nsize += data.length) > fileSizeLimit) {
              const extralen = fileSizeLimit - nsize + data.length;
              if (extralen > 0) {
                file2.push(data.slice(0, extralen));
              }
              file2.truncated = true;
              file2.bytesRead = fileSizeLimit;
              part.removeAllListeners("data");
              file2.emit("limit");
              return;
            } else if (!file2.push(data)) {
              self2._pause = true;
            }
            file2.bytesRead = nsize;
          };
          onEnd = function() {
            curFile = void 0;
            file2.push(null);
          };
        } else {
          if (nfields === fieldsLimit) {
            if (!boy.hitFieldsLimit) {
              boy.hitFieldsLimit = true;
              boy.emit("fieldsLimit");
            }
            return skipPart(part);
          }
          ++nfields;
          ++nends;
          let buffer = "";
          let truncated = false;
          curField = part;
          onData = function(data) {
            if ((nsize += data.length) > fieldSizeLimit) {
              const extralen = fieldSizeLimit - (nsize - data.length);
              buffer += data.toString("binary", 0, extralen);
              truncated = true;
              part.removeAllListeners("data");
            } else {
              buffer += data.toString("binary");
            }
          };
          onEnd = function() {
            curField = void 0;
            if (buffer.length) {
              buffer = decodeText(buffer, "binary", charset);
            }
            boy.emit("field", fieldname, buffer, false, truncated, encoding2, contype);
            --nends;
            checkFinished();
          };
        }
        part._readableState.sync = false;
        part.on("data", onData);
        part.on("end", onEnd);
      }).on("error", function(err) {
        if (curFile) {
          curFile.emit("error", err);
        }
      });
    }).on("error", function(err) {
      boy.emit("error", err);
    }).on("finish", function() {
      finished = true;
      checkFinished();
    });
  }
  Multipart.prototype.write = function(chunk, cb) {
    const r = this.parser.write(chunk);
    if (r && !this._pause) {
      cb();
    } else {
      this._needDrain = !r;
      this._cb = cb;
    }
  };
  Multipart.prototype.end = function() {
    const self2 = this;
    if (self2.parser.writable) {
      self2.parser.end();
    } else if (!self2._boy._done) {
      process.nextTick(function() {
        self2._boy._done = true;
        self2._boy.emit("finish");
      });
    }
  };
  function skipPart(part) {
    part.resume();
  }
  function FileStream(opts) {
    Readable.call(this, opts);
    this.bytesRead = 0;
    this.truncated = false;
  }
  inherits(FileStream, Readable);
  FileStream.prototype._read = function(n) {
  };
  multipart$1 = Multipart;
  return multipart$1;
}
var Decoder_1;
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return Decoder_1;
  hasRequiredDecoder = 1;
  const RE_PLUS = /\+/g;
  const HEX = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function Decoder() {
    this.buffer = void 0;
  }
  Decoder.prototype.write = function(str) {
    str = str.replace(RE_PLUS, " ");
    let res = "";
    let i = 0;
    let p = 0;
    const len = str.length;
    for (; i < len; ++i) {
      if (this.buffer !== void 0) {
        if (!HEX[str.charCodeAt(i)]) {
          res += "%" + this.buffer;
          this.buffer = void 0;
          --i;
        } else {
          this.buffer += str[i];
          ++p;
          if (this.buffer.length === 2) {
            res += String.fromCharCode(parseInt(this.buffer, 16));
            this.buffer = void 0;
          }
        }
      } else if (str[i] === "%") {
        if (i > p) {
          res += str.substring(p, i);
          p = i;
        }
        this.buffer = "";
        ++p;
      }
    }
    if (p < len && this.buffer === void 0) {
      res += str.substring(p);
    }
    return res;
  };
  Decoder.prototype.reset = function() {
    this.buffer = void 0;
  };
  Decoder_1 = Decoder;
  return Decoder_1;
}
var urlencoded;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded;
  hasRequiredUrlencoded = 1;
  const Decoder = /* @__PURE__ */ requireDecoder();
  const decodeText = /* @__PURE__ */ requireDecodeText();
  const getLimit2 = /* @__PURE__ */ requireGetLimit();
  const RE_CHARSET = /^charset$/i;
  UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
  function UrlEncoded(boy, cfg) {
    const limits = cfg.limits;
    const parsedConType = cfg.parsedConType;
    this.boy = boy;
    this.fieldSizeLimit = getLimit2(limits, "fieldSize", 1 * 1024 * 1024);
    this.fieldNameSizeLimit = getLimit2(limits, "fieldNameSize", 100);
    this.fieldsLimit = getLimit2(limits, "fields", Infinity);
    let charset;
    for (var i = 0, len = parsedConType.length; i < len; ++i) {
      if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
        charset = parsedConType[i][1].toLowerCase();
        break;
      }
    }
    if (charset === void 0) {
      charset = cfg.defCharset || "utf8";
    }
    this.decoder = new Decoder();
    this.charset = charset;
    this._fields = 0;
    this._state = "key";
    this._checkingBytes = true;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._key = "";
    this._val = "";
    this._keyTrunc = false;
    this._valTrunc = false;
    this._hitLimit = false;
  }
  UrlEncoded.prototype.write = function(data, cb) {
    if (this._fields === this.fieldsLimit) {
      if (!this.boy.hitFieldsLimit) {
        this.boy.hitFieldsLimit = true;
        this.boy.emit("fieldsLimit");
      }
      return cb();
    }
    let idxeq;
    let idxamp;
    let i;
    let p = 0;
    const len = data.length;
    while (p < len) {
      if (this._state === "key") {
        idxeq = idxamp = void 0;
        for (i = p; i < len; ++i) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i] === 61) {
            idxeq = i;
            break;
          } else if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesKey;
          }
        }
        if (idxeq !== void 0) {
          if (idxeq > p) {
            this._key += this.decoder.write(data.toString("binary", p, idxeq));
          }
          this._state = "val";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._val = "";
          this._bytesVal = 0;
          this._valTrunc = false;
          this.decoder.reset();
          p = idxeq + 1;
        } else if (idxamp !== void 0) {
          ++this._fields;
          let key;
          const keyTrunc = this._keyTrunc;
          if (idxamp > p) {
            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
          } else {
            key = this._key;
          }
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          if (key.length) {
            this.boy.emit(
              "field",
              decodeText(key, "binary", this.charset),
              "",
              keyTrunc,
              false
            );
          }
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i > p) {
            this._key += this.decoder.write(data.toString("binary", p, i));
          }
          p = i;
          if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
            this._checkingBytes = false;
            this._keyTrunc = true;
          }
        } else {
          if (p < len) {
            this._key += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      } else {
        idxamp = void 0;
        for (i = p; i < len; ++i) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesVal;
          }
        }
        if (idxamp !== void 0) {
          ++this._fields;
          if (idxamp > p) {
            this._val += this.decoder.write(data.toString("binary", p, idxamp));
          }
          this.boy.emit(
            "field",
            decodeText(this._key, "binary", this.charset),
            decodeText(this._val, "binary", this.charset),
            this._keyTrunc,
            this._valTrunc
          );
          this._state = "key";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i > p) {
            this._val += this.decoder.write(data.toString("binary", p, i));
          }
          p = i;
          if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
            this._checkingBytes = false;
            this._valTrunc = true;
          }
        } else {
          if (p < len) {
            this._val += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      }
    }
    cb();
  };
  UrlEncoded.prototype.end = function() {
    if (this.boy._done) {
      return;
    }
    if (this._state === "key" && this._key.length > 0) {
      this.boy.emit(
        "field",
        decodeText(this._key, "binary", this.charset),
        "",
        this._keyTrunc,
        false
      );
    } else if (this._state === "val") {
      this.boy.emit(
        "field",
        decodeText(this._key, "binary", this.charset),
        decodeText(this._val, "binary", this.charset),
        this._keyTrunc,
        this._valTrunc
      );
    }
    this.boy._done = true;
    this.boy.emit("finish");
  };
  urlencoded = UrlEncoded;
  return urlencoded;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main$1.exports;
  hasRequiredMain = 1;
  const WritableStream = require$$0$b.Writable;
  const { inherits } = require$$1$5;
  const Dicer = /* @__PURE__ */ requireDicer();
  const MultipartParser = /* @__PURE__ */ requireMultipart$1();
  const UrlencodedParser = /* @__PURE__ */ requireUrlencoded();
  const parseParams = /* @__PURE__ */ requireParseParams();
  function Busboy(opts) {
    if (!(this instanceof Busboy)) {
      return new Busboy(opts);
    }
    if (typeof opts !== "object") {
      throw new TypeError("Busboy expected an options-Object.");
    }
    if (typeof opts.headers !== "object") {
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    }
    if (typeof opts.headers["content-type"] !== "string") {
      throw new TypeError("Missing Content-Type-header.");
    }
    const {
      headers: headers2,
      ...streamOptions
    } = opts;
    this.opts = {
      autoDestroy: false,
      ...streamOptions
    };
    WritableStream.call(this, this.opts);
    this._done = false;
    this._parser = this.getParserByHeaders(headers2);
    this._finished = false;
  }
  inherits(Busboy, WritableStream);
  Busboy.prototype.emit = function(ev) {
    if (ev === "finish") {
      if (!this._done) {
        this._parser?.end();
        return;
      } else if (this._finished) {
        return;
      }
      this._finished = true;
    }
    WritableStream.prototype.emit.apply(this, arguments);
  };
  Busboy.prototype.getParserByHeaders = function(headers2) {
    const parsed = parseParams(headers2["content-type"]);
    const cfg = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers: headers2,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: parsed,
      preservePath: this.opts.preservePath
    };
    if (MultipartParser.detect.test(parsed[0])) {
      return new MultipartParser(this, cfg);
    }
    if (UrlencodedParser.detect.test(parsed[0])) {
      return new UrlencodedParser(this, cfg);
    }
    throw new Error("Unsupported Content-Type.");
  };
  Busboy.prototype._write = function(chunk, encoding2, cb) {
    this._parser.write(chunk, cb);
  };
  main$1.exports = Busboy;
  main$1.exports.default = Busboy;
  main$1.exports.Busboy = Busboy;
  main$1.exports.Dicer = Dicer;
  return main$1.exports;
}
var constants$9;
var hasRequiredConstants$9;
function requireConstants$9() {
  if (hasRequiredConstants$9) return constants$9;
  hasRequiredConstants$9 = 1;
  const { MessageChannel, receiveMessageOnPort } = require$$0$c;
  const corsSafeListedMethods = ["GET", "HEAD", "POST"];
  const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  const nullBodyStatus = [101, 204, 205, 304];
  const redirectStatus = [301, 302, 303, 307, 308];
  const redirectStatusSet = new Set(redirectStatus);
  const badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ];
  const badPortsSet = new Set(badPorts);
  const referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  const referrerPolicySet = new Set(referrerPolicy);
  const requestRedirect = ["follow", "manual", "error"];
  const safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  const safeMethodsSet = new Set(safeMethods);
  const requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  const requestCredentials = ["omit", "same-origin", "include"];
  const requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  const requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    // See https://github.com/nodejs/undici/issues/2021
    // 'Content-Length' is a forbidden header name, which is typically
    // removed in the Headers implementation. However, undici doesn't
    // filter out headers, so we add it here.
    "content-length"
  ];
  const requestDuplex = [
    "half"
  ];
  const forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  const forbiddenMethodsSet = new Set(forbiddenMethods);
  const subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  const subresourceSet = new Set(subresource);
  const DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })();
  let channel;
  const structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
  // structuredClone was added in v17.0.0, but fetch supports v16.8
  function structuredClone2(value, options2 = void 0) {
    if (arguments.length === 0) {
      throw new TypeError("missing argument");
    }
    if (!channel) {
      channel = new MessageChannel();
    }
    channel.port1.unref();
    channel.port2.unref();
    channel.port1.postMessage(value, options2?.transfer);
    return receiveMessageOnPort(channel.port2).message;
  };
  constants$9 = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
  return constants$9;
}
var global$2;
var hasRequiredGlobal$1;
function requireGlobal$1() {
  if (hasRequiredGlobal$1) return global$2;
  hasRequiredGlobal$1 = 1;
  const globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  global$2 = {
    getGlobalOrigin,
    setGlobalOrigin
  };
  return global$2;
}
var util$7;
var hasRequiredUtil$7;
function requireUtil$7() {
  if (hasRequiredUtil$7) return util$7;
  hasRequiredUtil$7 = 1;
  const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = /* @__PURE__ */ requireConstants$9();
  const { getGlobalOrigin } = /* @__PURE__ */ requireGlobal$1();
  const { performance: performance2 } = require$$2$1;
  const { isBlobLike, toUSVString, ReadableStreamFrom } = /* @__PURE__ */ requireUtil$8();
  const assert2 = require$$0$7;
  const { isUint8Array } = require$$5;
  let supportedHashes = [];
  let crypto;
  try {
    crypto = require("crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {
  }
  function responseURL(response2) {
    const urlList = response2.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response2, requestFragment) {
    if (!redirectStatusSet.has(response2.status)) {
      return null;
    }
    let location = response2.headersList.get("location");
    if (location !== null && isValidHeaderValue(location)) {
      location = new URL(location, responseURL(response2));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function requestCurrentURL(request2) {
    return request2.urlList[request2.urlList.length - 1];
  }
  function requestBadPort(request2) {
    const url = requestCurrentURL(request2);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object2) {
    return object2 instanceof Error || (object2?.constructor?.name === "Error" || object2?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0; i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || // HTAB
      c >= 32 && c <= 126 || // SP / VCHAR
      c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0) {
      return false;
    }
    for (let i = 0; i < characters.length; ++i) {
      if (!isTokenCharCode(characters.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  function isValidHeaderName(potentialValue) {
    return isValidHTTPToken(potentialValue);
  }
  function isValidHeaderValue(potentialValue) {
    if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
      return false;
    }
    if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
      return false;
    }
    return true;
  }
  function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length; i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request2.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header);
  }
  function appendRequestOriginHeader(request2) {
    let serializedOrigin = request2.origin;
    if (request2.responseTainting === "cors" || request2.mode === "websocket") {
      if (serializedOrigin) {
        request2.headersList.append("origin", serializedOrigin);
      }
    } else if (request2.method !== "GET" && request2.method !== "HEAD") {
      switch (request2.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request2, requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
      }
      if (serializedOrigin) {
        request2.headersList.append("origin", serializedOrigin);
      }
    }
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return performance2.now();
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request2) {
    const policy = request2.referrerPolicy;
    assert2(policy);
    let referrerSource = null;
    if (request2.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request2.referrer instanceof URL) {
      referrerSource = request2.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request2, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request2.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request2);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      // eslint-disable-line
      /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
      case "no-referrer-when-downgrade":
      // eslint-disable-line
      /**
       * 1. If referrerURL is a potentially trustworthy URL and
       * request’s current URL is not a potentially trustworthy URL,
       * then return no referrer.
       * 2. Return referrerOrigin
      */
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert2(url instanceof URL);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:") return true;
    if (url.protocol === "file:") return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto === void 0) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1; i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0; i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0; i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
  }
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  const normalizeMethodRecord = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(normalizeMethodRecord, null);
  function normalizeMethod(method) {
    return normalizeMethodRecord[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === void 0) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert2(typeof result === "string");
    return result;
  }
  const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function makeIterator(iterator, name, kind) {
    const object2 = {
      index: 0,
      kind,
      target: iterator
    };
    const i = {
      next() {
        if (Object.getPrototypeOf(this) !== i) {
          throw new TypeError(
            `'next' called on an object that does not implement interface ${name} Iterator.`
          );
        }
        const { index, kind: kind2, target } = object2;
        const values = target();
        const len = values.length;
        if (index >= len) {
          return { value: void 0, done: true };
        }
        const pair = values[index];
        object2.index = index + 1;
        return iteratorResult(pair, kind2);
      },
      // The class string of an iterator prototype object for a given interface is the
      // result of concatenating the identifier of the interface and the string " Iterator".
      [Symbol.toStringTag]: `${name} Iterator`
    };
    Object.setPrototypeOf(i, esIteratorPrototype);
    return Object.setPrototypeOf({}, i);
  }
  function iteratorResult(pair, kind) {
    let result;
    switch (kind) {
      case "key": {
        result = pair[0];
        break;
      }
      case "value": {
        result = pair[1];
        break;
      }
      case "key+value": {
        result = pair;
        break;
      }
    }
    return { value: result, done: false };
  }
  async function fullyReadBody(body2, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body2.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      const result = await readAllBytes(reader);
      successSteps(result);
    } catch (e) {
      errorSteps(e);
    }
  }
  let ReadableStream2 = globalThis.ReadableStream;
  function isReadableStreamLike(stream) {
    if (!ReadableStream2) {
      ReadableStream2 = require$$14.ReadableStream;
    }
    return stream instanceof ReadableStream2 || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  const MAXIMUM_ARGUMENT_LENGTH = 65535;
  function isomorphicDecode(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
      return String.fromCharCode(...input);
    }
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed")) {
        throw err;
      }
    }
  }
  function isomorphicEncode(input) {
    for (let i = 0; i < input.length; i++) {
      assert2(input.charCodeAt(i) <= 255);
    }
    return input;
  }
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert2("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    if (typeof url === "string") {
      return url.startsWith("https:");
    }
    return url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert2("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  const hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  util$7 = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    normalizeMethodRecord,
    parseMetadata
  };
  return util$7;
}
var symbols$3;
var hasRequiredSymbols$3;
function requireSymbols$3() {
  if (hasRequiredSymbols$3) return symbols$3;
  hasRequiredSymbols$3 = 1;
  symbols$3 = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
  return symbols$3;
}
var webidl_1;
var hasRequiredWebidl;
function requireWebidl() {
  if (hasRequiredWebidl) return webidl_1;
  hasRequiredWebidl = 1;
  const { types } = require$$0$5;
  const { hasOwn, toUSVString } = /* @__PURE__ */ requireUtil$7();
  const webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = void 0) {
    if (opts?.strict !== false && !(V instanceof I)) {
      throw new TypeError("Illegal invocation");
    } else {
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      }
      const method = V?.[Symbol.iterator]?.();
      const seq = [];
      if (method === void 0 || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = Object.keys(O);
        for (const key of keys2) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, opts = {}) => {
      if (opts.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: i.name,
          message: `Expected ${V} to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options2 of converters) {
        const { key, defaultValue, required, converter } = options2;
        if (required === true) {
          if (!hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = hasOwn(options2, "defaultValue");
        if (hasDefault && value !== null) {
          value = value ?? defaultValue;
        }
        if (required || hasDefault || value !== void 0) {
          value = converter(value);
          if (options2.allowedValues && !options2.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options2.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null) {
        return V;
      }
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw new TypeError("Could not convert argument of type symbol to string.");
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    const x = webidl.converters.DOMString(V);
    for (let index = 0; index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
        );
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "signed");
    return x;
  };
  webidl.converters["unsigned long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned");
    return x;
  };
  webidl.converters["unsigned long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned");
    return x;
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, opts);
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor);
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, opts);
    }
    throw new TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
    webidl.converters.ByteString
  );
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
    webidl.converters["sequence<ByteString>"]
  );
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
    webidl.converters.ByteString,
    webidl.converters.ByteString
  );
  webidl_1 = {
    webidl
  };
  return webidl_1;
}
var dataURL;
var hasRequiredDataURL;
function requireDataURL() {
  if (hasRequiredDataURL) return dataURL;
  hasRequiredDataURL = 1;
  const assert2 = require$$0$7;
  const { atob: atob2 } = require$$7;
  const { isomorphicDecode } = /* @__PURE__ */ requireUtil$7();
  const encoder = new TextEncoder();
  const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
  const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
  const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function dataURLProcessor(dataURL2) {
    assert2(dataURL2.protocol === "data:");
    let input = URLSerializer(dataURL2, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(
      ",",
      input,
      position
    );
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body2 = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body2);
      body2 = forgivingBase64(stringBody);
      if (body2 === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body: body2 };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function percentDecode(input) {
    const output = [];
    for (let i = 0; i < input.length; i++) {
      const byte = input[i];
      if (byte !== 37) {
        output.push(byte);
      } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
        output.push(37);
      } else {
        const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
        const bytePoint = Number.parseInt(nextTwoBytes, 16);
        output.push(bytePoint);
        i += 2;
      }
    }
    return Uint8Array.from(output);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast(
      "/",
      input,
      position
    );
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(
      ";",
      input,
      position
    );
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (char) => HTTP_WHITESPACE_REGEX.test(char),
        input,
        position
      );
      let parameterName = collectASequenceOfCodePoints(
        (char) => char !== ";" && char !== "=",
        input,
        position
      );
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
      } else {
        parameterValue = collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
    if (data.length % 4 === 0) {
      data = data.replace(/=?=$/, "");
    }
    if (data.length % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data)) {
      return "failure";
    }
    const binary = atob2(data);
    const bytes = new Uint8Array(binary.length);
    for (let byte = 0; byte < binary.length; byte++) {
      bytes[byte] = binary.charCodeAt(byte);
    }
    return bytes;
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert2(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== "\\",
        input,
        position
      );
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert2(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert2(mimeType !== "failure");
    const { parameters: parameters2, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters2.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === "\r" || char === "\n" || char === "	" || char === " ";
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
    }
    if (trailing) {
      for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
    }
    return str.slice(lead, trail + 1);
  }
  function isASCIIWhitespace(char) {
    return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
    }
    if (trailing) {
      for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
    }
    return str.slice(lead, trail + 1);
  }
  dataURL = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
  return dataURL;
}
var file$1;
var hasRequiredFile$1;
function requireFile$1() {
  if (hasRequiredFile$1) return file$1;
  hasRequiredFile$1 = 1;
  const { Blob: Blob2, File: NativeFile } = require$$7;
  const { types } = require$$0$5;
  const { kState } = /* @__PURE__ */ requireSymbols$3();
  const { isBlobLike } = /* @__PURE__ */ requireUtil$7();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { parseMIMEType, serializeAMimeType } = /* @__PURE__ */ requireDataURL();
  const { kEnumerableProperty } = /* @__PURE__ */ requireUtil$8();
  const encoder = new TextEncoder();
  class File2 extends Blob2 {
    constructor(fileBits, fileName, options2 = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
      fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
      fileName = webidl.converters.USVString(fileName);
      options2 = webidl.converters.FilePropertyBag(options2);
      const n = fileName;
      let t = options2.type;
      let d;
      substep: {
        if (t) {
          t = parseMIMEType(t);
          if (t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options2.lastModified;
      }
      super(processBlobParts(fileBits, options2), { type: t });
      this[kState] = {
        name: n,
        lastModified: d,
        type: t
      };
    }
    get name() {
      webidl.brandCheck(this, File2);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, File2);
      return this[kState].lastModified;
    }
    get type() {
      webidl.brandCheck(this, File2);
      return this[kState].type;
    }
  }
  class FileLike {
    constructor(blobLike, fileName, options2 = {}) {
      const n = fileName;
      const t = options2.type;
      const d = options2.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File2.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: true
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V, opts);
      }
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
    webidl.converters.BlobPart
  );
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        value = webidl.converters.DOMString(value);
        value = value.toLowerCase();
        if (value !== "native") {
          value = "transparent";
        }
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  function processBlobParts(parts, options2) {
    const bytes = [];
    for (const element of parts) {
      if (typeof element === "string") {
        let s = element;
        if (options2.endings === "native") {
          s = convertLineEndingsNative(s);
        }
        bytes.push(encoder.encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
        if (!element.buffer) {
          bytes.push(new Uint8Array(element));
        } else {
          bytes.push(
            new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
          );
        }
      } else if (isBlobLike(element)) {
        bytes.push(element);
      }
    }
    return bytes;
  }
  function convertLineEndingsNative(s) {
    let nativeLineEnding = "\n";
    if (process.platform === "win32") {
      nativeLineEnding = "\r\n";
    }
    return s.replace(/\r?\n/g, nativeLineEnding);
  }
  function isFileLike(object2) {
    return NativeFile && object2 instanceof NativeFile || object2 instanceof File2 || object2 && (typeof object2.stream === "function" || typeof object2.arrayBuffer === "function") && object2[Symbol.toStringTag] === "File";
  }
  file$1 = { File: File2, FileLike, isFileLike };
  return file$1;
}
var formdata;
var hasRequiredFormdata;
function requireFormdata() {
  if (hasRequiredFormdata) return formdata;
  hasRequiredFormdata = 1;
  const { isBlobLike, toUSVString, makeIterator } = /* @__PURE__ */ requireUtil$7();
  const { kState } = /* @__PURE__ */ requireSymbols$3();
  const { File: UndiciFile, FileLike, isFileLike } = /* @__PURE__ */ requireFile$1();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { Blob: Blob2, File: NativeFile } = require$$7;
  const File2 = NativeFile ?? UndiciFile;
  class FormData2 {
    constructor(form) {
      if (form !== void 0) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
      name = webidl.converters.USVString(name);
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
      name = webidl.converters.USVString(name);
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
      name = webidl.converters.USVString(name);
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
      name = webidl.converters.USVString(name);
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? toUSVString(filename) : void 0;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    entries() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(
        () => this[kState].map((pair) => [pair.name, pair.value]),
        "FormData",
        "key+value"
      );
    }
    keys() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(
        () => this[kState].map((pair) => [pair.name, pair.value]),
        "FormData",
        "key"
      );
    }
    values() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(
        () => this[kState].map((pair) => [pair.name, pair.value]),
        "FormData",
        "value"
      );
    }
    /**
     * @param {(value: string, key: string, self: FormData) => void} callbackFn
     * @param {unknown} thisArg
     */
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError(
          "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
        );
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    name = Buffer.from(name).toString("utf8");
    if (typeof value === "string") {
      value = Buffer.from(value).toString("utf8");
    } else {
      if (!isFileLike(value)) {
        value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== void 0) {
        const options2 = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options2) : new FileLike(value, filename, options2);
      }
    }
    return { name, value };
  }
  formdata = { FormData: FormData2 };
  return formdata;
}
var body;
var hasRequiredBody;
function requireBody() {
  if (hasRequiredBody) return body;
  hasRequiredBody = 1;
  const Busboy = /* @__PURE__ */ requireMain();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = /* @__PURE__ */ requireUtil$7();
  const { FormData: FormData2 } = /* @__PURE__ */ requireFormdata();
  const { kState } = /* @__PURE__ */ requireSymbols$3();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { DOMException: DOMException2, structuredClone } = /* @__PURE__ */ requireConstants$9();
  const { Blob: Blob2, File: NativeFile } = require$$7;
  const { kBodyUsed } = /* @__PURE__ */ requireSymbols$4();
  const assert2 = require$$0$7;
  const { isErrored } = /* @__PURE__ */ requireUtil$8();
  const { isUint8Array, isArrayBuffer } = require$$5;
  const { File: UndiciFile } = /* @__PURE__ */ requireFile$1();
  const { parseMIMEType, serializeAMimeType } = /* @__PURE__ */ requireDataURL();
  let random2;
  try {
    const crypto = require("node:crypto");
    random2 = (max) => crypto.randomInt(0, max);
  } catch {
    random2 = (max) => Math.floor(Math.random(max));
  }
  let ReadableStream2 = globalThis.ReadableStream;
  const File2 = NativeFile ?? UndiciFile;
  const textEncoder = new TextEncoder();
  const textDecoder = new TextDecoder();
  function extractBody(object2, keepalive = false) {
    if (!ReadableStream2) {
      ReadableStream2 = require$$14.ReadableStream;
    }
    let stream = null;
    if (object2 instanceof ReadableStream2) {
      stream = object2;
    } else if (isBlobLike(object2)) {
      stream = object2.stream();
    } else {
      stream = new ReadableStream2({
        async pull(controller) {
          controller.enqueue(
            typeof source === "string" ? textEncoder.encode(source) : source
          );
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: void 0
      });
    }
    assert2(isReadableStreamLike(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object2 === "string") {
      source = object2;
      type = "text/plain;charset=UTF-8";
    } else if (object2 instanceof URLSearchParams) {
      source = object2.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object2)) {
      source = new Uint8Array(object2.slice());
    } else if (ArrayBuffer.isView(object2)) {
      source = new Uint8Array(object2.buffer.slice(object2.byteOffset, object2.byteOffset + object2.byteLength));
    } else if (util2.isFormDataLike(object2)) {
      const boundary = `----formdata-undici-0${`${random2(1e11)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object2) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object2;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object2)) {
      source = object2;
      length = object2.size;
      if (object2.type) {
        type = object2.type;
      }
    } else if (typeof object2[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util2.isDisturbed(object2) || object2.locked) {
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      }
      stream = object2 instanceof ReadableStream2 ? object2 : ReadableStreamFrom(object2);
    }
    if (typeof source === "string" || util2.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream2({
        async start() {
          iterator = action(object2)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            if (!isErrored(stream)) {
              controller.enqueue(new Uint8Array(value));
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: void 0
      });
    }
    const body2 = { stream, source, length };
    return [body2, type];
  }
  function safelyExtractBody(object2, keepalive = false) {
    if (!ReadableStream2) {
      ReadableStream2 = require$$14.ReadableStream;
    }
    if (object2 instanceof ReadableStream2) {
      assert2(!util2.isDisturbed(object2), "The body has already been consumed.");
      assert2(!object2.locked, "The stream is locked.");
    }
    return extractBody(object2, keepalive);
  }
  function cloneBody(body2) {
    const [out1, out2] = body2.stream.tee();
    const out2Clone = structuredClone(out2, { transfer: [out2] });
    const [, finalClone] = out2Clone.tee();
    body2.stream = out1;
    return {
      stream: finalClone,
      length: body2.length,
      source: body2.source
    };
  }
  async function* consumeBody(body2) {
    if (body2) {
      if (isUint8Array(body2)) {
        yield body2;
      } else {
        const stream = body2.stream;
        if (util2.isDisturbed(stream)) {
          throw new TypeError("The body has already been consumed.");
        }
        if (stream.locked) {
          throw new TypeError("The stream is locked.");
        }
        stream[kBodyUsed] = true;
        yield* stream;
      }
    }
  }
  function throwIfAborted(state2) {
    if (state2.aborted) {
      throw new DOMException2("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods = {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure") {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance);
        throwIfAborted(this[kState]);
        const contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          const headers2 = {};
          for (const [key, value] of this.headers) headers2[key.toLowerCase()] = value;
          const responseFormData = new FormData2();
          let busboy;
          try {
            busboy = new Busboy({
              headers: headers2,
              preservePath: true
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          });
          busboy.on("file", (name, value, filename, encoding2, mimeType) => {
            const chunks = [];
            if (encoding2 === "base64" || encoding2.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                const end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                base64chunk = base64chunk.slice(end);
              });
              value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64"));
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            } else {
              value.on("data", (chunk) => {
                chunks.push(chunk);
              });
              value.on("end", () => {
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            }
          });
          const busboyResolve = new Promise((resolve, reject) => {
            busboy.on("finish", resolve);
            busboy.on("error", (err) => reject(new TypeError(err)));
          });
          if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
          busboy.end();
          await busboyResolve;
          return responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "";
            const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
            for await (const chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk)) {
                throw new TypeError("Expected Uint8Array chunk");
              }
              text += streamingDecoder.decode(chunk, { stream: true });
            }
            text += streamingDecoder.decode();
            entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(new TypeError(), { cause: err });
          }
          const formData = new FormData2();
          for (const [name, value] of entries) {
            formData.append(name, value);
          }
          return formData;
        } else {
          await Promise.resolve();
          throwIfAborted(this[kState]);
          throw webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
        }
      }
    };
    return methods;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function specConsumeBody(object2, convertBytesToJSValue, instance) {
    webidl.brandCheck(object2, instance);
    throwIfAborted(object2[kState]);
    if (bodyUnusable(object2[kState].body)) {
      throw new TypeError("Body is unusable");
    }
    const promise = createDeferredPromise();
    const errorSteps = (error2) => promise.reject(error2);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object2[kState].body == null) {
      successSteps(new Uint8Array());
      return promise.promise;
    }
    await fullyReadBody(object2[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(body2) {
    return body2 != null && (body2.stream.locked || util2.isDisturbed(body2.stream));
  }
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(object2) {
    const { headersList } = object2[kState];
    const contentType = headersList.get("content-type");
    if (contentType === null) {
      return "failure";
    }
    return parseMIMEType(contentType);
  }
  body = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
  return body;
}
var request$1;
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1) return request$1;
  hasRequiredRequest$1 = 1;
  const {
    InvalidArgumentError,
    NotSupportedError
  } = /* @__PURE__ */ requireErrors$1();
  const assert2 = require$$0$7;
  const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = /* @__PURE__ */ requireSymbols$4();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  const invalidPathRegex = /[^\u0021-\u00ff]/;
  const kHandler = Symbol("handler");
  const channels = {};
  let extractBody;
  try {
    const diagnosticsChannel = require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create");
    channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
    channels.headers = diagnosticsChannel.channel("undici:request:headers");
    channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
    channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: false };
    channels.bodySent = { hasSubscribers: false };
    channels.headers = { hasSubscribers: false };
    channels.trailers = { hasSubscribers: false };
    channels.error = { hasSubscribers: false };
  }
  class Request {
    constructor(origin, {
      path: path2,
      method,
      body: body2,
      headers: headers2,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue
    }, handler) {
      if (typeof path2 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path2[0] !== "/" && !(path2.startsWith("http://") || path2.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.exec(path2) !== null) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (tokenRegExp.exec(method) === null) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body2 == null) {
        this.body = null;
      } else if (util2.isStream(body2)) {
        this.body = body2;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            util2.destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (util2.isBuffer(body2)) {
        this.body = body2.byteLength ? body2 : null;
      } else if (ArrayBuffer.isView(body2)) {
        this.body = body2.buffer.byteLength ? Buffer.from(body2.buffer, body2.byteOffset, body2.byteLength) : null;
      } else if (body2 instanceof ArrayBuffer) {
        this.body = body2.byteLength ? Buffer.from(body2) : null;
      } else if (typeof body2 === "string") {
        this.body = body2.length ? Buffer.from(body2) : null;
      } else if (util2.isFormDataLike(body2) || util2.isIterable(body2) || util2.isBlobLike(body2)) {
        this.body = body2;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? util2.buildURL(path2, query) : path2;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = "";
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers2)) {
        if (headers2.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0; i < headers2.length; i += 2) {
          processHeader(this, headers2[i], headers2[i + 1]);
        }
      } else if (headers2 && typeof headers2 === "object") {
        const keys = Object.keys(headers2);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          processHeader(this, key, headers2[key]);
        }
      } else if (headers2 != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (util2.isFormDataLike(this.body)) {
        if (util2.nodeMajor < 16 || util2.nodeMajor === 16 && util2.nodeMinor < 8) {
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        }
        if (!extractBody) {
          extractBody = requireBody().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body2);
        if (this.contentType == null) {
          this.contentType = contentType;
          this.headers += `content-type: ${contentType}\r
`;
        }
        this.body = bodyStream.stream;
        this.contentLength = bodyStream.length;
      } else if (util2.isBlobLike(body2) && this.contentType == null && body2.type) {
        this.contentType = body2.type;
        this.headers += `content-type: ${body2.type}\r
`;
      }
      util2.validateHandler(handler, method, upgrade);
      this.servername = util2.getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert2(!this.aborted);
      assert2(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onHeaders(statusCode, headers2, resume, statusText) {
      assert2(!this.aborted);
      assert2(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers: headers2, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers2, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert2(!this.aborted);
      assert2(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers2, socket) {
      assert2(!this.aborted);
      assert2(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers2, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert2(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error2) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error: error2 });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error2);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    // TODO: adjust to support H2
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
    static [kHTTP1BuildRequest](origin, opts, handler) {
      return new Request(origin, opts, handler);
    }
    static [kHTTP2BuildRequest](origin, opts, handler) {
      const headers2 = opts.headers;
      opts = { ...opts, headers: null };
      const request2 = new Request(origin, opts, handler);
      request2.headers = {};
      if (Array.isArray(headers2)) {
        if (headers2.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0; i < headers2.length; i += 2) {
          processHeader(request2, headers2[i], headers2[i + 1], true);
        }
      } else if (headers2 && typeof headers2 === "object") {
        const keys = Object.keys(headers2);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          processHeader(request2, key, headers2[key], true);
        }
      } else if (headers2 != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      return request2;
    }
    static [kHTTP2CopyHeaders](raw) {
      const rawHeaders = raw.split("\r\n");
      const headers2 = {};
      for (const header of rawHeaders) {
        const [key, value] = header.split(": ");
        if (value == null || value.length === 0) continue;
        if (headers2[key]) headers2[key] += `,${value}`;
        else headers2[key] = value;
      }
      return headers2;
    }
  }
  function processHeaderValue(key, val, skipAppend) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    val = val != null ? `${val}` : "";
    if (headerCharRegex.exec(val) !== null) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    return skipAppend ? val : `${key}: ${val}\r
`;
  }
  function processHeader(request2, key, val, skipAppend = false) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === void 0) {
      return;
    }
    if (request2.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      request2.host = val;
    } else if (request2.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request2.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request2.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request2.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
      request2.contentType = val;
      if (skipAppend) request2.headers[key] = processHeaderValue(key, val, skipAppend);
      else request2.headers += processHeaderValue(key, val);
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (value === "close") {
        request2.reset = true;
      }
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else if (tokenRegExp.exec(key) === null) {
      throw new InvalidArgumentError("invalid header key");
    } else {
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          if (skipAppend) {
            if (request2.headers[key]) request2.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
            else request2.headers[key] = processHeaderValue(key, val[i], skipAppend);
          } else {
            request2.headers += processHeaderValue(key, val[i]);
          }
        }
      } else {
        if (skipAppend) request2.headers[key] = processHeaderValue(key, val, skipAppend);
        else request2.headers += processHeaderValue(key, val);
      }
    }
  }
  request$1 = Request;
  return request$1;
}
var dispatcher;
var hasRequiredDispatcher;
function requireDispatcher() {
  if (hasRequiredDispatcher) return dispatcher;
  hasRequiredDispatcher = 1;
  const EventEmitter = require$$0$6;
  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
  }
  dispatcher = Dispatcher;
  return dispatcher;
}
var dispatcherBase;
var hasRequiredDispatcherBase;
function requireDispatcherBase() {
  if (hasRequiredDispatcherBase) return dispatcherBase;
  hasRequiredDispatcherBase = 1;
  const Dispatcher = /* @__PURE__ */ requireDispatcher();
  const {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = /* @__PURE__ */ requireErrors$1();
  const { kDestroy, kClose, kDispatch, kInterceptors } = /* @__PURE__ */ requireSymbols$4();
  const kDestroyed = Symbol("destroyed");
  const kClosed = Symbol("closed");
  const kOnDestroyed = Symbol("onDestroyed");
  const kOnClosed = Symbol("onClosed");
  const kInterceptedDispatch = Symbol("Intercepted Dispatch");
  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1; i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError(), null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? (
              /* istanbul ignore next: should never error */
              reject(err2)
            ) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0; i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosed]) {
          throw new ClientClosedError();
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  dispatcherBase = DispatcherBase;
  return dispatcherBase;
}
var connect;
var hasRequiredConnect;
function requireConnect() {
  if (hasRequiredConnect) return connect;
  hasRequiredConnect = 1;
  const net = require$$0$8;
  const assert2 = require$$0$7;
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { InvalidArgumentError, ConnectTimeoutError } = /* @__PURE__ */ requireErrors$1();
  let tls;
  let SessionCache;
  if (commonjsGlobal.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = /* @__PURE__ */ new Map();
        this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = /* @__PURE__ */ new Map();
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options2 = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = require$$1$4;
        }
        servername = servername || options2.servername || util2.getServerName(host) || null;
        const sessionKey = servername || hostname;
        const session = sessionCache.get(sessionKey) || null;
        assert2(sessionKey);
        socket = tls.connect({
          highWaterMark: 16384,
          // TLS in node can't have bigger HWM anyway...
          ...options2,
          servername,
          session,
          localAddress,
          // TODO(HTTP/2): Add support for h2c
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          // upgrade socket connection
          port: port || 443,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert2(!httpSocket, "httpSocket can only be sent on TLS update");
        socket = net.connect({
          highWaterMark: 64 * 1024,
          // Same as nodejs fs streams.
          ...options2,
          localAddress,
          port: port || 80,
          host: hostname
        });
      }
      if (options2.keepAlive == null || options2.keepAlive) {
        const keepAliveInitialDelay = options2.keepAliveInitialDelay === void 0 ? 6e4 : options2.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  function setupTimeout(onConnectTimeout2, timeout) {
    if (!timeout) {
      return () => {
      };
    }
    let s1 = null;
    let s2 = null;
    const timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32") {
          s2 = setImmediate(() => onConnectTimeout2());
        } else {
          onConnectTimeout2();
        }
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  }
  function onConnectTimeout(socket) {
    util2.destroy(socket, new ConnectTimeoutError());
  }
  connect = buildConnector;
  return connect;
}
var constants$8 = {};
var utils$2 = {};
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  Object.defineProperty(utils$2, "__esModule", { value: true });
  utils$2.enumToMap = void 0;
  function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  }
  utils$2.enumToMap = enumToMap;
  return utils$2;
}
var hasRequiredConstants$8;
function requireConstants$8() {
  if (hasRequiredConstants$8) return constants$8;
  hasRequiredConstants$8 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
    const utils_1 = /* @__PURE__ */ requireUtils$2();
    (function(ERROR) {
      ERROR[ERROR["OK"] = 0] = "OK";
      ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
      ERROR[ERROR["STRICT"] = 2] = "STRICT";
      ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
      ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR[ERROR["USER"] = 24] = "USER";
    })(exports.ERROR || (exports.ERROR = {}));
    (function(TYPE) {
      TYPE[TYPE["BOTH"] = 0] = "BOTH";
      TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
      TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
    })(exports.TYPE || (exports.TYPE = {}));
    (function(FLAGS) {
      FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
      FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
      FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
      FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(exports.FLAGS || (exports.FLAGS = {}));
    (function(LENIENT_FLAGS) {
      LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports.METHODS || (exports.METHODS = {}));
    exports.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports.H_METHOD_MAP = {};
    Object.keys(exports.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
      }
    });
    (function(FINISH) {
      FINISH[FINISH["SAFE"] = 0] = "SAFE";
      FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
    })(exports.FINISH || (exports.FINISH = {}));
    exports.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports.ALPHA.push(String.fromCharCode(i));
      exports.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports.ALPHANUM);
    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports.URL_CHAR.push(i);
    }
    exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports.ALPHANUM);
    exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
    exports.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports.HEADER_CHARS.push(i);
      }
    }
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
    exports.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  })(constants$8);
  return constants$8;
}
var RedirectHandler_1;
var hasRequiredRedirectHandler;
function requireRedirectHandler() {
  if (hasRequiredRedirectHandler) return RedirectHandler_1;
  hasRequiredRedirectHandler = 1;
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { kBodyUsed } = /* @__PURE__ */ requireSymbols$4();
  const assert2 = require$$0$7;
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  const EE = require$$0$6;
  const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  const kBody = Symbol("body");
  class BodyAsyncIterable {
    constructor(body2) {
      this[kBody] = body2;
      this[kBodyUsed] = false;
    }
    async *[Symbol.asyncIterator]() {
      assert2(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util2.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util2.isStream(this.opts.body)) {
        if (util2.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert2(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers2, socket) {
      this.handler.onUpgrade(statusCode, headers2, socket);
    }
    onError(error2) {
      this.handler.onError(error2);
    }
    onHeaders(statusCode, headers2, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers2);
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers2, resume, statusText);
      }
      const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path2 = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path2;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) ;
      else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  function parseLocation(statusCode, headers2) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0; i < headers2.length; i += 2) {
      if (headers2[i].toString().toLowerCase() === "location") {
        return headers2[i + 1];
      }
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util2.headerNameToString(header) === "host";
    }
    if (removeContent && util2.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util2.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers2, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers2)) {
      for (let i = 0; i < headers2.length; i += 2) {
        if (!shouldRemoveHeader(headers2[i], removeContent, unknownOrigin)) {
          ret.push(headers2[i], headers2[i + 1]);
        }
      }
    } else if (headers2 && typeof headers2 === "object") {
      for (const key of Object.keys(headers2)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers2[key]);
        }
      }
    } else {
      assert2(headers2 == null, "headers must be an object or an array");
    }
    return ret;
  }
  RedirectHandler_1 = RedirectHandler;
  return RedirectHandler_1;
}
var redirectInterceptor;
var hasRequiredRedirectInterceptor;
function requireRedirectInterceptor() {
  if (hasRequiredRedirectInterceptor) return redirectInterceptor;
  hasRequiredRedirectInterceptor = 1;
  const RedirectHandler = /* @__PURE__ */ requireRedirectHandler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  }
  redirectInterceptor = createRedirectInterceptor;
  return redirectInterceptor;
}
var llhttpWasm;
var hasRequiredLlhttpWasm;
function requireLlhttpWasm() {
  if (hasRequiredLlhttpWasm) return llhttpWasm;
  hasRequiredLlhttpWasm = 1;
  llhttpWasm = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  return llhttpWasm;
}
var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;
function requireLlhttp_simdWasm() {
  if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
  hasRequiredLlhttp_simdWasm = 1;
  llhttp_simdWasm = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  return llhttp_simdWasm;
}
var client;
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  const assert2 = require$$0$7;
  const net = require$$0$8;
  const http = require$$2;
  const { pipeline: pipeline2 } = require$$0$9;
  const util2 = /* @__PURE__ */ requireUtil$8();
  const timers2 = /* @__PURE__ */ requireTimers();
  const Request = /* @__PURE__ */ requireRequest$1();
  const DispatcherBase = /* @__PURE__ */ requireDispatcherBase();
  const {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = /* @__PURE__ */ requireErrors$1();
  const buildConnector = /* @__PURE__ */ requireConnect();
  const {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kHTTPConnVersion,
    // HTTP2
    kHost,
    kHTTP2Session,
    kHTTP2SessionState,
    kHTTP2BuildRequest,
    kHTTP2CopyHeaders,
    kHTTP1BuildRequest
  } = /* @__PURE__ */ requireSymbols$4();
  let http2;
  try {
    http2 = require("http2");
  } catch {
    http2 = { constants: {} };
  }
  const {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  let h2ExperimentalWarned = false;
  const FastBuffer = Buffer[Symbol.species];
  const kClosedResolve = Symbol("kClosedResolve");
  const channels = {};
  try {
    const diagnosticsChannel = require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
    channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
    channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
    channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: false };
    channels.beforeConnect = { hasSubscribers: false };
    channels.connectError = { hasSubscribers: false };
    channels.connected = { hasSubscribers: false };
  }
  class Client extends DispatcherBase {
    /**
     *
     * @param {string|URL} url
     * @param {import('../types/client').Client.Options} options
     */
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect3,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      // h2
      allowH2,
      maxConcurrentStreams
    } = {}) {
      super();
      if (keepAlive !== void 0) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect3 != null && typeof connect3 !== "function" && typeof connect3 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
      }
      if (typeof connect3 !== "function") {
        connect3 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util2.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect3
        });
      }
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
      this[kUrl] = util2.parseOrigin(url);
      this[kConnector] = connect3;
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kHTTPConnVersion] = "h1";
      this[kHTTP2Session] = null;
      this[kHTTP2SessionState] = !allowH2 ? null : {
        // streams: null, // Fixed queue of streams - For future support of `push`
        openStreams: 0,
        // Keep track of them to decide wether or not unref the session
        maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
        // Max peerConcurrentStreams for a Node h2 server
      };
      this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    /* istanbul ignore: only used for test */
    [kConnect](cb) {
      connect2(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request2 = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
      this[kQueue].push(request2);
      if (this[kResuming]) ;
      else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {
        this[kResuming] = 1;
        process.nextTick(resume, this);
      } else {
        resume(this, true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async [kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize]) {
          resolve(null);
        } else {
          this[kClosedResolve] = resolve;
        }
      });
    }
    async [kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request2 = requests[i];
          errorRequest(this, request2, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve();
        };
        if (this[kHTTP2Session] != null) {
          util2.destroy(this[kHTTP2Session], err);
          this[kHTTP2Session] = null;
          this[kHTTP2SessionState] = null;
        }
        if (!this[kSocket]) {
          queueMicrotask(callback);
        } else {
          util2.destroy(this[kSocket].on("close", callback), err);
        }
        resume(this);
      });
    }
  }
  function onHttp2SessionError(err) {
    assert2(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    onError(this[kClient], err);
  }
  function onHttp2FrameError(type, code, id) {
    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    if (id === 0) {
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
  }
  function onHttp2SessionEnd() {
    util2.destroy(this, new SocketError("other side closed"));
    util2.destroy(this[kSocket], new SocketError("other side closed"));
  }
  function onHTTP2GoAway(code) {
    const client2 = this[kClient];
    const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    client2[kSocket] = null;
    client2[kHTTP2Session] = null;
    if (client2.destroyed) {
      assert2(this[kPending] === 0);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        errorRequest(this, request2, err);
      }
    } else if (client2[kRunning] > 0) {
      const request2 = client2[kQueue][client2[kRunningIdx]];
      client2[kQueue][client2[kRunningIdx]++] = null;
      errorRequest(client2, request2, err);
    }
    client2[kPendingIdx] = client2[kRunningIdx];
    assert2(client2[kRunning] === 0);
    client2.emit(
      "disconnect",
      client2[kUrl],
      [client2],
      err
    );
    resume(client2);
  }
  const constants2 = /* @__PURE__ */ requireConstants$8();
  const createRedirectInterceptor = /* @__PURE__ */ requireRedirectInterceptor();
  const EMPTY_BUF = Buffer.alloc(0);
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? /* @__PURE__ */ requireLlhttpWasm() : void 0;
    let mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(/* @__PURE__ */ requireLlhttp_simdWasm(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || /* @__PURE__ */ requireLlhttpWasm(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        /* eslint-disable camelcase */
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert2.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert2.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert2.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert2.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert2.strictEqual(currentParser.ptr, p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert2.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert2.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageComplete() || 0;
        }
        /* eslint-enable camelcase */
      }
    });
  }
  let llhttpInstance = null;
  let llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  let currentParser = null;
  let currentBufferRef = null;
  let currentBufferSize = 0;
  let currentBufferPtr = null;
  const TIMEOUT_HEADERS = 1;
  const TIMEOUT_BODY = 2;
  const TIMEOUT_IDLE = 3;
  class Parser {
    constructor(client2, socket, { exports }) {
      assert2(Number.isFinite(client2[kMaxHeadersSize]) && client2[kMaxHeadersSize] > 0);
      this.llhttp = exports;
      this.ptr = this.llhttp.llhttp_alloc(constants2.TYPE.RESPONSE);
      this.client = client2;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client2[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client2[kMaxResponseSize];
    }
    setTimeout(value, type) {
      this.timeoutType = type;
      if (value !== this.timeoutValue) {
        timers2.clearTimeout(this.timeout);
        if (value) {
          this.timeout = timers2.setTimeout(onParserTimeout, value, this);
          if (this.timeout.unref) {
            this.timeout.unref();
          }
        } else {
          this.timeout = null;
        }
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert2(this.ptr != null);
      assert2(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert2(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert2(this.ptr != null);
      assert2(currentParser == null);
      assert2(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants2.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants2.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants2.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants2.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util2.destroy(socket, err);
      }
    }
    destroy() {
      assert2(this.ptr != null);
      assert2(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      timers2.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client: client2 } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      if (!request2) {
        return -1;
      }
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
        this.connection += buf.toString();
      } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util2.destroy(this.socket, new HeadersOverflowError());
      }
    }
    onUpgrade(head) {
      const { upgrade, client: client2, socket, headers: headers2, statusCode } = this;
      assert2(upgrade);
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert2(request2);
      assert2(!socket.destroyed);
      assert2(socket === client2[kSocket]);
      assert2(!this.paused);
      assert2(request2.upgrade || request2.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      assert2(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
      client2[kSocket] = null;
      client2[kQueue][client2[kRunningIdx]++] = null;
      client2.emit("disconnect", client2[kUrl], [client2], new InformationalError("upgrade"));
      try {
        request2.onUpgrade(statusCode, headers2, socket);
      } catch (err) {
        util2.destroy(socket, err);
      }
      resume(client2);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client: client2, socket, headers: headers2, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      if (!request2) {
        return -1;
      }
      assert2(!this.upgrade);
      assert2(this.statusCode < 200);
      if (statusCode === 100) {
        util2.destroy(socket, new SocketError("bad response", util2.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request2.upgrade) {
        util2.destroy(socket, new SocketError("bad upgrade", util2.getSocketInfo(socket)));
        return -1;
      }
      assert2.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
      request2.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request2.method === "CONNECT") {
        assert2(client2[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert2(client2[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert2(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client2[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(
            keepAliveTimeout - client2[kKeepAliveTimeoutThreshold],
            client2[kKeepAliveMaxTimeout]
          );
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client2[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client2[kKeepAliveTimeoutValue] = client2[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request2.onHeaders(statusCode, headers2, this.resume, statusText) === false;
      if (request2.aborted) {
        return -1;
      }
      if (request2.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        resume(client2);
      }
      return pause ? constants2.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client: client2, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert2(request2);
      assert2.strictEqual(this.timeoutType, TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert2(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util2.destroy(socket, new ResponseExceededMaxSizeError());
        return -1;
      }
      this.bytesRead += buf.length;
      if (request2.onData(buf) === false) {
        return constants2.ERROR.PAUSED;
      }
    }
    onMessageComplete() {
      const { client: client2, socket, statusCode, upgrade, headers: headers2, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert2(request2);
      assert2(statusCode >= 100);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      assert2(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util2.destroy(socket, new ResponseContentLengthMismatchError());
        return -1;
      }
      request2.onComplete(headers2);
      client2[kQueue][client2[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert2.strictEqual(client2[kRunning], 0);
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (socket[kReset] && client2[kRunning] === 0) {
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (client2[kPipelining] === 1) {
        setImmediate(resume, client2);
      } else {
        resume(client2);
      }
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client: client2 } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client2[kRunning] > 1) {
        assert2(!parser.paused, "cannot be paused while waiting for headers");
        util2.destroy(socket, new HeadersTimeoutError());
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused) {
        util2.destroy(socket, new BodyTimeoutError());
      }
    } else if (timeoutType === TIMEOUT_IDLE) {
      assert2(client2[kRunning] === 0 && client2[kKeepAliveTimeoutValue]);
      util2.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  function onSocketReadable() {
    const { [kParser]: parser } = this;
    if (parser) {
      parser.readMore();
    }
  }
  function onSocketError(err) {
    const { [kClient]: client2, [kParser]: parser } = this;
    assert2(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    if (client2[kHTTPConnVersion] !== "h2") {
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    this[kError] = err;
    onError(this[kClient], err);
  }
  function onError(client2, err) {
    if (client2[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert2(client2[kPendingIdx] === client2[kRunningIdx]);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        errorRequest(client2, request2, err);
      }
      assert2(client2[kSize] === 0);
    }
  }
  function onSocketEnd() {
    const { [kParser]: parser, [kClient]: client2 } = this;
    if (client2[kHTTPConnVersion] !== "h2") {
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
  }
  function onSocketClose() {
    const { [kClient]: client2, [kParser]: parser } = this;
    if (client2[kHTTPConnVersion] === "h1" && parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
    client2[kSocket] = null;
    if (client2.destroyed) {
      assert2(client2[kPending] === 0);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i = 0; i < requests.length; i++) {
        const request2 = requests[i];
        errorRequest(client2, request2, err);
      }
    } else if (client2[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request2 = client2[kQueue][client2[kRunningIdx]];
      client2[kQueue][client2[kRunningIdx]++] = null;
      errorRequest(client2, request2, err);
    }
    client2[kPendingIdx] = client2[kRunningIdx];
    assert2(client2[kRunning] === 0);
    client2.emit("disconnect", client2[kUrl], [client2], err);
    resume(client2);
  }
  async function connect2(client2) {
    assert2(!client2[kConnecting]);
    assert2(!client2[kSocket]);
    let { host, hostname, protocol, port } = client2[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert2(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert2(net.isIP(ip));
      hostname = ip;
    }
    client2[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        },
        connector: client2[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject) => {
        client2[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client2.destroyed) {
        util2.destroy(socket.on("error", () => {
        }), new ClientDestroyedError());
        return;
      }
      client2[kConnecting] = false;
      assert2(socket);
      const isH2 = socket.alpnProtocol === "h2";
      if (isH2) {
        if (!h2ExperimentalWarned) {
          h2ExperimentalWarned = true;
          process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          });
        }
        const session = http2.connect(client2[kUrl], {
          createConnection: () => socket,
          peerMaxConcurrentStreams: client2[kHTTP2SessionState].maxConcurrentStreams
        });
        client2[kHTTPConnVersion] = "h2";
        session[kClient] = client2;
        session[kSocket] = socket;
        session.on("error", onHttp2SessionError);
        session.on("frameError", onHttp2FrameError);
        session.on("end", onHttp2SessionEnd);
        session.on("goaway", onHTTP2GoAway);
        session.on("close", onSocketClose);
        session.unref();
        client2[kHTTP2Session] = session;
        socket[kHTTP2Session] = session;
      } else {
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kParser] = new Parser(client2, socket, llhttpInstance);
      }
      socket[kCounter] = 0;
      socket[kMaxRequests] = client2[kMaxRequests];
      socket[kClient] = client2;
      socket[kError] = null;
      socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
      client2[kSocket] = socket;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client2[kServerName],
            localAddress: client2[kLocalAddress]
          },
          connector: client2[kConnector],
          socket
        });
      }
      client2.emit("connect", client2[kUrl], [client2]);
    } catch (err) {
      if (client2.destroyed) {
        return;
      }
      client2[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client2[kServerName],
            localAddress: client2[kLocalAddress]
          },
          connector: client2[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert2(client2[kRunning] === 0);
        while (client2[kPending] > 0 && client2[kQueue][client2[kPendingIdx]].servername === client2[kServerName]) {
          const request2 = client2[kQueue][client2[kPendingIdx]++];
          errorRequest(client2, request2, err);
        }
      } else {
        onError(client2, err);
      }
      client2.emit("connectionError", client2[kUrl], [client2], err);
    }
    resume(client2);
  }
  function emitDrain(client2) {
    client2[kNeedDrain] = 0;
    client2.emit("drain", client2[kUrl], [client2]);
  }
  function resume(client2, sync) {
    if (client2[kResuming] === 2) {
      return;
    }
    client2[kResuming] = 2;
    _resume(client2, sync);
    client2[kResuming] = 0;
    if (client2[kRunningIdx] > 256) {
      client2[kQueue].splice(0, client2[kRunningIdx]);
      client2[kPendingIdx] -= client2[kRunningIdx];
      client2[kRunningIdx] = 0;
    }
  }
  function _resume(client2, sync) {
    while (true) {
      if (client2.destroyed) {
        assert2(client2[kPending] === 0);
        return;
      }
      if (client2[kClosedResolve] && !client2[kSize]) {
        client2[kClosedResolve]();
        client2[kClosedResolve] = null;
        return;
      }
      const socket = client2[kSocket];
      if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
        if (client2[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client2[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
            socket[kParser].setTimeout(client2[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
          }
        } else if (client2[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request3 = client2[kQueue][client2[kRunningIdx]];
            const headersTimeout = request3.headersTimeout != null ? request3.headersTimeout : client2[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client2[kBusy]) {
        client2[kNeedDrain] = 2;
      } else if (client2[kNeedDrain] === 2) {
        if (sync) {
          client2[kNeedDrain] = 1;
          process.nextTick(emitDrain, client2);
        } else {
          emitDrain(client2);
        }
        continue;
      }
      if (client2[kPending] === 0) {
        return;
      }
      if (client2[kRunning] >= (client2[kPipelining] || 1)) {
        return;
      }
      const request2 = client2[kQueue][client2[kPendingIdx]];
      if (client2[kUrl].protocol === "https:" && client2[kServerName] !== request2.servername) {
        if (client2[kRunning] > 0) {
          return;
        }
        client2[kServerName] = request2.servername;
        if (socket && socket.servername !== request2.servername) {
          util2.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client2[kConnecting]) {
        return;
      }
      if (!socket && !client2[kHTTP2Session]) {
        connect2(client2);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
        return;
      }
      if (client2[kRunning] > 0 && !request2.idempotent) {
        return;
      }
      if (client2[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
        return;
      }
      if (client2[kRunning] > 0 && util2.bodyLength(request2.body) !== 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body))) {
        return;
      }
      if (!request2.aborted && write(client2, request2)) {
        client2[kPendingIdx]++;
      } else {
        client2[kQueue].splice(client2[kPendingIdx], 1);
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function write(client2, request2) {
    if (client2[kHTTPConnVersion] === "h2") {
      writeH2(client2, client2[kHTTP2Session], request2);
      return;
    }
    const { body: body2, method, path: path2, host, upgrade, headers: headers2, blocking, reset } = request2;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body2 && typeof body2.read === "function") {
      body2.read(0);
    }
    const bodyLength = util2.bodyLength(body2);
    let contentLength = bodyLength;
    if (contentLength === null) {
      contentLength = request2.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
      if (client2[kStrictContentLength]) {
        errorRequest(client2, request2, new RequestContentLengthMismatchError());
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    const socket = client2[kSocket];
    try {
      request2.onConnect((err) => {
        if (request2.aborted || request2.completed) {
          return;
        }
        errorRequest(client2, request2, err || new RequestAbortedError());
        util2.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client2, request2, err);
    }
    if (request2.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client2[kMaxRequests] && socket[kCounter]++ >= client2[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path2} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client2[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client2[kPipelining] && !socket[kReset]) {
      header += "connection: keep-alive\r\n";
    } else {
      header += "connection: close\r\n";
    }
    if (headers2) {
      header += headers2;
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request: request2, headers: header, socket });
    }
    if (!body2 || bodyLength === 0) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      } else {
        assert2(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "latin1");
      }
      request2.onRequestSent();
    } else if (util2.isBuffer(body2)) {
      assert2(contentLength === body2.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(body2);
      socket.uncork();
      request2.onBodySent(body2);
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else if (util2.isBlobLike(body2)) {
      if (typeof body2.stream === "function") {
        writeIterable({ body: body2.stream(), client: client2, request: request2, socket, contentLength, header, expectsPayload });
      } else {
        writeBlob({ body: body2, client: client2, request: request2, socket, contentLength, header, expectsPayload });
      }
    } else if (util2.isStream(body2)) {
      writeStream({ body: body2, client: client2, request: request2, socket, contentLength, header, expectsPayload });
    } else if (util2.isIterable(body2)) {
      writeIterable({ body: body2, client: client2, request: request2, socket, contentLength, header, expectsPayload });
    } else {
      assert2(false);
    }
    return true;
  }
  function writeH2(client2, session, request2) {
    const { body: body2, method, path: path2, host, upgrade, expectContinue, signal, headers: reqHeaders } = request2;
    let headers2;
    if (typeof reqHeaders === "string") headers2 = Request[kHTTP2CopyHeaders](reqHeaders.trim());
    else headers2 = reqHeaders;
    if (upgrade) {
      errorRequest(client2, request2, new Error("Upgrade not supported for H2"));
      return false;
    }
    try {
      request2.onConnect((err) => {
        if (request2.aborted || request2.completed) {
          return;
        }
        errorRequest(client2, request2, err || new RequestAbortedError());
      });
    } catch (err) {
      errorRequest(client2, request2, err);
    }
    if (request2.aborted) {
      return false;
    }
    let stream;
    const h2State = client2[kHTTP2SessionState];
    headers2[HTTP2_HEADER_AUTHORITY] = host || client2[kHost];
    headers2[HTTP2_HEADER_METHOD] = method;
    if (method === "CONNECT") {
      session.ref();
      stream = session.request(headers2, { endStream: false, signal });
      if (stream.id && !stream.pending) {
        request2.onUpgrade(null, null, stream);
        ++h2State.openStreams;
      } else {
        stream.once("ready", () => {
          request2.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        });
      }
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) session.unref();
      });
      return true;
    }
    headers2[HTTP2_HEADER_PATH] = path2;
    headers2[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body2 && typeof body2.read === "function") {
      body2.read(0);
    }
    let contentLength = util2.bodyLength(body2);
    if (contentLength == null) {
      contentLength = request2.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
      if (client2[kStrictContentLength]) {
        errorRequest(client2, request2, new RequestContentLengthMismatchError());
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    if (contentLength != null) {
      assert2(body2, "no body must not have content length");
      headers2[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD";
    if (expectContinue) {
      headers2[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers2, { endStream: shouldEndStream, signal });
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers2, {
        endStream: shouldEndStream,
        signal
      });
      writeBodyH2();
    }
    ++h2State.openStreams;
    stream.once("response", (headers3) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers3;
      if (request2.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
    });
    stream.once("end", () => {
      request2.onComplete([]);
    });
    stream.on("data", (chunk) => {
      if (request2.onData(chunk) === false) {
        stream.pause();
      }
    });
    stream.once("close", () => {
      h2State.openStreams -= 1;
      if (h2State.openStreams === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      if (client2[kHTTP2Session] && !client2[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util2.destroy(stream, err);
      }
    });
    stream.once("frameError", (type, code) => {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      errorRequest(client2, request2, err);
      if (client2[kHTTP2Session] && !client2[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util2.destroy(stream, err);
      }
    });
    return true;
    function writeBodyH2() {
      if (!body2) {
        request2.onRequestSent();
      } else if (util2.isBuffer(body2)) {
        assert2(contentLength === body2.byteLength, "buffer body must have content length");
        stream.cork();
        stream.write(body2);
        stream.uncork();
        stream.end();
        request2.onBodySent(body2);
        request2.onRequestSent();
      } else if (util2.isBlobLike(body2)) {
        if (typeof body2.stream === "function") {
          writeIterable({
            client: client2,
            request: request2,
            contentLength,
            h2stream: stream,
            expectsPayload,
            body: body2.stream(),
            socket: client2[kSocket],
            header: ""
          });
        } else {
          writeBlob({
            body: body2,
            client: client2,
            request: request2,
            contentLength,
            expectsPayload,
            h2stream: stream,
            header: "",
            socket: client2[kSocket]
          });
        }
      } else if (util2.isStream(body2)) {
        writeStream({
          body: body2,
          client: client2,
          request: request2,
          contentLength,
          expectsPayload,
          socket: client2[kSocket],
          h2stream: stream,
          header: ""
        });
      } else if (util2.isIterable(body2)) {
        writeIterable({
          body: body2,
          client: client2,
          request: request2,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream,
          socket: client2[kSocket]
        });
      } else {
        assert2(false);
      }
    }
  }
  function writeStream({ h2stream, body: body2, client: client2, request: request2, socket, contentLength, header, expectsPayload }) {
    assert2(contentLength !== 0 || client2[kRunning] === 0, "stream body cannot be pipelined");
    if (client2[kHTTPConnVersion] === "h2") {
      let onPipeData = function(chunk) {
        request2.onBodySent(chunk);
      };
      const pipe = pipeline2(
        body2,
        h2stream,
        (err) => {
          if (err) {
            util2.destroy(body2, err);
            util2.destroy(h2stream, err);
          } else {
            request2.onRequestSent();
          }
        }
      );
      pipe.on("data", onPipeData);
      pipe.once("end", () => {
        pipe.removeListener("data", onPipeData);
        util2.destroy(pipe);
      });
      return;
    }
    let finished = false;
    const writer = new AsyncWriter({ socket, request: request2, contentLength, client: client2, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util2.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body2.resume) {
        body2.resume();
      }
    };
    const onAbort = function() {
      if (finished) {
        return;
      }
      const err = new RequestAbortedError();
      queueMicrotask(() => onFinished(err));
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert2(socket.destroyed || socket[kWriting] && client2[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body2.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util2.destroy(body2, err);
      } else {
        util2.destroy(body2);
      }
    };
    body2.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
    if (body2.resume) {
      body2.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
  }
  async function writeBlob({ h2stream, body: body2, client: client2, request: request2, socket, contentLength, header, expectsPayload }) {
    assert2(contentLength === body2.size, "blob body must have content length");
    const isH2 = client2[kHTTPConnVersion] === "h2";
    try {
      if (contentLength != null && contentLength !== body2.size) {
        throw new RequestContentLengthMismatchError();
      }
      const buffer = Buffer.from(await body2.arrayBuffer());
      if (isH2) {
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
      } else {
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(buffer);
        socket.uncork();
      }
      request2.onBodySent(buffer);
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      resume(client2);
    } catch (err) {
      util2.destroy(isH2 ? h2stream : socket, err);
    }
  }
  async function writeIterable({ h2stream, body: body2, client: client2, request: request2, socket, contentLength, header, expectsPayload }) {
    assert2(contentLength !== 0 || client2[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert2(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    if (client2[kHTTPConnVersion] === "h2") {
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body2) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request2.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
      } catch (err) {
        h2stream.destroy(err);
      } finally {
        request2.onRequestSent();
        h2stream.end();
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
      return;
    }
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ socket, request: request2, contentLength, client: client2, expectsPayload, header });
    try {
      for await (const chunk of body2) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  class AsyncWriter {
    constructor({ socket, request: request2, contentLength, client: client2, expectsPayload, header }) {
      this.socket = socket;
      this.request = request2;
      this.contentLength = contentLength;
      this.client = client2;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request: request2, contentLength, client: client2, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client2[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError();
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request2.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client: client2, bytesWritten, expectsPayload, header, request: request2 } = this;
      request2.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write("\r\n0\r\n\r\n", "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client2[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError();
        } else {
          process.emitWarning(new RequestContentLengthMismatchError());
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      resume(client2);
    }
    destroy(err) {
      const { socket, client: client2 } = this;
      socket[kWriting] = false;
      if (err) {
        assert2(client2[kRunning] <= 1, "pipeline should only contain this request");
        util2.destroy(socket, err);
      }
    }
  }
  function errorRequest(client2, request2, err) {
    try {
      request2.onError(err);
      assert2(request2.aborted);
    } catch (err2) {
      client2.emit("error", err2);
    }
  }
  client = Client;
  return client;
}
var fixedQueue;
var hasRequiredFixedQueue;
function requireFixedQueue() {
  if (hasRequiredFixedQueue) return fixedQueue;
  hasRequiredFixedQueue = 1;
  const kSize = 2048;
  const kMask = kSize - 1;
  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      this.list[this.bottom] = void 0;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  fixedQueue = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer();
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
  return fixedQueue;
}
var poolStats;
var hasRequiredPoolStats;
function requirePoolStats() {
  if (hasRequiredPoolStats) return poolStats;
  hasRequiredPoolStats = 1;
  const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = /* @__PURE__ */ requireSymbols$4();
  const kPool = Symbol("pool");
  class PoolStats {
    constructor(pool2) {
      this[kPool] = pool2;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  poolStats = PoolStats;
  return poolStats;
}
var poolBase;
var hasRequiredPoolBase;
function requirePoolBase() {
  if (hasRequiredPoolBase) return poolBase;
  hasRequiredPoolBase = 1;
  const DispatcherBase = /* @__PURE__ */ requireDispatcherBase();
  const FixedQueue = /* @__PURE__ */ requireFixedQueue();
  const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = /* @__PURE__ */ requireSymbols$4();
  const PoolStats = /* @__PURE__ */ requirePoolStats();
  const kClients = Symbol("clients");
  const kNeedDrain = Symbol("needDrain");
  const kQueue = Symbol("queue");
  const kClosedResolve = Symbol("closed resolve");
  const kOnDrain = Symbol("onDrain");
  const kOnConnect = Symbol("onConnect");
  const kOnDisconnect = Symbol("onDisconnect");
  const kOnConnectionError = Symbol("onConnectionError");
  const kGetDispatcher = Symbol("get dispatcher");
  const kAddClient = Symbol("add client");
  const kRemoveClient = Symbol("remove client");
  const kStats = Symbol("stats");
  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue();
      this[kClients] = [];
      this[kQueued] = 0;
      const pool2 = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool2[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool2[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool2[kNeedDrain]) {
          pool2[kNeedDrain] = false;
          pool2.emit("drain", origin, [pool2, ...targets]);
        }
        if (pool2[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool2[kClients].map((c) => c.close())).then(pool2[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool2.emit("connect", origin, [pool2, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool2.emit("disconnect", origin, [pool2, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool2.emit("connectionError", origin, [pool2, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client2) => client2[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client2) => client2[kConnected] && !client2[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async [kClose]() {
      if (this[kQueue].isEmpty()) {
        return Promise.all(this[kClients].map((c) => c.close()));
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async [kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher2 = this[kGetDispatcher]();
      if (!dispatcher2) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher2.dispatch(opts, handler)) {
        dispatcher2[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client2) {
      client2.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client2);
      if (this[kNeedDrain]) {
        process.nextTick(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client2[kUrl], [this, client2]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client2) {
      client2.close(() => {
        const idx = this[kClients].indexOf(client2);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
    }
  }
  poolBase = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
  return poolBase;
}
var pool;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool;
  hasRequiredPool = 1;
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = /* @__PURE__ */ requirePoolBase();
  const Client = /* @__PURE__ */ requireClient();
  const {
    InvalidArgumentError
  } = /* @__PURE__ */ requireErrors$1();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { kUrl, kInterceptors } = /* @__PURE__ */ requireSymbols$4();
  const buildConnector = /* @__PURE__ */ requireConnect();
  const kOptions = Symbol("options");
  const kConnections = Symbol("connections");
  const kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }
  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect: connect2,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options2
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util2.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        });
      }
      this[kInterceptors] = options2.interceptors && options2.interceptors.Pool && Array.isArray(options2.interceptors.Pool) ? options2.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util2.parseOrigin(origin);
      this[kOptions] = { ...util2.deepClone(options2), connect: connect2, allowH2 };
      this[kOptions].interceptors = options2.interceptors ? { ...options2.interceptors } : void 0;
      this[kFactory] = factory;
      this.on("connectionError", (origin2, targets, error2) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      let dispatcher2 = this[kClients].find((dispatcher3) => !dispatcher3[kNeedDrain]);
      if (dispatcher2) {
        return dispatcher2;
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        dispatcher2 = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher2);
      }
      return dispatcher2;
    }
  }
  pool = Pool;
  return pool;
}
var balancedPool;
var hasRequiredBalancedPool;
function requireBalancedPool() {
  if (hasRequiredBalancedPool) return balancedPool;
  hasRequiredBalancedPool = 1;
  const {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = /* @__PURE__ */ requireErrors$1();
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = /* @__PURE__ */ requirePoolBase();
  const Pool = /* @__PURE__ */ requirePool();
  const { kUrl, kInterceptors } = /* @__PURE__ */ requireSymbols$4();
  const { parseOrigin } = /* @__PURE__ */ requireUtil$8();
  const kFactory = Symbol("factory");
  const kOptions = Symbol("options");
  const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  const kCurrentWeight = Symbol("kCurrentWeight");
  const kIndex = Symbol("kIndex");
  const kWeight = Symbol("kWeight");
  const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  const kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (b === 0) return a;
    return getGreatestCommonDivisor(b, a % b);
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true)) {
        return this;
      }
      const pool2 = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool2);
      pool2.on("connect", () => {
        pool2[kWeight] = Math.min(this[kMaxWeightPerServer], pool2[kWeight] + this[kErrorPenalty]);
      });
      pool2.on("connectionError", () => {
        pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool2.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool2[kWeight] = Math.max(1, pool2[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client2 of this[kClients]) {
        client2[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool2 = this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true);
      if (pool2) {
        this[kRemoveClient](pool2);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher2) => dispatcher2.closed !== true && dispatcher2.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError();
      }
      const dispatcher2 = this[kClients].find((dispatcher3) => !dispatcher3[kNeedDrain] && dispatcher3.closed !== true && dispatcher3.destroyed !== true);
      if (!dispatcher2) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool2) => pool2[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool2) => !pool2[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool2 = this[kClients][this[kIndex]];
        if (pool2[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool2[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool2[kWeight] >= this[kCurrentWeight] && !pool2[kNeedDrain]) {
          return pool2;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  balancedPool = BalancedPool;
  return balancedPool;
}
var dispatcherWeakref;
var hasRequiredDispatcherWeakref;
function requireDispatcherWeakref() {
  if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
  hasRequiredDispatcherWeakref = 1;
  const { kConnected, kSize } = /* @__PURE__ */ requireSymbols$4();
  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
    }
  }
  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher2, key) {
      if (dispatcher2.on) {
        dispatcher2.on("disconnect", () => {
          if (dispatcher2[kConnected] === 0 && dispatcher2[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
  }
  dispatcherWeakref = function() {
    if (process.env.NODE_V8_COVERAGE) {
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return {
      WeakRef: commonjsGlobal.WeakRef || CompatWeakRef,
      FinalizationRegistry: commonjsGlobal.FinalizationRegistry || CompatFinalizer
    };
  };
  return dispatcherWeakref;
}
var agent;
var hasRequiredAgent;
function requireAgent() {
  if (hasRequiredAgent) return agent;
  hasRequiredAgent = 1;
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = /* @__PURE__ */ requireSymbols$4();
  const DispatcherBase = /* @__PURE__ */ requireDispatcherBase();
  const Pool = /* @__PURE__ */ requirePool();
  const Client = /* @__PURE__ */ requireClient();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const createRedirectInterceptor = /* @__PURE__ */ requireRedirectInterceptor();
  const { WeakRef: WeakRef2, FinalizationRegistry } = /* @__PURE__ */ requireDispatcherWeakref()();
  const kOnConnect = Symbol("onConnect");
  const kOnDisconnect = Symbol("onDisconnect");
  const kOnConnectionError = Symbol("onConnectionError");
  const kMaxRedirections = Symbol("maxRedirections");
  const kOnDrain = Symbol("onDrain");
  const kFactory = Symbol("factory");
  const kFinalizer = Symbol("finalizer");
  const kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }
  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect: connect2, ...options2 } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect2 && typeof connect2 !== "function") {
        connect2 = { ...connect2 };
      }
      this[kInterceptors] = options2.interceptors && options2.interceptors.Agent && Array.isArray(options2.interceptors.Agent) ? options2.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util2.deepClone(options2), connect: connect2 };
      this[kOptions].interceptors = options2.interceptors ? { ...options2.interceptors } : void 0;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = /* @__PURE__ */ new Map();
      this[kFinalizer] = new FinalizationRegistry(
        /* istanbul ignore next: gc is undeterministic */
        (key) => {
          const ref = this[kClients].get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this[kClients].delete(key);
          }
        }
      );
      const agent2 = this;
      this[kOnDrain] = (origin, targets) => {
        agent2.emit("drain", origin, [agent2, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        agent2.emit("connect", origin, [agent2, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        agent2.emit("disconnect", origin, [agent2, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        agent2.emit("connectionError", origin, [agent2, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const ref of this[kClients].values()) {
        const client2 = ref.deref();
        if (client2) {
          ret += client2[kRunning];
        }
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      const ref = this[kClients].get(key);
      let dispatcher2 = ref ? ref.deref() : null;
      if (!dispatcher2) {
        dispatcher2 = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, new WeakRef2(dispatcher2));
        this[kFinalizer].register(dispatcher2, key);
      }
      return dispatcher2.dispatch(opts, handler);
    }
    async [kClose]() {
      const closePromises = [];
      for (const ref of this[kClients].values()) {
        const client2 = ref.deref();
        if (client2) {
          closePromises.push(client2.close());
        }
      }
      await Promise.all(closePromises);
    }
    async [kDestroy](err) {
      const destroyPromises = [];
      for (const ref of this[kClients].values()) {
        const client2 = ref.deref();
        if (client2) {
          destroyPromises.push(client2.destroy(err));
        }
      }
      await Promise.all(destroyPromises);
    }
  }
  agent = Agent;
  return agent;
}
var api = {};
var apiRequest = { exports: {} };
var readable;
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable;
  hasRequiredReadable = 1;
  const assert2 = require$$0$7;
  const { Readable } = require$$0$9;
  const { RequestAbortedError, NotSupportedError, InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { ReadableStreamFrom, toUSVString } = /* @__PURE__ */ requireUtil$8();
  let Blob2;
  const kConsume = Symbol("kConsume");
  const kReading = Symbol("kReading");
  const kBody = Symbol("kBody");
  const kAbort = Symbol("abort");
  const kContentType = Symbol("kContentType");
  const noop = () => {
  };
  readable = class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      highWaterMark = 64 * 1024
      // Same as nodejs fs streams.
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kReading] = false;
    }
    destroy(err) {
      if (this.destroyed) {
        return this;
      }
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data") {
        this._readableState.dataEmitted = true;
      } else if (ev === "error") {
        this._readableState.errorEmitted = true;
      }
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    // https://fetch.spec.whatwg.org/#dom-body-text
    async text() {
      return consume(this, "text");
    }
    // https://fetch.spec.whatwg.org/#dom-body-json
    async json() {
      return consume(this, "json");
    }
    // https://fetch.spec.whatwg.org/#dom-body-blob
    async blob() {
      return consume(this, "blob");
    }
    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    // https://fetch.spec.whatwg.org/#dom-body-formdata
    async formData() {
      throw new NotSupportedError();
    }
    // https://fetch.spec.whatwg.org/#dom-body-bodyused
    get bodyUsed() {
      return util2.isDisturbed(this);
    }
    // https://fetch.spec.whatwg.org/#dom-body-body
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert2(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
      const signal = opts && opts.signal;
      if (signal) {
        try {
          if (typeof signal !== "object" || !("aborted" in signal)) {
            throw new InvalidArgumentError("signal must be an AbortSignal");
          }
          util2.throwIfAborted(signal);
        } catch (err) {
          return Promise.reject(err);
        }
      }
      if (this.closed) {
        return Promise.resolve(null);
      }
      return new Promise((resolve, reject) => {
        const signalListenerCleanup = signal ? util2.addAbortListener(signal, () => {
          this.destroy();
        }) : noop;
        this.on("close", function() {
          signalListenerCleanup();
          if (signal && signal.aborted) {
            reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
          } else {
            resolve(null);
          }
        }).on("error", noop).on("data", function(chunk) {
          limit -= chunk.length;
          if (limit <= 0) {
            this.destroy();
          }
        }).resume();
      });
    }
  };
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  }
  function isUnusable(self2) {
    return util2.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    if (isUnusable(stream)) {
      throw new TypeError("unusable");
    }
    assert2(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      stream[kConsume] = {
        type,
        stream,
        resolve,
        reject,
        length: 0,
        body: []
      };
      stream.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null) {
          consumeFinish(this[kConsume], new RequestAbortedError());
        }
      });
      process.nextTick(consumeStart, stream[kConsume]);
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state2 } = consume2.stream;
    for (const chunk of state2.buffer) {
      consumePush(consume2, chunk);
    }
    if (state2.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  }
  function consumeEnd(consume2) {
    const { type, body: body2, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(toUSVString(Buffer.concat(body2)));
      } else if (type === "json") {
        resolve(JSON.parse(Buffer.concat(body2)));
      } else if (type === "arrayBuffer") {
        const dst = new Uint8Array(length);
        let pos = 0;
        for (const buf of body2) {
          dst.set(buf, pos);
          pos += buf.byteLength;
        }
        resolve(dst.buffer);
      } else if (type === "blob") {
        if (!Blob2) {
          Blob2 = require("buffer").Blob;
        }
        resolve(new Blob2(body2, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  return readable;
}
var util$6;
var hasRequiredUtil$6;
function requireUtil$6() {
  if (hasRequiredUtil$6) return util$6;
  hasRequiredUtil$6 = 1;
  const assert2 = require$$0$7;
  const {
    ResponseStatusCodeError
  } = /* @__PURE__ */ requireErrors$1();
  const { toUSVString } = /* @__PURE__ */ requireUtil$8();
  async function getResolveErrorBodyCallback({ callback, body: body2, contentType, statusCode, statusMessage, headers: headers2 }) {
    assert2(body2);
    let chunks = [];
    let limit = 0;
    for await (const chunk of body2) {
      chunks.push(chunk);
      limit += chunk.length;
      if (limit > 128 * 1024) {
        chunks = null;
        break;
      }
    }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers2));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers2, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        const payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers2, payload));
        return;
      }
    } catch (err) {
    }
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers2));
  }
  util$6 = { getResolveErrorBodyCallback };
  return util$6;
}
var abortSignal$1;
var hasRequiredAbortSignal;
function requireAbortSignal() {
  if (hasRequiredAbortSignal) return abortSignal$1;
  hasRequiredAbortSignal = 1;
  const { addAbortListener } = /* @__PURE__ */ requireUtil$8();
  const { RequestAbortedError } = /* @__PURE__ */ requireErrors$1();
  const kListener = Symbol("kListener");
  const kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError());
    }
  }
  function addSignal(self2, signal) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  abortSignal$1 = {
    addSignal,
    removeSignal
  };
  return abortSignal$1;
}
var hasRequiredApiRequest;
function requireApiRequest() {
  if (hasRequiredApiRequest) return apiRequest.exports;
  hasRequiredApiRequest = 1;
  const Readable = /* @__PURE__ */ requireReadable();
  const {
    InvalidArgumentError,
    RequestAbortedError
  } = /* @__PURE__ */ requireErrors$1();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { getResolveErrorBodyCallback } = /* @__PURE__ */ requireUtil$6();
  const { AsyncResource } = require$$4;
  const { addSignal, removeSignal } = /* @__PURE__ */ requireAbortSignal();
  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body: body2, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util2.isStream(body2)) {
          util2.destroy(body2.on("error", util2.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body2;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      if (util2.isStream(body2)) {
        body2.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers2 = responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util2.parseHeaders(rawHeaders) : headers2;
      const contentType = parsedHeaders["content-type"];
      const body2 = new Readable({ resume, abort, contentType, highWaterMark });
      this.callback = null;
      this.res = body2;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: body2, contentType, statusCode, statusMessage, headers: headers2 }
          );
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers: headers2,
            trailers: this.trailers,
            opaque,
            body: body2,
            context
          });
        }
      }
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      util2.parseHeaders(trailers, this.trailers);
      res.push(null);
    }
    onError(err) {
      const { res, callback, body: body2, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util2.destroy(res, err);
        });
      }
      if (body2) {
        this.body = null;
        util2.destroy(body2, err);
      }
    }
  }
  function request2(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        request2.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiRequest.exports = request2;
  apiRequest.exports.RequestHandler = RequestHandler;
  return apiRequest.exports;
}
var apiStream;
var hasRequiredApiStream;
function requireApiStream() {
  if (hasRequiredApiStream) return apiStream;
  hasRequiredApiStream = 1;
  const { finished, PassThrough } = require$$0$9;
  const {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = /* @__PURE__ */ requireErrors$1();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { getResolveErrorBodyCallback } = /* @__PURE__ */ requireUtil$6();
  const { AsyncResource } = require$$4;
  const { addSignal, removeSignal } = /* @__PURE__ */ requireAbortSignal();
  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body: body2, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util2.isStream(body2)) {
          util2.destroy(body2.on("error", util2.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body2;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util2.isStream(body2)) {
        body2.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers2 = responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util2.parseHeaders(rawHeaders) : headers2;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough();
        this.callback = null;
        this.runInAsyncScope(
          getResolveErrorBodyCallback,
          null,
          { callback, body: res, contentType, statusCode, statusMessage, headers: headers2 }
        );
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers: headers2,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util2.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util2.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body: body2 } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body2) {
        this.body = null;
        util2.destroy(body2, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiStream = stream;
  return apiStream;
}
var apiPipeline;
var hasRequiredApiPipeline;
function requireApiPipeline() {
  if (hasRequiredApiPipeline) return apiPipeline;
  hasRequiredApiPipeline = 1;
  const {
    Readable,
    Duplex,
    PassThrough
  } = require$$0$9;
  const {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = /* @__PURE__ */ requireErrors$1();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { AsyncResource } = require$$4;
  const { addSignal, removeSignal } = /* @__PURE__ */ requireAbortSignal();
  const assert2 = require$$0$7;
  const kResume = Symbol("resume");
  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }
  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      callback(err);
    }
  }
  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util2.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body: body2 } = this;
          if (body2 && body2.resume) {
            body2.resume();
          }
        },
        write: (chunk, encoding2, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding2) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body: body2, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (abort && err) {
            abort();
          }
          util2.destroy(body2, err);
          util2.destroy(req, err);
          util2.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      assert2(!res, "pipeline cannot be retried");
      if (ret.destroyed) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body2;
      try {
        this.handler = null;
        const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        body2 = this.runInAsyncScope(handler, null, {
          statusCode,
          headers: headers2,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util2.nop);
        throw err;
      }
      if (!body2 || typeof body2.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body2.on("data", (chunk) => {
        const { ret, body: body3 } = this;
        if (!ret.push(chunk) && body3.pause) {
          body3.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util2.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util2.destroy(ret, new RequestAbortedError());
        }
      });
      this.body = body2;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util2.destroy(ret, err);
    }
  }
  function pipeline2(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  apiPipeline = pipeline2;
  return apiPipeline;
}
var apiUpgrade;
var hasRequiredApiUpgrade;
function requireApiUpgrade() {
  if (hasRequiredApiUpgrade) return apiUpgrade;
  hasRequiredApiUpgrade = 1;
  const { InvalidArgumentError, RequestAbortedError, SocketError } = /* @__PURE__ */ requireErrors$1();
  const { AsyncResource } = require$$4;
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { addSignal, removeSignal } = /* @__PURE__ */ requireAbortSignal();
  const assert2 = require$$0$7;
  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      assert2.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers: headers2,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiUpgrade = upgrade;
  return apiUpgrade;
}
var apiConnect;
var hasRequiredApiConnect;
function requireApiConnect() {
  if (hasRequiredApiConnect) return apiConnect;
  hasRequiredApiConnect = 1;
  const { AsyncResource } = require$$4;
  const { InvalidArgumentError, RequestAbortedError, SocketError } = /* @__PURE__ */ requireErrors$1();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { addSignal, removeSignal } = /* @__PURE__ */ requireAbortSignal();
  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers2 = rawHeaders;
      if (headers2 != null) {
        headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: headers2,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect2(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        connect2.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiConnect = connect2;
  return apiConnect;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api;
  hasRequiredApi = 1;
  api.request = /* @__PURE__ */ requireApiRequest();
  api.stream = /* @__PURE__ */ requireApiStream();
  api.pipeline = /* @__PURE__ */ requireApiPipeline();
  api.upgrade = /* @__PURE__ */ requireApiUpgrade();
  api.connect = /* @__PURE__ */ requireApiConnect();
  return api;
}
var mockErrors;
var hasRequiredMockErrors;
function requireMockErrors() {
  if (hasRequiredMockErrors) return mockErrors;
  hasRequiredMockErrors = 1;
  const { UndiciError } = /* @__PURE__ */ requireErrors$1();
  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  mockErrors = {
    MockNotMatchedError
  };
  return mockErrors;
}
var mockSymbols;
var hasRequiredMockSymbols;
function requireMockSymbols() {
  if (hasRequiredMockSymbols) return mockSymbols;
  hasRequiredMockSymbols = 1;
  mockSymbols = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
  return mockSymbols;
}
var mockUtils;
var hasRequiredMockUtils;
function requireMockUtils() {
  if (hasRequiredMockUtils) return mockUtils;
  hasRequiredMockUtils = 1;
  const { MockNotMatchedError } = /* @__PURE__ */ requireMockErrors();
  const {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = /* @__PURE__ */ requireMockSymbols();
  const { buildURL, nop } = /* @__PURE__ */ requireUtil$8();
  const { STATUS_CODES } = require$$2;
  const {
    types: {
      isPromise
    }
  } = require$$0$5;
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers2) {
    return Object.fromEntries(
      Object.entries(headers2).map(([headerName, headerValue]) => {
        return [headerName.toLocaleLowerCase(), headerValue];
      })
    );
  }
  function getHeaderByName(headers2, key) {
    if (Array.isArray(headers2)) {
      for (let i = 0; i < headers2.length; i += 2) {
        if (headers2[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers2[i + 1];
        }
      }
      return void 0;
    } else if (typeof headers2.get === "function") {
      return headers2.get(key);
    } else {
      return lowerCaseEntries(headers2)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers2) {
    const clone = headers2.slice();
    const entries = [];
    for (let index = 0; index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers2) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers2)) {
        headers2 = buildHeadersFromArray(headers2);
      }
      return mockDispatch2.headers(headers2 ? lowerCaseEntries(headers2) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers2 !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers2, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function safeUrl(path2) {
    if (typeof path2 !== "string") {
      return path2;
    }
    const pathSegments = path2.split("?");
    if (pathSegments.length !== 2) {
      return path2;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path: path2, method, body: body2, headers: headers2 }) {
    const pathMatch = matchValue(mockDispatch2.path, path2);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body2) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers2);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path2 }) => matchValue(safeUrl(path2), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body: body2 }) => typeof body2 !== "undefined" ? matchValue(body2, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function buildKey(opts) {
    const { path: path2, method, body: body2, headers: headers2, query } = opts;
    return {
      path: path2,
      method,
      body: body2,
      headers: headers2,
      query
    };
  }
  function generateKeyValues(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body2) {
    const buffers = [];
    for await (const data of body2) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers: headers2, trailers, error: error2 }, delay: delay2, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error2 !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error2);
      return true;
    }
    if (typeof delay2 === "number" && delay2 > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay2);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body2 = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body2)) {
        body2.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body2);
      const responseHeaders = generateKeyValues(headers2);
      const responseTrailers = generateKeyValues(trailers);
      handler.abort = nop;
      handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData(Buffer.from(responseData));
      handler.onComplete(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  }
  function buildMockDispatch() {
    const agent2 = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent2.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error2) {
          if (error2 instanceof MockNotMatchedError) {
            const netConnect = agent2[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error2;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildMockOptions(opts) {
    if (opts) {
      const { agent: agent2, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  mockUtils = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
  return mockUtils;
}
var mockInterceptor = {};
var hasRequiredMockInterceptor;
function requireMockInterceptor() {
  if (hasRequiredMockInterceptor) return mockInterceptor;
  hasRequiredMockInterceptor = 1;
  const { getResponseData, buildKey, addMockDispatch } = /* @__PURE__ */ requireMockUtils();
  const {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = /* @__PURE__ */ requireMockSymbols();
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  const { buildURL } = /* @__PURE__ */ requireUtil$8();
  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    /**
     * Delay a reply by a set amount in ms.
     */
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    /**
     * For a defined reply, never mark as consumed.
     */
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    /**
     * Allow one to define a reply for a set amount of matching requests.
     */
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }
  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers2 = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers: headers2, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof data === "undefined") {
        throw new InvalidArgumentError("data must be defined");
      }
      if (typeof responseOptions !== "object") {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    /**
     * Mock an undici request with a defined reply.
     */
    reply(replyData) {
      if (typeof replyData === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyData(opts);
          if (typeof resolvedData !== "object") {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          this.validateReplyParameters(statusCode2, data2, responseOptions2);
          return {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    /**
     * Mock an undici request with a defined error.
     */
    replyWithError(error2) {
      if (typeof error2 === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
      return new MockScope(newMockDispatch);
    }
    /**
     * Set default reply headers on the interceptor for subsequent replies
     */
    defaultReplyHeaders(headers2) {
      if (typeof headers2 === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers2;
      return this;
    }
    /**
     * Set default reply trailers on the interceptor for subsequent replies
     */
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    /**
     * Set reply content length header for replies on the interceptor
     */
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  mockInterceptor.MockInterceptor = MockInterceptor;
  mockInterceptor.MockScope = MockScope;
  return mockInterceptor;
}
var mockClient;
var hasRequiredMockClient;
function requireMockClient() {
  if (hasRequiredMockClient) return mockClient;
  hasRequiredMockClient = 1;
  const { promisify } = require$$0$5;
  const Client = /* @__PURE__ */ requireClient();
  const { buildMockDispatch } = /* @__PURE__ */ requireMockUtils();
  const {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = /* @__PURE__ */ requireMockSymbols();
  const { MockInterceptor } = /* @__PURE__ */ requireMockInterceptor();
  const Symbols = /* @__PURE__ */ requireSymbols$4();
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async [kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  mockClient = MockClient;
  return mockClient;
}
var mockPool;
var hasRequiredMockPool;
function requireMockPool() {
  if (hasRequiredMockPool) return mockPool;
  hasRequiredMockPool = 1;
  const { promisify } = require$$0$5;
  const Pool = /* @__PURE__ */ requirePool();
  const { buildMockDispatch } = /* @__PURE__ */ requireMockUtils();
  const {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = /* @__PURE__ */ requireMockSymbols();
  const { MockInterceptor } = /* @__PURE__ */ requireMockInterceptor();
  const Symbols = /* @__PURE__ */ requireSymbols$4();
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async [kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  mockPool = MockPool;
  return mockPool;
}
var pluralizer;
var hasRequiredPluralizer;
function requirePluralizer() {
  if (hasRequiredPluralizer) return pluralizer;
  hasRequiredPluralizer = 1;
  const singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  const plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  pluralizer = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
  return pluralizer;
}
var pendingInterceptorsFormatter;
var hasRequiredPendingInterceptorsFormatter;
function requirePendingInterceptorsFormatter() {
  if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
  hasRequiredPendingInterceptorsFormatter = 1;
  const { Transform } = require$$0$9;
  const { Console } = require$$1$6;
  pendingInterceptorsFormatter = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(
        ({ method, path: path2, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
          Method: method,
          Origin: origin,
          Path: path2,
          "Status code": statusCode,
          Persistent: persist ? "✅" : "❌",
          Invocations: timesInvoked,
          Remaining: persist ? Infinity : times - timesInvoked
        })
      );
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
  return pendingInterceptorsFormatter;
}
var mockAgent;
var hasRequiredMockAgent;
function requireMockAgent() {
  if (hasRequiredMockAgent) return mockAgent;
  hasRequiredMockAgent = 1;
  const { kClients } = /* @__PURE__ */ requireSymbols$4();
  const Agent = /* @__PURE__ */ requireAgent();
  const {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = /* @__PURE__ */ requireMockSymbols();
  const MockClient = /* @__PURE__ */ requireMockClient();
  const MockPool = /* @__PURE__ */ requireMockPool();
  const { matchValue, buildMockOptions } = /* @__PURE__ */ requireMockUtils();
  const { InvalidArgumentError, UndiciError } = /* @__PURE__ */ requireErrors$1();
  const Dispatcher = /* @__PURE__ */ requireDispatcher();
  const Pluralizer = /* @__PURE__ */ requirePluralizer();
  const PendingInterceptorsFormatter = /* @__PURE__ */ requirePendingInterceptorsFormatter();
  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }
  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent2 = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent2;
      this[kClients] = agent2[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher2 = this[kMockAgentGet](origin);
      if (!dispatcher2) {
        dispatcher2 = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher2);
      }
      return dispatcher2;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    // This is required to bypass issues caused by using global symbols - see:
    // https://github.com/nodejs/undici/issues/1447
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher2) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher2));
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const ref = this[kClients].get(origin);
      if (ref) {
        return ref.deref();
      }
      if (typeof origin !== "string") {
        const dispatcher2 = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher2);
        return dispatcher2;
      }
      for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        const nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher2 = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher2);
          dispatcher2[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher2;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter: pendingInterceptorsFormatter2 = new PendingInterceptorsFormatter() } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer2 = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer2.count} ${pluralizer2.noun} ${pluralizer2.is} pending:

${pendingInterceptorsFormatter2.format(pending)}
`.trim());
    }
  }
  mockAgent = MockAgent;
  return mockAgent;
}
var proxyAgent;
var hasRequiredProxyAgent;
function requireProxyAgent() {
  if (hasRequiredProxyAgent) return proxyAgent;
  hasRequiredProxyAgent = 1;
  const { kProxy, kClose, kDestroy, kInterceptors } = /* @__PURE__ */ requireSymbols$4();
  const { URL: URL2 } = require$$5$1;
  const Agent = /* @__PURE__ */ requireAgent();
  const Pool = /* @__PURE__ */ requirePool();
  const DispatcherBase = /* @__PURE__ */ requireDispatcherBase();
  const { InvalidArgumentError, RequestAbortedError } = /* @__PURE__ */ requireErrors$1();
  const buildConnector = /* @__PURE__ */ requireConnect();
  const kAgent = Symbol("proxy agent");
  const kClient = Symbol("proxy client");
  const kProxyHeaders = Symbol("proxy headers");
  const kRequestTls = Symbol("request tls settings");
  const kProxyTls = Symbol("proxy tls settings");
  const kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function buildProxyOptions(opts) {
    if (typeof opts === "string") {
      opts = { uri: opts };
    }
    if (!opts || !opts.uri) {
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    }
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      this[kProxy] = buildProxyOptions(opts);
      this[kAgent] = new Agent(opts);
      this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      const resolvedUrl = new URL2(opts.uri);
      const { origin, port, host, username, password } = resolvedUrl;
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect2 = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(resolvedUrl, { connect: connect2 });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port) {
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200) {
              socket.on("error", () => {
              }).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      const { host } = new URL2(opts.origin);
      const headers2 = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers2);
      return this[kAgent].dispatch(
        {
          ...opts,
          headers: {
            ...headers2,
            host
          }
        },
        handler
      );
    }
    async [kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async [kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  function buildHeaders(headers2) {
    if (Array.isArray(headers2)) {
      const headersPair = {};
      for (let i = 0; i < headers2.length; i += 2) {
        headersPair[headers2[i]] = headers2[i + 1];
      }
      return headersPair;
    }
    return headers2;
  }
  function throwIfProxyAuthIsSent(headers2) {
    const existProxyAuth = headers2 && Object.keys(headers2).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  proxyAgent = ProxyAgent;
  return proxyAgent;
}
var RetryHandler_1;
var hasRequiredRetryHandler;
function requireRetryHandler() {
  if (hasRequiredRetryHandler) return RetryHandler_1;
  hasRequiredRetryHandler = 1;
  const assert2 = require$$0$7;
  const { kRetryHandlerDefaultRetry } = /* @__PURE__ */ requireSymbols$4();
  const { RequestRetryError } = /* @__PURE__ */ requireErrors$1();
  const { isDisturbed, parseHeaders, parseRangeHeader } = /* @__PURE__ */ requireUtil$8();
  function calculateRetryAfterHeader(retryAfter) {
    const current = Date.now();
    const diff = new Date(retryAfter).getTime() - current;
    return diff;
  }
  class RetryHandler {
    constructor(opts, handlers) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        // Retry scoped
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        // Response scoped
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch;
      this.handler = handlers.handler;
      this.opts = dispatchOpts;
      this.abort = null;
      this.aborted = false;
      this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1e3,
        // 30s,
        timeout: minTimeout ?? 500,
        // .5s
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        // What errors we should retry
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        // Indicates which errors to retry
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        // List of errors to retry
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE"
        ]
      };
      this.retryCount = 0;
      this.start = 0;
      this.end = null;
      this.etag = null;
      this.resume = null;
      this.handler.onConnect((reason) => {
        this.aborted = true;
        if (this.abort) {
          this.abort(reason);
        } else {
          this.reason = reason;
        }
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) {
        this.handler.onRequestSent();
      }
    }
    onUpgrade(statusCode, headers2, socket) {
      if (this.handler.onUpgrade) {
        this.handler.onUpgrade(statusCode, headers2, socket);
      }
    }
    onConnect(abort) {
      if (this.aborted) {
        abort(this.reason);
      } else {
        this.abort = abort;
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state: state2, opts }, cb) {
      const { statusCode, code, headers: headers2 } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        timeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      let { counter, currentTimeout } = state2;
      currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
      if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers2 != null && headers2["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
      state2.currentTimeout = retryTimeout;
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers2 = parseHeaders(rawHeaders);
      this.retryCount += 1;
      if (statusCode >= 300) {
        this.abort(
          new RequestRetryError("Request failed", statusCode, {
            headers: headers2,
            count: this.retryCount
          })
        );
        return false;
      }
      if (this.resume != null) {
        this.resume = null;
        if (statusCode !== 206) {
          return true;
        }
        const contentRange = parseRangeHeader(headers2["content-range"]);
        if (!contentRange) {
          this.abort(
            new RequestRetryError("Content-Range mismatch", statusCode, {
              headers: headers2,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.etag != null && this.etag !== headers2.etag) {
          this.abort(
            new RequestRetryError("ETag mismatch", statusCode, {
              headers: headers2,
              count: this.retryCount
            })
          );
          return false;
        }
        const { start, size, end = size } = contentRange;
        assert2(this.start === start, "content-range mismatch");
        assert2(this.end == null || this.end === end, "content-range mismatch");
        this.resume = resume;
        return true;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers2["content-range"]);
          if (range == null) {
            return this.handler.onHeaders(
              statusCode,
              rawHeaders,
              resume,
              statusMessage
            );
          }
          const { start, size, end = size } = range;
          assert2(
            start != null && Number.isFinite(start) && this.start !== start,
            "content-range mismatch"
          );
          assert2(Number.isFinite(start));
          assert2(
            end != null && Number.isFinite(end) && this.end !== end,
            "invalid content-length"
          );
          this.start = start;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers2["content-length"];
          this.end = contentLength != null ? Number(contentLength) : null;
        }
        assert2(Number.isFinite(this.start));
        assert2(
          this.end == null || Number.isFinite(this.end),
          "invalid content-length"
        );
        this.resume = resume;
        this.etag = headers2.etag != null ? headers2.etag : null;
        return this.handler.onHeaders(
          statusCode,
          rawHeaders,
          resume,
          statusMessage
        );
      }
      const err = new RequestRetryError("Request failed", statusCode, {
        headers: headers2,
        count: this.retryCount
      });
      this.abort(err);
      return false;
    }
    onData(chunk) {
      this.start += chunk.length;
      return this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      this.retryCount = 0;
      return this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err);
      }
      this.retryOpts.retry(
        err,
        {
          state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
          opts: { retryOptions: this.retryOpts, ...this.opts }
        },
        onRetry.bind(this)
      );
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err2);
        }
        if (this.start !== 0) {
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`
            }
          };
        }
        try {
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  RetryHandler_1 = RetryHandler;
  return RetryHandler_1;
}
var global$1;
var hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal) return global$1;
  hasRequiredGlobal = 1;
  const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  const { InvalidArgumentError } = /* @__PURE__ */ requireErrors$1();
  const Agent = /* @__PURE__ */ requireAgent();
  if (getGlobalDispatcher() === void 0) {
    setGlobalDispatcher(new Agent());
  }
  function setGlobalDispatcher(agent2) {
    if (!agent2 || typeof agent2.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent2,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  global$1 = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
  return global$1;
}
var DecoratorHandler_1;
var hasRequiredDecoratorHandler;
function requireDecoratorHandler() {
  if (hasRequiredDecoratorHandler) return DecoratorHandler_1;
  hasRequiredDecoratorHandler = 1;
  DecoratorHandler_1 = class DecoratorHandler {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
  return DecoratorHandler_1;
}
var headers;
var hasRequiredHeaders;
function requireHeaders() {
  if (hasRequiredHeaders) return headers;
  hasRequiredHeaders = 1;
  const { kHeadersList, kConstruct } = /* @__PURE__ */ requireSymbols$4();
  const { kGuard } = /* @__PURE__ */ requireSymbols$3();
  const { kEnumerableProperty } = /* @__PURE__ */ requireUtil$8();
  const {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = /* @__PURE__ */ requireUtil$7();
  const util2 = require$$0$5;
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const assert2 = require$$0$7;
  const kHeadersMap = Symbol("headers map");
  const kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers2, object2) {
    if (Array.isArray(object2)) {
      for (let i = 0; i < object2.length; ++i) {
        const header = object2[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers2, header[0], header[1]);
      }
    } else if (typeof object2 === "object" && object2 !== null) {
      const keys = Object.keys(object2);
      for (let i = 0; i < keys.length; ++i) {
        appendHeader(headers2, keys[i], object2[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers2, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (headers2[kGuard] === "immutable") {
      throw new TypeError("immutable");
    }
    return headers2[kHeadersList].append(name, value);
  }
  class HeadersList {
    /** @type {[string, string][]|null} */
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    // https://fetch.spec.whatwg.org/#header-list-contains
    contains(name) {
      name = name.toLowerCase();
      return this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-append
    append(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        this.cookies ??= [];
        this.cookies.push(value);
      }
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-set
    set(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-delete
    delete(name) {
      this[kHeadersSortedMap] = null;
      name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-get
    get(name) {
      const value = this[kHeadersMap].get(name.toLowerCase());
      return value === void 0 ? null : value.value;
    }
    *[Symbol.iterator]() {
      for (const [name, { value }] of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers2 = {};
      if (this[kHeadersMap].size) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers2[name] = value;
        }
      }
      return headers2;
    }
  }
  class Headers {
    constructor(init = void 0) {
      if (init === kConstruct) {
        return;
      }
      this[kHeadersList] = new HeadersList();
      this[kGuard] = "none";
      if (init !== void 0) {
        init = webidl.converters.HeadersInit(init);
        fill(this, init);
      }
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      return appendHeader(this, name, value);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      }
      if (!this[kHeadersList].contains(name)) {
        return;
      }
      this[kHeadersList].delete(name);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].get(name);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].contains(name);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      }
      this[kHeadersList].set(name, value);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this[kHeadersList].cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap]) {
        return this[kHeadersList][kHeadersSortedMap];
      }
      const headers2 = [];
      const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
      const cookies2 = this[kHeadersList].cookies;
      for (let i = 0; i < names.length; ++i) {
        const [name, value] = names[i];
        if (name === "set-cookie") {
          for (let j = 0; j < cookies2.length; ++j) {
            headers2.push([name, cookies2[j]]);
          }
        } else {
          assert2(value !== null);
          headers2.push([name, value]);
        }
      }
      this[kHeadersList][kHeadersSortedMap] = headers2;
      return headers2;
    }
    keys() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(
          () => value,
          "Headers",
          "key"
        );
      }
      return makeIterator(
        () => [...this[kHeadersSortedMap].values()],
        "Headers",
        "key"
      );
    }
    values() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(
          () => value,
          "Headers",
          "value"
        );
      }
      return makeIterator(
        () => [...this[kHeadersSortedMap].values()],
        "Headers",
        "value"
      );
    }
    entries() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(
          () => value,
          "Headers",
          "key+value"
        );
      }
      return makeIterator(
        () => [...this[kHeadersSortedMap].values()],
        "Headers",
        "key+value"
      );
    }
    /**
     * @param {(value: string, key: string, self: Headers) => void} callbackFn
     * @param {unknown} thisArg
     */
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError(
          "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
        );
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      webidl.brandCheck(this, Headers);
      return this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: false },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util2.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator]) {
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      }
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  headers = {
    fill,
    Headers,
    HeadersList
  };
  return headers;
}
var response$1;
var hasRequiredResponse$1;
function requireResponse$1() {
  if (hasRequiredResponse$1) return response$1;
  hasRequiredResponse$1 = 1;
  const { Headers, HeadersList, fill } = /* @__PURE__ */ requireHeaders();
  const { extractBody, cloneBody, mixinBody } = /* @__PURE__ */ requireBody();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { kEnumerableProperty } = util2;
  const {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = /* @__PURE__ */ requireUtil$7();
  const {
    redirectStatusSet,
    nullBodyStatus,
    DOMException: DOMException2
  } = /* @__PURE__ */ requireConstants$9();
  const { kState, kHeaders, kGuard, kRealm } = /* @__PURE__ */ requireSymbols$3();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { FormData: FormData2 } = /* @__PURE__ */ requireFormdata();
  const { getGlobalOrigin } = /* @__PURE__ */ requireGlobal$1();
  const { URLSerializer } = /* @__PURE__ */ requireDataURL();
  const { kHeadersList, kConstruct } = /* @__PURE__ */ requireSymbols$4();
  const assert2 = require$$0$7;
  const { types } = require$$0$5;
  const ReadableStream2 = globalThis.ReadableStream || require$$14.ReadableStream;
  const textEncoder = new TextEncoder("utf-8");
  class Response {
    // Creates network error Response.
    static error() {
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response();
      responseObject[kState] = makeNetworkError();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(
        serializeJavascriptValueToJSONString(data)
      );
      const body2 = extractBody(bytes);
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "response";
      responseObject[kHeaders][kRealm] = relevantRealm;
      initializeResponse(responseObject, init, { body: body2[0], type: "application/json" });
      return responseObject;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(url, status = 302) {
      const relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(new TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError("Invalid status code " + status);
      }
      const responseObject = new Response();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value);
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(body2 = null, init = {}) {
      if (body2 !== null) {
        body2 = webidl.converters.BodyInit(body2);
      }
      init = webidl.converters.ResponseInit(init);
      this[kRealm] = { settingsObject: {} };
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers(kConstruct);
      this[kHeaders][kGuard] = "response";
      this[kHeaders][kHeadersList] = this[kState].headersList;
      this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body2 != null) {
        const [extractedBody, type] = extractBody(body2);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    // Returns response’s type, e.g., "cors".
    get type() {
      webidl.brandCheck(this, Response);
      return this[kState].type;
    }
    // Returns response’s URL, if it has one; otherwise the empty string.
    get url() {
      webidl.brandCheck(this, Response);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      webidl.brandCheck(this, Response);
      return this[kState].urlList.length > 1;
    }
    // Returns response’s status.
    get status() {
      webidl.brandCheck(this, Response);
      return this[kState].status;
    }
    // Returns whether response’s status is an ok status.
    get ok() {
      webidl.brandCheck(this, Response);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    // Returns response’s status message.
    get statusText() {
      webidl.brandCheck(this, Response);
      return this[kState].statusText;
    }
    // Returns response’s headers as Headers.
    get headers() {
      webidl.brandCheck(this, Response);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response);
      return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
    }
    // Returns a clone of response.
    clone() {
      webidl.brandCheck(this, Response);
      if (this.bodyUsed || this.body && this.body.locked) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      const clonedResponseObject = new Response();
      clonedResponseObject[kState] = clonedResponse;
      clonedResponseObject[kRealm] = this[kRealm];
      clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
      clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      return clonedResponseObject;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response2) {
    if (response2.internalResponse) {
      return filterResponse(
        cloneResponse(response2.internalResponse),
        response2.type
      );
    }
    const newResponse = makeResponse({ ...response2, body: null });
    if (response2.body != null) {
      newResponse.body = cloneBody(response2.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
      urlList: init.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function makeFilteredResponse(response2, state2) {
    state2 = {
      internalResponse: response2,
      ...state2
    };
    return new Proxy(response2, {
      get(target, p) {
        return p in state2 ? state2[p] : target[p];
      },
      set(target, p, value) {
        assert2(!(p in state2));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response2, type) {
    if (type === "basic") {
      return makeFilteredResponse(response2, {
        type: "basic",
        headersList: response2.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response2, {
        type: "cors",
        headersList: response2.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response2, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response2, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert2(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert2(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response2, init, body2) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response2[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response2[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response2[kHeaders], init.headers);
    }
    if (body2) {
      if (nullBodyStatus.includes(response2.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response2.status
        });
      }
      response2[kState].body = body2.body;
      if (body2.type != null && !response2[kState].headersList.contains("Content-Type")) {
        response2[kState].headersList.append("content-type", body2.type);
      }
    }
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(
    ReadableStream2
  );
  webidl.converters.FormData = webidl.interfaceConverter(
    FormData2
  );
  webidl.converters.URLSearchParams = webidl.interfaceConverter(
    URLSearchParams
  );
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false });
    }
    if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
      return webidl.converters.BufferSource(V);
    }
    if (util2.isFormDataLike(V)) {
      return webidl.converters.FormData(V, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream2) {
      return webidl.converters.ReadableStream(V);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  response$1 = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse
  };
  return response$1;
}
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  const { extractBody, mixinBody, cloneBody } = /* @__PURE__ */ requireBody();
  const { Headers, fill: fillHeaders, HeadersList } = /* @__PURE__ */ requireHeaders();
  const { FinalizationRegistry } = /* @__PURE__ */ requireDispatcherWeakref()();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer,
    normalizeMethodRecord
  } = /* @__PURE__ */ requireUtil$7();
  const {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = /* @__PURE__ */ requireConstants$9();
  const { kEnumerableProperty } = util2;
  const { kHeaders, kSignal, kState, kGuard, kRealm } = /* @__PURE__ */ requireSymbols$3();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { getGlobalOrigin } = /* @__PURE__ */ requireGlobal$1();
  const { URLSerializer } = /* @__PURE__ */ requireDataURL();
  const { kHeadersList, kConstruct } = /* @__PURE__ */ requireSymbols$4();
  const assert2 = require$$0$7;
  const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$0$6;
  let TransformStream = globalThis.TransformStream;
  const kAbortController = Symbol("abortController");
  const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });
  class Request {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(input, init = {}) {
      if (input === kConstruct) {
        return;
      }
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request2 = null;
      let fallbackMode = null;
      const baseUrl = this[kRealm].settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + input
          );
        }
        request2 = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert2(input instanceof Request);
        request2 = input[kState];
        signal = input[kSignal];
      }
      const origin = this[kRealm].settingsObject.origin;
      let window2 = "client";
      if (request2.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
        window2 = request2.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request2 = makeRequest({
        // URL request’s URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method request’s method.
        method: request2.method,
        // header list A copy of request’s header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: request2.headersList,
        // unsafe-request flag Set.
        unsafeRequest: request2.unsafeRequest,
        // client This’s relevant settings object.
        client: this[kRealm].settingsObject,
        // window window.
        window: window2,
        // priority request’s priority.
        priority: request2.priority,
        // origin request’s origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: request2.origin,
        // referrer request’s referrer.
        referrer: request2.referrer,
        // referrer policy request’s referrer policy.
        referrerPolicy: request2.referrerPolicy,
        // mode request’s mode.
        mode: request2.mode,
        // credentials mode request’s credentials mode.
        credentials: request2.credentials,
        // cache mode request’s cache mode.
        cache: request2.cache,
        // redirect mode request’s redirect mode.
        redirect: request2.redirect,
        // integrity metadata request’s integrity metadata.
        integrity: request2.integrity,
        // keepalive request’s keepalive.
        keepalive: request2.keepalive,
        // reload-navigation flag request’s reload-navigation flag.
        reloadNavigation: request2.reloadNavigation,
        // history-navigation flag request’s history-navigation flag.
        historyNavigation: request2.historyNavigation,
        // URL list A clone of request’s URL list.
        urlList: [...request2.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request2.mode === "navigate") {
          request2.mode = "same-origin";
        }
        request2.reloadNavigation = false;
        request2.historyNavigation = false;
        request2.origin = "client";
        request2.referrer = "client";
        request2.referrerPolicy = "";
        request2.url = request2.urlList[request2.urlList.length - 1];
        request2.urlList = [request2.url];
      }
      if (init.referrer !== void 0) {
        const referrer = init.referrer;
        if (referrer === "") {
          request2.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
            request2.referrer = "client";
          } else {
            request2.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== void 0) {
        request2.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== void 0) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request2.mode = mode;
      }
      if (init.credentials !== void 0) {
        request2.credentials = init.credentials;
      }
      if (init.cache !== void 0) {
        request2.cache = init.cache;
      }
      if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      }
      if (init.redirect !== void 0) {
        request2.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request2.integrity = String(init.integrity);
      }
      if (init.keepalive !== void 0) {
        request2.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== void 0) {
        let method = init.method;
        if (!isValidHTTPToken(method)) {
          throw new TypeError(`'${method}' is not a valid HTTP method.`);
        }
        if (forbiddenMethodsSet.has(method.toUpperCase())) {
          throw new TypeError(`'${method}' HTTP method is unsupported.`);
        }
        method = normalizeMethodRecord[method] ?? normalizeMethod(method);
        request2.method = method;
      }
      if (init.signal !== void 0) {
        signal = init.signal;
      }
      this[kState] = request2;
      const ac = new AbortController();
      this[kSignal] = ac.signal;
      this[kSignal][kRealm] = this[kRealm];
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal."
          );
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = function() {
            const ac2 = acRef.deref();
            if (ac2 !== void 0) {
              ac2.abort(this.reason);
            }
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(100, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(100, signal);
            }
          } catch {
          }
          util2.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort });
        }
      }
      this[kHeaders] = new Headers(kConstruct);
      this[kHeaders][kHeadersList] = request2.headersList;
      this[kHeaders][kGuard] = "request";
      this[kHeaders][kRealm] = this[kRealm];
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request2.method)) {
          throw new TypeError(
            `'${request2.method} is unsupported in no-cors mode.`
          );
        }
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (initHasKey) {
        const headersList = this[kHeaders][kHeadersList];
        const headers2 = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers2 instanceof HeadersList) {
          for (const [key, val] of headers2) {
            headersList.append(key, val);
          }
          headersList.cookies = headers2.cookies;
        } else {
          fillHeaders(this[kHeaders], headers2);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(
          init.body,
          request2.keepalive
        );
        initBody = extractedBody;
        if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request2.mode !== "same-origin" && request2.mode !== "cors") {
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        }
        request2.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        }
        if (!TransformStream) {
          TransformStream = require$$14.TransformStream;
        }
        const identityTransform = new TransformStream();
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    // Returns request’s HTTP method, which is "GET" by default.
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    // Returns the URL of request as a string.
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the global’s default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the request’s
    // referrer.
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      return this[kState].credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browser’s cache when fetching.
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    // Returns request’s subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-foward navigation).
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    // Returns a clone of request.
    clone() {
      webidl.brandCheck(this, Request);
      if (this.bodyUsed || this.body?.locked) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const clonedRequestObject = new Request(kConstruct);
      clonedRequestObject[kState] = clonedRequest;
      clonedRequestObject[kRealm] = this[kRealm];
      clonedRequestObject[kHeaders] = new Headers(kConstruct);
      clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
      clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      const ac = new AbortController();
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        util2.addAbortListener(
          this.signal,
          () => {
            ac.abort(this.signal.reason);
          }
        );
      }
      clonedRequestObject[kSignal] = ac.signal;
      return clonedRequestObject;
    }
  }
  mixinBody(Request);
  function makeRequest(init) {
    const request2 = {
      method: "GET",
      localURLsOnly: false,
      unsafeRequest: false,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: false,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: false,
      credentials: "same-origin",
      useCredentials: false,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: false,
      historyNavigation: false,
      userActivation: false,
      taintedOrigin: false,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: false,
      done: false,
      timingAllowFailed: false,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
    };
    request2.url = request2.urlList[0];
    return request2;
  }
  function cloneRequest(request2) {
    const newRequest = makeRequest({ ...request2, body: null });
    if (request2.body != null) {
      newRequest.body = cloneBody(request2.body);
    }
    return newRequest;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(
    Request
  );
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V);
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(
    AbortSignal
  );
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(
        webidl.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(
        (signal) => webidl.converters.AbortSignal(
          signal,
          { strict: false }
        )
      )
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  request = { Request, makeRequest };
  return request;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  hasRequiredFetch = 1;
  const {
    Response,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = /* @__PURE__ */ requireResponse$1();
  const { Headers } = /* @__PURE__ */ requireHeaders();
  const { Request, makeRequest } = /* @__PURE__ */ requireRequest();
  const zlib = require$$3;
  const {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = /* @__PURE__ */ requireUtil$7();
  const { kState, kHeaders, kGuard, kRealm } = /* @__PURE__ */ requireSymbols$3();
  const assert2 = require$$0$7;
  const { safelyExtractBody } = /* @__PURE__ */ requireBody();
  const {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet,
    DOMException: DOMException2
  } = /* @__PURE__ */ requireConstants$9();
  const { kHeadersList } = /* @__PURE__ */ requireSymbols$4();
  const EE = require$$0$6;
  const { Readable, pipeline: pipeline2 } = require$$0$9;
  const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = /* @__PURE__ */ requireUtil$8();
  const { dataURLProcessor, serializeAMimeType } = /* @__PURE__ */ requireDataURL();
  const { TransformStream } = require$$14;
  const { getGlobalDispatcher } = /* @__PURE__ */ requireGlobal();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { STATUS_CODES } = require$$2;
  const GET_OR_HEAD = ["GET", "HEAD"];
  let resolveObjectURL;
  let ReadableStream2 = globalThis.ReadableStream;
  class Fetch extends EE {
    constructor(dispatcher2) {
      super();
      this.dispatcher = dispatcher2;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
      this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(error2) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error2) {
        error2 = new DOMException2("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error2;
      this.connection?.destroy(error2);
      this.emit("terminated", error2);
    }
  }
  function fetch(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request2 = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request2, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request2.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request2.serviceWorkers = "none";
    }
    let responseObject = null;
    const relevantRealm = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(
      requestObject.signal,
      () => {
        locallyAborted = true;
        assert2(controller != null);
        controller.abort(requestObject.signal.reason);
        abortFetch(p, request2, responseObject, requestObject.signal.reason);
      }
    );
    const handleFetchDone = (response2) => finalizeAndReportTiming(response2, "fetch");
    const processResponse = (response2) => {
      if (locallyAborted) {
        return Promise.resolve();
      }
      if (response2.aborted) {
        abortFetch(p, request2, responseObject, controller.serializedAbortReason);
        return Promise.resolve();
      }
      if (response2.type === "error") {
        p.reject(
          Object.assign(new TypeError("fetch failed"), { cause: response2.error })
        );
        return Promise.resolve();
      }
      responseObject = new Response();
      responseObject[kState] = response2;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = response2.headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      p.resolve(responseObject);
    };
    controller = fetching({
      request: request2,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
      // undici
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response2, initiatorType = "other") {
    if (response2.type === "error" && response2.aborted) {
      return;
    }
    if (!response2.urlList?.length) {
      return;
    }
    const originalURL = response2.urlList[0];
    let timingInfo = response2.timingInfo;
    let cacheState = response2.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response2.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response2.timingInfo = timingInfo;
    markResourceTiming(
      timingInfo,
      originalURL,
      initiatorType,
      globalThis,
      cacheState
    );
  }
  function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
      performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
    }
  }
  function abortFetch(p, request2, responseObject, error2) {
    if (!error2) {
      error2 = new DOMException2("The operation was aborted.", "AbortError");
    }
    p.reject(error2);
    if (request2.body != null && isReadable(request2.body?.stream)) {
      request2.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response2 = responseObject[kState];
    if (response2.body != null && isReadable(response2.body?.stream)) {
      response2.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request: request2,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher: dispatcher2
    // undici
  }) {
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request2.client != null) {
      taskDestination = request2.client.globalObject;
      crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
    }
    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher2),
      request: request2,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert2(!request2.body || request2.body.stream);
    if (request2.window === "client") {
      request2.window = request2.client?.globalObject?.constructor?.name === "Window" ? request2.client : "no-window";
    }
    if (request2.origin === "client") {
      request2.origin = request2.client?.origin;
    }
    if (request2.policyContainer === "client") {
      if (request2.client != null) {
        request2.policyContainer = clonePolicyContainer(
          request2.client.policyContainer
        );
      } else {
        request2.policyContainer = makePolicyContainer();
      }
    }
    if (!request2.headersList.contains("accept")) {
      const value = "*/*";
      request2.headersList.append("accept", value);
    }
    if (!request2.headersList.contains("accept-language")) {
      request2.headersList.append("accept-language", "*");
    }
    if (subresourceSet.has(request2.destination)) ;
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request2 = fetchParams.request;
    let response2 = null;
    if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
      response2 = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
    if (requestBadPort(request2) === "blocked") {
      response2 = makeNetworkError("bad port");
    }
    if (request2.referrerPolicy === "") {
      request2.referrerPolicy = request2.policyContainer.referrerPolicy;
    }
    if (request2.referrer !== "no-referrer") {
      request2.referrer = determineRequestsReferrer(request2);
    }
    if (response2 === null) {
      response2 = await (async () => {
        const currentURL = requestCurrentURL(request2);
        if (
          // - request’s current URL’s origin is same origin with request’s origin,
          //   and request’s response tainting is "basic"
          sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // request’s current URL’s scheme is "data"
          currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
          (request2.mode === "navigate" || request2.mode === "websocket")
        ) {
          request2.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request2.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request2.mode === "no-cors") {
          if (request2.redirect !== "follow") {
            return makeNetworkError(
              'redirect mode cannot be "follow" for "no-cors" request'
            );
          }
          request2.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request2.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response2;
    }
    if (response2.status !== 0 && !response2.internalResponse) {
      if (request2.responseTainting === "basic") {
        response2 = filterResponse(response2, "basic");
      } else if (request2.responseTainting === "cors") {
        response2 = filterResponse(response2, "cors");
      } else if (request2.responseTainting === "opaque") {
        response2 = filterResponse(response2, "opaque");
      } else {
        assert2(false);
      }
    }
    let internalResponse = response2.status === 0 ? response2 : response2.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request2.urlList);
    }
    if (!request2.timingAllowFailed) {
      response2.timingAllowPassed = true;
    }
    if (response2.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range")) {
      response2 = internalResponse = makeNetworkError();
    }
    if (response2.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request2.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request2.responseTainting === "opaque" || response2.body == null) {
        processBodyError(response2.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request2.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response2.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response2);
      };
      await fullyReadBody(response2.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response2);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request: request2 } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request2);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = require$$7.resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request2);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request2.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const bodyWithType = safelyExtractBody(blobURLEntryObject);
        const body2 = bodyWithType[0];
        const length = isomorphicEncode(`${body2.length}`);
        const type = bodyWithType[1] ?? "";
        const response2 = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type }]
          ]
        });
        response2.body = body2;
        return Promise.resolve(response2);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request2);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response2) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response2));
    }
  }
  function fetchFinale(fetchParams, response2) {
    if (response2.type === "error") {
      response2.urlList = [fetchParams.request.urlList[0]];
      response2.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    }
    const processResponseEndOfBody = () => {
      fetchParams.request.done = true;
      if (fetchParams.processResponseEndOfBody != null) {
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response2));
      }
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => fetchParams.processResponse(response2));
    }
    if (response2.body == null) {
      processResponseEndOfBody();
    } else {
      const identityTransformAlgorithm = (chunk, controller) => {
        controller.enqueue(chunk);
      };
      const transformStream = new TransformStream({
        start() {
        },
        transform: identityTransformAlgorithm,
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response2.body = { stream: response2.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response2, nullOrBytes);
      const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response2, failure);
      if (response2.body == null) {
        queueMicrotask(() => processBody(null));
      } else {
        return fullyReadBody(response2.body, processBody, processBodyError);
      }
      return Promise.resolve();
    }
  }
  async function httpFetch(fetchParams) {
    const request2 = fetchParams.request;
    let response2 = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (response2 === null) {
      if (request2.redirect === "follow") {
        request2.serviceWorkers = "none";
      }
      actualResponse = response2 = await httpNetworkOrCacheFetch(fetchParams);
      if (request2.responseTainting === "cors" && corsCheck(request2, response2) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request2, response2) === "failure") {
        request2.timingAllowFailed = true;
      }
    }
    if ((request2.responseTainting === "opaque" || response2.type === "opaque") && crossOriginResourcePolicyCheck(
      request2.origin,
      request2.client,
      request2.destination,
      actualResponse
    ) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request2.redirect !== "manual") {
        fetchParams.controller.connection.destroy();
      }
      if (request2.redirect === "error") {
        response2 = makeNetworkError("unexpected redirect");
      } else if (request2.redirect === "manual") {
        response2 = actualResponse;
      } else if (request2.redirect === "follow") {
        response2 = await httpRedirectFetch(fetchParams, response2);
      } else {
        assert2(false);
      }
    }
    response2.timingInfo = timingInfo;
    return response2;
  }
  function httpRedirectFetch(fetchParams, response2) {
    const request2 = fetchParams.request;
    const actualResponse = response2.internalResponse ? response2.internalResponse : response2;
    let locationURL;
    try {
      locationURL = responseLocationURL(
        actualResponse,
        requestCurrentURL(request2).hash
      );
      if (locationURL == null) {
        return response2;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request2.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request2.redirectCount += 1;
    if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError(
        'URL cannot contain credentials for request mode "cors"'
      ));
    }
    if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
      request2.method = "GET";
      request2.body = null;
      for (const headerName of requestBodyHeader) {
        request2.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
      request2.headersList.delete("authorization");
      request2.headersList.delete("proxy-authorization", true);
      request2.headersList.delete("cookie");
      request2.headersList.delete("host");
    }
    if (request2.body != null) {
      assert2(request2.body.source != null);
      request2.body = safelyExtractBody(request2.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request2.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request2, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request2 = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response2 = null;
    if (request2.window === "no-window" && request2.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request2;
    } else {
      httpRequest = makeRequest(request2);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    }
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent")) {
      httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
      httpRequest.headersList.append("cache-control", "max-age=0");
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma")) {
        httpRequest.headersList.append("pragma", "no-cache");
      }
      if (!httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "no-cache");
      }
    }
    if (httpRequest.headersList.contains("range")) {
      httpRequest.headersList.append("accept-encoding", "identity");
    }
    if (!httpRequest.headersList.contains("accept-encoding")) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
      }
    }
    httpRequest.headersList.delete("host");
    {
      httpRequest.cache = "no-store";
    }
    if (response2 == null) {
      if (httpRequest.mode === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(
        httpFetchParams,
        includeCredentials,
        isNewConnectionFetch
      );
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
      if (response2 == null) {
        response2 = forwardResponse;
      }
    }
    response2.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range")) {
      response2.rangeRequested = true;
    }
    response2.requestIncludesCredentials = includeCredentials;
    if (response2.status === 407) {
      if (request2.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (
      // response’s status is 421
      response2.status === 421 && // isNewConnectionFetch is false
      !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
      (request2.body == null || request2.body.source != null)
    ) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response2 = await httpNetworkOrCacheFetch(
        fetchParams,
        isAuthenticationFetch,
        true
      );
    }
    return response2;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert2(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err) {
        if (!this.destroyed) {
          this.destroyed = true;
          this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
        }
      }
    };
    const request2 = fetchParams.request;
    let response2 = null;
    const timingInfo = fetchParams.timingInfo;
    {
      request2.cache = "no-store";
    }
    let requestBody = null;
    if (request2.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request2.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = (async function* () {
        try {
          for await (const bytes of request2.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      })();
    }
    try {
      const { body: body2, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response2 = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body2[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response2 = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream2) {
      ReadableStream2 = require$$14.ReadableStream;
    }
    const stream = new ReadableStream2(
      {
        async start(controller) {
          fetchParams.controller.controller = controller;
        },
        async pull(controller) {
          await pullAlgorithm();
        },
        async cancel(reason) {
          await cancelAlgorithm(reason);
        }
      },
      {
        highWaterMark: 0,
        size() {
          return 1;
        }
      }
    );
    response2.body = { stream };
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = void 0;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response2);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response2.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(
            fetchParams.controller.serializedAbortReason
          );
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : void 0
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response2;
    async function dispatch({ body: body2 }) {
      const url = requestCurrentURL(request2);
      const agent2 = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent2.dispatch(
        {
          path: url.pathname + url.search,
          origin: url.origin,
          method: request2.method,
          body: fetchParams.controller.dispatcher.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body2,
          headers: request2.headersList.entries,
          maxRedirections: 0,
          upgrade: request2.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(abort) {
            const { connection: connection2 } = fetchParams.controller;
            if (connection2.destroyed) {
              abort(new DOMException2("The operation was aborted.", "AbortError"));
            } else {
              fetchParams.controller.on("terminated", abort);
              this.abort = connection2.abort = abort;
            }
          },
          onHeaders(status, headersList, resume, statusText) {
            if (status < 200) {
              return;
            }
            let codings = [];
            let location = "";
            const headers2 = new Headers();
            if (Array.isArray(headersList)) {
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                if (key.toLowerCase() === "content-encoding") {
                  codings = val.toLowerCase().split(",").map((x) => x.trim());
                } else if (key.toLowerCase() === "location") {
                  location = val;
                }
                headers2[kHeadersList].append(key, val);
              }
            } else {
              const keys = Object.keys(headersList);
              for (const key of keys) {
                const val = headersList[key];
                if (key.toLowerCase() === "content-encoding") {
                  codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                } else if (key.toLowerCase() === "location") {
                  location = val;
                }
                headers2[kHeadersList].append(key, val);
              }
            }
            this.body = new Readable({ read: resume });
            const decoders = [];
            const willFollow = request2.redirect === "follow" && location && redirectStatusSet.has(status);
            if (request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
              for (const coding of codings) {
                if (coding === "x-gzip" || coding === "gzip") {
                  decoders.push(zlib.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: zlib.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "deflate") {
                  decoders.push(zlib.createInflate());
                } else if (coding === "br") {
                  decoders.push(zlib.createBrotliDecompress());
                } else {
                  decoders.length = 0;
                  break;
                }
              }
            }
            resolve({
              status,
              statusText,
              headersList: headers2[kHeadersList],
              body: decoders.length ? pipeline2(this.body, ...decoders, () => {
              }) : this.body.on("error", () => {
              })
            });
            return true;
          },
          onData(chunk) {
            if (fetchParams.controller.dump) {
              return;
            }
            const bytes = chunk;
            timingInfo.encodedBodySize += bytes.byteLength;
            return this.body.push(bytes);
          },
          onComplete() {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            fetchParams.controller.ended = true;
            this.body.push(null);
          },
          onError(error2) {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            this.body?.destroy(error2);
            fetchParams.controller.terminate(error2);
            reject(error2);
          },
          onUpgrade(status, headersList, socket) {
            if (status !== 101) {
              return;
            }
            const headers2 = new Headers();
            for (let n = 0; n < headersList.length; n += 2) {
              const key = headersList[n + 0].toString("latin1");
              const val = headersList[n + 1].toString("latin1");
              headers2[kHeadersList].append(key, val);
            }
            resolve({
              status,
              statusText: STATUS_CODES[status],
              headersList: headers2[kHeadersList],
              socket
            });
            return true;
          }
        }
      ));
    }
  }
  fetch_1 = {
    fetch,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
  return fetch_1;
}
var symbols$2;
var hasRequiredSymbols$2;
function requireSymbols$2() {
  if (hasRequiredSymbols$2) return symbols$2;
  hasRequiredSymbols$2 = 1;
  symbols$2 = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
  return symbols$2;
}
var progressevent;
var hasRequiredProgressevent;
function requireProgressevent() {
  if (hasRequiredProgressevent) return progressevent;
  hasRequiredProgressevent = 1;
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const kState = Symbol("ProgressEvent state");
  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ]);
  progressevent = {
    ProgressEvent
  };
  return progressevent;
}
var encoding;
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding;
  hasRequiredEncoding = 1;
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  encoding = {
    getEncoding
  };
  return encoding;
}
var util$5;
var hasRequiredUtil$5;
function requireUtil$5() {
  if (hasRequiredUtil$5) return util$5;
  hasRequiredUtil$5 = 1;
  const {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = /* @__PURE__ */ requireSymbols$2();
  const { ProgressEvent } = /* @__PURE__ */ requireProgressevent();
  const { getEncoding } = /* @__PURE__ */ requireEncoding();
  const { DOMException: DOMException2 } = /* @__PURE__ */ requireConstants$9();
  const { serializeAMimeType, parseMIMEType } = /* @__PURE__ */ requireDataURL();
  const { types } = require$$0$5;
  const { StringDecoder } = require$$6;
  const { btoa: btoa2 } = require$$7;
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  function readOperation(fr, blob2, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException2("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob2.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob2.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error2) {
                fr[kError] = error2;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error2) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error2;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL2 = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL2 += serializeAMimeType(parsed);
        }
        dataURL2 += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL2 += btoa2(decoder.write(chunk));
        }
        dataURL2 += btoa2(decoder.end());
        return dataURL2;
      }
      case "Text": {
        let encoding2 = "failure";
        if (encodingName) {
          encoding2 = getEncoding(encodingName);
        }
        if (encoding2 === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding2 = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding2 === "failure") {
          encoding2 = "UTF-8";
        }
        return decode(bytes, encoding2);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode(ioQueue, encoding2) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding2 = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding2).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  }
  util$5 = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
  return util$5;
}
var filereader;
var hasRequiredFilereader;
function requireFilereader() {
  if (hasRequiredFilereader) return filereader;
  hasRequiredFilereader = 1;
  const {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = /* @__PURE__ */ requireUtil$5();
  const {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = /* @__PURE__ */ requireSymbols$2();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { kEnumerableProperty } = /* @__PURE__ */ requireUtil$8();
  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
     * @param {import('buffer').Blob} blob
     */
    readAsArrayBuffer(blob2) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
      blob2 = webidl.converters.Blob(blob2, { strict: false });
      readOperation(this, blob2, "ArrayBuffer");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsBinaryString
     * @param {import('buffer').Blob} blob
     */
    readAsBinaryString(blob2) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
      blob2 = webidl.converters.Blob(blob2, { strict: false });
      readOperation(this, blob2, "BinaryString");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsDataText
     * @param {import('buffer').Blob} blob
     * @param {string?} encoding
     */
    readAsText(blob2, encoding2 = void 0) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
      blob2 = webidl.converters.Blob(blob2, { strict: false });
      if (encoding2 !== void 0) {
        encoding2 = webidl.converters.DOMString(encoding2);
      }
      readOperation(this, blob2, "Text", encoding2);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
     * @param {import('buffer').Blob} blob
     */
    readAsDataURL(blob2) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
      blob2 = webidl.converters.Blob(blob2, { strict: false });
      readOperation(this, blob2, "DataURL");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-abort
     */
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
     */
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-result
     */
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-error
     */
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  filereader = {
    FileReader
  };
  return filereader;
}
var symbols$1;
var hasRequiredSymbols$1;
function requireSymbols$1() {
  if (hasRequiredSymbols$1) return symbols$1;
  hasRequiredSymbols$1 = 1;
  symbols$1 = {
    kConstruct: requireSymbols$4().kConstruct
  };
  return symbols$1;
}
var util$4;
var hasRequiredUtil$4;
function requireUtil$4() {
  if (hasRequiredUtil$4) return util$4;
  hasRequiredUtil$4 = 1;
  const assert2 = require$$0$7;
  const { URLSerializer } = /* @__PURE__ */ requireDataURL();
  const { isValidHeaderName } = /* @__PURE__ */ requireUtil$7();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function fieldValues(header) {
    assert2(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (!value.length) {
        continue;
      } else if (!isValidHeaderName(value)) {
        continue;
      }
      values.push(value);
    }
    return values;
  }
  util$4 = {
    urlEquals,
    fieldValues
  };
  return util$4;
}
var cache$3;
var hasRequiredCache$3;
function requireCache$3() {
  if (hasRequiredCache$3) return cache$3;
  hasRequiredCache$3 = 1;
  const { kConstruct } = /* @__PURE__ */ requireSymbols$1();
  const { urlEquals, fieldValues: getFieldValues } = /* @__PURE__ */ requireUtil$4();
  const { kEnumerableProperty, isDisturbed } = /* @__PURE__ */ requireUtil$8();
  const { kHeadersList } = /* @__PURE__ */ requireSymbols$4();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { Response, cloneResponse } = /* @__PURE__ */ requireResponse$1();
  const { Request } = /* @__PURE__ */ requireRequest();
  const { kState, kHeaders, kGuard, kRealm } = /* @__PURE__ */ requireSymbols$3();
  const { fetching } = /* @__PURE__ */ requireFetch();
  const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = /* @__PURE__ */ requireUtil$7();
  const assert2 = require$$0$7;
  const { getGlobalDispatcher } = /* @__PURE__ */ requireGlobal();
  class Cache {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
     * @type {requestResponseList}
     */
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request2, options2 = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
      request2 = webidl.converters.RequestInfo(request2);
      options2 = webidl.converters.CacheQueryOptions(options2);
      const p = await this.matchAll(request2, options2);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request2 = void 0, options2 = {}) {
      webidl.brandCheck(this, Cache);
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2);
      options2 = webidl.converters.CacheQueryOptions(options2);
      let r = null;
      if (request2 !== void 0) {
        if (request2 instanceof Request) {
          r = request2[kState];
          if (r.method !== "GET" && !options2.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r = new Request(request2)[kState];
        }
      }
      const responses = [];
      if (request2 === void 0) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options2);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response2 of responses) {
        const responseObject = new Response(response2.body?.source ?? null);
        const body2 = responseObject[kState].body;
        responseObject[kState] = response2;
        responseObject[kState].body = body2;
        responseObject[kHeaders][kHeadersList] = response2.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request2) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
      request2 = webidl.converters.RequestInfo(request2);
      const requests = [request2];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
      requests = webidl.converters["sequence<RequestInfo>"](requests);
      const responsePromises = [];
      const requestList = [];
      for (const request2 of requests) {
        if (typeof request2 === "string") {
          continue;
        }
        const r = request2[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request2 of requests) {
        const r = new Request(request2)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response2) {
            if (response2.type === "error" || response2.status === 206 || response2.status < 200 || response2.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response2.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response2.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response2) {
            if (response2.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response2);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations2 = [];
      let index = 0;
      for (const response2 of responses) {
        const operation2 = {
          type: "put",
          // 7.3.2
          request: requestList[index],
          // 7.3.3
          response: response2
          // 7.3.4
        };
        operations2.push(operation2);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations2);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(void 0);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request2, response2) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
      request2 = webidl.converters.RequestInfo(request2);
      response2 = webidl.converters.Response(response2);
      let innerRequest = null;
      if (request2 instanceof Request) {
        innerRequest = request2[kState];
      } else {
        innerRequest = new Request(request2)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response2[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(void 0);
      }
      const operations2 = [];
      const operation2 = {
        type: "put",
        // 14.
        request: innerRequest,
        // 15.
        response: clonedResponse
        // 16.
      };
      operations2.push(operation2);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations2);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request2, options2 = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
      request2 = webidl.converters.RequestInfo(request2);
      options2 = webidl.converters.CacheQueryOptions(options2);
      let r = null;
      if (request2 instanceof Request) {
        r = request2[kState];
        if (r.method !== "GET" && !options2.ignoreMethod) {
          return false;
        }
      } else {
        assert2(typeof request2 === "string");
        r = new Request(request2)[kState];
      }
      const operations2 = [];
      const operation2 = {
        type: "delete",
        request: r,
        options: options2
      };
      operations2.push(operation2);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations2);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {readonly Request[]}
     */
    async keys(request2 = void 0, options2 = {}) {
      webidl.brandCheck(this, Cache);
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2);
      options2 = webidl.converters.CacheQueryOptions(options2);
      let r = null;
      if (request2 !== void 0) {
        if (request2 instanceof Request) {
          r = request2[kState];
          if (r.method !== "GET" && !options2.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r = new Request(request2)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request2 === void 0) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options2);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request3 of requests) {
          const requestObject = new Request("https://a");
          requestObject[kState] = request3;
          requestObject[kHeaders][kHeadersList] = request3.headersList;
          requestObject[kHeaders][kGuard] = "immutable";
          requestObject[kRealm] = request3.client;
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    #batchCacheOperations(operations2) {
      const cache2 = this.#relevantRequestResponseList;
      const backupCache = [...cache2];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation2 of operations2) {
          if (operation2.type !== "delete" && operation2.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation2.type === "delete" && operation2.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation2.request, operation2.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation2.type === "delete") {
            requestResponses = this.#queryCache(operation2.request, operation2.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache2.indexOf(requestResponse);
              assert2(idx !== -1);
              cache2.splice(idx, 1);
            }
          } else if (operation2.type === "put") {
            if (operation2.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation2.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation2.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation2.request);
            for (const requestResponse of requestResponses) {
              const idx = cache2.indexOf(requestResponse);
              assert2(idx !== -1);
              cache2.splice(idx, 1);
            }
            cache2.push([operation2.request, operation2.response]);
            addedItems.push([operation2.request, operation2.response]);
          }
          resultList.push([operation2.request, operation2.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    #queryCache(requestQuery, options2, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options2)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    #requestMatchesCachedItem(requestQuery, request2, response2 = null, options2) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request2.url);
      if (options2?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response2 == null || options2?.ignoreVary || !response2.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response2.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request2.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  const cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
    webidl.converters.RequestInfo
  );
  cache$3 = {
    Cache
  };
  return cache$3;
}
var cachestorage;
var hasRequiredCachestorage;
function requireCachestorage() {
  if (hasRequiredCachestorage) return cachestorage;
  hasRequiredCachestorage = 1;
  const { kConstruct } = /* @__PURE__ */ requireSymbols$1();
  const { Cache } = /* @__PURE__ */ requireCache$3();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { kEnumerableProperty } = /* @__PURE__ */ requireUtil$8();
  class CacheStorage {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
     * @type {Map<string, import('./cache').requestResponseList}
     */
    #caches = /* @__PURE__ */ new Map();
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
    }
    async match(request2, options2 = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
      request2 = webidl.converters.RequestInfo(request2);
      options2 = webidl.converters.MultiCacheQueryOptions(options2);
      if (options2.cacheName != null) {
        if (this.#caches.has(options2.cacheName)) {
          const cacheList = this.#caches.get(options2.cacheName);
          const cache2 = new Cache(kConstruct, cacheList);
          return await cache2.match(request2, options2);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache2 = new Cache(kConstruct, cacheList);
          const response2 = await cache2.match(request2, options2);
          if (response2 !== void 0) {
            return response2;
          }
        }
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.has(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
      cacheName = webidl.converters.DOMString(cacheName);
      if (this.#caches.has(cacheName)) {
        const cache3 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache3);
      }
      const cache2 = [];
      this.#caches.set(cacheName, cache2);
      return new Cache(kConstruct, cache2);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.delete(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {string[]}
     */
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  cachestorage = {
    CacheStorage
  };
  return cachestorage;
}
var constants$7;
var hasRequiredConstants$7;
function requireConstants$7() {
  if (hasRequiredConstants$7) return constants$7;
  hasRequiredConstants$7 = 1;
  const maxAttributeValueSize = 1024;
  const maxNameValuePairSize = 4096;
  constants$7 = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
  return constants$7;
}
var util$3;
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3) return util$3;
  hasRequiredUtil$3 = 1;
  function isCTLExcludingHtab(value) {
    if (value.length === 0) {
      return false;
    }
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
        return false;
      }
    }
  }
  function validateCookieName(name) {
    for (const char of name) {
      const code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code < 33 || // exclude CTLs (0-31)
      code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
        throw new Error("Invalid header value");
      }
    }
  }
  function validateCookiePath(path2) {
    for (const char of path2) {
      const code = char.charCodeAt(0);
      if (code < 33 || char === ";") {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    const days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    const dayName = days[date.getUTCDay()];
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();
    const hour = date.getUTCHours().toString().padStart(2, "0");
    const minute = date.getUTCMinutes().toString().padStart(2, "0");
    const second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  util$3 = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
  return util$3;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  const { maxNameValuePairSize, maxAttributeValueSize } = /* @__PURE__ */ requireConstants$7();
  const { isCTLExcludingHtab } = /* @__PURE__ */ requireUtil$3();
  const { collectASequenceOfCodePointsFast } = /* @__PURE__ */ requireDataURL();
  const assert2 = require$$0$7;
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast(
        "=",
        nameValuePair,
        position
      );
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert2(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(
        ";",
        unparsedAttributes,
        { position: 0 }
      );
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast(
        "=",
        cookieAv,
        position
      );
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  parse = {
    parseSetCookie,
    parseUnparsedAttributes
  };
  return parse;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  const { parseSetCookie } = /* @__PURE__ */ requireParse();
  const { stringify } = /* @__PURE__ */ requireUtil$3();
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { Headers } = /* @__PURE__ */ requireHeaders();
  function getCookies(headers2) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
    webidl.brandCheck(headers2, Headers, { strict: false });
    const cookie = headers2.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers2, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
    webidl.brandCheck(headers2, Headers, { strict: false });
    name = webidl.converters.DOMString(name);
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers2, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers2) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
    webidl.brandCheck(headers2, Headers, { strict: false });
    const cookies2 = headers2.getSetCookie();
    if (!cookies2) {
      return [];
    }
    return cookies2.map((pair) => parseSetCookie(pair));
  }
  function setCookie(headers2, cookie) {
    webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
    webidl.brandCheck(headers2, Headers, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers2.append("Set-Cookie", stringify(cookie));
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  cookies = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
  return cookies;
}
var constants$6;
var hasRequiredConstants$6;
function requireConstants$6() {
  if (hasRequiredConstants$6) return constants$6;
  hasRequiredConstants$6 = 1;
  const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  const states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  const opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  const maxUnsigned16Bit = 2 ** 16 - 1;
  const parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  const emptyBuffer = Buffer.allocUnsafe(0);
  constants$6 = {
    uid,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer
  };
  return constants$6;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  symbols = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
  return symbols;
}
var events;
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { kEnumerableProperty } = /* @__PURE__ */ requireUtil$8();
  const { MessagePort } = require$$0$c;
  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }
  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }
  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
    webidl.converters.MessagePort
  );
  const eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  events = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
  return events;
}
var util$2;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = /* @__PURE__ */ requireSymbols();
  const { states, opcodes } = /* @__PURE__ */ requireConstants$6();
  const { MessageEvent, ErrorEvent } = /* @__PURE__ */ requireEvents();
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
    const event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = new Uint8Array(data).buffer;
      }
    }
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (const char of protocol) {
      const code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
      code === 9) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1e3 && code < 1015) {
      return code !== 1004 && // reserved
      code !== 1005 && // "MUST NOT be set as a status code"
      code !== 1006;
    }
    return code >= 3e3 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response2 } = ws;
    controller.abort();
    if (response2?.socket && !response2.socket.destroyed) {
      response2.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, ErrorEvent, {
        error: new Error(reason)
      });
    }
  }
  util$2 = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
  return util$2;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const diagnosticsChannel = require$$0$d;
  const { uid, states } = /* @__PURE__ */ requireConstants$6();
  const {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = /* @__PURE__ */ requireSymbols();
  const { fireEvent, failWebsocketConnection } = /* @__PURE__ */ requireUtil$2();
  const { CloseEvent } = /* @__PURE__ */ requireEvents();
  const { makeRequest } = /* @__PURE__ */ requireRequest();
  const { fetching } = /* @__PURE__ */ requireFetch();
  const { Headers } = /* @__PURE__ */ requireHeaders();
  const { getGlobalDispatcher } = /* @__PURE__ */ requireGlobal();
  const { kHeadersList } = /* @__PURE__ */ requireSymbols$4();
  const channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  let crypto;
  try {
    crypto = require("crypto");
  } catch {
  }
  function establishWebSocketConnection(url, protocols, ws, onEstablish, options2) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request2 = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options2.headers) {
      const headersList = new Headers(options2.headers)[kHeadersList];
      request2.headersList = headersList;
    }
    const keyValue = crypto.randomBytes(16).toString("base64");
    request2.headersList.append("sec-websocket-key", keyValue);
    request2.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request2.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "";
    const controller = fetching({
      request: request2,
      useParallelQueue: true,
      dispatcher: options2.dispatcher ?? getGlobalDispatcher(),
      processResponse(response2) {
        if (response2.type === "error" || response2.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response2.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response2.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response2.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response2.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response2.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        const secProtocol = response2.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request2.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        response2.socket.on("data", onSocketData);
        response2.socket.on("close", onSocketClose);
        response2.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response2.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response2);
      }
    });
    return controller;
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose() {
    const { ws } = this;
    const wasClean = ws[kSentClose] && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kSentClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error2) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error2);
    }
    this.destroy();
  }
  connection = {
    establishWebSocketConnection
  };
  return connection;
}
var frame;
var hasRequiredFrame;
function requireFrame() {
  if (hasRequiredFrame) return frame;
  hasRequiredFrame = 1;
  const { maxUnsigned16Bit } = /* @__PURE__ */ requireConstants$6();
  let crypto;
  try {
    crypto = require("crypto");
  } catch {
  }
  class WebsocketFrameSend {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(data) {
      this.frameData = data;
      this.maskKey = crypto.randomBytes(4);
    }
    createFrame(opcode) {
      const bodyLength = this.frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0;
      buffer[0] |= 128;
      buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer[offset - 4] = this.maskKey[0];
      buffer[offset - 3] = this.maskKey[1];
      buffer[offset - 2] = this.maskKey[2];
      buffer[offset - 1] = this.maskKey[3];
      buffer[1] = payloadLength;
      if (payloadLength === 126) {
        buffer.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer[2] = buffer[3] = 0;
        buffer.writeUIntBE(bodyLength, 4, 6);
      }
      buffer[1] |= 128;
      for (let i = 0; i < bodyLength; i++) {
        buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
      }
      return buffer;
    }
  }
  frame = {
    WebsocketFrameSend
  };
  return frame;
}
var receiver;
var hasRequiredReceiver;
function requireReceiver() {
  if (hasRequiredReceiver) return receiver;
  hasRequiredReceiver = 1;
  const { Writable } = require$$0$9;
  const diagnosticsChannel = require$$0$d;
  const { parserStates, opcodes, states, emptyBuffer } = /* @__PURE__ */ requireConstants$6();
  const { kReadyState, kSentClose, kResponse, kReceivedClose } = /* @__PURE__ */ requireSymbols();
  const { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = /* @__PURE__ */ requireUtil$2();
  const { WebsocketFrameSend } = /* @__PURE__ */ requireFrame();
  const channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.run(callback);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(callback) {
      while (true) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.fin = (buffer[0] & 128) !== 0;
          this.#info.opcode = buffer[0] & 15;
          this.#info.originalOpcode ??= this.#info.opcode;
          this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
          if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const payloadLength = buffer[1] & 127;
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const body2 = this.consume(payloadLength);
            this.#info.closeInfo = this.parseCloseBody(false, body2);
            if (!this.ws[kSentClose]) {
              const body3 = Buffer.allocUnsafe(2);
              body3.writeUInt16BE(this.#info.closeInfo.code, 0);
              const closeFrame = new WebsocketFrameSend(body3);
              this.ws[kResponse].socket.write(
                closeFrame.createFrame(opcodes.CLOSE),
                (err) => {
                  if (!err) {
                    this.ws[kSentClose] = true;
                  }
                }
              );
            }
            this.ws[kReadyState] = states.CLOSING;
            this.ws[kReceivedClose] = true;
            this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            const body2 = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              const frame2 = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(frame2.createFrame(opcodes.PONG));
              if (channels.ping.hasSubscribers) {
                channels.ping.publish({
                  payload: body2
                });
              }
            }
            this.#state = parserStates.INFO;
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            const body2 = this.consume(payloadLength);
            if (channels.pong.hasSubscribers) {
              channels.pong.publish({
                payload: body2
              });
            }
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          } else if (this.#byteOffset >= this.#info.payloadLength) {
            const body2 = this.consume(this.#info.payloadLength);
            this.#fragments.push(body2);
            if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              const fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
              this.#info = {};
              this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0) {
          continue;
        } else {
          callback();
          break;
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer|null}
     */
    consume(n) {
      if (n > this.#byteOffset) {
        return null;
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (onlyCode) {
        if (!isValidStatusCode(code)) {
          return null;
        }
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      if (code !== void 0 && !isValidStatusCode(code)) {
        return null;
      }
      try {
        reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  receiver = {
    ByteParser
  };
  return receiver;
}
var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
  if (hasRequiredWebsocket) return websocket;
  hasRequiredWebsocket = 1;
  const { webidl } = /* @__PURE__ */ requireWebidl();
  const { DOMException: DOMException2 } = /* @__PURE__ */ requireConstants$9();
  const { URLSerializer } = /* @__PURE__ */ requireDataURL();
  const { getGlobalOrigin } = /* @__PURE__ */ requireGlobal$1();
  const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = /* @__PURE__ */ requireConstants$6();
  const {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = /* @__PURE__ */ requireSymbols();
  const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = /* @__PURE__ */ requireUtil$2();
  const { establishWebSocketConnection } = /* @__PURE__ */ requireConnection();
  const { WebsocketFrameSend } = /* @__PURE__ */ requireFrame();
  const { ByteParser } = /* @__PURE__ */ requireReceiver();
  const { kEnumerableProperty, isBlobLike } = /* @__PURE__ */ requireUtil$8();
  const { getGlobalDispatcher } = /* @__PURE__ */ requireGlobal();
  const { types } = require$$0$5;
  let experimentalWarned = false;
  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(url, protocols = []) {
      super();
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      }
      const options2 = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url);
      protocols = options2.protocols;
      const baseURL = getGlobalOrigin();
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException2(
          `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
          "SyntaxError"
        );
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException2("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      this[kController] = establishWebSocketConnection(
        urlRecord,
        protocols,
        this,
        (response2) => this.#onConnectionEstablished(response2),
        options2
      );
      this[kReadyState] = WebSocket.CONNECTING;
      this[kBinaryType] = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(code = void 0, reason = void 0) {
      webidl.brandCheck(this, WebSocket);
      if (code !== void 0) {
        code = webidl.converters["unsigned short"](code, { clamp: true });
      }
      if (reason !== void 0) {
        reason = webidl.converters.USVString(reason);
      }
      if (code !== void 0) {
        if (code !== 1e3 && (code < 3e3 || code > 4999)) {
          throw new DOMException2("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== void 0) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException2(
            `Reason must be less than 123 bytes; received ${reasonByteLength}`,
            "SyntaxError"
          );
        }
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) ;
      else if (!isEstablished(this)) {
        failWebsocketConnection(this, "Connection was closed before it was established.");
        this[kReadyState] = WebSocket.CLOSING;
      } else if (!isClosing(this)) {
        const frame2 = new WebsocketFrameSend();
        if (code !== void 0 && reason === void 0) {
          frame2.frameData = Buffer.allocUnsafe(2);
          frame2.frameData.writeUInt16BE(code, 0);
        } else if (code !== void 0 && reason !== void 0) {
          frame2.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
          frame2.frameData.writeUInt16BE(code, 0);
          frame2.frameData.write(reason, 2, "utf-8");
        } else {
          frame2.frameData = emptyBuffer;
        }
        const socket = this[kResponse].socket;
        socket.write(frame2.createFrame(opcodes.CLOSE), (err) => {
          if (!err) {
            this[kSentClose] = true;
          }
        });
        this[kReadyState] = states.CLOSING;
      } else {
        this[kReadyState] = WebSocket.CLOSING;
      }
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(data) {
      webidl.brandCheck(this, WebSocket);
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
      data = webidl.converters.WebSocketSendData(data);
      if (this[kReadyState] === WebSocket.CONNECTING) {
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      const socket = this[kResponse].socket;
      if (typeof data === "string") {
        const value = Buffer.from(data);
        const frame2 = new WebsocketFrameSend(value);
        const buffer = frame2.createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        const value = Buffer.from(data);
        const frame2 = new WebsocketFrameSend(value);
        const buffer = frame2.createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        const ab = Buffer.from(data, data.byteOffset, data.byteLength);
        const frame2 = new WebsocketFrameSend(ab);
        const buffer = frame2.createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        const frame2 = new WebsocketFrameSend();
        data.arrayBuffer().then((ab) => {
          const value = Buffer.from(ab);
          frame2.frameData = value;
          const buffer = frame2.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    #onConnectionEstablished(response2) {
      this[kResponse] = response2;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response2.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response2.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response2.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
    webidl.converters.DOMString
  );
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  websocket = {
    WebSocket
  };
  return websocket;
}
var hasRequiredUndici;
function requireUndici() {
  if (hasRequiredUndici) return undici;
  hasRequiredUndici = 1;
  const Client = /* @__PURE__ */ requireClient();
  const Dispatcher = /* @__PURE__ */ requireDispatcher();
  const errors2 = /* @__PURE__ */ requireErrors$1();
  const Pool = /* @__PURE__ */ requirePool();
  const BalancedPool = /* @__PURE__ */ requireBalancedPool();
  const Agent = /* @__PURE__ */ requireAgent();
  const util2 = /* @__PURE__ */ requireUtil$8();
  const { InvalidArgumentError } = errors2;
  const api2 = /* @__PURE__ */ requireApi();
  const buildConnector = /* @__PURE__ */ requireConnect();
  const MockClient = /* @__PURE__ */ requireMockClient();
  const MockAgent = /* @__PURE__ */ requireMockAgent();
  const MockPool = /* @__PURE__ */ requireMockPool();
  const mockErrors2 = /* @__PURE__ */ requireMockErrors();
  const ProxyAgent = /* @__PURE__ */ requireProxyAgent();
  const RetryHandler = /* @__PURE__ */ requireRetryHandler();
  const { getGlobalDispatcher, setGlobalDispatcher } = /* @__PURE__ */ requireGlobal();
  const DecoratorHandler = /* @__PURE__ */ requireDecoratorHandler();
  const RedirectHandler = /* @__PURE__ */ requireRedirectHandler();
  const createRedirectInterceptor = /* @__PURE__ */ requireRedirectInterceptor();
  let hasCrypto;
  try {
    require("crypto");
    hasCrypto = true;
  } catch {
    hasCrypto = false;
  }
  Object.assign(Dispatcher.prototype, api2);
  undici.Dispatcher = Dispatcher;
  undici.Client = Client;
  undici.Pool = Pool;
  undici.BalancedPool = BalancedPool;
  undici.Agent = Agent;
  undici.ProxyAgent = ProxyAgent;
  undici.RetryHandler = RetryHandler;
  undici.DecoratorHandler = DecoratorHandler;
  undici.RedirectHandler = RedirectHandler;
  undici.createRedirectInterceptor = createRedirectInterceptor;
  undici.buildConnector = buildConnector;
  undici.errors = errors2;
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path2 = opts.path;
        if (!opts.path.startsWith("/")) {
          path2 = `/${path2}`;
        }
        url = new URL(util2.parseOrigin(url).origin + path2);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util2.parseURL(url);
      }
      const { agent: agent2, dispatcher: dispatcher2 = getGlobalDispatcher() } = opts;
      if (agent2) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher2, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  undici.setGlobalDispatcher = setGlobalDispatcher;
  undici.getGlobalDispatcher = getGlobalDispatcher;
  if (util2.nodeMajor > 16 || util2.nodeMajor === 16 && util2.nodeMinor >= 8) {
    let fetchImpl = null;
    undici.fetch = async function fetch(resource) {
      if (!fetchImpl) {
        fetchImpl = requireFetch().fetch;
      }
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        if (typeof err === "object") {
          Error.captureStackTrace(err, this);
        }
        throw err;
      }
    };
    undici.Headers = requireHeaders().Headers;
    undici.Response = requireResponse$1().Response;
    undici.Request = requireRequest().Request;
    undici.FormData = requireFormdata().FormData;
    undici.File = requireFile$1().File;
    undici.FileReader = requireFilereader().FileReader;
    const { setGlobalOrigin, getGlobalOrigin } = /* @__PURE__ */ requireGlobal$1();
    undici.setGlobalOrigin = setGlobalOrigin;
    undici.getGlobalOrigin = getGlobalOrigin;
    const { CacheStorage } = /* @__PURE__ */ requireCachestorage();
    const { kConstruct } = /* @__PURE__ */ requireSymbols$1();
    undici.caches = new CacheStorage(kConstruct);
  }
  if (util2.nodeMajor >= 16) {
    const { deleteCookie, getCookies, getSetCookies, setCookie } = /* @__PURE__ */ requireCookies();
    undici.deleteCookie = deleteCookie;
    undici.getCookies = getCookies;
    undici.getSetCookies = getSetCookies;
    undici.setCookie = setCookie;
    const { parseMIMEType, serializeAMimeType } = /* @__PURE__ */ requireDataURL();
    undici.parseMIMEType = parseMIMEType;
    undici.serializeAMimeType = serializeAMimeType;
  }
  if (util2.nodeMajor >= 18 && hasCrypto) {
    const { WebSocket } = /* @__PURE__ */ requireWebsocket();
    undici.WebSocket = WebSocket;
  }
  undici.request = makeDispatcher(api2.request);
  undici.stream = makeDispatcher(api2.stream);
  undici.pipeline = makeDispatcher(api2.pipeline);
  undici.connect = makeDispatcher(api2.connect);
  undici.upgrade = makeDispatcher(api2.upgrade);
  undici.MockClient = MockClient;
  undici.MockPool = MockPool;
  undici.MockAgent = MockAgent;
  undici.mockErrors = mockErrors2;
  return undici;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  var __createBinding2 = lib$1 && lib$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = lib$1 && lib$1.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = lib$1 && lib$1.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = lib$1 && lib$1.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(lib$1, "__esModule", { value: true });
  lib$1.HttpClient = lib$1.isHttps = lib$1.HttpClientResponse = lib$1.HttpClientError = lib$1.getProxyUrl = lib$1.MediaTypes = lib$1.Headers = lib$1.HttpCodes = void 0;
  const http = __importStar2(require$$2);
  const https = __importStar2(require$$1$3);
  const pm = __importStar2(/* @__PURE__ */ requireProxy$1());
  const tunnel2 = __importStar2(/* @__PURE__ */ requireTunnel());
  const undici_1 = /* @__PURE__ */ requireUndici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (lib$1.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (lib$1.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (lib$1.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  lib$1.getProxyUrl = getProxyUrl;
  const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  const RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  const ExponentialBackoffCeiling = 10;
  const ExponentialBackoffTimeSlice = 5;
  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  lib$1.HttpClientError = HttpClientError;
  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  lib$1.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }
  lib$1.isHttps = isHttps;
  class HttpClient {
    constructor(userAgent2, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = userAgent2;
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers2) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers2);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response2;
        do {
          response2 = yield this.requestRaw(info, data);
          if (response2 && response2.message && response2.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response2)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response2;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response2.message.statusCode && HttpRedirectCodes.includes(response2.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response2.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response2.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers2) {
                if (header.toLowerCase() === "authorization") {
                  delete headers2[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers2);
            response2 = yield this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (!response2.message.statusCode || !HttpResponseRetryCodes.includes(response2.message.statusCode)) {
            return response2;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response2.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response2;
      });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err) {
              reject(err);
            } else if (!res) {
              reject(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers) {
          info.options.headers = {};
        }
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info.httpModule.request(info.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult(void 0, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error(`Request timeout: ${info.options.path}`));
      });
      req.on("error", function(err) {
        handleResult(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers2) {
      const info = {};
      info.parsedUrl = requestUrl;
      const usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info.options = {};
      info.options.host = info.parsedUrl.hostname;
      info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
      info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
      info.options.method = method;
      info.options.headers = this._mergeHeaders(headers2);
      if (this.userAgent != null) {
        info.options.headers["user-agent"] = this.userAgent;
      }
      info.options.agent = this._getAgent(info.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info.options);
        }
      }
      return info;
    }
    _mergeHeaders(headers2) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers2 || {}));
      }
      return lowercaseKeys(headers2 || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
      }
      return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent2;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent2 = this._proxyAgent;
      }
      if (!useProxy) {
        agent2 = this._agent;
      }
      if (agent2) {
        return agent2;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel2.httpsOverHttps : tunnel2.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel2.httpOverHttps : tunnel2.httpOverHttp;
        }
        agent2 = tunnelAgent(agentOptions);
        this._proxyAgent = agent2;
      }
      if (!agent2) {
        const options2 = { keepAlive: this._keepAlive, maxSockets };
        agent2 = usingSsl ? new https.Agent(options2) : new http.Agent(options2);
        this._agent = agent2;
      }
      if (usingSsl && this._ignoreSslError) {
        agent2.options = Object.assign(agent2.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent2;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent2;
      if (this._keepAlive) {
        proxyAgent2 = this._proxyAgentDispatcher;
      }
      if (proxyAgent2) {
        return proxyAgent2;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent2 = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent2;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent2.options = Object.assign(proxyAgent2.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent2;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter2(this, void 0, void 0, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms2 = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms2));
      });
    }
    _processResponse(res, options2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
          const statusCode = res.message.statusCode || 0;
          const response2 = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response2);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a = new Date(value);
              if (!isNaN(a.valueOf())) {
                return a;
              }
            }
            return value;
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options2 && options2.deserializeDates) {
                obj = JSON.parse(contents, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response2.result = obj;
            }
            response2.headers = res.message.headers;
          } catch (err) {
          }
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response2.result;
            reject(err);
          } else {
            resolve(response2);
          }
        }));
      });
    }
  }
  lib$1.HttpClient = HttpClient;
  const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  return lib$1;
}
var auth = {};
var hasRequiredAuth;
function requireAuth() {
  if (hasRequiredAuth) return auth;
  hasRequiredAuth = 1;
  var __awaiter2 = auth && auth.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(auth, "__esModule", { value: true });
  auth.PersonalAccessTokenCredentialHandler = auth.BearerCredentialHandler = auth.BasicCredentialHandler = void 0;
  class BasicCredentialHandler {
    constructor(username, password) {
      this.username = username;
      this.password = password;
    }
    prepareRequest(options2) {
      if (!options2.headers) {
        throw Error("The request has no headers");
      }
      options2.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter2(this, void 0, void 0, function* () {
        throw new Error("not implemented");
      });
    }
  }
  auth.BasicCredentialHandler = BasicCredentialHandler;
  class BearerCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options2) {
      if (!options2.headers) {
        throw Error("The request has no headers");
      }
      options2.headers["Authorization"] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter2(this, void 0, void 0, function* () {
        throw new Error("not implemented");
      });
    }
  }
  auth.BearerCredentialHandler = BearerCredentialHandler;
  class PersonalAccessTokenCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options2) {
      if (!options2.headers) {
        throw Error("The request has no headers");
      }
      options2.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter2(this, void 0, void 0, function* () {
        throw new Error("not implemented");
      });
    }
  }
  auth.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  return auth;
}
var hasRequiredOidcUtils;
function requireOidcUtils() {
  if (hasRequiredOidcUtils) return oidcUtils;
  hasRequiredOidcUtils = 1;
  var __awaiter2 = oidcUtils && oidcUtils.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(oidcUtils, "__esModule", { value: true });
  oidcUtils.OidcClient = void 0;
  const http_client_1 = /* @__PURE__ */ requireLib$1();
  const auth_1 = /* @__PURE__ */ requireAuth();
  const core_1 = /* @__PURE__ */ requireCore();
  class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
      const requestOptions = {
        allowRetries: allowRetry,
        maxRetries: maxRetry
      };
      return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
      const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
      if (!token) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      }
      return token;
    }
    static getIDTokenUrl() {
      const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
      if (!runtimeUrl) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      }
      return runtimeUrl;
    }
    static getCall(id_token_url) {
      var _a;
      return __awaiter2(this, void 0, void 0, function* () {
        const httpclient = OidcClient.createHttpClient();
        const res = yield httpclient.getJson(id_token_url).catch((error2) => {
          throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error2.statusCode}
 
        Error Message: ${error2.message}`);
        });
        const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
        if (!id_token) {
          throw new Error("Response json body do not have ID Token field");
        }
        return id_token;
      });
    }
    static getIDToken(audience) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          let id_token_url = OidcClient.getIDTokenUrl();
          if (audience) {
            const encodedAudience = encodeURIComponent(audience);
            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
          }
          (0, core_1.debug)(`ID token url is ${id_token_url}`);
          const id_token = yield OidcClient.getCall(id_token_url);
          (0, core_1.setSecret)(id_token);
          return id_token;
        } catch (error2) {
          throw new Error(`Error message: ${error2.message}`);
        }
      });
    }
  }
  oidcUtils.OidcClient = OidcClient;
  return oidcUtils;
}
var summary = {};
var hasRequiredSummary;
function requireSummary() {
  if (hasRequiredSummary) return summary;
  hasRequiredSummary = 1;
  (function(exports) {
    var __awaiter2 = summary && summary.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
    const os_1 = require$$0$3;
    const fs_1 = require$$1$2;
    const { access, appendFile, writeFile } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    class Summary {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const overwrite = !!(options2 === null || options2 === void 0 ? void 0 : options2.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter2(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src2, alt, options2) {
        const { width, height } = options2 || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src: src2, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    }
    const _summary = new Summary();
    exports.markdownSummary = _summary;
    exports.summary = _summary;
  })(summary);
  return summary;
}
var pathUtils = {};
var hasRequiredPathUtils;
function requirePathUtils() {
  if (hasRequiredPathUtils) return pathUtils;
  hasRequiredPathUtils = 1;
  var __createBinding2 = pathUtils && pathUtils.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = pathUtils && pathUtils.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = pathUtils && pathUtils.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(pathUtils, "__esModule", { value: true });
  pathUtils.toPlatformPath = pathUtils.toWin32Path = pathUtils.toPosixPath = void 0;
  const path2 = __importStar2(require$$1$7);
  function toPosixPath(pth) {
    return pth.replace(/[\\]/g, "/");
  }
  pathUtils.toPosixPath = toPosixPath;
  function toWin32Path(pth) {
    return pth.replace(/[/]/g, "\\");
  }
  pathUtils.toWin32Path = toWin32Path;
  function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path2.sep);
  }
  pathUtils.toPlatformPath = toPlatformPath;
  return pathUtils;
}
var platform = {};
var exec = {};
var toolrunner = {};
var io$1 = {};
var ioUtil$1 = {};
var hasRequiredIoUtil$1;
function requireIoUtil$1() {
  if (hasRequiredIoUtil$1) return ioUtil$1;
  hasRequiredIoUtil$1 = 1;
  (function(exports) {
    var __createBinding2 = ioUtil$1 && ioUtil$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault2 = ioUtil$1 && ioUtil$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = ioUtil$1 && ioUtil$1.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter2 = ioUtil$1 && ioUtil$1.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
    const fs = __importStar2(require$$1$2);
    const path2 = __importStar2(require$$1$7);
    _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
    exports.IS_WINDOWS = process.platform === "win32";
    exports.UV_FS_O_EXLOCK = 268435456;
    exports.READONLY = fs.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          yield exports.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter2(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter2(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            const upperExt = path2.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              try {
                const directory = path2.dirname(filePath);
                const upperName = path2.basename(filePath).toUpperCase();
                for (const actualName of yield exports.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path2.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports.getCmdPath = getCmdPath;
  })(ioUtil$1);
  return ioUtil$1;
}
var hasRequiredIo$1;
function requireIo$1() {
  if (hasRequiredIo$1) return io$1;
  hasRequiredIo$1 = 1;
  var __createBinding2 = io$1 && io$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = io$1 && io$1.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = io$1 && io$1.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = io$1 && io$1.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(io$1, "__esModule", { value: true });
  io$1.findInPath = io$1.which = io$1.mkdirP = io$1.rmRF = io$1.mv = io$1.cp = void 0;
  const assert_1 = require$$0$7;
  const path2 = __importStar2(require$$1$7);
  const ioUtil2 = __importStar2(/* @__PURE__ */ requireIoUtil$1());
  function cp(source, dest, options2 = {}) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { force, recursive, copySourceDirectory } = readCopyOptions(options2);
      const destStat = (yield ioUtil2.exists(dest)) ? yield ioUtil2.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path2.join(dest, path2.basename(source)) : dest;
      if (!(yield ioUtil2.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil2.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path2.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  io$1.cp = cp;
  function mv(source, dest, options2 = {}) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (yield ioUtil2.exists(dest)) {
        let destExists = true;
        if (yield ioUtil2.isDirectory(dest)) {
          dest = path2.join(dest, path2.basename(source));
          destExists = yield ioUtil2.exists(dest);
        }
        if (destExists) {
          if (options2.force == null || options2.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path2.dirname(dest));
      yield ioUtil2.rename(source, dest);
    });
  }
  io$1.mv = mv;
  function rmRF(inputPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (ioUtil2.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath)) {
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        }
      }
      try {
        yield ioUtil2.rm(inputPath, {
          force: true,
          maxRetries: 3,
          recursive: true,
          retryDelay: 300
        });
      } catch (err) {
        throw new Error(`File was unable to be removed ${err}`);
      }
    });
  }
  io$1.rmRF = rmRF;
  function mkdirP(fsPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      assert_1.ok(fsPath, "a path argument must be provided");
      yield ioUtil2.mkdir(fsPath, { recursive: true });
    });
  }
  io$1.mkdirP = mkdirP;
  function which(tool, check) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result = yield which(tool, false);
        if (!result) {
          if (ioUtil2.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
        return result;
      }
      const matches = yield findInPath(tool);
      if (matches && matches.length > 0) {
        return matches[0];
      }
      return "";
    });
  }
  io$1.which = which;
  function findInPath(tool) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      const extensions = [];
      if (ioUtil2.IS_WINDOWS && process.env["PATHEXT"]) {
        for (const extension of process.env["PATHEXT"].split(path2.delimiter)) {
          if (extension) {
            extensions.push(extension);
          }
        }
      }
      if (ioUtil2.isRooted(tool)) {
        const filePath = yield ioUtil2.tryGetExecutablePath(tool, extensions);
        if (filePath) {
          return [filePath];
        }
        return [];
      }
      if (tool.includes(path2.sep)) {
        return [];
      }
      const directories = [];
      if (process.env.PATH) {
        for (const p of process.env.PATH.split(path2.delimiter)) {
          if (p) {
            directories.push(p);
          }
        }
      }
      const matches = [];
      for (const directory of directories) {
        const filePath = yield ioUtil2.tryGetExecutablePath(path2.join(directory, tool), extensions);
        if (filePath) {
          matches.push(filePath);
        }
      }
      return matches;
    });
  }
  io$1.findInPath = findInPath;
  function readCopyOptions(options2) {
    const force = options2.force == null ? true : options2.force;
    const recursive = Boolean(options2.recursive);
    const copySourceDirectory = options2.copySourceDirectory == null ? true : Boolean(options2.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil2.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil2.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil2.chmod(destDir, (yield ioUtil2.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter2(this, void 0, void 0, function* () {
      if ((yield ioUtil2.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil2.lstat(destFile);
          yield ioUtil2.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil2.chmod(destFile, "0666");
            yield ioUtil2.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil2.readlink(srcFile);
        yield ioUtil2.symlink(symlinkFull, destFile, ioUtil2.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil2.exists(destFile)) || force) {
        yield ioUtil2.copyFile(srcFile, destFile);
      }
    });
  }
  return io$1;
}
var hasRequiredToolrunner;
function requireToolrunner() {
  if (hasRequiredToolrunner) return toolrunner;
  hasRequiredToolrunner = 1;
  var __createBinding2 = toolrunner && toolrunner.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = toolrunner && toolrunner.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = toolrunner && toolrunner.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = toolrunner && toolrunner.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(toolrunner, "__esModule", { value: true });
  toolrunner.argStringToArray = toolrunner.ToolRunner = void 0;
  const os = __importStar2(require$$0$3);
  const events2 = __importStar2(require$$0$6);
  const child = __importStar2(require$$2$2);
  const path2 = __importStar2(require$$1$7);
  const io2 = __importStar2(/* @__PURE__ */ requireIo$1());
  const ioUtil2 = __importStar2(/* @__PURE__ */ requireIoUtil$1());
  const timers_1 = require$$6$1;
  const IS_WINDOWS = process.platform === "win32";
  class ToolRunner extends events2.EventEmitter {
    constructor(toolPath, args, options2) {
      super();
      if (!toolPath) {
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      }
      this.toolPath = toolPath;
      this.args = args || [];
      this.options = options2 || {};
    }
    _debug(message) {
      if (this.options.listeners && this.options.listeners.debug) {
        this.options.listeners.debug(message);
      }
    }
    _getCommandString(options2, noPrefix) {
      const toolPath = this._getSpawnFileName();
      const args = this._getSpawnArgs(options2);
      let cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else if (options2.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (const a of args) {
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
          }
        }
      } else {
        cmd += toolPath;
        for (const a of args) {
          cmd += ` ${a}`;
        }
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString();
        let n = s.indexOf(os.EOL);
        while (n > -1) {
          const line = s.substring(0, n);
          onLine(line);
          s = s.substring(n + os.EOL.length);
          n = s.indexOf(os.EOL);
        }
        return s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
        return "";
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          return process.env["COMSPEC"] || "cmd.exe";
        }
      }
      return this.toolPath;
    }
    _getSpawnArgs(options2) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (const a of this.args) {
            argline += " ";
            argline += options2.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          }
          argline += '"';
          return [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      const upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile()) {
        return this._uvQuoteCmdArg(arg);
      }
      if (!arg) {
        return '""';
      }
      const cmdSpecialChars = [
        " ",
        "	",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let needsQuotes = false;
      for (const char of arg) {
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = true;
          break;
        }
      }
      if (!needsQuotes) {
        return arg;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length; i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += '"';
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg) {
        return '""';
      }
      if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
        return arg;
      }
      if (!arg.includes('"') && !arg.includes("\\")) {
        return `"${arg}"`;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length; i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += "\\";
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options2) {
      options2 = options2 || {};
      const result = {
        cwd: options2.cwd || process.cwd(),
        env: options2.env || process.env,
        silent: options2.silent || false,
        windowsVerbatimArguments: options2.windowsVerbatimArguments || false,
        failOnStdErr: options2.failOnStdErr || false,
        ignoreReturnCode: options2.ignoreReturnCode || false,
        delay: options2.delay || 1e4
      };
      result.outStream = options2.outStream || process.stdout;
      result.errStream = options2.errStream || process.stderr;
      return result;
    }
    _getSpawnOptions(options2, toolPath) {
      options2 = options2 || {};
      const result = {};
      result.cwd = options2.cwd;
      result.env = options2.env;
      result["windowsVerbatimArguments"] = options2.windowsVerbatimArguments || this._isCmdFile();
      if (options2.windowsVerbatimArguments) {
        result.argv0 = `"${toolPath}"`;
      }
      return result;
    }
    /**
     * Exec a tool.
     * Output will be streamed to the live console.
     * Returns promise with return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See ExecOptions
     * @returns   number
     */
    exec() {
      return __awaiter2(this, void 0, void 0, function* () {
        if (!ioUtil2.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
          this.toolPath = path2.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        }
        this.toolPath = yield io2.which(this.toolPath, true);
        return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
          this._debug(`exec tool: ${this.toolPath}`);
          this._debug("arguments:");
          for (const arg of this.args) {
            this._debug(`   ${arg}`);
          }
          const optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream) {
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          }
          const state2 = new ExecState(optionsNonNull, this.toolPath);
          state2.on("debug", (message) => {
            this._debug(message);
          });
          if (this.options.cwd && !(yield ioUtil2.exists(this.options.cwd))) {
            return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
          }
          const fileName = this._getSpawnFileName();
          const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
          let stdbuffer = "";
          if (cp.stdout) {
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout) {
                this.options.listeners.stdout(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(data);
              }
              stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline) {
                  this.options.listeners.stdline(line);
                }
              });
            });
          }
          let errbuffer = "";
          if (cp.stderr) {
            cp.stderr.on("data", (data) => {
              state2.processStderr = true;
              if (this.options.listeners && this.options.listeners.stderr) {
                this.options.listeners.stderr(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                s.write(data);
              }
              errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline) {
                  this.options.listeners.errline(line);
                }
              });
            });
          }
          cp.on("error", (err) => {
            state2.processError = err.message;
            state2.processExited = true;
            state2.processClosed = true;
            state2.CheckComplete();
          });
          cp.on("exit", (code) => {
            state2.processExitCode = code;
            state2.processExited = true;
            this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
            state2.CheckComplete();
          });
          cp.on("close", (code) => {
            state2.processExitCode = code;
            state2.processExited = true;
            state2.processClosed = true;
            this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
            state2.CheckComplete();
          });
          state2.on("done", (error2, exitCode) => {
            if (stdbuffer.length > 0) {
              this.emit("stdline", stdbuffer);
            }
            if (errbuffer.length > 0) {
              this.emit("errline", errbuffer);
            }
            cp.removeAllListeners();
            if (error2) {
              reject(error2);
            } else {
              resolve(exitCode);
            }
          });
          if (this.options.input) {
            if (!cp.stdin) {
              throw new Error("child process missing stdin");
            }
            cp.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  toolrunner.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = "";
    function append(c) {
      if (escaped && c !== '"') {
        arg += "\\";
      }
      arg += c;
      escaped = false;
    }
    for (let i = 0; i < argString.length; i++) {
      const c = argString.charAt(i);
      if (c === '"') {
        if (!escaped) {
          inQuotes = !inQuotes;
        } else {
          append(c);
        }
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = true;
        continue;
      }
      if (c === " " && !inQuotes) {
        if (arg.length > 0) {
          args.push(arg);
          arg = "";
        }
        continue;
      }
      append(c);
    }
    if (arg.length > 0) {
      args.push(arg.trim());
    }
    return args;
  }
  toolrunner.argStringToArray = argStringToArray;
  class ExecState extends events2.EventEmitter {
    constructor(options2, toolPath) {
      super();
      this.processClosed = false;
      this.processError = "";
      this.processExitCode = 0;
      this.processExited = false;
      this.processStderr = false;
      this.delay = 1e4;
      this.done = false;
      this.timeout = null;
      if (!toolPath) {
        throw new Error("toolPath must not be empty");
      }
      this.options = options2;
      this.toolPath = toolPath;
      if (options2.delay) {
        this.delay = options2.delay;
      }
    }
    CheckComplete() {
      if (this.done) {
        return;
      }
      if (this.processClosed) {
        this._setResult();
      } else if (this.processExited) {
        this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
      }
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error2;
      if (this.processExited) {
        if (this.processError) {
          error2 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
          error2 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        } else if (this.processStderr && this.options.failOnStdErr) {
          error2 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
        }
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.done = true;
      this.emit("done", error2, this.processExitCode);
    }
    static HandleTimeout(state2) {
      if (state2.done) {
        return;
      }
      if (!state2.processClosed && state2.processExited) {
        const message = `The STDIO streams did not close within ${state2.delay / 1e3} seconds of the exit event from process '${state2.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state2._debug(message);
      }
      state2._setResult();
    }
  }
  return toolrunner;
}
var hasRequiredExec;
function requireExec() {
  if (hasRequiredExec) return exec;
  hasRequiredExec = 1;
  var __createBinding2 = exec && exec.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = exec && exec.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = exec && exec.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = exec && exec.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exec, "__esModule", { value: true });
  exec.getExecOutput = exec.exec = void 0;
  const string_decoder_1 = require$$6;
  const tr = __importStar2(/* @__PURE__ */ requireToolrunner());
  function exec$1(commandLine, args, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0) {
        throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
      }
      const toolPath = commandArgs[0];
      args = commandArgs.slice(1).concat(args || []);
      const runner = new tr.ToolRunner(toolPath, args, options2);
      return runner.exec();
    });
  }
  exec.exec = exec$1;
  function getExecOutput(commandLine, args, options2) {
    var _a, _b;
    return __awaiter2(this, void 0, void 0, function* () {
      let stdout = "";
      let stderr = "";
      const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
      const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
      const originalStdoutListener = (_a = options2 === null || options2 === void 0 ? void 0 : options2.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
      const originalStdErrListener = (_b = options2 === null || options2 === void 0 ? void 0 : options2.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
      const stdErrListener = (data) => {
        stderr += stderrDecoder.write(data);
        if (originalStdErrListener) {
          originalStdErrListener(data);
        }
      };
      const stdOutListener = (data) => {
        stdout += stdoutDecoder.write(data);
        if (originalStdoutListener) {
          originalStdoutListener(data);
        }
      };
      const listeners = Object.assign(Object.assign({}, options2 === null || options2 === void 0 ? void 0 : options2.listeners), { stdout: stdOutListener, stderr: stdErrListener });
      const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options2), { listeners }));
      stdout += stdoutDecoder.end();
      stderr += stderrDecoder.end();
      return {
        exitCode,
        stdout,
        stderr
      };
    });
  }
  exec.getExecOutput = getExecOutput;
  return exec;
}
var hasRequiredPlatform;
function requirePlatform() {
  if (hasRequiredPlatform) return platform;
  hasRequiredPlatform = 1;
  (function(exports) {
    var __createBinding2 = platform && platform.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault2 = platform && platform.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = platform && platform.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter2 = platform && platform.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = platform && platform.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
    const os_1 = __importDefault2(require$$0$3);
    const exec2 = __importStar2(/* @__PURE__ */ requireExec());
    const getWindowsInfo = () => __awaiter2(void 0, void 0, void 0, function* () {
      const { stdout: version2 } = yield exec2.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name } = yield exec2.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name.trim(),
        version: version2.trim()
      };
    });
    const getMacOsInfo = () => __awaiter2(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec2.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version2 = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name,
        version: version2
      };
    });
    const getLinuxInfo = () => __awaiter2(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec2.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name, version2] = stdout.trim().split("\n");
      return {
        name,
        version: version2
      };
    });
    exports.platform = os_1.default.platform();
    exports.arch = os_1.default.arch();
    exports.isWindows = exports.platform === "win32";
    exports.isMacOS = exports.platform === "darwin";
    exports.isLinux = exports.platform === "linux";
    function getDetails() {
      return __awaiter2(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
          platform: exports.platform,
          arch: exports.arch,
          isWindows: exports.isWindows,
          isMacOS: exports.isMacOS,
          isLinux: exports.isLinux
        });
      });
    }
    exports.getDetails = getDetails;
  })(platform);
  return platform;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  (function(exports) {
    var __createBinding2 = core && core.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault2 = core && core.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = core && core.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __awaiter2 = core && core.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
    const command_1 = /* @__PURE__ */ requireCommand();
    const file_command_1 = /* @__PURE__ */ requireFileCommand();
    const utils_1 = /* @__PURE__ */ requireUtils$3();
    const os = __importStar2(require$$0$3);
    const path2 = __importStar2(require$$1$7);
    const oidc_utils_1 = /* @__PURE__ */ requireOidcUtils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports.ExitCode = ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
      }
      (0, command_1.issueCommand)("set-env", { name }, convertedVal);
    }
    exports.exportVariable = exportVariable;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path2.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    function getInput2(name, options2) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options2 && options2.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options2 && options2.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput2;
    function getMultilineInput(name, options2) {
      const inputs = getInput2(name, options2).split("\n").filter((x) => x !== "");
      if (options2 && options2.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options2) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput2(name, options2);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      process.stdout.write(os.EOL);
      (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed(message) {
      process.exitCode = ExitCode.Failure;
      error2(message);
    }
    exports.setFailed = setFailed;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    function debug2(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports.debug = debug2;
    function error2(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.error = error2;
    function warning(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.warning = warning;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.notice = notice;
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports.info = info;
    function startGroup(name) {
      (0, command_1.issue)("group", name);
    }
    exports.startGroup = startGroup;
    function endGroup() {
      (0, command_1.issue)("endgroup");
    }
    exports.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter2(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState;
    function getIDToken(aud) {
      return __awaiter2(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    var summary_1 = /* @__PURE__ */ requireSummary();
    Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = /* @__PURE__ */ requireSummary();
    Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = /* @__PURE__ */ requirePathUtils();
    Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports.platform = __importStar2(/* @__PURE__ */ requirePlatform());
  })(core);
  return core;
}
var coreExports = /* @__PURE__ */ requireCore();
var execExports = /* @__PURE__ */ requireExec();
class BaseProgram {
  path;
  constructor(path2) {
    this.path = path2;
  }
  call(arguments_, options2) {
    return execExports.exec(this.path, arguments_, options2);
  }
}
var cache$2 = {};
var cacheUtils = {};
var glob = {};
var internalGlobber = {};
var internalGlobOptionsHelper = {};
var hasRequiredInternalGlobOptionsHelper;
function requireInternalGlobOptionsHelper() {
  if (hasRequiredInternalGlobOptionsHelper) return internalGlobOptionsHelper;
  hasRequiredInternalGlobOptionsHelper = 1;
  var __createBinding2 = internalGlobOptionsHelper && internalGlobOptionsHelper.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = internalGlobOptionsHelper && internalGlobOptionsHelper.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = internalGlobOptionsHelper && internalGlobOptionsHelper.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(internalGlobOptionsHelper, "__esModule", { value: true });
  internalGlobOptionsHelper.getOptions = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  function getOptions(copy2) {
    const result = {
      followSymbolicLinks: true,
      implicitDescendants: true,
      omitBrokenSymbolicLinks: true
    };
    if (copy2) {
      if (typeof copy2.followSymbolicLinks === "boolean") {
        result.followSymbolicLinks = copy2.followSymbolicLinks;
        core2.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
      }
      if (typeof copy2.implicitDescendants === "boolean") {
        result.implicitDescendants = copy2.implicitDescendants;
        core2.debug(`implicitDescendants '${result.implicitDescendants}'`);
      }
      if (typeof copy2.omitBrokenSymbolicLinks === "boolean") {
        result.omitBrokenSymbolicLinks = copy2.omitBrokenSymbolicLinks;
        core2.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
      }
    }
    return result;
  }
  internalGlobOptionsHelper.getOptions = getOptions;
  return internalGlobOptionsHelper;
}
var internalPatternHelper = {};
var internalPathHelper = {};
var hasRequiredInternalPathHelper;
function requireInternalPathHelper() {
  if (hasRequiredInternalPathHelper) return internalPathHelper;
  hasRequiredInternalPathHelper = 1;
  var __createBinding2 = internalPathHelper && internalPathHelper.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = internalPathHelper && internalPathHelper.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = internalPathHelper && internalPathHelper.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = internalPathHelper && internalPathHelper.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(internalPathHelper, "__esModule", { value: true });
  internalPathHelper.safeTrimTrailingSeparator = internalPathHelper.normalizeSeparators = internalPathHelper.hasRoot = internalPathHelper.hasAbsoluteRoot = internalPathHelper.ensureAbsoluteRoot = internalPathHelper.dirname = void 0;
  const path2 = __importStar2(require$$1$7);
  const assert_1 = __importDefault2(require$$0$7);
  const IS_WINDOWS = process.platform === "win32";
  function dirname(p) {
    p = safeTrimTrailingSeparator(p);
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
      return p;
    }
    let result = path2.dirname(p);
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
      result = safeTrimTrailingSeparator(result);
    }
    return result;
  }
  internalPathHelper.dirname = dirname;
  function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    if (hasAbsoluteRoot(itemPath)) {
      return itemPath;
    }
    if (IS_WINDOWS) {
      if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let cwd = process.cwd();
        assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
        if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
          if (itemPath.length === 2) {
            return `${itemPath[0]}:\\${cwd.substr(3)}`;
          } else {
            if (!cwd.endsWith("\\")) {
              cwd += "\\";
            }
            return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
          }
        } else {
          return `${itemPath[0]}:\\${itemPath.substr(2)}`;
        }
      } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
        const cwd = process.cwd();
        assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
        return `${cwd[0]}:\\${itemPath.substr(1)}`;
      }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) ;
    else {
      root += path2.sep;
    }
    return root + itemPath;
  }
  internalPathHelper.ensureAbsoluteRoot = ensureAbsoluteRoot;
  function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  internalPathHelper.hasAbsoluteRoot = hasAbsoluteRoot;
  function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  internalPathHelper.hasRoot = hasRoot;
  function normalizeSeparators(p) {
    p = p || "";
    if (IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      const isUnc = /^\\\\+[^\\]/.test(p);
      return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  internalPathHelper.normalizeSeparators = normalizeSeparators;
  function safeTrimTrailingSeparator(p) {
    if (!p) {
      return "";
    }
    p = normalizeSeparators(p);
    if (!p.endsWith(path2.sep)) {
      return p;
    }
    if (p === path2.sep) {
      return p;
    }
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
      return p;
    }
    return p.substr(0, p.length - 1);
  }
  internalPathHelper.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
  return internalPathHelper;
}
var internalMatchKind = {};
var hasRequiredInternalMatchKind;
function requireInternalMatchKind() {
  if (hasRequiredInternalMatchKind) return internalMatchKind;
  hasRequiredInternalMatchKind = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MatchKind = void 0;
    (function(MatchKind) {
      MatchKind[MatchKind["None"] = 0] = "None";
      MatchKind[MatchKind["Directory"] = 1] = "Directory";
      MatchKind[MatchKind["File"] = 2] = "File";
      MatchKind[MatchKind["All"] = 3] = "All";
    })(exports.MatchKind || (exports.MatchKind = {}));
  })(internalMatchKind);
  return internalMatchKind;
}
var hasRequiredInternalPatternHelper;
function requireInternalPatternHelper() {
  if (hasRequiredInternalPatternHelper) return internalPatternHelper;
  hasRequiredInternalPatternHelper = 1;
  var __createBinding2 = internalPatternHelper && internalPatternHelper.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = internalPatternHelper && internalPatternHelper.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = internalPatternHelper && internalPatternHelper.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(internalPatternHelper, "__esModule", { value: true });
  internalPatternHelper.partialMatch = internalPatternHelper.match = internalPatternHelper.getSearchPaths = void 0;
  const pathHelper = __importStar2(/* @__PURE__ */ requireInternalPathHelper());
  const internal_match_kind_1 = /* @__PURE__ */ requireInternalMatchKind();
  const IS_WINDOWS = process.platform === "win32";
  function getSearchPaths(patterns) {
    patterns = patterns.filter((x) => !x.negate);
    const searchPathMap = {};
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      searchPathMap[key] = "candidate";
    }
    const result = [];
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      if (searchPathMap[key] === "included") {
        continue;
      }
      let foundAncestor = false;
      let tempKey = key;
      let parent = pathHelper.dirname(tempKey);
      while (parent !== tempKey) {
        if (searchPathMap[parent]) {
          foundAncestor = true;
          break;
        }
        tempKey = parent;
        parent = pathHelper.dirname(tempKey);
      }
      if (!foundAncestor) {
        result.push(pattern.searchPath);
        searchPathMap[key] = "included";
      }
    }
    return result;
  }
  internalPatternHelper.getSearchPaths = getSearchPaths;
  function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
      if (pattern.negate) {
        result &= ~pattern.match(itemPath);
      } else {
        result |= pattern.match(itemPath);
      }
    }
    return result;
  }
  internalPatternHelper.match = match;
  function partialMatch(patterns, itemPath) {
    return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
  }
  internalPatternHelper.partialMatch = partialMatch;
  return internalPatternHelper;
}
var internalPattern = {};
var concatMap;
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1;
  concatMap = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x)) res.push.apply(res, x);
      else res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap;
}
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var concatMap2 = /* @__PURE__ */ requireConcatMap();
  var balanced = /* @__PURE__ */ requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body2 = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body2 + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre)) return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap2(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path2 = (function() {
    try {
      return require("path");
    } catch (e) {
    }
  })() || {
    sep: "/"
  };
  minimatch.sep = path2.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = /* @__PURE__ */ requireBraceExpansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options2) {
    options2 = options2 || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options2);
    };
  }
  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch2(p, pattern, options2) {
      return orig(p, pattern, ext(def, options2));
    };
    m.Minimatch = function Minimatch2(pattern, options2) {
      return new orig.Minimatch(pattern, ext(def, options2));
    };
    m.Minimatch.defaults = function defaults(options2) {
      return orig.defaults(ext(def, options2)).Minimatch;
    };
    m.filter = function filter2(pattern, options2) {
      return orig.filter(pattern, ext(def, options2));
    };
    m.defaults = function defaults(options2) {
      return orig.defaults(ext(def, options2));
    };
    m.makeRe = function makeRe2(pattern, options2) {
      return orig.makeRe(pattern, ext(def, options2));
    };
    m.braceExpand = function braceExpand2(pattern, options2) {
      return orig.braceExpand(pattern, ext(def, options2));
    };
    m.match = function(list, pattern, options2) {
      return orig.match(list, pattern, ext(def, options2));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options2) {
    assertValidPattern(pattern);
    if (!options2) options2 = {};
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options2).match(p);
  }
  function Minimatch(pattern, options2) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options2);
    }
    assertValidPattern(pattern);
    if (!options2) options2 = {};
    pattern = pattern.trim();
    if (!options2.allowWindowsEscape && path2.sep !== "/") {
      pattern = pattern.split(path2.sep).join("/");
    }
    this.options = options2;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options2.debug) this.debug = function debug2() {
      console.error.apply(console, arguments);
    };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options2 = this.options;
    var negateOffset = 0;
    if (options2.nonegate) return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options2) {
    return braceExpand(pattern, options2);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options2) {
    if (!options2) {
      if (this instanceof Minimatch) {
        options2 = this.options;
      } else {
        options2 = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    assertValidPattern(pattern);
    var options2 = this.options;
    if (pattern === "**") {
      if (!options2.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "") return "";
    var re = "";
    var hasMagic = !!options2.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        /* istanbul ignore next */
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1) c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options2.noext) clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options2) {
    return new Minimatch(pattern, options2 || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options2 = this.options;
    var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
    var flags = options2.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate) re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch(pattern, options2);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined") partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment) return false;
    if (this.empty) return f === "";
    if (f === "/" && partial) return true;
    var options2 = this.options;
    if (path2.sep !== "/") {
      f = f.split(path2.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file2 = f;
      if (options2.matchBase && pattern.length === 1) {
        file2 = [filename];
      }
      var hit = this.matchOne(file2, pattern, partial);
      if (hit) {
        if (options2.flipNegate) return true;
        return !this.negate;
      }
    }
    if (options2.flipNegate) return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file2, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { "this": this, file: file2, pattern }
    );
    this.debug("matchOne", file2.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file2[fi];
      this.debug(pattern, p, f);
      if (p === false) return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file2[fi] === "." || file2[fi] === ".." || !options2.dot && file2[fi].charAt(0) === ".") return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file2[fr];
          this.debug("\nglobstar while", file2, fr, pattern, pr, swallowee);
          if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file2, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file2, fr, pattern, pr);
          if (fr === fl) return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit) return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file2[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1;
}
var internalPath = {};
var hasRequiredInternalPath;
function requireInternalPath() {
  if (hasRequiredInternalPath) return internalPath;
  hasRequiredInternalPath = 1;
  var __createBinding2 = internalPath && internalPath.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = internalPath && internalPath.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = internalPath && internalPath.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = internalPath && internalPath.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(internalPath, "__esModule", { value: true });
  internalPath.Path = void 0;
  const path2 = __importStar2(require$$1$7);
  const pathHelper = __importStar2(/* @__PURE__ */ requireInternalPathHelper());
  const assert_1 = __importDefault2(require$$0$7);
  const IS_WINDOWS = process.platform === "win32";
  class Path {
    /**
     * Constructs a Path
     * @param itemPath Path or array of segments
     */
    constructor(itemPath) {
      this.segments = [];
      if (typeof itemPath === "string") {
        assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (!pathHelper.hasRoot(itemPath)) {
          this.segments = itemPath.split(path2.sep);
        } else {
          let remaining = itemPath;
          let dir = pathHelper.dirname(remaining);
          while (dir !== remaining) {
            const basename2 = path2.basename(remaining);
            this.segments.unshift(basename2);
            remaining = dir;
            dir = pathHelper.dirname(remaining);
          }
          this.segments.unshift(remaining);
        }
      } else {
        assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
        for (let i = 0; i < itemPath.length; i++) {
          let segment = itemPath[i];
          assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
          segment = pathHelper.normalizeSeparators(itemPath[i]);
          if (i === 0 && pathHelper.hasRoot(segment)) {
            segment = pathHelper.safeTrimTrailingSeparator(segment);
            assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
            this.segments.push(segment);
          } else {
            assert_1.default(!segment.includes(path2.sep), `Parameter 'itemPath' contains unexpected path separators`);
            this.segments.push(segment);
          }
        }
      }
    }
    /**
     * Converts the path to it's string representation
     */
    toString() {
      let result = this.segments[0];
      let skipSlash = result.endsWith(path2.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
      for (let i = 1; i < this.segments.length; i++) {
        if (skipSlash) {
          skipSlash = false;
        } else {
          result += path2.sep;
        }
        result += this.segments[i];
      }
      return result;
    }
  }
  internalPath.Path = Path;
  return internalPath;
}
var hasRequiredInternalPattern;
function requireInternalPattern() {
  if (hasRequiredInternalPattern) return internalPattern;
  hasRequiredInternalPattern = 1;
  var __createBinding2 = internalPattern && internalPattern.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = internalPattern && internalPattern.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = internalPattern && internalPattern.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = internalPattern && internalPattern.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(internalPattern, "__esModule", { value: true });
  internalPattern.Pattern = void 0;
  const os = __importStar2(require$$0$3);
  const path2 = __importStar2(require$$1$7);
  const pathHelper = __importStar2(/* @__PURE__ */ requireInternalPathHelper());
  const assert_1 = __importDefault2(require$$0$7);
  const minimatch_12 = /* @__PURE__ */ requireMinimatch();
  const internal_match_kind_1 = /* @__PURE__ */ requireInternalMatchKind();
  const internal_path_1 = /* @__PURE__ */ requireInternalPath();
  const IS_WINDOWS = process.platform === "win32";
  class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
      this.negate = false;
      let pattern;
      if (typeof patternOrNegate === "string") {
        pattern = patternOrNegate.trim();
      } else {
        segments = segments || [];
        assert_1.default(segments.length, `Parameter 'segments' must not empty`);
        const root = Pattern.getLiteral(segments[0]);
        assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
        pattern = new internal_path_1.Path(segments).toString().trim();
        if (patternOrNegate) {
          pattern = `!${pattern}`;
        }
      }
      while (pattern.startsWith("!")) {
        this.negate = !this.negate;
        pattern = pattern.substr(1).trim();
      }
      pattern = Pattern.fixupPattern(pattern, homedir);
      this.segments = new internal_path_1.Path(pattern).segments;
      this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path2.sep);
      pattern = pathHelper.safeTrimTrailingSeparator(pattern);
      let foundGlob = false;
      const searchSegments = this.segments.map((x) => Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
      this.searchPath = new internal_path_1.Path(searchSegments).toString();
      this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
      this.isImplicitPattern = isImplicitPattern;
      const minimatchOptions = {
        dot: true,
        nobrace: true,
        nocase: IS_WINDOWS,
        nocomment: true,
        noext: true,
        nonegate: true
      };
      pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
      this.minimatch = new minimatch_12.Minimatch(pattern, minimatchOptions);
    }
    /**
     * Matches the pattern against the specified path
     */
    match(itemPath) {
      if (this.segments[this.segments.length - 1] === "**") {
        itemPath = pathHelper.normalizeSeparators(itemPath);
        if (!itemPath.endsWith(path2.sep) && this.isImplicitPattern === false) {
          itemPath = `${itemPath}${path2.sep}`;
        }
      } else {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      }
      if (this.minimatch.match(itemPath)) {
        return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
      }
      return internal_match_kind_1.MatchKind.None;
    }
    /**
     * Indicates whether the pattern may match descendants of the specified path
     */
    partialMatch(itemPath) {
      itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      if (pathHelper.dirname(itemPath) === itemPath) {
        return this.rootRegExp.test(itemPath);
      }
      return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    /**
     * Escapes glob patterns within a path
     */
    static globEscape(s) {
      return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
    }
    /**
     * Normalizes slashes and ensures absolute root
     */
    static fixupPattern(pattern, homedir) {
      assert_1.default(pattern, "pattern cannot be empty");
      const literalSegments = new internal_path_1.Path(pattern).segments.map((x) => Pattern.getLiteral(x));
      assert_1.default(literalSegments.every((x, i) => (x !== "." || i === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
      assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
      pattern = pathHelper.normalizeSeparators(pattern);
      if (pattern === "." || pattern.startsWith(`.${path2.sep}`)) {
        pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
      } else if (pattern === "~" || pattern.startsWith(`~${path2.sep}`)) {
        homedir = homedir || os.homedir();
        assert_1.default(homedir, "Unable to determine HOME directory");
        assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
        pattern = Pattern.globEscape(homedir) + pattern.substr(1);
      } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
        if (pattern.length > 2 && !root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(2);
      } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        if (!root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(1);
      } else {
        pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
      }
      return pathHelper.normalizeSeparators(pattern);
    }
    /**
     * Attempts to unescape a pattern segment to create a literal path segment.
     * Otherwise returns empty string.
     */
    static getLiteral(segment) {
      let literal = "";
      for (let i = 0; i < segment.length; i++) {
        const c = segment[i];
        if (c === "\\" && !IS_WINDOWS && i + 1 < segment.length) {
          literal += segment[++i];
          continue;
        } else if (c === "*" || c === "?") {
          return "";
        } else if (c === "[" && i + 1 < segment.length) {
          let set = "";
          let closed = -1;
          for (let i2 = i + 1; i2 < segment.length; i2++) {
            const c2 = segment[i2];
            if (c2 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
              set += segment[++i2];
              continue;
            } else if (c2 === "]") {
              closed = i2;
              break;
            } else {
              set += c2;
            }
          }
          if (closed >= 0) {
            if (set.length > 1) {
              return "";
            }
            if (set) {
              literal += set;
              i = closed;
              continue;
            }
          }
        }
        literal += c;
      }
      return literal;
    }
    /**
     * Escapes regexp special characters
     * https://javascript.info/regexp-escaping
     */
    static regExpEscape(s) {
      return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  }
  internalPattern.Pattern = Pattern;
  return internalPattern;
}
var internalSearchState = {};
var hasRequiredInternalSearchState;
function requireInternalSearchState() {
  if (hasRequiredInternalSearchState) return internalSearchState;
  hasRequiredInternalSearchState = 1;
  Object.defineProperty(internalSearchState, "__esModule", { value: true });
  internalSearchState.SearchState = void 0;
  class SearchState {
    constructor(path2, level) {
      this.path = path2;
      this.level = level;
    }
  }
  internalSearchState.SearchState = SearchState;
  return internalSearchState;
}
var hasRequiredInternalGlobber;
function requireInternalGlobber() {
  if (hasRequiredInternalGlobber) return internalGlobber;
  hasRequiredInternalGlobber = 1;
  var __createBinding2 = internalGlobber && internalGlobber.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = internalGlobber && internalGlobber.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = internalGlobber && internalGlobber.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = internalGlobber && internalGlobber.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues2 = internalGlobber && internalGlobber.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await2 = internalGlobber && internalGlobber.__await || function(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  };
  var __asyncGenerator2 = internalGlobber && internalGlobber.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n]) i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(internalGlobber, "__esModule", { value: true });
  internalGlobber.DefaultGlobber = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const fs = __importStar2(require$$1$2);
  const globOptionsHelper = __importStar2(/* @__PURE__ */ requireInternalGlobOptionsHelper());
  const path2 = __importStar2(require$$1$7);
  const patternHelper = __importStar2(/* @__PURE__ */ requireInternalPatternHelper());
  const internal_match_kind_1 = /* @__PURE__ */ requireInternalMatchKind();
  const internal_pattern_1 = /* @__PURE__ */ requireInternalPattern();
  const internal_search_state_1 = /* @__PURE__ */ requireInternalSearchState();
  const IS_WINDOWS = process.platform === "win32";
  class DefaultGlobber {
    constructor(options2) {
      this.patterns = [];
      this.searchPaths = [];
      this.options = globOptionsHelper.getOptions(options2);
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var e_1, _a;
      return __awaiter2(this, void 0, void 0, function* () {
        const result = [];
        try {
          for (var _b = __asyncValues2(this.globGenerator()), _c; _c = yield _b.next(), !_c.done; ) {
            const itemPath = _c.value;
            result.push(itemPath);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return result;
      });
    }
    globGenerator() {
      return __asyncGenerator2(this, arguments, function* globGenerator_1() {
        const options2 = globOptionsHelper.getOptions(this.options);
        const patterns = [];
        for (const pattern of this.patterns) {
          patterns.push(pattern);
          if (options2.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
            patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
          }
        }
        const stack = [];
        for (const searchPath of patternHelper.getSearchPaths(patterns)) {
          core2.debug(`Search path '${searchPath}'`);
          try {
            yield __await2(fs.promises.lstat(searchPath));
          } catch (err) {
            if (err.code === "ENOENT") {
              continue;
            }
            throw err;
          }
          stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
        }
        const traversalChain = [];
        while (stack.length) {
          const item = stack.pop();
          const match = patternHelper.match(patterns, item.path);
          const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
          if (!match && !partialMatch) {
            continue;
          }
          const stats = yield __await2(
            DefaultGlobber.stat(item, options2, traversalChain)
            // Broken symlink, or symlink cycle detected, or no longer exists
          );
          if (!stats) {
            continue;
          }
          if (stats.isDirectory()) {
            if (match & internal_match_kind_1.MatchKind.Directory) {
              yield yield __await2(item.path);
            } else if (!partialMatch) {
              continue;
            }
            const childLevel = item.level + 1;
            const childItems = (yield __await2(fs.promises.readdir(item.path))).map((x) => new internal_search_state_1.SearchState(path2.join(item.path, x), childLevel));
            stack.push(...childItems.reverse());
          } else if (match & internal_match_kind_1.MatchKind.File) {
            yield yield __await2(item.path);
          }
        }
      });
    }
    /**
     * Constructs a DefaultGlobber
     */
    static create(patterns, options2) {
      return __awaiter2(this, void 0, void 0, function* () {
        const result = new DefaultGlobber(options2);
        if (IS_WINDOWS) {
          patterns = patterns.replace(/\r\n/g, "\n");
          patterns = patterns.replace(/\r/g, "\n");
        }
        const lines = patterns.split("\n").map((x) => x.trim());
        for (const line of lines) {
          if (!line || line.startsWith("#")) {
            continue;
          } else {
            result.patterns.push(new internal_pattern_1.Pattern(line));
          }
        }
        result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
        return result;
      });
    }
    static stat(item, options2, traversalChain) {
      return __awaiter2(this, void 0, void 0, function* () {
        let stats;
        if (options2.followSymbolicLinks) {
          try {
            stats = yield fs.promises.stat(item.path);
          } catch (err) {
            if (err.code === "ENOENT") {
              if (options2.omitBrokenSymbolicLinks) {
                core2.debug(`Broken symlink '${item.path}'`);
                return void 0;
              }
              throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
            }
            throw err;
          }
        } else {
          stats = yield fs.promises.lstat(item.path);
        }
        if (stats.isDirectory() && options2.followSymbolicLinks) {
          const realPath = yield fs.promises.realpath(item.path);
          while (traversalChain.length >= item.level) {
            traversalChain.pop();
          }
          if (traversalChain.some((x) => x === realPath)) {
            core2.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
            return void 0;
          }
          traversalChain.push(realPath);
        }
        return stats;
      });
    }
  }
  internalGlobber.DefaultGlobber = DefaultGlobber;
  return internalGlobber;
}
var hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob;
  hasRequiredGlob = 1;
  var __awaiter2 = glob && glob.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(glob, "__esModule", { value: true });
  glob.create = void 0;
  const internal_globber_1 = /* @__PURE__ */ requireInternalGlobber();
  function create(patterns, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield internal_globber_1.DefaultGlobber.create(patterns, options2);
    });
  }
  glob.create = create;
  return glob;
}
var semver = { exports: {} };
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver.exports;
  hasRequiredSemver = 1;
  (function(module, exports) {
    exports = module.exports = SemVer;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src2 = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src2[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src2[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src2[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src2[t.MAINVERSION] = "(" + src2[t.NUMERICIDENTIFIER] + ")\\.(" + src2[t.NUMERICIDENTIFIER] + ")\\.(" + src2[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src2[t.MAINVERSIONLOOSE] = "(" + src2[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src2[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src2[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src2[t.PRERELEASEIDENTIFIER] = "(?:" + src2[t.NUMERICIDENTIFIER] + "|" + src2[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src2[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src2[t.NUMERICIDENTIFIERLOOSE] + "|" + src2[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src2[t.PRERELEASE] = "(?:-(" + src2[t.PRERELEASEIDENTIFIER] + "(?:\\." + src2[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src2[t.PRERELEASELOOSE] = "(?:-?(" + src2[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src2[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src2[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src2[t.BUILD] = "(?:\\+(" + src2[t.BUILDIDENTIFIER] + "(?:\\." + src2[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src2[t.FULLPLAIN] = "v?" + src2[t.MAINVERSION] + src2[t.PRERELEASE] + "?" + src2[t.BUILD] + "?";
    src2[t.FULL] = "^" + src2[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src2[t.LOOSEPLAIN] = "[v=\\s]*" + src2[t.MAINVERSIONLOOSE] + src2[t.PRERELEASELOOSE] + "?" + src2[t.BUILD] + "?";
    tok("LOOSE");
    src2[t.LOOSE] = "^" + src2[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src2[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src2[t.XRANGEIDENTIFIERLOOSE] = src2[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src2[t.XRANGEIDENTIFIER] = src2[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src2[t.XRANGEPLAIN] = "[v=\\s]*(" + src2[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src2[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src2[t.XRANGEIDENTIFIER] + ")(?:" + src2[t.PRERELEASE] + ")?" + src2[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src2[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src2[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src2[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src2[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src2[t.PRERELEASELOOSE] + ")?" + src2[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src2[t.XRANGE] = "^" + src2[t.GTLT] + "\\s*" + src2[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src2[t.XRANGELOOSE] = "^" + src2[t.GTLT] + "\\s*" + src2[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src2[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src2[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src2[t.COERCE]), "g");
    tok("LONETILDE");
    src2[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src2[t.TILDETRIM] = "(\\s*)" + src2[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src2[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src2[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src2[t.TILDE] = "^" + src2[t.LONETILDE] + src2[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src2[t.TILDELOOSE] = "^" + src2[t.LONETILDE] + src2[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src2[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src2[t.CARETTRIM] = "(\\s*)" + src2[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src2[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src2[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src2[t.CARET] = "^" + src2[t.LONECARET] + src2[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src2[t.CARETLOOSE] = "^" + src2[t.LONECARET] + src2[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src2[t.COMPARATORLOOSE] = "^" + src2[t.GTLT] + "\\s*(" + src2[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src2[t.COMPARATOR] = "^" + src2[t.GTLT] + "\\s*(" + src2[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src2[t.COMPARATORTRIM] = "(\\s*)" + src2[t.GTLT] + "\\s*(" + src2[t.LOOSEPLAIN] + "|" + src2[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src2[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src2[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src2[t.HYPHENRANGE] = "^\\s*(" + src2[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src2[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src2[t.HYPHENRANGELOOSE] = "^\\s*(" + src2[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src2[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src2[t.STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug2(i, src2[i]);
      if (!re[i]) {
        re[i] = new RegExp(src2[i]);
        safeRe[i] = new RegExp(makeSafeRe(src2[i]));
      }
    }
    exports.parse = parse2;
    function parse2(version2, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r = options2.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options2);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version2, options2) {
      var v = parse2(version2, options2);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version2, options2) {
      var s = parse2(version2.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version2, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options2.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options2);
      }
      debug2("SemVer", version2, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m = version2.trim().match(options2.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range2(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range2(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range2;
    function Range2(range, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range instanceof Range2) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range2(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        return new Range2(range.value, options2);
      }
      if (!(this instanceof Range2)) {
        return new Range2(range, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range2.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range2.prototype.toString = function() {
      return this.range;
    };
    Range2.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug2("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range2.prototype.intersects = function(range, options2) {
      if (!(range instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options2) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options2) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options2) {
      return new Range2(range, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug2("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug2("caret", comp);
      comp = replaceTildes(comp, options2);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug2("xrange", comp);
      comp = replaceStars(comp, options2);
      debug2("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug2("caret", comp, options2);
      var r = options2.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug2("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug2("replaceStars", comp, options2);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range2.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version2, options2) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug2(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version2, range, options2) {
      try {
        range = new Range2(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range2(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options2) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range2(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range2(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options2) {
      try {
        return new Range2(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version2, range, options2) {
      return outside(version2, range, "<", options2);
    }
    exports.gtr = gtr;
    function gtr(version2, range, options2) {
      return outside(version2, range, ">", options2);
    }
    exports.outside = outside;
    function outside(version2, range, hilo, options2) {
      version2 = new SemVer(version2, options2);
      range = new Range2(range, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version2, options2) {
      var parsed = parse2(version2, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range2(r1, options2);
      r2 = new Range2(r2, options2);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version2, options2) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options2 = options2 || {};
      var match = null;
      if (!options2.rtl) {
        match = version2.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options2);
    }
  })(semver, semver.exports);
  return semver.exports;
}
var constants$5 = {};
var hasRequiredConstants$5;
function requireConstants$5() {
  if (hasRequiredConstants$5) return constants$5;
  hasRequiredConstants$5 = 1;
  Object.defineProperty(constants$5, "__esModule", { value: true });
  constants$5.CacheFileSizeLimit = constants$5.ManifestFilename = constants$5.TarFilename = constants$5.SystemTarPathOnWindows = constants$5.GnuTarPathOnWindows = constants$5.SocketTimeout = constants$5.DefaultRetryDelay = constants$5.DefaultRetryAttempts = constants$5.ArchiveToolType = constants$5.CompressionMethod = constants$5.CacheFilename = void 0;
  var CacheFilename;
  (function(CacheFilename2) {
    CacheFilename2["Gzip"] = "cache.tgz";
    CacheFilename2["Zstd"] = "cache.tzst";
  })(CacheFilename || (constants$5.CacheFilename = CacheFilename = {}));
  var CompressionMethod;
  (function(CompressionMethod2) {
    CompressionMethod2["Gzip"] = "gzip";
    CompressionMethod2["ZstdWithoutLong"] = "zstd-without-long";
    CompressionMethod2["Zstd"] = "zstd";
  })(CompressionMethod || (constants$5.CompressionMethod = CompressionMethod = {}));
  var ArchiveToolType;
  (function(ArchiveToolType2) {
    ArchiveToolType2["GNU"] = "gnu";
    ArchiveToolType2["BSD"] = "bsd";
  })(ArchiveToolType || (constants$5.ArchiveToolType = ArchiveToolType = {}));
  constants$5.DefaultRetryAttempts = 2;
  constants$5.DefaultRetryDelay = 5e3;
  constants$5.SocketTimeout = 5e3;
  constants$5.GnuTarPathOnWindows = `${process.env["PROGRAMFILES"]}\\Git\\usr\\bin\\tar.exe`;
  constants$5.SystemTarPathOnWindows = `${process.env["SYSTEMDRIVE"]}\\Windows\\System32\\tar.exe`;
  constants$5.TarFilename = "cache.tar";
  constants$5.ManifestFilename = "manifest.txt";
  constants$5.CacheFileSizeLimit = 10 * Math.pow(1024, 3);
  return constants$5;
}
var hasRequiredCacheUtils;
function requireCacheUtils() {
  if (hasRequiredCacheUtils) return cacheUtils;
  hasRequiredCacheUtils = 1;
  var __createBinding2 = cacheUtils && cacheUtils.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = cacheUtils && cacheUtils.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = cacheUtils && cacheUtils.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = cacheUtils && cacheUtils.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues2 = cacheUtils && cacheUtils.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  Object.defineProperty(cacheUtils, "__esModule", { value: true });
  cacheUtils.getRuntimeToken = cacheUtils.getCacheVersion = cacheUtils.assertDefined = cacheUtils.getGnuTarPathOnWindows = cacheUtils.getCacheFileName = cacheUtils.getCompressionMethod = cacheUtils.unlinkFile = cacheUtils.resolvePaths = cacheUtils.getArchiveFileSizeInBytes = cacheUtils.createTempDirectory = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const exec2 = __importStar2(/* @__PURE__ */ requireExec());
  const glob2 = __importStar2(/* @__PURE__ */ requireGlob());
  const io2 = __importStar2(/* @__PURE__ */ requireIo$1());
  const crypto = __importStar2(require$$0$4);
  const fs = __importStar2(require$$1$2);
  const path2 = __importStar2(require$$1$7);
  const semver2 = __importStar2(/* @__PURE__ */ requireSemver());
  const util2 = __importStar2(require$$0$5);
  const constants_1 = /* @__PURE__ */ requireConstants$5();
  const versionSalt = "1.0";
  function createTempDirectory() {
    return __awaiter2(this, void 0, void 0, function* () {
      const IS_WINDOWS = process.platform === "win32";
      let tempDirectory = process.env["RUNNER_TEMP"] || "";
      if (!tempDirectory) {
        let baseLocation;
        if (IS_WINDOWS) {
          baseLocation = process.env["USERPROFILE"] || "C:\\";
        } else {
          if (process.platform === "darwin") {
            baseLocation = "/Users";
          } else {
            baseLocation = "/home";
          }
        }
        tempDirectory = path2.join(baseLocation, "actions", "temp");
      }
      const dest = path2.join(tempDirectory, crypto.randomUUID());
      yield io2.mkdirP(dest);
      return dest;
    });
  }
  cacheUtils.createTempDirectory = createTempDirectory;
  function getArchiveFileSizeInBytes(filePath) {
    return fs.statSync(filePath).size;
  }
  cacheUtils.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
  function resolvePaths(patterns) {
    var _a, e_1, _b, _c;
    var _d;
    return __awaiter2(this, void 0, void 0, function* () {
      const paths = [];
      const workspace = (_d = process.env["GITHUB_WORKSPACE"]) !== null && _d !== void 0 ? _d : process.cwd();
      const globber = yield glob2.create(patterns.join("\n"), {
        implicitDescendants: false
      });
      try {
        for (var _e = true, _f = __asyncValues2(globber.globGenerator()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {
          _c = _g.value;
          _e = false;
          const file2 = _c;
          const relativeFile = path2.relative(workspace, file2).replace(new RegExp(`\\${path2.sep}`, "g"), "/");
          core2.debug(`Matched: ${relativeFile}`);
          if (relativeFile === "") {
            paths.push(".");
          } else {
            paths.push(`${relativeFile}`);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return paths;
    });
  }
  cacheUtils.resolvePaths = resolvePaths;
  function unlinkFile(filePath) {
    return __awaiter2(this, void 0, void 0, function* () {
      return util2.promisify(fs.unlink)(filePath);
    });
  }
  cacheUtils.unlinkFile = unlinkFile;
  function getVersion(app, additionalArgs = []) {
    return __awaiter2(this, void 0, void 0, function* () {
      let versionOutput = "";
      additionalArgs.push("--version");
      core2.debug(`Checking ${app} ${additionalArgs.join(" ")}`);
      try {
        yield exec2.exec(`${app}`, additionalArgs, {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
      } catch (err) {
        core2.debug(err.message);
      }
      versionOutput = versionOutput.trim();
      core2.debug(versionOutput);
      return versionOutput;
    });
  }
  function getCompressionMethod() {
    return __awaiter2(this, void 0, void 0, function* () {
      const versionOutput = yield getVersion("zstd", ["--quiet"]);
      const version2 = semver2.clean(versionOutput);
      core2.debug(`zstd version: ${version2}`);
      if (versionOutput === "") {
        return constants_1.CompressionMethod.Gzip;
      } else {
        return constants_1.CompressionMethod.ZstdWithoutLong;
      }
    });
  }
  cacheUtils.getCompressionMethod = getCompressionMethod;
  function getCacheFileName(compressionMethod) {
    return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
  }
  cacheUtils.getCacheFileName = getCacheFileName;
  function getGnuTarPathOnWindows() {
    return __awaiter2(this, void 0, void 0, function* () {
      if (fs.existsSync(constants_1.GnuTarPathOnWindows)) {
        return constants_1.GnuTarPathOnWindows;
      }
      const versionOutput = yield getVersion("tar");
      return versionOutput.toLowerCase().includes("gnu tar") ? io2.which("tar") : "";
    });
  }
  cacheUtils.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
  function assertDefined(name, value) {
    if (value === void 0) {
      throw Error(`Expected ${name} but value was undefiend`);
    }
    return value;
  }
  cacheUtils.assertDefined = assertDefined;
  function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
    const components = paths.slice();
    if (compressionMethod) {
      components.push(compressionMethod);
    }
    if (process.platform === "win32" && !enableCrossOsArchive) {
      components.push("windows-only");
    }
    components.push(versionSalt);
    return crypto.createHash("sha256").update(components.join("|")).digest("hex");
  }
  cacheUtils.getCacheVersion = getCacheVersion;
  function getRuntimeToken() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"];
    if (!token) {
      throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
    }
    return token;
  }
  cacheUtils.getRuntimeToken = getRuntimeToken;
  return cacheUtils;
}
var cacheHttpClient = {};
var uploadUtils = {};
var commonjs$c = {};
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$5(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body2.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};
var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver2, state2, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver2 !== state2 || !f : !state2.has(receiver2)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state2.get(receiver2);
}
function __classPrivateFieldSet(receiver2, state2, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver2 !== state2 || !f : !state2.has(receiver2)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state2.set(receiver2, value), value;
}
function __classPrivateFieldIn(state2, receiver2) {
  if (receiver2 === null || typeof receiver2 !== "object" && typeof receiver2 !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver2 === state2 : state2.has(receiver2);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path2, preserveJsx) {
  if (typeof path2 === "string" && /^\.\.?\//.test(path2)) {
    return path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path2;
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter: __awaiter$5,
  __generator,
  __createBinding,
  __exportStar,
  __values: __values$1,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter: __awaiter$5,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values: __values$1,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var commonjs$b = {};
var pipeline$2 = {};
var commonjs$a = {};
var AbortError$2 = {};
var hasRequiredAbortError$1;
function requireAbortError$1() {
  if (hasRequiredAbortError$1) return AbortError$2;
  hasRequiredAbortError$1 = 1;
  Object.defineProperty(AbortError$2, "__esModule", { value: true });
  AbortError$2.AbortError = void 0;
  class AbortError2 extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  AbortError$2.AbortError = AbortError2;
  return AbortError$2;
}
var logger$1 = {};
var debug = {};
var log$5 = {};
var hasRequiredLog$5;
function requireLog$5() {
  if (hasRequiredLog$5) return log$5;
  hasRequiredLog$5 = 1;
  Object.defineProperty(log$5, "__esModule", { value: true });
  log$5.log = log2;
  const tslib_1 = require$$0$2;
  const node_os_1 = require$$1__default;
  const node_util_1 = tslib_1.__importDefault(require$$1$5);
  const node_process_1 = tslib_1.__importDefault(require$$2$3);
  function log2(message, ...args) {
    node_process_1.default.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
  }
  return log$5;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  Object.defineProperty(debug, "__esModule", { value: true });
  const log_js_1 = /* @__PURE__ */ requireLog$5();
  const debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
  let enabledString;
  let enabledNamespaces = [];
  let skippedNamespaces = [];
  const debuggers = [];
  if (debugEnvVariable) {
    enable(debugEnvVariable);
  }
  const debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
  }, {
    enable,
    enabled,
    disable,
    log: log_js_1.log
  });
  function enable(namespaces) {
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    const namespaceList = namespaces.split(",").map((ns) => ns.trim());
    for (const ns of namespaceList) {
      if (ns.startsWith("-")) {
        skippedNamespaces.push(ns.substring(1));
      } else {
        enabledNamespaces.push(ns);
      }
    }
    for (const instance of debuggers) {
      instance.enabled = enabled(instance.namespace);
    }
  }
  function enabled(namespace) {
    if (namespace.endsWith("*")) {
      return true;
    }
    for (const skipped of skippedNamespaces) {
      if (namespaceMatches(namespace, skipped)) {
        return false;
      }
    }
    for (const enabledNamespace of enabledNamespaces) {
      if (namespaceMatches(namespace, enabledNamespace)) {
        return true;
      }
    }
    return false;
  }
  function namespaceMatches(namespace, patternToMatch) {
    if (patternToMatch.indexOf("*") === -1) {
      return namespace === patternToMatch;
    }
    let pattern = patternToMatch;
    if (patternToMatch.indexOf("**") !== -1) {
      const patternParts = [];
      let lastCharacter = "";
      for (const character of patternToMatch) {
        if (character === "*" && lastCharacter === "*") {
          continue;
        } else {
          lastCharacter = character;
          patternParts.push(character);
        }
      }
      pattern = patternParts.join("");
    }
    let namespaceIndex = 0;
    let patternIndex = 0;
    const patternLength = pattern.length;
    const namespaceLength = namespace.length;
    let lastWildcard = -1;
    let lastWildcardNamespace = -1;
    while (namespaceIndex < namespaceLength && patternIndex < patternLength) {
      if (pattern[patternIndex] === "*") {
        lastWildcard = patternIndex;
        patternIndex++;
        if (patternIndex === patternLength) {
          return true;
        }
        while (namespace[namespaceIndex] !== pattern[patternIndex]) {
          namespaceIndex++;
          if (namespaceIndex === namespaceLength) {
            return false;
          }
        }
        lastWildcardNamespace = namespaceIndex;
        namespaceIndex++;
        patternIndex++;
        continue;
      } else if (pattern[patternIndex] === namespace[namespaceIndex]) {
        patternIndex++;
        namespaceIndex++;
      } else if (lastWildcard >= 0) {
        patternIndex = lastWildcard + 1;
        namespaceIndex = lastWildcardNamespace + 1;
        if (namespaceIndex === namespaceLength) {
          return false;
        }
        while (namespace[namespaceIndex] !== pattern[patternIndex]) {
          namespaceIndex++;
          if (namespaceIndex === namespaceLength) {
            return false;
          }
        }
        lastWildcardNamespace = namespaceIndex;
        namespaceIndex++;
        patternIndex++;
        continue;
      } else {
        return false;
      }
    }
    const namespaceDone = namespaceIndex === namespace.length;
    const patternDone = patternIndex === pattern.length;
    const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
    return namespaceDone && (patternDone || trailingWildCard);
  }
  function disable() {
    const result = enabledString || "";
    enable("");
    return result;
  }
  function createDebugger(namespace) {
    const newDebugger = Object.assign(debug2, {
      enabled: enabled(namespace),
      destroy,
      log: debugObj.log,
      namespace,
      extend
    });
    function debug2(...args) {
      if (!newDebugger.enabled) {
        return;
      }
      if (args.length > 0) {
        args[0] = `${namespace} ${args[0]}`;
      }
      newDebugger.log(...args);
    }
    debuggers.push(newDebugger);
    return newDebugger;
  }
  function destroy() {
    const index = debuggers.indexOf(this);
    if (index >= 0) {
      debuggers.splice(index, 1);
      return true;
    }
    return false;
  }
  function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
  }
  debug.default = debugObj;
  return debug;
}
var hasRequiredLogger$1;
function requireLogger$1() {
  if (hasRequiredLogger$1) return logger$1;
  hasRequiredLogger$1 = 1;
  Object.defineProperty(logger$1, "__esModule", { value: true });
  logger$1.TypeSpecRuntimeLogger = void 0;
  logger$1.createLoggerContext = createLoggerContext;
  logger$1.setLogLevel = setLogLevel;
  logger$1.getLogLevel = getLogLevel;
  logger$1.createClientLogger = createClientLogger;
  const tslib_1 = require$$0$2;
  const debug_js_1 = tslib_1.__importDefault(/* @__PURE__ */ requireDebug());
  const TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
  const levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function isTypeSpecRuntimeLogLevel(level) {
    return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
  }
  function createLoggerContext(options2) {
    const registeredLoggers = /* @__PURE__ */ new Set();
    const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options2.logLevelEnvVarName] || void 0;
    let logLevel;
    const clientLogger = (0, debug_js_1.default)(options2.namespace);
    clientLogger.log = (...args) => {
      debug_js_1.default.log(...args);
    };
    function contextSetLogLevel(level) {
      if (level && !isTypeSpecRuntimeLogLevel(level)) {
        throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
      }
      logLevel = level;
      const enabledNamespaces = [];
      for (const logger2 of registeredLoggers) {
        if (shouldEnable(logger2)) {
          enabledNamespaces.push(logger2.namespace);
        }
      }
      debug_js_1.default.enable(enabledNamespaces.join(","));
    }
    if (logLevelFromEnv) {
      if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
        contextSetLogLevel(logLevelFromEnv);
      } else {
        console.error(`${options2.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
      }
    }
    function shouldEnable(logger2) {
      return Boolean(logLevel && levelMap[logger2.level] <= levelMap[logLevel]);
    }
    function createLogger(parent, level) {
      const logger2 = Object.assign(parent.extend(level), {
        level
      });
      patchLogMethod(parent, logger2);
      if (shouldEnable(logger2)) {
        const enabledNamespaces = debug_js_1.default.disable();
        debug_js_1.default.enable(enabledNamespaces + "," + logger2.namespace);
      }
      registeredLoggers.add(logger2);
      return logger2;
    }
    function contextGetLogLevel() {
      return logLevel;
    }
    function contextCreateClientLogger(namespace) {
      const clientRootLogger = clientLogger.extend(namespace);
      patchLogMethod(clientLogger, clientRootLogger);
      return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
      };
    }
    return {
      setLogLevel: contextSetLogLevel,
      getLogLevel: contextGetLogLevel,
      createClientLogger: contextCreateClientLogger,
      logger: clientLogger
    };
  }
  const context = createLoggerContext({
    logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
    namespace: "typeSpecRuntime"
  });
  logger$1.TypeSpecRuntimeLogger = context.logger;
  function setLogLevel(logLevel) {
    context.setLogLevel(logLevel);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
  return logger$1;
}
var httpHeaders$1 = {};
var hasRequiredHttpHeaders$1;
function requireHttpHeaders$1() {
  if (hasRequiredHttpHeaders$1) return httpHeaders$1;
  hasRequiredHttpHeaders$1 = 1;
  Object.defineProperty(httpHeaders$1, "__esModule", { value: true });
  httpHeaders$1.createHttpHeaders = createHttpHeaders;
  function normalizeName(name) {
    return name.toLowerCase();
  }
  function* headerIterator(map) {
    for (const entry of map.values()) {
      yield [entry.name, entry.value];
    }
  }
  class HttpHeadersImpl {
    _headersMap;
    constructor(rawHeaders) {
      this._headersMap = /* @__PURE__ */ new Map();
      if (rawHeaders) {
        for (const headerName of Object.keys(rawHeaders)) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param name - The name of the header to set. This value is case-insensitive.
     * @param value - The value of the header to set.
     */
    set(name, value) {
      this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param name - The name of the header. This value is case-insensitive.
     */
    get(name) {
      return this._headersMap.get(normalizeName(name))?.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     * @param name - The name of the header to set. This value is case-insensitive.
     */
    has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    /**
     * Remove the header with the provided headerName.
     * @param name - The name of the header to remove.
     */
    delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */
    toJSON(options2 = {}) {
      const result = {};
      if (options2.preserveCase) {
        for (const entry of this._headersMap.values()) {
          result[entry.name] = entry.value;
        }
      } else {
        for (const [normalizedName, entry] of this._headersMap) {
          result[normalizedName] = entry.value;
        }
      }
      return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    /**
     * Iterate over tuples of header [name, value] pairs.
     */
    [Symbol.iterator]() {
      return headerIterator(this._headersMap);
    }
  }
  function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
  }
  return httpHeaders$1;
}
var schemes = {};
var hasRequiredSchemes;
function requireSchemes() {
  if (hasRequiredSchemes) return schemes;
  hasRequiredSchemes = 1;
  Object.defineProperty(schemes, "__esModule", { value: true });
  return schemes;
}
var oauth2Flows = {};
var hasRequiredOauth2Flows;
function requireOauth2Flows() {
  if (hasRequiredOauth2Flows) return oauth2Flows;
  hasRequiredOauth2Flows = 1;
  Object.defineProperty(oauth2Flows, "__esModule", { value: true });
  return oauth2Flows;
}
var pipelineRequest$1 = {};
var uuidUtils = {};
var hasRequiredUuidUtils;
function requireUuidUtils() {
  if (hasRequiredUuidUtils) return uuidUtils;
  hasRequiredUuidUtils = 1;
  Object.defineProperty(uuidUtils, "__esModule", { value: true });
  uuidUtils.randomUUID = randomUUID;
  const node_crypto_1 = require$$0$e;
  const uuidFunction = typeof globalThis?.crypto?.randomUUID === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : node_crypto_1.randomUUID;
  function randomUUID() {
    return uuidFunction();
  }
  return uuidUtils;
}
var hasRequiredPipelineRequest$1;
function requirePipelineRequest$1() {
  if (hasRequiredPipelineRequest$1) return pipelineRequest$1;
  hasRequiredPipelineRequest$1 = 1;
  Object.defineProperty(pipelineRequest$1, "__esModule", { value: true });
  pipelineRequest$1.createPipelineRequest = createPipelineRequest;
  const httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
  const uuidUtils_js_1 = /* @__PURE__ */ requireUuidUtils();
  class PipelineRequestImpl {
    url;
    method;
    headers;
    timeout;
    withCredentials;
    body;
    multipartBody;
    formData;
    streamResponseStatusCodes;
    enableBrowserStreams;
    proxySettings;
    disableKeepAlive;
    abortSignal;
    requestId;
    allowInsecureConnection;
    onUploadProgress;
    onDownloadProgress;
    requestOverrides;
    authSchemes;
    constructor(options2) {
      this.url = options2.url;
      this.body = options2.body;
      this.headers = options2.headers ?? (0, httpHeaders_js_1.createHttpHeaders)();
      this.method = options2.method ?? "GET";
      this.timeout = options2.timeout ?? 0;
      this.multipartBody = options2.multipartBody;
      this.formData = options2.formData;
      this.disableKeepAlive = options2.disableKeepAlive ?? false;
      this.proxySettings = options2.proxySettings;
      this.streamResponseStatusCodes = options2.streamResponseStatusCodes;
      this.withCredentials = options2.withCredentials ?? false;
      this.abortSignal = options2.abortSignal;
      this.onUploadProgress = options2.onUploadProgress;
      this.onDownloadProgress = options2.onDownloadProgress;
      this.requestId = options2.requestId || (0, uuidUtils_js_1.randomUUID)();
      this.allowInsecureConnection = options2.allowInsecureConnection ?? false;
      this.enableBrowserStreams = options2.enableBrowserStreams ?? false;
      this.requestOverrides = options2.requestOverrides;
      this.authSchemes = options2.authSchemes;
    }
  }
  function createPipelineRequest(options2) {
    return new PipelineRequestImpl(options2);
  }
  return pipelineRequest$1;
}
var pipeline$1 = {};
var hasRequiredPipeline$3;
function requirePipeline$3() {
  if (hasRequiredPipeline$3) return pipeline$1;
  hasRequiredPipeline$3 = 1;
  Object.defineProperty(pipeline$1, "__esModule", { value: true });
  pipeline$1.createEmptyPipeline = createEmptyPipeline;
  const ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
  class HttpPipeline {
    _policies = [];
    _orderedPolicies;
    constructor(policies) {
      this._policies = policies?.slice(0) ?? [];
      this._orderedPolicies = void 0;
    }
    addPolicy(policy, options2 = {}) {
      if (options2.phase && options2.afterPhase) {
        throw new Error("Policies inside a phase cannot specify afterPhase.");
      }
      if (options2.phase && !ValidPhaseNames.has(options2.phase)) {
        throw new Error(`Invalid phase name: ${options2.phase}`);
      }
      if (options2.afterPhase && !ValidPhaseNames.has(options2.afterPhase)) {
        throw new Error(`Invalid afterPhase name: ${options2.afterPhase}`);
      }
      this._policies.push({
        policy,
        options: options2
      });
      this._orderedPolicies = void 0;
    }
    removePolicy(options2) {
      const removedPolicies = [];
      this._policies = this._policies.filter((policyDescriptor) => {
        if (options2.name && policyDescriptor.policy.name === options2.name || options2.phase && policyDescriptor.options.phase === options2.phase) {
          removedPolicies.push(policyDescriptor.policy);
          return false;
        } else {
          return true;
        }
      });
      this._orderedPolicies = void 0;
      return removedPolicies;
    }
    sendRequest(httpClient, request2) {
      const policies = this.getOrderedPolicies();
      const pipeline2 = policies.reduceRight((next, policy) => {
        return (req) => {
          return policy.sendRequest(req, next);
        };
      }, (req) => httpClient.sendRequest(req));
      return pipeline2(request2);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies) {
        this._orderedPolicies = this.orderPolicies();
      }
      return this._orderedPolicies;
    }
    clone() {
      return new HttpPipeline(this._policies);
    }
    static create() {
      return new HttpPipeline();
    }
    orderPolicies() {
      const result = [];
      const policyMap = /* @__PURE__ */ new Map();
      function createPhase(name) {
        return {
          name,
          policies: /* @__PURE__ */ new Set(),
          hasRun: false,
          hasAfterPolicies: false
        };
      }
      const serializePhase = createPhase("Serialize");
      const noPhase = createPhase("None");
      const deserializePhase = createPhase("Deserialize");
      const retryPhase = createPhase("Retry");
      const signPhase = createPhase("Sign");
      const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      function getPhase(phase) {
        if (phase === "Retry") {
          return retryPhase;
        } else if (phase === "Serialize") {
          return serializePhase;
        } else if (phase === "Deserialize") {
          return deserializePhase;
        } else if (phase === "Sign") {
          return signPhase;
        } else {
          return noPhase;
        }
      }
      for (const descriptor of this._policies) {
        const policy = descriptor.policy;
        const options2 = descriptor.options;
        const policyName = policy.name;
        if (policyMap.has(policyName)) {
          throw new Error("Duplicate policy names not allowed in pipeline");
        }
        const node2 = {
          policy,
          dependsOn: /* @__PURE__ */ new Set(),
          dependants: /* @__PURE__ */ new Set()
        };
        if (options2.afterPhase) {
          node2.afterPhase = getPhase(options2.afterPhase);
          node2.afterPhase.hasAfterPolicies = true;
        }
        policyMap.set(policyName, node2);
        const phase = getPhase(options2.phase);
        phase.policies.add(node2);
      }
      for (const descriptor of this._policies) {
        const { policy, options: options2 } = descriptor;
        const policyName = policy.name;
        const node2 = policyMap.get(policyName);
        if (!node2) {
          throw new Error(`Missing node for policy ${policyName}`);
        }
        if (options2.afterPolicies) {
          for (const afterPolicyName of options2.afterPolicies) {
            const afterNode = policyMap.get(afterPolicyName);
            if (afterNode) {
              node2.dependsOn.add(afterNode);
              afterNode.dependants.add(node2);
            }
          }
        }
        if (options2.beforePolicies) {
          for (const beforePolicyName of options2.beforePolicies) {
            const beforeNode = policyMap.get(beforePolicyName);
            if (beforeNode) {
              beforeNode.dependsOn.add(node2);
              node2.dependants.add(beforeNode);
            }
          }
        }
      }
      function walkPhase(phase) {
        phase.hasRun = true;
        for (const node2 of phase.policies) {
          if (node2.afterPhase && (!node2.afterPhase.hasRun || node2.afterPhase.policies.size)) {
            continue;
          }
          if (node2.dependsOn.size === 0) {
            result.push(node2.policy);
            for (const dependant of node2.dependants) {
              dependant.dependsOn.delete(node2);
            }
            policyMap.delete(node2.policy.name);
            phase.policies.delete(node2);
          }
        }
      }
      function walkPhases() {
        for (const phase of orderedPhases) {
          walkPhase(phase);
          if (phase.policies.size > 0 && phase !== noPhase) {
            if (!noPhase.hasRun) {
              walkPhase(noPhase);
            }
            return;
          }
          if (phase.hasAfterPolicies) {
            walkPhase(noPhase);
          }
        }
      }
      let iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        const initialResultLength = result.length;
        walkPhases();
        if (result.length <= initialResultLength && iteration > 1) {
          throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
      }
      return result;
    }
  }
  function createEmptyPipeline() {
    return HttpPipeline.create();
  }
  return pipeline$1;
}
var restError$2 = {};
var error$1 = {};
var object = {};
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  Object.defineProperty(object, "__esModule", { value: true });
  object.isObject = isObject;
  function isObject(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
  return object;
}
var hasRequiredError$1;
function requireError$1() {
  if (hasRequiredError$1) return error$1;
  hasRequiredError$1 = 1;
  Object.defineProperty(error$1, "__esModule", { value: true });
  error$1.isError = isError;
  const object_js_1 = /* @__PURE__ */ requireObject();
  function isError(e) {
    if ((0, object_js_1.isObject)(e)) {
      const hasName = typeof e.name === "string";
      const hasMessage = typeof e.message === "string";
      return hasName && hasMessage;
    }
    return false;
  }
  return error$1;
}
var inspect = {};
var hasRequiredInspect;
function requireInspect() {
  if (hasRequiredInspect) return inspect;
  hasRequiredInspect = 1;
  Object.defineProperty(inspect, "__esModule", { value: true });
  inspect.custom = void 0;
  const node_util_1 = require$$1$5;
  inspect.custom = node_util_1.inspect.custom;
  return inspect;
}
var sanitizer = {};
var hasRequiredSanitizer;
function requireSanitizer() {
  if (hasRequiredSanitizer) return sanitizer;
  hasRequiredSanitizer = 1;
  Object.defineProperty(sanitizer, "__esModule", { value: true });
  sanitizer.Sanitizer = void 0;
  const object_js_1 = /* @__PURE__ */ requireObject();
  const RedactedString = "REDACTED";
  const defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
  ];
  const defaultAllowedQueryParameters = ["api-version"];
  class Sanitizer {
    allowedHeaderNames;
    allowedQueryParameters;
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
      allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
      allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
      this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
      this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    /**
     * Sanitizes an object for logging.
     * @param obj - The object to sanitize
     * @returns - The sanitized object as a string
     */
    sanitize(obj) {
      const seen = /* @__PURE__ */ new Set();
      return JSON.stringify(obj, (key, value) => {
        if (value instanceof Error) {
          return {
            ...value,
            name: value.name,
            message: value.message
          };
        }
        if (key === "headers") {
          return this.sanitizeHeaders(value);
        } else if (key === "url") {
          return this.sanitizeUrl(value);
        } else if (key === "query") {
          return this.sanitizeQuery(value);
        } else if (key === "body") {
          return void 0;
        } else if (key === "response") {
          return void 0;
        } else if (key === "operationSpec") {
          return void 0;
        } else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      }, 2);
    }
    /**
     * Sanitizes a URL for logging.
     * @param value - The URL to sanitize
     * @returns - The sanitized URL as a string
     */
    sanitizeUrl(value) {
      if (typeof value !== "string" || value === null || value === "") {
        return value;
      }
      const url = new URL(value);
      if (!url.search) {
        return value;
      }
      for (const [key] of url.searchParams) {
        if (!this.allowedQueryParameters.has(key.toLowerCase())) {
          url.searchParams.set(key, RedactedString);
        }
      }
      return url.toString();
    }
    sanitizeHeaders(obj) {
      const sanitized = {};
      for (const key of Object.keys(obj)) {
        if (this.allowedHeaderNames.has(key.toLowerCase())) {
          sanitized[key] = obj[key];
        } else {
          sanitized[key] = RedactedString;
        }
      }
      return sanitized;
    }
    sanitizeQuery(value) {
      if (typeof value !== "object" || value === null) {
        return value;
      }
      const sanitized = {};
      for (const k of Object.keys(value)) {
        if (this.allowedQueryParameters.has(k.toLowerCase())) {
          sanitized[k] = value[k];
        } else {
          sanitized[k] = RedactedString;
        }
      }
      return sanitized;
    }
  }
  sanitizer.Sanitizer = Sanitizer;
  return sanitizer;
}
var hasRequiredRestError$2;
function requireRestError$2() {
  if (hasRequiredRestError$2) return restError$2;
  hasRequiredRestError$2 = 1;
  Object.defineProperty(restError$2, "__esModule", { value: true });
  restError$2.RestError = void 0;
  restError$2.isRestError = isRestError;
  const error_js_1 = /* @__PURE__ */ requireError$1();
  const inspect_js_1 = /* @__PURE__ */ requireInspect();
  const sanitizer_js_1 = /* @__PURE__ */ requireSanitizer();
  const errorSanitizer = new sanitizer_js_1.Sanitizer();
  class RestError extends Error {
    /**
     * Something went wrong when making the request.
     * This means the actual request failed for some reason,
     * such as a DNS issue or the connection being lost.
     */
    static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    /**
     * This means that parsing the response from the server failed.
     * It may have been malformed.
     */
    static PARSE_ERROR = "PARSE_ERROR";
    /**
     * The code of the error itself (use statics on RestError if possible.)
     */
    code;
    /**
     * The HTTP status code of the request (if applicable.)
     */
    statusCode;
    /**
     * The request that was made.
     * This property is non-enumerable.
     */
    request;
    /**
     * The response received (if any.)
     * This property is non-enumerable.
     */
    response;
    /**
     * Bonus property set by the throw site.
     */
    details;
    constructor(message, options2 = {}) {
      super(message);
      this.name = "RestError";
      this.code = options2.code;
      this.statusCode = options2.statusCode;
      Object.defineProperty(this, "request", { value: options2.request, enumerable: false });
      Object.defineProperty(this, "response", { value: options2.response, enumerable: false });
      const agent2 = this.request?.agent ? {
        maxFreeSockets: this.request.agent.maxFreeSockets,
        maxSockets: this.request.agent.maxSockets
      } : void 0;
      Object.defineProperty(this, inspect_js_1.custom, {
        value: () => {
          return `RestError: ${this.message} 
 ${errorSanitizer.sanitize({
            ...this,
            request: { ...this.request, agent: agent2 },
            response: this.response
          })}`;
        },
        enumerable: false
      });
      Object.setPrototypeOf(this, RestError.prototype);
    }
  }
  restError$2.RestError = RestError;
  function isRestError(e) {
    if (e instanceof RestError) {
      return true;
    }
    return (0, error_js_1.isError)(e) && e.name === "RestError";
  }
  return restError$2;
}
var bytesEncoding = {};
var hasRequiredBytesEncoding;
function requireBytesEncoding() {
  if (hasRequiredBytesEncoding) return bytesEncoding;
  hasRequiredBytesEncoding = 1;
  Object.defineProperty(bytesEncoding, "__esModule", { value: true });
  bytesEncoding.uint8ArrayToString = uint8ArrayToString;
  bytesEncoding.stringToUint8Array = stringToUint8Array;
  function uint8ArrayToString(bytes, format) {
    return Buffer.from(bytes).toString(format);
  }
  function stringToUint8Array(value, format) {
    return Buffer.from(value, format);
  }
  return bytesEncoding;
}
var defaultHttpClient$1 = {};
var nodeHttpClient = {};
var log$4 = {};
var hasRequiredLog$4;
function requireLog$4() {
  if (hasRequiredLog$4) return log$4;
  hasRequiredLog$4 = 1;
  Object.defineProperty(log$4, "__esModule", { value: true });
  log$4.logger = void 0;
  const logger_js_1 = /* @__PURE__ */ requireLogger$1();
  log$4.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
  return log$4;
}
var hasRequiredNodeHttpClient;
function requireNodeHttpClient() {
  if (hasRequiredNodeHttpClient) return nodeHttpClient;
  hasRequiredNodeHttpClient = 1;
  Object.defineProperty(nodeHttpClient, "__esModule", { value: true });
  nodeHttpClient.getBodyLength = getBodyLength;
  nodeHttpClient.createNodeHttpClient = createNodeHttpClient;
  const tslib_1 = require$$0$2;
  const node_http_1 = tslib_1.__importDefault(require$$1$8);
  const node_https_1 = tslib_1.__importDefault(require$$2$4);
  const node_zlib_1 = tslib_1.__importDefault(require$$3$1);
  const node_stream_1 = require$$0$b;
  const AbortError_js_1 = /* @__PURE__ */ requireAbortError$1();
  const httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
  const restError_js_1 = /* @__PURE__ */ requireRestError$2();
  const log_js_1 = /* @__PURE__ */ requireLog$4();
  const sanitizer_js_1 = /* @__PURE__ */ requireSanitizer();
  const DEFAULT_TLS_SETTINGS = {};
  function isReadableStream(body2) {
    return body2 && typeof body2.pipe === "function";
  }
  function isStreamComplete(stream) {
    if (stream.readable === false) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const handler = () => {
        resolve();
        stream.removeListener("close", handler);
        stream.removeListener("end", handler);
        stream.removeListener("error", handler);
      };
      stream.on("close", handler);
      stream.on("end", handler);
      stream.on("error", handler);
    });
  }
  function isArrayBuffer(body2) {
    return body2 && typeof body2.byteLength === "number";
  }
  class ReportTransform extends node_stream_1.Transform {
    loadedBytes = 0;
    progressCallback;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    _transform(chunk, _encoding, callback) {
      this.push(chunk);
      this.loadedBytes += chunk.length;
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes });
        callback();
      } catch (e) {
        callback(e);
      }
    }
    constructor(progressCallback) {
      super();
      this.progressCallback = progressCallback;
    }
  }
  class NodeHttpClient {
    cachedHttpAgent;
    cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
    /**
     * Makes a request over an underlying transport layer and returns the response.
     * @param request - The request to be made.
     */
    async sendRequest(request2) {
      const abortController = new AbortController();
      let abortListener;
      if (request2.abortSignal) {
        if (request2.abortSignal.aborted) {
          throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
        }
        abortListener = (event) => {
          if (event.type === "abort") {
            abortController.abort();
          }
        };
        request2.abortSignal.addEventListener("abort", abortListener);
      }
      let timeoutId;
      if (request2.timeout > 0) {
        timeoutId = setTimeout(() => {
          const sanitizer2 = new sanitizer_js_1.Sanitizer();
          log_js_1.logger.info(`request to '${sanitizer2.sanitizeUrl(request2.url)}' timed out. canceling...`);
          abortController.abort();
        }, request2.timeout);
      }
      const acceptEncoding = request2.headers.get("Accept-Encoding");
      const shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
      let body2 = typeof request2.body === "function" ? request2.body() : request2.body;
      if (body2 && !request2.headers.has("Content-Length")) {
        const bodyLength = getBodyLength(body2);
        if (bodyLength !== null) {
          request2.headers.set("Content-Length", bodyLength);
        }
      }
      let responseStream;
      try {
        if (body2 && request2.onUploadProgress) {
          const onUploadProgress = request2.onUploadProgress;
          const uploadReportStream = new ReportTransform(onUploadProgress);
          uploadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in upload progress", e);
          });
          if (isReadableStream(body2)) {
            body2.pipe(uploadReportStream);
          } else {
            uploadReportStream.end(body2);
          }
          body2 = uploadReportStream;
        }
        const res = await this.makeRequest(request2, abortController, body2);
        if (timeoutId !== void 0) {
          clearTimeout(timeoutId);
        }
        const headers2 = getResponseHeaders(res);
        const status = res.statusCode ?? 0;
        const response2 = {
          status,
          headers: headers2,
          request: request2
        };
        if (request2.method === "HEAD") {
          res.resume();
          return response2;
        }
        responseStream = shouldDecompress ? getDecodedResponseStream(res, headers2) : res;
        const onDownloadProgress = request2.onDownloadProgress;
        if (onDownloadProgress) {
          const downloadReportStream = new ReportTransform(onDownloadProgress);
          downloadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in download progress", e);
          });
          responseStream.pipe(downloadReportStream);
          responseStream = downloadReportStream;
        }
        if (
          // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
          request2.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request2.streamResponseStatusCodes?.has(response2.status)
        ) {
          response2.readableStreamBody = responseStream;
        } else {
          response2.bodyAsText = await streamToText(responseStream);
        }
        return response2;
      } finally {
        if (request2.abortSignal && abortListener) {
          let uploadStreamDone = Promise.resolve();
          if (isReadableStream(body2)) {
            uploadStreamDone = isStreamComplete(body2);
          }
          let downloadStreamDone = Promise.resolve();
          if (isReadableStream(responseStream)) {
            downloadStreamDone = isStreamComplete(responseStream);
          }
          Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
            if (abortListener) {
              request2.abortSignal?.removeEventListener("abort", abortListener);
            }
          }).catch((e) => {
            log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
          });
        }
      }
    }
    makeRequest(request2, abortController, body2) {
      const url = new URL(request2.url);
      const isInsecure = url.protocol !== "https:";
      if (isInsecure && !request2.allowInsecureConnection) {
        throw new Error(`Cannot connect to ${request2.url} while allowInsecureConnection is false.`);
      }
      const agent2 = request2.agent ?? this.getOrCreateAgent(request2, isInsecure);
      const options2 = {
        agent: agent2,
        hostname: url.hostname,
        path: `${url.pathname}${url.search}`,
        port: url.port,
        method: request2.method,
        headers: request2.headers.toJSON({ preserveCase: true }),
        ...request2.requestOverrides
      };
      return new Promise((resolve, reject) => {
        const req = isInsecure ? node_http_1.default.request(options2, resolve) : node_https_1.default.request(options2, resolve);
        req.once("error", (err) => {
          reject(new restError_js_1.RestError(err.message, { code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR, request: request2 }));
        });
        abortController.signal.addEventListener("abort", () => {
          const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
          req.destroy(abortError);
          reject(abortError);
        });
        if (body2 && isReadableStream(body2)) {
          body2.pipe(req);
        } else if (body2) {
          if (typeof body2 === "string" || Buffer.isBuffer(body2)) {
            req.end(body2);
          } else if (isArrayBuffer(body2)) {
            req.end(ArrayBuffer.isView(body2) ? Buffer.from(body2.buffer) : Buffer.from(body2));
          } else {
            log_js_1.logger.error("Unrecognized body type", body2);
            reject(new restError_js_1.RestError("Unrecognized body type"));
          }
        } else {
          req.end();
        }
      });
    }
    getOrCreateAgent(request2, isInsecure) {
      const disableKeepAlive = request2.disableKeepAlive;
      if (isInsecure) {
        if (disableKeepAlive) {
          return node_http_1.default.globalAgent;
        }
        if (!this.cachedHttpAgent) {
          this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: true });
        }
        return this.cachedHttpAgent;
      } else {
        if (disableKeepAlive && !request2.tlsSettings) {
          return node_https_1.default.globalAgent;
        }
        const tlsSettings = request2.tlsSettings ?? DEFAULT_TLS_SETTINGS;
        let agent2 = this.cachedHttpsAgents.get(tlsSettings);
        if (agent2 && agent2.options.keepAlive === !disableKeepAlive) {
          return agent2;
        }
        log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
        agent2 = new node_https_1.default.Agent({
          // keepAlive is true if disableKeepAlive is false.
          keepAlive: !disableKeepAlive,
          // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
          ...tlsSettings
        });
        this.cachedHttpsAgents.set(tlsSettings, agent2);
        return agent2;
      }
    }
  }
  function getResponseHeaders(res) {
    const headers2 = (0, httpHeaders_js_1.createHttpHeaders)();
    for (const header of Object.keys(res.headers)) {
      const value = res.headers[header];
      if (Array.isArray(value)) {
        if (value.length > 0) {
          headers2.set(header, value[0]);
        }
      } else if (value) {
        headers2.set(header, value);
      }
    }
    return headers2;
  }
  function getDecodedResponseStream(stream, headers2) {
    const contentEncoding = headers2.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      const unzip = node_zlib_1.default.createGunzip();
      stream.pipe(unzip);
      return unzip;
    } else if (contentEncoding === "deflate") {
      const inflate = node_zlib_1.default.createInflate();
      stream.pipe(inflate);
      return inflate;
    }
    return stream;
  }
  function streamToText(stream) {
    return new Promise((resolve, reject) => {
      const buffer = [];
      stream.on("data", (chunk) => {
        if (Buffer.isBuffer(chunk)) {
          buffer.push(chunk);
        } else {
          buffer.push(Buffer.from(chunk));
        }
      });
      stream.on("end", () => {
        resolve(Buffer.concat(buffer).toString("utf8"));
      });
      stream.on("error", (e) => {
        if (e && e?.name === "AbortError") {
          reject(e);
        } else {
          reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
            code: restError_js_1.RestError.PARSE_ERROR
          }));
        }
      });
    });
  }
  function getBodyLength(body2) {
    if (!body2) {
      return 0;
    } else if (Buffer.isBuffer(body2)) {
      return body2.length;
    } else if (isReadableStream(body2)) {
      return null;
    } else if (isArrayBuffer(body2)) {
      return body2.byteLength;
    } else if (typeof body2 === "string") {
      return Buffer.from(body2).length;
    } else {
      return null;
    }
  }
  function createNodeHttpClient() {
    return new NodeHttpClient();
  }
  return nodeHttpClient;
}
var hasRequiredDefaultHttpClient$1;
function requireDefaultHttpClient$1() {
  if (hasRequiredDefaultHttpClient$1) return defaultHttpClient$1;
  hasRequiredDefaultHttpClient$1 = 1;
  Object.defineProperty(defaultHttpClient$1, "__esModule", { value: true });
  defaultHttpClient$1.createDefaultHttpClient = createDefaultHttpClient;
  const nodeHttpClient_js_1 = /* @__PURE__ */ requireNodeHttpClient();
  function createDefaultHttpClient() {
    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
  }
  return defaultHttpClient$1;
}
var getClient = {};
var clientHelpers = {};
var createPipelineFromOptions$1 = {};
var logPolicy$1 = {};
var hasRequiredLogPolicy$1;
function requireLogPolicy$1() {
  if (hasRequiredLogPolicy$1) return logPolicy$1;
  hasRequiredLogPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logPolicyName = void 0;
    exports.logPolicy = logPolicy2;
    const log_js_1 = /* @__PURE__ */ requireLog$4();
    const sanitizer_js_1 = /* @__PURE__ */ requireSanitizer();
    exports.logPolicyName = "logPolicy";
    function logPolicy2(options2 = {}) {
      const logger2 = options2.logger ?? log_js_1.logger.info;
      const sanitizer2 = new sanitizer_js_1.Sanitizer({
        additionalAllowedHeaderNames: options2.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options2.additionalAllowedQueryParameters
      });
      return {
        name: exports.logPolicyName,
        async sendRequest(request2, next) {
          if (!logger2.enabled) {
            return next(request2);
          }
          logger2(`Request: ${sanitizer2.sanitize(request2)}`);
          const response2 = await next(request2);
          logger2(`Response status code: ${response2.status}`);
          logger2(`Headers: ${sanitizer2.sanitize(response2.headers)}`);
          return response2;
        }
      };
    }
  })(logPolicy$1);
  return logPolicy$1;
}
var redirectPolicy$1 = {};
var hasRequiredRedirectPolicy$1;
function requireRedirectPolicy$1() {
  if (hasRequiredRedirectPolicy$1) return redirectPolicy$1;
  hasRequiredRedirectPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.redirectPolicyName = void 0;
    exports.redirectPolicy = redirectPolicy2;
    exports.redirectPolicyName = "redirectPolicy";
    const allowedRedirect = ["GET", "HEAD"];
    function redirectPolicy2(options2 = {}) {
      const { maxRetries = 20 } = options2;
      return {
        name: exports.redirectPolicyName,
        async sendRequest(request2, next) {
          const response2 = await next(request2);
          return handleRedirect(next, response2, maxRetries);
        }
      };
    }
    async function handleRedirect(next, response2, maxRetries, currentRetries = 0) {
      const { request: request2, status, headers: headers2 } = response2;
      const locationHeader = headers2.get("location");
      if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request2.method) || status === 302 && allowedRedirect.includes(request2.method) || status === 303 && request2.method === "POST" || status === 307) && currentRetries < maxRetries) {
        const url = new URL(locationHeader, request2.url);
        request2.url = url.toString();
        if (status === 303) {
          request2.method = "GET";
          request2.headers.delete("Content-Length");
          delete request2.body;
        }
        request2.headers.delete("Authorization");
        const res = await next(request2);
        return handleRedirect(next, res, maxRetries, currentRetries + 1);
      }
      return response2;
    }
  })(redirectPolicy$1);
  return redirectPolicy$1;
}
var userAgentPolicy$1 = {};
var userAgent$2 = {};
var userAgentPlatform$1 = {};
var hasRequiredUserAgentPlatform$1;
function requireUserAgentPlatform$1() {
  if (hasRequiredUserAgentPlatform$1) return userAgentPlatform$1;
  hasRequiredUserAgentPlatform$1 = 1;
  Object.defineProperty(userAgentPlatform$1, "__esModule", { value: true });
  userAgentPlatform$1.getHeaderName = getHeaderName;
  userAgentPlatform$1.setPlatformSpecificData = setPlatformSpecificData;
  const tslib_1 = require$$0$2;
  const node_os_1 = tslib_1.__importDefault(require$$1__default);
  const node_process_1 = tslib_1.__importDefault(require$$2$3);
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (node_process_1.default && node_process_1.default.versions) {
      const versions = node_process_1.default.versions;
      if (versions.bun) {
        map.set("Bun", versions.bun);
      } else if (versions.deno) {
        map.set("Deno", versions.deno);
      } else if (versions.node) {
        map.set("Node", versions.node);
      }
    }
    map.set("OS", `(${node_os_1.default.arch()}-${node_os_1.default.type()}-${node_os_1.default.release()})`);
  }
  return userAgentPlatform$1;
}
var constants$4 = {};
var hasRequiredConstants$4;
function requireConstants$4() {
  if (hasRequiredConstants$4) return constants$4;
  hasRequiredConstants$4 = 1;
  Object.defineProperty(constants$4, "__esModule", { value: true });
  constants$4.DEFAULT_RETRY_POLICY_COUNT = constants$4.SDK_VERSION = void 0;
  constants$4.SDK_VERSION = "0.3.1";
  constants$4.DEFAULT_RETRY_POLICY_COUNT = 3;
  return constants$4;
}
var hasRequiredUserAgent$2;
function requireUserAgent$2() {
  if (hasRequiredUserAgent$2) return userAgent$2;
  hasRequiredUserAgent$2 = 1;
  Object.defineProperty(userAgent$2, "__esModule", { value: true });
  userAgent$2.getUserAgentHeaderName = getUserAgentHeaderName;
  userAgent$2.getUserAgentValue = getUserAgentValue;
  const userAgentPlatform_js_1 = /* @__PURE__ */ requireUserAgentPlatform$1();
  const constants_js_1 = /* @__PURE__ */ requireConstants$4();
  function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    const runtimeInfo = /* @__PURE__ */ new Map();
    runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
  return userAgent$2;
}
var hasRequiredUserAgentPolicy$1;
function requireUserAgentPolicy$1() {
  if (hasRequiredUserAgentPolicy$1) return userAgentPolicy$1;
  hasRequiredUserAgentPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.userAgentPolicyName = void 0;
    exports.userAgentPolicy = userAgentPolicy2;
    const userAgent_js_1 = /* @__PURE__ */ requireUserAgent$2();
    const UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
    exports.userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy2(options2 = {}) {
      const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options2.userAgentPrefix);
      return {
        name: exports.userAgentPolicyName,
        async sendRequest(request2, next) {
          if (!request2.headers.has(UserAgentHeaderName)) {
            request2.headers.set(UserAgentHeaderName, await userAgentValue);
          }
          return next(request2);
        }
      };
    }
  })(userAgentPolicy$1);
  return userAgentPolicy$1;
}
var decompressResponsePolicy$1 = {};
var hasRequiredDecompressResponsePolicy$1;
function requireDecompressResponsePolicy$1() {
  if (hasRequiredDecompressResponsePolicy$1) return decompressResponsePolicy$1;
  hasRequiredDecompressResponsePolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decompressResponsePolicyName = void 0;
    exports.decompressResponsePolicy = decompressResponsePolicy2;
    exports.decompressResponsePolicyName = "decompressResponsePolicy";
    function decompressResponsePolicy2() {
      return {
        name: exports.decompressResponsePolicyName,
        async sendRequest(request2, next) {
          if (request2.method !== "HEAD") {
            request2.headers.set("Accept-Encoding", "gzip,deflate");
          }
          return next(request2);
        }
      };
    }
  })(decompressResponsePolicy$1);
  return decompressResponsePolicy$1;
}
var defaultRetryPolicy$1 = {};
var exponentialRetryStrategy = {};
var delay$2 = {};
var random = {};
var hasRequiredRandom;
function requireRandom() {
  if (hasRequiredRandom) return random;
  hasRequiredRandom = 1;
  Object.defineProperty(random, "__esModule", { value: true });
  random.getRandomIntegerInclusive = getRandomIntegerInclusive;
  function getRandomIntegerInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
  }
  return random;
}
var hasRequiredDelay$1;
function requireDelay$1() {
  if (hasRequiredDelay$1) return delay$2;
  hasRequiredDelay$1 = 1;
  Object.defineProperty(delay$2, "__esModule", { value: true });
  delay$2.calculateRetryDelay = calculateRetryDelay;
  const random_js_1 = /* @__PURE__ */ requireRandom();
  function calculateRetryDelay(retryAttempt, config2) {
    const exponentialDelay = config2.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config2.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
  return delay$2;
}
var throttlingRetryStrategy = {};
var helpers$1 = {};
var hasRequiredHelpers$1;
function requireHelpers$1() {
  if (hasRequiredHelpers$1) return helpers$1;
  hasRequiredHelpers$1 = 1;
  Object.defineProperty(helpers$1, "__esModule", { value: true });
  helpers$1.delay = delay2;
  helpers$1.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
  const AbortError_js_1 = /* @__PURE__ */ requireAbortError$1();
  const StandardAbortMessage = "The operation was aborted.";
  function delay2(delayInMs, value, options2) {
    return new Promise((resolve, reject) => {
      let timer = void 0;
      let onAborted = void 0;
      const rejectOnAbort = () => {
        return reject(new AbortError_js_1.AbortError(options2?.abortErrorMsg ? options2?.abortErrorMsg : StandardAbortMessage));
      };
      const removeListeners = () => {
        if (options2?.abortSignal && onAborted) {
          options2.abortSignal.removeEventListener("abort", onAborted);
        }
      };
      onAborted = () => {
        if (timer) {
          clearTimeout(timer);
        }
        removeListeners();
        return rejectOnAbort();
      };
      if (options2?.abortSignal && options2.abortSignal.aborted) {
        return rejectOnAbort();
      }
      timer = setTimeout(() => {
        removeListeners();
        resolve(value);
      }, delayInMs);
      if (options2?.abortSignal) {
        options2.abortSignal.addEventListener("abort", onAborted);
      }
    });
  }
  function parseHeaderValueAsNumber(response2, headerName) {
    const value = response2.headers.get(headerName);
    if (!value)
      return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
      return;
    return valueAsNum;
  }
  return helpers$1;
}
var hasRequiredThrottlingRetryStrategy;
function requireThrottlingRetryStrategy() {
  if (hasRequiredThrottlingRetryStrategy) return throttlingRetryStrategy;
  hasRequiredThrottlingRetryStrategy = 1;
  Object.defineProperty(throttlingRetryStrategy, "__esModule", { value: true });
  throttlingRetryStrategy.isThrottlingRetryResponse = isThrottlingRetryResponse;
  throttlingRetryStrategy.throttlingRetryStrategy = throttlingRetryStrategy$1;
  const helpers_js_1 = /* @__PURE__ */ requireHelpers$1();
  const RetryAfterHeader = "Retry-After";
  const AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  function getRetryAfterInMs(response2) {
    if (!(response2 && [429, 503].includes(response2.status)))
      return void 0;
    try {
      for (const header of AllRetryAfterHeaders) {
        const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response2, header);
        if (retryAfterValue === 0 || retryAfterValue) {
          const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
          return retryAfterValue * multiplyingFactor;
        }
      }
      const retryAfterHeader = response2.headers.get(RetryAfterHeader);
      if (!retryAfterHeader)
        return;
      const date = Date.parse(retryAfterHeader);
      const diff = date - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
    } catch {
      return void 0;
    }
  }
  function isThrottlingRetryResponse(response2) {
    return Number.isFinite(getRetryAfterInMs(response2));
  }
  function throttlingRetryStrategy$1() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response: response2 }) {
        const retryAfterInMs = getRetryAfterInMs(response2);
        if (!Number.isFinite(retryAfterInMs)) {
          return { skipStrategy: true };
        }
        return {
          retryAfterInMs
        };
      }
    };
  }
  return throttlingRetryStrategy;
}
var hasRequiredExponentialRetryStrategy;
function requireExponentialRetryStrategy() {
  if (hasRequiredExponentialRetryStrategy) return exponentialRetryStrategy;
  hasRequiredExponentialRetryStrategy = 1;
  Object.defineProperty(exponentialRetryStrategy, "__esModule", { value: true });
  exponentialRetryStrategy.exponentialRetryStrategy = exponentialRetryStrategy$1;
  exponentialRetryStrategy.isExponentialRetryResponse = isExponentialRetryResponse;
  exponentialRetryStrategy.isSystemError = isSystemError;
  const delay_js_1 = /* @__PURE__ */ requireDelay$1();
  const throttlingRetryStrategy_js_1 = /* @__PURE__ */ requireThrottlingRetryStrategy();
  const DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
  const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
  function exponentialRetryStrategy$1(options2 = {}) {
    const retryInterval = options2.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = options2.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount, response: response2, responseError }) {
        const matchedSystemError = isSystemError(responseError);
        const ignoreSystemErrors = matchedSystemError && options2.ignoreSystemErrors;
        const isExponential = isExponentialRetryResponse(response2);
        const ignoreExponentialResponse = isExponential && options2.ignoreHttpStatusCodes;
        const unknownResponse = response2 && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response2) || !isExponential);
        if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
          return { skipStrategy: true };
        }
        if (responseError && !matchedSystemError && !isExponential) {
          return { errorToThrow: responseError };
        }
        return (0, delay_js_1.calculateRetryDelay)(retryCount, {
          retryDelayInMs: retryInterval,
          maxRetryDelayInMs: maxRetryInterval
        });
      }
    };
  }
  function isExponentialRetryResponse(response2) {
    return Boolean(response2 && response2.status !== void 0 && (response2.status >= 500 || response2.status === 408) && response2.status !== 501 && response2.status !== 505);
  }
  function isSystemError(err) {
    if (!err) {
      return false;
    }
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
  }
  return exponentialRetryStrategy;
}
var retryPolicy$1 = {};
var hasRequiredRetryPolicy$1;
function requireRetryPolicy$1() {
  if (hasRequiredRetryPolicy$1) return retryPolicy$1;
  hasRequiredRetryPolicy$1 = 1;
  Object.defineProperty(retryPolicy$1, "__esModule", { value: true });
  retryPolicy$1.retryPolicy = retryPolicy2;
  const helpers_js_1 = /* @__PURE__ */ requireHelpers$1();
  const AbortError_js_1 = /* @__PURE__ */ requireAbortError$1();
  const logger_js_1 = /* @__PURE__ */ requireLogger$1();
  const constants_js_1 = /* @__PURE__ */ requireConstants$4();
  const retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
  const retryPolicyName = "retryPolicy";
  function retryPolicy2(strategies, options2 = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    const logger2 = options2.logger || retryPolicyLogger;
    return {
      name: retryPolicyName,
      async sendRequest(request2, next) {
        let response2;
        let responseError;
        let retryCount = -1;
        retryRequest: while (true) {
          retryCount += 1;
          response2 = void 0;
          responseError = void 0;
          try {
            logger2.info(`Retry ${retryCount}: Attempting to send request`, request2.requestId);
            response2 = await next(request2);
            logger2.info(`Retry ${retryCount}: Received a response from request`, request2.requestId);
          } catch (e) {
            logger2.error(`Retry ${retryCount}: Received an error from request`, request2.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response2 = responseError.response;
          }
          if (request2.abortSignal?.aborted) {
            logger2.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError_js_1.AbortError();
            throw abortError;
          }
          if (retryCount >= (options2.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
            logger2.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response2) {
              return response2;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger2.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop: for (const strategy of strategies) {
            const strategyLogger = strategy.logger || logger2;
            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
            const modifiers = strategy.retry({
              retryCount,
              response: response2,
              responseError
            });
            if (modifiers.skipStrategy) {
              strategyLogger.info(`Retry ${retryCount}: Skipped.`);
              continue strategiesLoop;
            }
            const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
            if (errorToThrow) {
              strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
              throw errorToThrow;
            }
            if (retryAfterInMs || retryAfterInMs === 0) {
              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
              await (0, helpers_js_1.delay)(retryAfterInMs, void 0, { abortSignal: request2.abortSignal });
              continue retryRequest;
            }
            if (redirectTo) {
              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
              request2.url = redirectTo;
              continue retryRequest;
            }
          }
          if (responseError) {
            logger2.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response2) {
            logger2.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response2;
          }
        }
      }
    };
  }
  return retryPolicy$1;
}
var hasRequiredDefaultRetryPolicy$1;
function requireDefaultRetryPolicy$1() {
  if (hasRequiredDefaultRetryPolicy$1) return defaultRetryPolicy$1;
  hasRequiredDefaultRetryPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultRetryPolicyName = void 0;
    exports.defaultRetryPolicy = defaultRetryPolicy2;
    const exponentialRetryStrategy_js_1 = /* @__PURE__ */ requireExponentialRetryStrategy();
    const throttlingRetryStrategy_js_1 = /* @__PURE__ */ requireThrottlingRetryStrategy();
    const retryPolicy_js_1 = /* @__PURE__ */ requireRetryPolicy$1();
    const constants_js_1 = /* @__PURE__ */ requireConstants$4();
    exports.defaultRetryPolicyName = "defaultRetryPolicy";
    function defaultRetryPolicy2(options2 = {}) {
      return {
        name: exports.defaultRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options2)], {
          maxRetries: options2.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  })(defaultRetryPolicy$1);
  return defaultRetryPolicy$1;
}
var formDataPolicy$1 = {};
var checkEnvironment = {};
var hasRequiredCheckEnvironment;
function requireCheckEnvironment() {
  if (hasRequiredCheckEnvironment) return checkEnvironment;
  hasRequiredCheckEnvironment = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = void 0;
    exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    exports.isWebWorker = typeof self === "object" && typeof self?.importScripts === "function" && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name === "SharedWorkerGlobalScope");
    exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node);
    exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
    exports.isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
  })(checkEnvironment);
  return checkEnvironment;
}
var hasRequiredFormDataPolicy$1;
function requireFormDataPolicy$1() {
  if (hasRequiredFormDataPolicy$1) return formDataPolicy$1;
  hasRequiredFormDataPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formDataPolicyName = void 0;
    exports.formDataPolicy = formDataPolicy2;
    const bytesEncoding_js_1 = /* @__PURE__ */ requireBytesEncoding();
    const checkEnvironment_js_1 = /* @__PURE__ */ requireCheckEnvironment();
    const httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
    exports.formDataPolicyName = "formDataPolicy";
    function formDataToFormDataMap(formData) {
      const formDataMap = {};
      for (const [key, value] of formData.entries()) {
        formDataMap[key] ??= [];
        formDataMap[key].push(value);
      }
      return formDataMap;
    }
    function formDataPolicy2() {
      return {
        name: exports.formDataPolicyName,
        async sendRequest(request2, next) {
          if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request2.body instanceof FormData) {
            request2.formData = formDataToFormDataMap(request2.body);
            request2.body = void 0;
          }
          if (request2.formData) {
            const contentType = request2.headers.get("Content-Type");
            if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
              request2.body = wwwFormUrlEncode(request2.formData);
            } else {
              await prepareFormData(request2.formData, request2);
            }
            request2.formData = void 0;
          }
          return next(request2);
        }
      };
    }
    function wwwFormUrlEncode(formData) {
      const urlSearchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(formData)) {
        if (Array.isArray(value)) {
          for (const subValue of value) {
            urlSearchParams.append(key, subValue.toString());
          }
        } else {
          urlSearchParams.append(key, value.toString());
        }
      }
      return urlSearchParams.toString();
    }
    async function prepareFormData(formData, request2) {
      const contentType = request2.headers.get("Content-Type");
      if (contentType && !contentType.startsWith("multipart/form-data")) {
        return;
      }
      request2.headers.set("Content-Type", contentType ?? "multipart/form-data");
      const parts = [];
      for (const [fieldName, values] of Object.entries(formData)) {
        for (const value of Array.isArray(values) ? values : [values]) {
          if (typeof value === "string") {
            parts.push({
              headers: (0, httpHeaders_js_1.createHttpHeaders)({
                "Content-Disposition": `form-data; name="${fieldName}"`
              }),
              body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8")
            });
          } else if (value === void 0 || value === null || typeof value !== "object") {
            throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
          } else {
            const fileName = value.name || "blob";
            const headers2 = (0, httpHeaders_js_1.createHttpHeaders)();
            headers2.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
            headers2.set("Content-Type", value.type || "application/octet-stream");
            parts.push({
              headers: headers2,
              body: value
            });
          }
        }
      }
      request2.multipartBody = { parts };
    }
  })(formDataPolicy$1);
  return formDataPolicy$1;
}
var proxyPolicy$1 = {};
var dist$2 = {};
var src$2 = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = /* @__PURE__ */ requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = /* @__PURE__ */ requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$3;
  const tty = require$$1$9;
  const hasFlag2 = /* @__PURE__ */ requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$1$9;
    const util2 = require$$0$5;
    exports.init = init;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = /* @__PURE__ */ requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = /* @__PURE__ */ requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
var hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1) return src$2.exports;
  hasRequiredSrc$1 = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src$2.exports = /* @__PURE__ */ requireBrowser();
  } else {
    src$2.exports = /* @__PURE__ */ requireNode();
  }
  return src$2.exports;
}
var dist$1 = {};
var helpers = {};
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  var __createBinding2 = helpers && helpers.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = helpers && helpers.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = helpers && helpers.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.req = helpers.json = helpers.toBuffer = void 0;
  const http = __importStar2(require$$2);
  const https = __importStar2(require$$1$3);
  async function toBuffer(stream) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  helpers.toBuffer = toBuffer;
  async function json(stream) {
    const buf = await toBuffer(stream);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  helpers.json = json;
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
    const promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  }
  helpers.req = req;
  return helpers;
}
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2) return dist$1;
  hasRequiredDist$2 = 1;
  (function(exports) {
    var __createBinding2 = dist$1 && dist$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault2 = dist$1 && dist$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = dist$1 && dist$1.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = dist$1 && dist$1.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent = void 0;
    const net = __importStar2(require$$0$8);
    const http = __importStar2(require$$2);
    const https_1 = require$$1$3;
    __exportStar2(/* @__PURE__ */ requireHelpers(), exports);
    const INTERNAL = Symbol("AgentBaseInternalState");
    class Agent extends http.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options2) {
        if (options2) {
          if (typeof options2.secureEndpoint === "boolean") {
            return options2.secureEndpoint;
          }
          if (typeof options2.protocol === "string") {
            return options2.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options2) {
        const secureEndpoint = this.isSecureEndpoint(options2);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options2);
        }
        return super.getName(options2);
      }
      createSocket(req, options2, cb) {
        const connectOpts = {
          ...options2,
          secureEndpoint: this.isSecureEndpoint(options2)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options2, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    }
    exports.Agent = Agent;
  })(dist$1);
  return dist$1;
}
var parseProxyResponse = {};
var hasRequiredParseProxyResponse;
function requireParseProxyResponse() {
  if (hasRequiredParseProxyResponse) return parseProxyResponse;
  hasRequiredParseProxyResponse = 1;
  var __importDefault2 = parseProxyResponse && parseProxyResponse.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(parseProxyResponse, "__esModule", { value: true });
  parseProxyResponse.parseProxyResponse = void 0;
  const debug_1 = __importDefault2(/* @__PURE__ */ requireSrc$1());
  const debug2 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse$1(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug2("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug2("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug2("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers2 = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers2[key];
          if (typeof current === "string") {
            headers2[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers2[key] = value;
          }
        }
        debug2("got proxy server response: %o %o", firstLine, headers2);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers: headers2
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  parseProxyResponse.parseProxyResponse = parseProxyResponse$1;
  return parseProxyResponse;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$2;
  hasRequiredDist$1 = 1;
  var __createBinding2 = dist$2 && dist$2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = dist$2 && dist$2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = dist$2 && dist$2.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = dist$2 && dist$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(dist$2, "__esModule", { value: true });
  dist$2.HttpsProxyAgent = void 0;
  const net = __importStar2(require$$0$8);
  const tls = __importStar2(require$$1$4);
  const assert_1 = __importDefault2(require$$0$7);
  const debug_1 = __importDefault2(/* @__PURE__ */ requireSrc$1());
  const agent_base_1 = /* @__PURE__ */ requireDist$2();
  const url_1 = require$$5$1;
  const parse_proxy_response_1 = /* @__PURE__ */ requireParseProxyResponse();
  const debug2 = (0, debug_1.default)("https-proxy-agent");
  const setServernameFromNonIpHost = (options2) => {
    if (options2.servername === void 0 && options2.host && !net.isIP(options2.host)) {
      return {
        ...options2,
        servername: options2.host
      };
    }
    return options2;
  };
  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy2, opts) {
      super(opts);
      this.options = { path: void 0 };
      this.proxy = typeof proxy2 === "string" ? new url_1.URL(proxy2) : proxy2;
      this.proxyHeaders = opts?.headers ?? {};
      debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        // Attempt to negotiate http/1.1 for proxy servers that support http/2
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    async connect(req, opts) {
      const { proxy: proxy2 } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy2.protocol === "https:") {
        debug2("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
      } else {
        debug2("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers2 = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy2.username || proxy2.password) {
        const auth2 = `${decodeURIComponent(proxy2.username)}:${decodeURIComponent(proxy2.password)}`;
        headers2["Proxy-Authorization"] = `Basic ${Buffer.from(auth2).toString("base64")}`;
      }
      headers2.Host = `${host}:${opts.port}`;
      if (!headers2["Proxy-Connection"]) {
        headers2["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers2)) {
        payload += `${name}: ${headers2[name]}\r
`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      const { connect: connect2, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect2);
      this.emit("proxyConnect", connect2, req);
      if (connect2.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug2("Upgrading socket connection to TLS");
          return tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug2("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  dist$2.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  return dist$2;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  var __createBinding2 = dist && dist.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = dist && dist.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = dist && dist.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = dist && dist.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.HttpProxyAgent = void 0;
  const net = __importStar2(require$$0$8);
  const tls = __importStar2(require$$1$4);
  const debug_1 = __importDefault2(/* @__PURE__ */ requireSrc$1());
  const events_1 = require$$0$6;
  const agent_base_1 = /* @__PURE__ */ requireDist$2();
  const url_1 = require$$5$1;
  const debug2 = (0, debug_1.default)("http-proxy-agent");
  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy2, opts) {
      super(opts);
      this.proxy = typeof proxy2 === "string" ? new url_1.URL(proxy2) : proxy2;
      this.proxyHeaders = opts?.headers ?? {};
      debug2("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null;
      this.setRequestProps(req, opts);
      super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      const { proxy: proxy2 } = this;
      const protocol = opts.secureEndpoint ? "https:" : "http:";
      const hostname = req.getHeader("host") || "localhost";
      const base = `${protocol}//${hostname}`;
      const url = new url_1.URL(req.path, base);
      if (opts.port !== 80) {
        url.port = String(opts.port);
      }
      req.path = String(url);
      const headers2 = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy2.username || proxy2.password) {
        const auth2 = `${decodeURIComponent(proxy2.username)}:${decodeURIComponent(proxy2.password)}`;
        headers2["Proxy-Authorization"] = `Basic ${Buffer.from(auth2).toString("base64")}`;
      }
      if (!headers2["Proxy-Connection"]) {
        headers2["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers2)) {
        const value = headers2[name];
        if (value) {
          req.setHeader(name, value);
        }
      }
    }
    async connect(req, opts) {
      req._header = null;
      if (!req.path.includes("://")) {
        this.setRequestProps(req, opts);
      }
      let first;
      let endOfHeaders;
      debug2("Regenerating stored HTTP header string for request");
      req._implicitHeader();
      if (req.outputData && req.outputData.length > 0) {
        debug2("Patching connection write() output buffer with updated header");
        first = req.outputData[0].data;
        endOfHeaders = first.indexOf("\r\n\r\n") + 4;
        req.outputData[0].data = req._header + first.substring(endOfHeaders);
        debug2("Output buffer: %o", req.outputData[0].data);
      }
      let socket;
      if (this.proxy.protocol === "https:") {
        debug2("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(this.connectOpts);
      } else {
        debug2("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      await (0, events_1.once)(socket, "connect");
      return socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  dist.HttpProxyAgent = HttpProxyAgent;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  return dist;
}
var hasRequiredProxyPolicy$1;
function requireProxyPolicy$1() {
  if (hasRequiredProxyPolicy$1) return proxyPolicy$1;
  hasRequiredProxyPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalNoProxyList = exports.proxyPolicyName = void 0;
    exports.loadNoProxy = loadNoProxy;
    exports.getDefaultProxySettings = getDefaultProxySettings;
    exports.proxyPolicy = proxyPolicy2;
    const https_proxy_agent_1 = /* @__PURE__ */ requireDist$1();
    const http_proxy_agent_1 = /* @__PURE__ */ requireDist();
    const log_js_1 = /* @__PURE__ */ requireLog$4();
    const HTTPS_PROXY = "HTTPS_PROXY";
    const HTTP_PROXY = "HTTP_PROXY";
    const ALL_PROXY = "ALL_PROXY";
    const NO_PROXY = "NO_PROXY";
    exports.proxyPolicyName = "proxyPolicy";
    exports.globalNoProxyList = [];
    let noProxyListLoaded = false;
    const globalBypassedMap = /* @__PURE__ */ new Map();
    function getEnvironmentValue(name) {
      if (process.env[name]) {
        return process.env[name];
      } else if (process.env[name.toLowerCase()]) {
        return process.env[name.toLowerCase()];
      }
      return void 0;
    }
    function loadEnvironmentProxyValue() {
      if (!process) {
        return void 0;
      }
      const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
      const allProxy = getEnvironmentValue(ALL_PROXY);
      const httpProxy = getEnvironmentValue(HTTP_PROXY);
      return httpsProxy || allProxy || httpProxy;
    }
    function isBypassed(uri, noProxyList, bypassedMap) {
      if (noProxyList.length === 0) {
        return false;
      }
      const host = new URL(uri).hostname;
      if (bypassedMap?.has(host)) {
        return bypassedMap.get(host);
      }
      let isBypassedFlag = false;
      for (const pattern of noProxyList) {
        if (pattern[0] === ".") {
          if (host.endsWith(pattern)) {
            isBypassedFlag = true;
          } else {
            if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
              isBypassedFlag = true;
            }
          }
        } else {
          if (host === pattern) {
            isBypassedFlag = true;
          }
        }
      }
      bypassedMap?.set(host, isBypassedFlag);
      return isBypassedFlag;
    }
    function loadNoProxy() {
      const noProxy = getEnvironmentValue(NO_PROXY);
      noProxyListLoaded = true;
      if (noProxy) {
        return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
      }
      return [];
    }
    function getDefaultProxySettings(proxyUrl) {
      if (!proxyUrl) {
        proxyUrl = loadEnvironmentProxyValue();
        if (!proxyUrl) {
          return void 0;
        }
      }
      const parsedUrl = new URL(proxyUrl);
      const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
      return {
        host: schema + parsedUrl.hostname,
        port: Number.parseInt(parsedUrl.port || "80"),
        username: parsedUrl.username,
        password: parsedUrl.password
      };
    }
    function getDefaultProxySettingsInternal() {
      const envProxy = loadEnvironmentProxyValue();
      return envProxy ? new URL(envProxy) : void 0;
    }
    function getUrlFromProxySettings(settings) {
      let parsedProxyUrl;
      try {
        parsedProxyUrl = new URL(settings.host);
      } catch {
        throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
      }
      parsedProxyUrl.port = String(settings.port);
      if (settings.username) {
        parsedProxyUrl.username = settings.username;
      }
      if (settings.password) {
        parsedProxyUrl.password = settings.password;
      }
      return parsedProxyUrl;
    }
    function setProxyAgentOnRequest(request2, cachedAgents, proxyUrl) {
      if (request2.agent) {
        return;
      }
      const url = new URL(request2.url);
      const isInsecure = url.protocol !== "https:";
      if (request2.tlsSettings) {
        log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
      }
      const headers2 = request2.headers.toJSON();
      if (isInsecure) {
        if (!cachedAgents.httpProxyAgent) {
          cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers: headers2 });
        }
        request2.agent = cachedAgents.httpProxyAgent;
      } else {
        if (!cachedAgents.httpsProxyAgent) {
          cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers: headers2 });
        }
        request2.agent = cachedAgents.httpsProxyAgent;
      }
    }
    function proxyPolicy2(proxySettings, options2) {
      if (!noProxyListLoaded) {
        exports.globalNoProxyList.push(...loadNoProxy());
      }
      const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
      const cachedAgents = {};
      return {
        name: exports.proxyPolicyName,
        async sendRequest(request2, next) {
          if (!request2.proxySettings && defaultProxy && !isBypassed(request2.url, options2?.customNoProxyList ?? exports.globalNoProxyList, options2?.customNoProxyList ? void 0 : globalBypassedMap)) {
            setProxyAgentOnRequest(request2, cachedAgents, defaultProxy);
          } else if (request2.proxySettings) {
            setProxyAgentOnRequest(request2, cachedAgents, getUrlFromProxySettings(request2.proxySettings));
          }
          return next(request2);
        }
      };
    }
  })(proxyPolicy$1);
  return proxyPolicy$1;
}
var agentPolicy$1 = {};
var hasRequiredAgentPolicy$1;
function requireAgentPolicy$1() {
  if (hasRequiredAgentPolicy$1) return agentPolicy$1;
  hasRequiredAgentPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agentPolicyName = void 0;
    exports.agentPolicy = agentPolicy2;
    exports.agentPolicyName = "agentPolicy";
    function agentPolicy2(agent2) {
      return {
        name: exports.agentPolicyName,
        sendRequest: async (req, next) => {
          if (!req.agent) {
            req.agent = agent2;
          }
          return next(req);
        }
      };
    }
  })(agentPolicy$1);
  return agentPolicy$1;
}
var tlsPolicy$1 = {};
var hasRequiredTlsPolicy$1;
function requireTlsPolicy$1() {
  if (hasRequiredTlsPolicy$1) return tlsPolicy$1;
  hasRequiredTlsPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tlsPolicyName = void 0;
    exports.tlsPolicy = tlsPolicy2;
    exports.tlsPolicyName = "tlsPolicy";
    function tlsPolicy2(tlsSettings) {
      return {
        name: exports.tlsPolicyName,
        sendRequest: async (req, next) => {
          if (!req.tlsSettings) {
            req.tlsSettings = tlsSettings;
          }
          return next(req);
        }
      };
    }
  })(tlsPolicy$1);
  return tlsPolicy$1;
}
var multipartPolicy$1 = {};
var typeGuards$1 = {};
var hasRequiredTypeGuards$1;
function requireTypeGuards$1() {
  if (hasRequiredTypeGuards$1) return typeGuards$1;
  hasRequiredTypeGuards$1 = 1;
  Object.defineProperty(typeGuards$1, "__esModule", { value: true });
  typeGuards$1.isNodeReadableStream = isNodeReadableStream;
  typeGuards$1.isWebReadableStream = isWebReadableStream;
  typeGuards$1.isBinaryBody = isBinaryBody;
  typeGuards$1.isReadableStream = isReadableStream;
  typeGuards$1.isBlob = isBlob;
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x["pipe"] === "function");
  }
  function isWebReadableStream(x) {
    return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
  }
  function isBinaryBody(body2) {
    return body2 !== void 0 && (body2 instanceof Uint8Array || isReadableStream(body2) || typeof body2 === "function" || body2 instanceof Blob);
  }
  function isReadableStream(x) {
    return isNodeReadableStream(x) || isWebReadableStream(x);
  }
  function isBlob(x) {
    return typeof x.stream === "function";
  }
  return typeGuards$1;
}
var concat = {};
var hasRequiredConcat;
function requireConcat() {
  if (hasRequiredConcat) return concat;
  hasRequiredConcat = 1;
  Object.defineProperty(concat, "__esModule", { value: true });
  concat.concat = concat$1;
  const stream_1 = require$$0$9;
  const typeGuards_js_1 = /* @__PURE__ */ requireTypeGuards$1();
  async function* streamAsyncIterator() {
    const reader = this.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return;
        }
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
  function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
      webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
    }
    if (!webStream.values) {
      webStream.values = streamAsyncIterator.bind(webStream);
    }
  }
  function ensureNodeStream(stream) {
    if (stream instanceof ReadableStream) {
      makeAsyncIterable(stream);
      return stream_1.Readable.fromWeb(stream);
    } else {
      return stream;
    }
  }
  function toStream(source) {
    if (source instanceof Uint8Array) {
      return stream_1.Readable.from(Buffer.from(source));
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return ensureNodeStream(source.stream());
    } else {
      return ensureNodeStream(source);
    }
  }
  async function concat$1(sources) {
    return function() {
      const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
      return stream_1.Readable.from((async function* () {
        for (const stream of streams) {
          for await (const chunk of stream) {
            yield chunk;
          }
        }
      })());
    };
  }
  return concat;
}
var hasRequiredMultipartPolicy$1;
function requireMultipartPolicy$1() {
  if (hasRequiredMultipartPolicy$1) return multipartPolicy$1;
  hasRequiredMultipartPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multipartPolicyName = void 0;
    exports.multipartPolicy = multipartPolicy2;
    const bytesEncoding_js_1 = /* @__PURE__ */ requireBytesEncoding();
    const typeGuards_js_1 = /* @__PURE__ */ requireTypeGuards$1();
    const uuidUtils_js_1 = /* @__PURE__ */ requireUuidUtils();
    const concat_js_1 = /* @__PURE__ */ requireConcat();
    function generateBoundary() {
      return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
    }
    function encodeHeaders(headers2) {
      let result = "";
      for (const [key, value] of headers2) {
        result += `${key}: ${value}\r
`;
      }
      return result;
    }
    function getLength(source) {
      if (source instanceof Uint8Array) {
        return source.byteLength;
      } else if ((0, typeGuards_js_1.isBlob)(source)) {
        return source.size === -1 ? void 0 : source.size;
      } else {
        return void 0;
      }
    }
    function getTotalLength(sources) {
      let total = 0;
      for (const source of sources) {
        const partLength = getLength(source);
        if (partLength === void 0) {
          return void 0;
        } else {
          total += partLength;
        }
      }
      return total;
    }
    async function buildRequestBody(request2, parts, boundary) {
      const sources = [
        (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
        ...parts.flatMap((part) => [
          (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
          (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
          (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
          part.body,
          (0, bytesEncoding_js_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
        ]),
        (0, bytesEncoding_js_1.stringToUint8Array)("--\r\n\r\n", "utf-8")
      ];
      const contentLength = getTotalLength(sources);
      if (contentLength) {
        request2.headers.set("Content-Length", contentLength);
      }
      request2.body = await (0, concat_js_1.concat)(sources);
    }
    exports.multipartPolicyName = "multipartPolicy";
    const maxBoundaryLength = 70;
    const validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
    function assertValidBoundary(boundary) {
      if (boundary.length > maxBoundaryLength) {
        throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
      }
      if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
        throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
      }
    }
    function multipartPolicy2() {
      return {
        name: exports.multipartPolicyName,
        async sendRequest(request2, next) {
          if (!request2.multipartBody) {
            return next(request2);
          }
          if (request2.body) {
            throw new Error("multipartBody and regular body cannot be set at the same time");
          }
          let boundary = request2.multipartBody.boundary;
          const contentTypeHeader = request2.headers.get("Content-Type") ?? "multipart/mixed";
          const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
          if (!parsedHeader) {
            throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
          }
          const [, contentType, parsedBoundary] = parsedHeader;
          if (parsedBoundary && boundary && parsedBoundary !== boundary) {
            throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
          }
          boundary ??= parsedBoundary;
          if (boundary) {
            assertValidBoundary(boundary);
          } else {
            boundary = generateBoundary();
          }
          request2.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
          await buildRequestBody(request2, request2.multipartBody.parts, boundary);
          request2.multipartBody = void 0;
          return next(request2);
        }
      };
    }
  })(multipartPolicy$1);
  return multipartPolicy$1;
}
var hasRequiredCreatePipelineFromOptions$1;
function requireCreatePipelineFromOptions$1() {
  if (hasRequiredCreatePipelineFromOptions$1) return createPipelineFromOptions$1;
  hasRequiredCreatePipelineFromOptions$1 = 1;
  Object.defineProperty(createPipelineFromOptions$1, "__esModule", { value: true });
  createPipelineFromOptions$1.createPipelineFromOptions = createPipelineFromOptions2;
  const logPolicy_js_1 = /* @__PURE__ */ requireLogPolicy$1();
  const pipeline_js_1 = /* @__PURE__ */ requirePipeline$3();
  const redirectPolicy_js_1 = /* @__PURE__ */ requireRedirectPolicy$1();
  const userAgentPolicy_js_1 = /* @__PURE__ */ requireUserAgentPolicy$1();
  const decompressResponsePolicy_js_1 = /* @__PURE__ */ requireDecompressResponsePolicy$1();
  const defaultRetryPolicy_js_1 = /* @__PURE__ */ requireDefaultRetryPolicy$1();
  const formDataPolicy_js_1 = /* @__PURE__ */ requireFormDataPolicy$1();
  const checkEnvironment_js_1 = /* @__PURE__ */ requireCheckEnvironment();
  const proxyPolicy_js_1 = /* @__PURE__ */ requireProxyPolicy$1();
  const agentPolicy_js_1 = /* @__PURE__ */ requireAgentPolicy$1();
  const tlsPolicy_js_1 = /* @__PURE__ */ requireTlsPolicy$1();
  const multipartPolicy_js_1 = /* @__PURE__ */ requireMultipartPolicy$1();
  function createPipelineFromOptions2(options2) {
    const pipeline2 = (0, pipeline_js_1.createEmptyPipeline)();
    if (checkEnvironment_js_1.isNodeLike) {
      if (options2.agent) {
        pipeline2.addPolicy((0, agentPolicy_js_1.agentPolicy)(options2.agent));
      }
      if (options2.tlsOptions) {
        pipeline2.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options2.tlsOptions));
      }
      pipeline2.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options2.proxyOptions));
      pipeline2.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline2.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline2.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options2.userAgentOptions));
    pipeline2.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline2.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options2.retryOptions), { phase: "Retry" });
    if (checkEnvironment_js_1.isNodeLike) {
      pipeline2.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options2.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline2.addPolicy((0, logPolicy_js_1.logPolicy)(options2.loggingOptions), { afterPhase: "Sign" });
    return pipeline2;
  }
  return createPipelineFromOptions$1;
}
var apiVersionPolicy = {};
var hasRequiredApiVersionPolicy;
function requireApiVersionPolicy() {
  if (hasRequiredApiVersionPolicy) return apiVersionPolicy;
  hasRequiredApiVersionPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiVersionPolicyName = void 0;
    exports.apiVersionPolicy = apiVersionPolicy2;
    exports.apiVersionPolicyName = "ApiVersionPolicy";
    function apiVersionPolicy2(options2) {
      return {
        name: exports.apiVersionPolicyName,
        sendRequest: (req, next) => {
          const url = new URL(req.url);
          if (!url.searchParams.get("api-version") && options2.apiVersion) {
            req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options2.apiVersion}`;
          }
          return next(req);
        }
      };
    }
  })(apiVersionPolicy);
  return apiVersionPolicy;
}
var credentials = {};
var hasRequiredCredentials;
function requireCredentials() {
  if (hasRequiredCredentials) return credentials;
  hasRequiredCredentials = 1;
  Object.defineProperty(credentials, "__esModule", { value: true });
  credentials.isOAuth2TokenCredential = isOAuth2TokenCredential;
  credentials.isBearerTokenCredential = isBearerTokenCredential;
  credentials.isBasicCredential = isBasicCredential;
  credentials.isApiKeyCredential = isApiKeyCredential;
  function isOAuth2TokenCredential(credential) {
    return "getOAuth2Token" in credential;
  }
  function isBearerTokenCredential(credential) {
    return "getBearerToken" in credential;
  }
  function isBasicCredential(credential) {
    return "username" in credential && "password" in credential;
  }
  function isApiKeyCredential(credential) {
    return "key" in credential;
  }
  return credentials;
}
var apiKeyAuthenticationPolicy = {};
var checkInsecureConnection = {};
var hasRequiredCheckInsecureConnection;
function requireCheckInsecureConnection() {
  if (hasRequiredCheckInsecureConnection) return checkInsecureConnection;
  hasRequiredCheckInsecureConnection = 1;
  Object.defineProperty(checkInsecureConnection, "__esModule", { value: true });
  checkInsecureConnection.ensureSecureConnection = ensureSecureConnection;
  const log_js_1 = /* @__PURE__ */ requireLog$4();
  let insecureConnectionWarningEmmitted = false;
  function allowInsecureConnection(request2, options2) {
    if (options2.allowInsecureConnection && request2.allowInsecureConnection) {
      const url = new URL(request2.url);
      if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
        return true;
      }
    }
    return false;
  }
  function emitInsecureConnectionWarning() {
    const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
    log_js_1.logger.warning(warning);
    if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
      insecureConnectionWarningEmmitted = true;
      process.emitWarning(warning);
    }
  }
  function ensureSecureConnection(request2, options2) {
    if (!request2.url.toLowerCase().startsWith("https://")) {
      if (allowInsecureConnection(request2, options2)) {
        emitInsecureConnectionWarning();
      } else {
        throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
      }
    }
  }
  return checkInsecureConnection;
}
var hasRequiredApiKeyAuthenticationPolicy;
function requireApiKeyAuthenticationPolicy() {
  if (hasRequiredApiKeyAuthenticationPolicy) return apiKeyAuthenticationPolicy;
  hasRequiredApiKeyAuthenticationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiKeyAuthenticationPolicyName = void 0;
    exports.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy2;
    const checkInsecureConnection_js_1 = /* @__PURE__ */ requireCheckInsecureConnection();
    exports.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
    function apiKeyAuthenticationPolicy2(options2) {
      return {
        name: exports.apiKeyAuthenticationPolicyName,
        async sendRequest(request2, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request2, options2);
          const scheme = (request2.authSchemes ?? options2.authSchemes)?.find((x) => x.kind === "apiKey");
          if (!scheme) {
            return next(request2);
          }
          if (scheme.apiKeyLocation !== "header") {
            throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
          }
          request2.headers.set(scheme.name, options2.credential.key);
          return next(request2);
        }
      };
    }
  })(apiKeyAuthenticationPolicy);
  return apiKeyAuthenticationPolicy;
}
var basicAuthenticationPolicy = {};
var hasRequiredBasicAuthenticationPolicy;
function requireBasicAuthenticationPolicy() {
  if (hasRequiredBasicAuthenticationPolicy) return basicAuthenticationPolicy;
  hasRequiredBasicAuthenticationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.basicAuthenticationPolicyName = void 0;
    exports.basicAuthenticationPolicy = basicAuthenticationPolicy2;
    const bytesEncoding_js_1 = /* @__PURE__ */ requireBytesEncoding();
    const checkInsecureConnection_js_1 = /* @__PURE__ */ requireCheckInsecureConnection();
    exports.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
    function basicAuthenticationPolicy2(options2) {
      return {
        name: exports.basicAuthenticationPolicyName,
        async sendRequest(request2, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request2, options2);
          const scheme = (request2.authSchemes ?? options2.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic");
          if (!scheme) {
            return next(request2);
          }
          const { username, password } = options2.credential;
          const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
          request2.headers.set("Authorization", `Basic ${headerValue}`);
          return next(request2);
        }
      };
    }
  })(basicAuthenticationPolicy);
  return basicAuthenticationPolicy;
}
var bearerAuthenticationPolicy = {};
var hasRequiredBearerAuthenticationPolicy;
function requireBearerAuthenticationPolicy() {
  if (hasRequiredBearerAuthenticationPolicy) return bearerAuthenticationPolicy;
  hasRequiredBearerAuthenticationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearerAuthenticationPolicyName = void 0;
    exports.bearerAuthenticationPolicy = bearerAuthenticationPolicy2;
    const checkInsecureConnection_js_1 = /* @__PURE__ */ requireCheckInsecureConnection();
    exports.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
    function bearerAuthenticationPolicy2(options2) {
      return {
        name: exports.bearerAuthenticationPolicyName,
        async sendRequest(request2, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request2, options2);
          const scheme = (request2.authSchemes ?? options2.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer");
          if (!scheme) {
            return next(request2);
          }
          const token = await options2.credential.getBearerToken({
            abortSignal: request2.abortSignal
          });
          request2.headers.set("Authorization", `Bearer ${token}`);
          return next(request2);
        }
      };
    }
  })(bearerAuthenticationPolicy);
  return bearerAuthenticationPolicy;
}
var oauth2AuthenticationPolicy = {};
var hasRequiredOauth2AuthenticationPolicy;
function requireOauth2AuthenticationPolicy() {
  if (hasRequiredOauth2AuthenticationPolicy) return oauth2AuthenticationPolicy;
  hasRequiredOauth2AuthenticationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oauth2AuthenticationPolicyName = void 0;
    exports.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy2;
    const checkInsecureConnection_js_1 = /* @__PURE__ */ requireCheckInsecureConnection();
    exports.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
    function oauth2AuthenticationPolicy2(options2) {
      return {
        name: exports.oauth2AuthenticationPolicyName,
        async sendRequest(request2, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request2, options2);
          const scheme = (request2.authSchemes ?? options2.authSchemes)?.find((x) => x.kind === "oauth2");
          if (!scheme) {
            return next(request2);
          }
          const token = await options2.credential.getOAuth2Token(scheme.flows, {
            abortSignal: request2.abortSignal
          });
          request2.headers.set("Authorization", `Bearer ${token}`);
          return next(request2);
        }
      };
    }
  })(oauth2AuthenticationPolicy);
  return oauth2AuthenticationPolicy;
}
var hasRequiredClientHelpers;
function requireClientHelpers() {
  if (hasRequiredClientHelpers) return clientHelpers;
  hasRequiredClientHelpers = 1;
  Object.defineProperty(clientHelpers, "__esModule", { value: true });
  clientHelpers.createDefaultPipeline = createDefaultPipeline;
  clientHelpers.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
  const defaultHttpClient_js_1 = /* @__PURE__ */ requireDefaultHttpClient$1();
  const createPipelineFromOptions_js_1 = /* @__PURE__ */ requireCreatePipelineFromOptions$1();
  const apiVersionPolicy_js_1 = /* @__PURE__ */ requireApiVersionPolicy();
  const credentials_js_1 = /* @__PURE__ */ requireCredentials();
  const apiKeyAuthenticationPolicy_js_1 = /* @__PURE__ */ requireApiKeyAuthenticationPolicy();
  const basicAuthenticationPolicy_js_1 = /* @__PURE__ */ requireBasicAuthenticationPolicy();
  const bearerAuthenticationPolicy_js_1 = /* @__PURE__ */ requireBearerAuthenticationPolicy();
  const oauth2AuthenticationPolicy_js_1 = /* @__PURE__ */ requireOauth2AuthenticationPolicy();
  let cachedHttpClient;
  function createDefaultPipeline(options2 = {}) {
    const pipeline2 = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options2);
    pipeline2.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options2));
    const { credential, authSchemes, allowInsecureConnection } = options2;
    if (credential) {
      if ((0, credentials_js_1.isApiKeyCredential)(credential)) {
        pipeline2.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      } else if ((0, credentials_js_1.isBasicCredential)(credential)) {
        pipeline2.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      } else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) {
        pipeline2.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      } else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) {
        pipeline2.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      }
    }
    return pipeline2;
  }
  function getCachedDefaultHttpsClient() {
    if (!cachedHttpClient) {
      cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
    }
    return cachedHttpClient;
  }
  return clientHelpers;
}
var sendRequest = {};
var multipart = {};
var hasRequiredMultipart;
function requireMultipart() {
  if (hasRequiredMultipart) return multipart;
  hasRequiredMultipart = 1;
  Object.defineProperty(multipart, "__esModule", { value: true });
  multipart.buildBodyPart = buildBodyPart;
  multipart.buildMultipartBody = buildMultipartBody;
  const restError_js_1 = /* @__PURE__ */ requireRestError$2();
  const httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
  const bytesEncoding_js_1 = /* @__PURE__ */ requireBytesEncoding();
  const typeGuards_js_1 = /* @__PURE__ */ requireTypeGuards$1();
  function getHeaderValue(descriptor, headerName) {
    if (descriptor.headers) {
      const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
      if (actualHeaderName) {
        return descriptor.headers[actualHeaderName];
      }
    }
    return void 0;
  }
  function getPartContentType(descriptor) {
    const contentTypeHeader = getHeaderValue(descriptor, "content-type");
    if (contentTypeHeader) {
      return contentTypeHeader;
    }
    if (descriptor.contentType === null) {
      return void 0;
    }
    if (descriptor.contentType) {
      return descriptor.contentType;
    }
    const { body: body2 } = descriptor;
    if (body2 === null || body2 === void 0) {
      return void 0;
    }
    if (typeof body2 === "string" || typeof body2 === "number" || typeof body2 === "boolean") {
      return "text/plain; charset=UTF-8";
    }
    if (body2 instanceof Blob) {
      return body2.type || "application/octet-stream";
    }
    if ((0, typeGuards_js_1.isBinaryBody)(body2)) {
      return "application/octet-stream";
    }
    return "application/json";
  }
  function escapeDispositionField(value) {
    return JSON.stringify(value);
  }
  function getContentDisposition(descriptor) {
    const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
    if (contentDispositionHeader) {
      return contentDispositionHeader;
    }
    if (descriptor.dispositionType === void 0 && descriptor.name === void 0 && descriptor.filename === void 0) {
      return void 0;
    }
    const dispositionType = descriptor.dispositionType ?? "form-data";
    let disposition = dispositionType;
    if (descriptor.name) {
      disposition += `; name=${escapeDispositionField(descriptor.name)}`;
    }
    let filename = void 0;
    if (descriptor.filename) {
      filename = descriptor.filename;
    } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
      const filenameFromFile = descriptor.body.name;
      if (filenameFromFile !== "") {
        filename = filenameFromFile;
      }
    }
    if (filename) {
      disposition += `; filename=${escapeDispositionField(filename)}`;
    }
    return disposition;
  }
  function normalizeBody(body2, contentType) {
    if (body2 === void 0) {
      return new Uint8Array([]);
    }
    if ((0, typeGuards_js_1.isBinaryBody)(body2)) {
      return body2;
    }
    if (typeof body2 === "string" || typeof body2 === "number" || typeof body2 === "boolean") {
      return (0, bytesEncoding_js_1.stringToUint8Array)(String(body2), "utf-8");
    }
    if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
      return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body2), "utf-8");
    }
    throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body2}, ${contentType}`);
  }
  function buildBodyPart(descriptor) {
    const contentType = getPartContentType(descriptor);
    const contentDisposition = getContentDisposition(descriptor);
    const headers2 = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
    if (contentType) {
      headers2.set("content-type", contentType);
    }
    if (contentDisposition) {
      headers2.set("content-disposition", contentDisposition);
    }
    const body2 = normalizeBody(descriptor.body, contentType);
    return {
      headers: headers2,
      body: body2
    };
  }
  function buildMultipartBody(parts) {
    return { parts: parts.map(buildBodyPart) };
  }
  return multipart;
}
var hasRequiredSendRequest;
function requireSendRequest() {
  if (hasRequiredSendRequest) return sendRequest;
  hasRequiredSendRequest = 1;
  Object.defineProperty(sendRequest, "__esModule", { value: true });
  sendRequest.sendRequest = sendRequest$1;
  const restError_js_1 = /* @__PURE__ */ requireRestError$2();
  const httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
  const pipelineRequest_js_1 = /* @__PURE__ */ requirePipelineRequest$1();
  const clientHelpers_js_1 = /* @__PURE__ */ requireClientHelpers();
  const typeGuards_js_1 = /* @__PURE__ */ requireTypeGuards$1();
  const multipart_js_1 = /* @__PURE__ */ requireMultipart();
  async function sendRequest$1(method, url, pipeline2, options2 = {}, customHttpClient) {
    const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
    const request2 = buildPipelineRequest(method, url, options2);
    try {
      const response2 = await pipeline2.sendRequest(httpClient, request2);
      const headers2 = response2.headers.toJSON();
      const stream = response2.readableStreamBody ?? response2.browserStreamBody;
      const parsedBody = options2.responseAsStream || stream !== void 0 ? void 0 : getResponseBody(response2);
      const body2 = stream ?? parsedBody;
      if (options2?.onResponse) {
        options2.onResponse({ ...response2, request: request2, rawHeaders: headers2, parsedBody });
      }
      return {
        request: request2,
        headers: headers2,
        status: `${response2.status}`,
        body: body2
      };
    } catch (e) {
      if ((0, restError_js_1.isRestError)(e) && e.response && options2.onResponse) {
        const { response: response2 } = e;
        const rawHeaders = response2.headers.toJSON();
        options2?.onResponse({ ...response2, request: request2, rawHeaders }, e);
      }
      throw e;
    }
  }
  function getRequestContentType(options2 = {}) {
    return options2.contentType ?? options2.headers?.["content-type"] ?? getContentType(options2.body);
  }
  function getContentType(body2) {
    if (ArrayBuffer.isView(body2)) {
      return "application/octet-stream";
    }
    if (typeof body2 === "string") {
      try {
        JSON.parse(body2);
        return "application/json";
      } catch (error2) {
        return void 0;
      }
    }
    return "application/json";
  }
  function buildPipelineRequest(method, url, options2 = {}) {
    const requestContentType = getRequestContentType(options2);
    const { body: body2, multipartBody } = getRequestBody(options2.body, requestContentType);
    const hasContent = body2 !== void 0 || multipartBody !== void 0;
    const headers2 = (0, httpHeaders_js_1.createHttpHeaders)({
      ...options2.headers ? options2.headers : {},
      accept: options2.accept ?? options2.headers?.accept ?? "application/json",
      ...hasContent && requestContentType && {
        "content-type": requestContentType
      }
    });
    return (0, pipelineRequest_js_1.createPipelineRequest)({
      url,
      method,
      body: body2,
      multipartBody,
      headers: headers2,
      allowInsecureConnection: options2.allowInsecureConnection,
      abortSignal: options2.abortSignal,
      onUploadProgress: options2.onUploadProgress,
      onDownloadProgress: options2.onDownloadProgress,
      timeout: options2.timeout,
      enableBrowserStreams: true,
      streamResponseStatusCodes: options2.responseAsStream ? /* @__PURE__ */ new Set([Number.POSITIVE_INFINITY]) : void 0
    });
  }
  function getRequestBody(body2, contentType = "") {
    if (body2 === void 0) {
      return { body: void 0 };
    }
    if (typeof FormData !== "undefined" && body2 instanceof FormData) {
      return { body: body2 };
    }
    if ((0, typeGuards_js_1.isReadableStream)(body2)) {
      return { body: body2 };
    }
    if (ArrayBuffer.isView(body2)) {
      return { body: body2 instanceof Uint8Array ? body2 : JSON.stringify(body2) };
    }
    const firstType = contentType.split(";")[0];
    switch (firstType) {
      case "application/json":
        return { body: JSON.stringify(body2) };
      case "multipart/form-data":
        if (Array.isArray(body2)) {
          return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body2) };
        }
        return { body: JSON.stringify(body2) };
      case "text/plain":
        return { body: String(body2) };
      default:
        if (typeof body2 === "string") {
          return { body: body2 };
        }
        return { body: JSON.stringify(body2) };
    }
  }
  function getResponseBody(response2) {
    const contentType = response2.headers.get("content-type") ?? "";
    const firstType = contentType.split(";")[0];
    const bodyToParse = response2.bodyAsText ?? "";
    if (firstType === "text/plain") {
      return String(bodyToParse);
    }
    try {
      return bodyToParse ? JSON.parse(bodyToParse) : void 0;
    } catch (error2) {
      if (firstType === "application/json") {
        throw createParseError(response2, error2);
      }
      return String(bodyToParse);
    }
  }
  function createParseError(response2, err) {
    const msg = `Error "${err}" occurred while parsing the response body - ${response2.bodyAsText}.`;
    const errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
    return new restError_js_1.RestError(msg, {
      code: errCode,
      statusCode: response2.status,
      request: response2.request,
      response: response2
    });
  }
  return sendRequest;
}
var urlHelpers$1 = {};
var hasRequiredUrlHelpers$1;
function requireUrlHelpers$1() {
  if (hasRequiredUrlHelpers$1) return urlHelpers$1;
  hasRequiredUrlHelpers$1 = 1;
  Object.defineProperty(urlHelpers$1, "__esModule", { value: true });
  urlHelpers$1.buildRequestUrl = buildRequestUrl;
  urlHelpers$1.buildBaseUrl = buildBaseUrl;
  urlHelpers$1.replaceAll = replaceAll;
  function isQueryParameterWithOptions(x) {
    const value = x.value;
    return value !== void 0 && value.toString !== void 0 && typeof value.toString === "function";
  }
  function buildRequestUrl(endpoint, routePath, pathParameters, options2 = {}) {
    if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
      return routePath;
    }
    endpoint = buildBaseUrl(endpoint, options2);
    routePath = buildRoutePath(routePath, pathParameters, options2);
    const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options2);
    const url = new URL(requestUrl);
    return url.toString().replace(/([^:]\/)\/+/g, "$1");
  }
  function getQueryParamValue(key, allowReserved, style, param) {
    let separator;
    if (style === "pipeDelimited") {
      separator = "|";
    } else if (style === "spaceDelimited") {
      separator = "%20";
    } else {
      separator = ",";
    }
    let paramValues;
    if (Array.isArray(param)) {
      paramValues = param;
    } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
      paramValues = Object.entries(param).flat();
    } else {
      paramValues = [param];
    }
    const value = paramValues.map((p) => {
      if (p === null || p === void 0) {
        return "";
      }
      if (!p.toString || typeof p.toString !== "function") {
        throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
      }
      const rawValue = p.toISOString !== void 0 ? p.toISOString() : p.toString();
      return allowReserved ? rawValue : encodeURIComponent(rawValue);
    }).join(separator);
    return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
  }
  function appendQueryParams(url, options2 = {}) {
    if (!options2.queryParameters) {
      return url;
    }
    const parsedUrl = new URL(url);
    const queryParams = options2.queryParameters;
    const paramStrings = [];
    for (const key of Object.keys(queryParams)) {
      const param = queryParams[key];
      if (param === void 0 || param === null) {
        continue;
      }
      const hasMetadata = isQueryParameterWithOptions(param);
      const rawValue = hasMetadata ? param.value : param;
      const explode = hasMetadata ? param.explode ?? false : false;
      const style = hasMetadata && param.style ? param.style : "form";
      if (explode) {
        if (Array.isArray(rawValue)) {
          for (const item of rawValue) {
            paramStrings.push(getQueryParamValue(key, options2.skipUrlEncoding ?? false, style, item));
          }
        } else if (typeof rawValue === "object") {
          for (const [actualKey, value] of Object.entries(rawValue)) {
            paramStrings.push(getQueryParamValue(actualKey, options2.skipUrlEncoding ?? false, style, value));
          }
        } else {
          throw new Error("explode can only be set to true for objects and arrays");
        }
      } else {
        paramStrings.push(getQueryParamValue(key, options2.skipUrlEncoding ?? false, style, rawValue));
      }
    }
    if (parsedUrl.search !== "") {
      parsedUrl.search += "&";
    }
    parsedUrl.search += paramStrings.join("&");
    return parsedUrl.toString();
  }
  function buildBaseUrl(endpoint, options2) {
    if (!options2.pathParameters) {
      return endpoint;
    }
    const pathParams = options2.pathParameters;
    for (const [key, param] of Object.entries(pathParams)) {
      if (param === void 0 || param === null) {
        throw new Error(`Path parameters ${key} must not be undefined or null`);
      }
      if (!param.toString || typeof param.toString !== "function") {
        throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
      }
      let value = param.toISOString !== void 0 ? param.toISOString() : String(param);
      if (!options2.skipUrlEncoding) {
        value = encodeURIComponent(param);
      }
      endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
    }
    return endpoint;
  }
  function buildRoutePath(routePath, pathParameters, options2 = {}) {
    for (const pathParam of pathParameters) {
      const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
      let value = typeof pathParam === "object" ? pathParam.value : pathParam;
      if (!options2.skipUrlEncoding && !allowReserved) {
        value = encodeURIComponent(value);
      }
      routePath = routePath.replace(/\{[\w-]+\}/, String(value));
    }
    return routePath;
  }
  function replaceAll(value, searchValue, replaceValue) {
    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
  }
  return urlHelpers$1;
}
var hasRequiredGetClient;
function requireGetClient() {
  if (hasRequiredGetClient) return getClient;
  hasRequiredGetClient = 1;
  Object.defineProperty(getClient, "__esModule", { value: true });
  getClient.getClient = getClient$1;
  const clientHelpers_js_1 = /* @__PURE__ */ requireClientHelpers();
  const sendRequest_js_1 = /* @__PURE__ */ requireSendRequest();
  const urlHelpers_js_1 = /* @__PURE__ */ requireUrlHelpers$1();
  const checkEnvironment_js_1 = /* @__PURE__ */ requireCheckEnvironment();
  function getClient$1(endpoint, clientOptions = {}) {
    const pipeline2 = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
    if (clientOptions.additionalPolicies?.length) {
      for (const { policy, position } of clientOptions.additionalPolicies) {
        const afterPhase = position === "perRetry" ? "Sign" : void 0;
        pipeline2.addPolicy(policy, {
          afterPhase
        });
      }
    }
    const { allowInsecureConnection, httpClient } = clientOptions;
    const endpointUrl = clientOptions.endpoint ?? endpoint;
    const client2 = (path2, ...args) => {
      const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path2, args, { allowInsecureConnection, ...requestOptions });
      return {
        get: (requestOptions = {}) => {
          return buildOperation("GET", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        post: (requestOptions = {}) => {
          return buildOperation("POST", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        put: (requestOptions = {}) => {
          return buildOperation("PUT", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        patch: (requestOptions = {}) => {
          return buildOperation("PATCH", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        delete: (requestOptions = {}) => {
          return buildOperation("DELETE", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        head: (requestOptions = {}) => {
          return buildOperation("HEAD", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        options: (requestOptions = {}) => {
          return buildOperation("OPTIONS", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        },
        trace: (requestOptions = {}) => {
          return buildOperation("TRACE", getUrl(requestOptions), pipeline2, requestOptions, allowInsecureConnection, httpClient);
        }
      };
    };
    return {
      path: client2,
      pathUnchecked: client2,
      pipeline: pipeline2
    };
  }
  function buildOperation(method, url, pipeline2, options2, allowInsecureConnection, httpClient) {
    allowInsecureConnection = options2.allowInsecureConnection ?? allowInsecureConnection;
    return {
      then: function(onFulfilled, onrejected) {
        return (0, sendRequest_js_1.sendRequest)(method, url, pipeline2, { ...options2, allowInsecureConnection }, httpClient).then(onFulfilled, onrejected);
      },
      async asBrowserStream() {
        if (checkEnvironment_js_1.isNodeLike) {
          throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
        } else {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline2, { ...options2, allowInsecureConnection, responseAsStream: true }, httpClient);
        }
      },
      async asNodeStream() {
        if (checkEnvironment_js_1.isNodeLike) {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline2, { ...options2, allowInsecureConnection, responseAsStream: true }, httpClient);
        } else {
          throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
        }
      }
    };
  }
  return getClient;
}
var operationOptionHelpers = {};
var hasRequiredOperationOptionHelpers;
function requireOperationOptionHelpers() {
  if (hasRequiredOperationOptionHelpers) return operationOptionHelpers;
  hasRequiredOperationOptionHelpers = 1;
  Object.defineProperty(operationOptionHelpers, "__esModule", { value: true });
  operationOptionHelpers.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
  function operationOptionsToRequestParameters(options2) {
    return {
      allowInsecureConnection: options2.requestOptions?.allowInsecureConnection,
      timeout: options2.requestOptions?.timeout,
      skipUrlEncoding: options2.requestOptions?.skipUrlEncoding,
      abortSignal: options2.abortSignal,
      onUploadProgress: options2.requestOptions?.onUploadProgress,
      onDownloadProgress: options2.requestOptions?.onDownloadProgress,
      headers: { ...options2.requestOptions?.headers },
      onResponse: options2.onResponse
    };
  }
  return operationOptionHelpers;
}
var restError$1 = {};
var hasRequiredRestError$1;
function requireRestError$1() {
  if (hasRequiredRestError$1) return restError$1;
  hasRequiredRestError$1 = 1;
  Object.defineProperty(restError$1, "__esModule", { value: true });
  restError$1.createRestError = createRestError;
  const restError_js_1 = /* @__PURE__ */ requireRestError$2();
  const httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
  function createRestError(messageOrResponse, response2) {
    const resp = typeof messageOrResponse === "string" ? response2 : messageOrResponse;
    const internalError = resp.body?.error ?? resp.body;
    const message = typeof messageOrResponse === "string" ? messageOrResponse : internalError?.message ?? `Unexpected status code: ${resp.status}`;
    return new restError_js_1.RestError(message, {
      statusCode: statusCodeToNumber(resp.status),
      code: internalError?.code,
      request: resp.request,
      response: toPipelineResponse(resp)
    });
  }
  function toPipelineResponse(response2) {
    return {
      headers: (0, httpHeaders_js_1.createHttpHeaders)(response2.headers),
      request: response2.request,
      status: statusCodeToNumber(response2.status) ?? -1
    };
  }
  function statusCodeToNumber(statusCode) {
    const status = Number.parseInt(statusCode);
    return Number.isNaN(status) ? void 0 : status;
  }
  return restError$1;
}
var hasRequiredCommonjs$c;
function requireCommonjs$c() {
  if (hasRequiredCommonjs$c) return commonjs$a;
  hasRequiredCommonjs$c = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRestError = exports.operationOptionsToRequestParameters = exports.getClient = exports.createDefaultHttpClient = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isRestError = exports.RestError = exports.createEmptyPipeline = exports.createPipelineRequest = exports.createHttpHeaders = exports.TypeSpecRuntimeLogger = exports.setLogLevel = exports.getLogLevel = exports.createClientLogger = exports.AbortError = void 0;
    const tslib_1 = require$$0$2;
    var AbortError_js_1 = /* @__PURE__ */ requireAbortError$1();
    Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
    var logger_js_1 = /* @__PURE__ */ requireLogger$1();
    Object.defineProperty(exports, "createClientLogger", { enumerable: true, get: function() {
      return logger_js_1.createClientLogger;
    } });
    Object.defineProperty(exports, "getLogLevel", { enumerable: true, get: function() {
      return logger_js_1.getLogLevel;
    } });
    Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function() {
      return logger_js_1.setLogLevel;
    } });
    Object.defineProperty(exports, "TypeSpecRuntimeLogger", { enumerable: true, get: function() {
      return logger_js_1.TypeSpecRuntimeLogger;
    } });
    var httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders$1();
    Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
      return httpHeaders_js_1.createHttpHeaders;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireSchemes(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireOauth2Flows(), exports);
    var pipelineRequest_js_1 = /* @__PURE__ */ requirePipelineRequest$1();
    Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
      return pipelineRequest_js_1.createPipelineRequest;
    } });
    var pipeline_js_1 = /* @__PURE__ */ requirePipeline$3();
    Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createEmptyPipeline;
    } });
    var restError_js_1 = /* @__PURE__ */ requireRestError$2();
    Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
      return restError_js_1.RestError;
    } });
    Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
      return restError_js_1.isRestError;
    } });
    var bytesEncoding_js_1 = /* @__PURE__ */ requireBytesEncoding();
    Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
    Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    var defaultHttpClient_js_1 = /* @__PURE__ */ requireDefaultHttpClient$1();
    Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
      return defaultHttpClient_js_1.createDefaultHttpClient;
    } });
    var getClient_js_1 = /* @__PURE__ */ requireGetClient();
    Object.defineProperty(exports, "getClient", { enumerable: true, get: function() {
      return getClient_js_1.getClient;
    } });
    var operationOptionHelpers_js_1 = /* @__PURE__ */ requireOperationOptionHelpers();
    Object.defineProperty(exports, "operationOptionsToRequestParameters", { enumerable: true, get: function() {
      return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
    } });
    var restError_js_2 = /* @__PURE__ */ requireRestError$1();
    Object.defineProperty(exports, "createRestError", { enumerable: true, get: function() {
      return restError_js_2.createRestError;
    } });
  })(commonjs$a);
  return commonjs$a;
}
var hasRequiredPipeline$2;
function requirePipeline$2() {
  if (hasRequiredPipeline$2) return pipeline$2;
  hasRequiredPipeline$2 = 1;
  Object.defineProperty(pipeline$2, "__esModule", { value: true });
  pipeline$2.createEmptyPipeline = createEmptyPipeline;
  const ts_http_runtime_1 = /* @__PURE__ */ requireCommonjs$c();
  function createEmptyPipeline() {
    return (0, ts_http_runtime_1.createEmptyPipeline)();
  }
  return pipeline$2;
}
var createPipelineFromOptions = {};
var logPolicy = {};
var log$3 = {};
var commonjs$9 = {};
var internal$2 = {};
var hasRequiredInternal$2;
function requireInternal$2() {
  if (hasRequiredInternal$2) return internal$2;
  hasRequiredInternal$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLoggerContext = void 0;
    var logger_js_1 = /* @__PURE__ */ requireLogger$1();
    Object.defineProperty(exports, "createLoggerContext", { enumerable: true, get: function() {
      return logger_js_1.createLoggerContext;
    } });
  })(internal$2);
  return internal$2;
}
var hasRequiredCommonjs$b;
function requireCommonjs$b() {
  if (hasRequiredCommonjs$b) return commonjs$9;
  hasRequiredCommonjs$b = 1;
  Object.defineProperty(commonjs$9, "__esModule", { value: true });
  commonjs$9.AzureLogger = void 0;
  commonjs$9.setLogLevel = setLogLevel;
  commonjs$9.getLogLevel = getLogLevel;
  commonjs$9.createClientLogger = createClientLogger;
  const logger_1 = /* @__PURE__ */ requireInternal$2();
  const context = (0, logger_1.createLoggerContext)({
    logLevelEnvVarName: "AZURE_LOG_LEVEL",
    namespace: "azure"
  });
  commonjs$9.AzureLogger = context.logger;
  function setLogLevel(level) {
    context.setLogLevel(level);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
  return commonjs$9;
}
var hasRequiredLog$3;
function requireLog$3() {
  if (hasRequiredLog$3) return log$3;
  hasRequiredLog$3 = 1;
  Object.defineProperty(log$3, "__esModule", { value: true });
  log$3.logger = void 0;
  const logger_1 = /* @__PURE__ */ requireCommonjs$b();
  log$3.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
  return log$3;
}
var internal$1 = {};
var exponentialRetryPolicy$1 = {};
var hasRequiredExponentialRetryPolicy$1;
function requireExponentialRetryPolicy$1() {
  if (hasRequiredExponentialRetryPolicy$1) return exponentialRetryPolicy$1;
  hasRequiredExponentialRetryPolicy$1 = 1;
  Object.defineProperty(exponentialRetryPolicy$1, "__esModule", { value: true });
  exponentialRetryPolicy$1.exponentialRetryPolicyName = void 0;
  exponentialRetryPolicy$1.exponentialRetryPolicy = exponentialRetryPolicy2;
  const exponentialRetryStrategy_js_1 = /* @__PURE__ */ requireExponentialRetryStrategy();
  const retryPolicy_js_1 = /* @__PURE__ */ requireRetryPolicy$1();
  const constants_js_1 = /* @__PURE__ */ requireConstants$4();
  exponentialRetryPolicy$1.exponentialRetryPolicyName = "exponentialRetryPolicy";
  function exponentialRetryPolicy2(options2 = {}) {
    return (0, retryPolicy_js_1.retryPolicy)([
      (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
        ...options2,
        ignoreSystemErrors: true
      })
    ], {
      maxRetries: options2.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
    });
  }
  return exponentialRetryPolicy$1;
}
var systemErrorRetryPolicy$1 = {};
var hasRequiredSystemErrorRetryPolicy$1;
function requireSystemErrorRetryPolicy$1() {
  if (hasRequiredSystemErrorRetryPolicy$1) return systemErrorRetryPolicy$1;
  hasRequiredSystemErrorRetryPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.systemErrorRetryPolicyName = void 0;
    exports.systemErrorRetryPolicy = systemErrorRetryPolicy2;
    const exponentialRetryStrategy_js_1 = /* @__PURE__ */ requireExponentialRetryStrategy();
    const retryPolicy_js_1 = /* @__PURE__ */ requireRetryPolicy$1();
    const constants_js_1 = /* @__PURE__ */ requireConstants$4();
    exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
    function systemErrorRetryPolicy2(options2 = {}) {
      return {
        name: exports.systemErrorRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([
          (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
            ...options2,
            ignoreHttpStatusCodes: true
          })
        ], {
          maxRetries: options2.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  })(systemErrorRetryPolicy$1);
  return systemErrorRetryPolicy$1;
}
var throttlingRetryPolicy$1 = {};
var hasRequiredThrottlingRetryPolicy$1;
function requireThrottlingRetryPolicy$1() {
  if (hasRequiredThrottlingRetryPolicy$1) return throttlingRetryPolicy$1;
  hasRequiredThrottlingRetryPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttlingRetryPolicyName = void 0;
    exports.throttlingRetryPolicy = throttlingRetryPolicy2;
    const throttlingRetryStrategy_js_1 = /* @__PURE__ */ requireThrottlingRetryStrategy();
    const retryPolicy_js_1 = /* @__PURE__ */ requireRetryPolicy$1();
    const constants_js_1 = /* @__PURE__ */ requireConstants$4();
    exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
    function throttlingRetryPolicy2(options2 = {}) {
      return {
        name: exports.throttlingRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
          maxRetries: options2.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  })(throttlingRetryPolicy$1);
  return throttlingRetryPolicy$1;
}
var hasRequiredInternal$1;
function requireInternal$1() {
  if (hasRequiredInternal$1) return internal$1;
  hasRequiredInternal$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.userAgentPolicyName = exports.userAgentPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.retryPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.defaultRetryPolicyName = exports.defaultRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.agentPolicyName = exports.agentPolicy = void 0;
    var agentPolicy_js_1 = /* @__PURE__ */ requireAgentPolicy$1();
    Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicy;
    } });
    Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicyName;
    } });
    var decompressResponsePolicy_js_1 = /* @__PURE__ */ requireDecompressResponsePolicy$1();
    Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicy;
    } });
    Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicyName;
    } });
    var defaultRetryPolicy_js_1 = /* @__PURE__ */ requireDefaultRetryPolicy$1();
    Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicy;
    } });
    Object.defineProperty(exports, "defaultRetryPolicyName", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicyName;
    } });
    var exponentialRetryPolicy_js_1 = /* @__PURE__ */ requireExponentialRetryPolicy$1();
    Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
    } });
    Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
    } });
    var retryPolicy_js_1 = /* @__PURE__ */ requireRetryPolicy$1();
    Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
      return retryPolicy_js_1.retryPolicy;
    } });
    var systemErrorRetryPolicy_js_1 = /* @__PURE__ */ requireSystemErrorRetryPolicy$1();
    Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
    } });
    Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
    } });
    var throttlingRetryPolicy_js_1 = /* @__PURE__ */ requireThrottlingRetryPolicy$1();
    Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
    } });
    Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
    } });
    var formDataPolicy_js_1 = /* @__PURE__ */ requireFormDataPolicy$1();
    Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicy;
    } });
    Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicyName;
    } });
    var logPolicy_js_1 = /* @__PURE__ */ requireLogPolicy$1();
    Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicy;
    } });
    Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicyName;
    } });
    var multipartPolicy_js_1 = /* @__PURE__ */ requireMultipartPolicy$1();
    Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicy;
    } });
    Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicyName;
    } });
    var proxyPolicy_js_1 = /* @__PURE__ */ requireProxyPolicy$1();
    Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicy;
    } });
    Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicyName;
    } });
    Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
      return proxyPolicy_js_1.getDefaultProxySettings;
    } });
    var redirectPolicy_js_1 = /* @__PURE__ */ requireRedirectPolicy$1();
    Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicy;
    } });
    Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicyName;
    } });
    var tlsPolicy_js_1 = /* @__PURE__ */ requireTlsPolicy$1();
    Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicy;
    } });
    Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicyName;
    } });
    var userAgentPolicy_js_1 = /* @__PURE__ */ requireUserAgentPolicy$1();
    Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicy;
    } });
    Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicyName;
    } });
  })(internal$1);
  return internal$1;
}
var hasRequiredLogPolicy;
function requireLogPolicy() {
  if (hasRequiredLogPolicy) return logPolicy;
  hasRequiredLogPolicy = 1;
  Object.defineProperty(logPolicy, "__esModule", { value: true });
  logPolicy.logPolicyName = void 0;
  logPolicy.logPolicy = logPolicy$12;
  const log_js_1 = /* @__PURE__ */ requireLog$3();
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  logPolicy.logPolicyName = policies_1.logPolicyName;
  function logPolicy$12(options2 = {}) {
    return (0, policies_1.logPolicy)({
      logger: log_js_1.logger.info,
      ...options2
    });
  }
  return logPolicy;
}
var redirectPolicy = {};
var hasRequiredRedirectPolicy;
function requireRedirectPolicy() {
  if (hasRequiredRedirectPolicy) return redirectPolicy;
  hasRequiredRedirectPolicy = 1;
  Object.defineProperty(redirectPolicy, "__esModule", { value: true });
  redirectPolicy.redirectPolicyName = void 0;
  redirectPolicy.redirectPolicy = redirectPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  redirectPolicy.redirectPolicyName = policies_1.redirectPolicyName;
  function redirectPolicy$12(options2 = {}) {
    return (0, policies_1.redirectPolicy)(options2);
  }
  return redirectPolicy;
}
var userAgentPolicy = {};
var userAgent$1 = {};
var userAgentPlatform = {};
var hasRequiredUserAgentPlatform;
function requireUserAgentPlatform() {
  if (hasRequiredUserAgentPlatform) return userAgentPlatform;
  hasRequiredUserAgentPlatform = 1;
  Object.defineProperty(userAgentPlatform, "__esModule", { value: true });
  userAgentPlatform.getHeaderName = getHeaderName;
  userAgentPlatform.setPlatformSpecificData = setPlatformSpecificData;
  const tslib_1 = require$$0$2;
  const node_os_1 = tslib_1.__importDefault(require$$1__default);
  const node_process_1 = tslib_1.__importDefault(require$$2$3);
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (node_process_1.default && node_process_1.default.versions) {
      const versions = node_process_1.default.versions;
      if (versions.bun) {
        map.set("Bun", versions.bun);
      } else if (versions.deno) {
        map.set("Deno", versions.deno);
      } else if (versions.node) {
        map.set("Node", versions.node);
      }
    }
    map.set("OS", `(${node_os_1.default.arch()}-${node_os_1.default.type()}-${node_os_1.default.release()})`);
  }
  return userAgentPlatform;
}
var constants$3 = {};
var hasRequiredConstants$3;
function requireConstants$3() {
  if (hasRequiredConstants$3) return constants$3;
  hasRequiredConstants$3 = 1;
  Object.defineProperty(constants$3, "__esModule", { value: true });
  constants$3.DEFAULT_RETRY_POLICY_COUNT = constants$3.SDK_VERSION = void 0;
  constants$3.SDK_VERSION = "1.22.1";
  constants$3.DEFAULT_RETRY_POLICY_COUNT = 3;
  return constants$3;
}
var hasRequiredUserAgent$1;
function requireUserAgent$1() {
  if (hasRequiredUserAgent$1) return userAgent$1;
  hasRequiredUserAgent$1 = 1;
  Object.defineProperty(userAgent$1, "__esModule", { value: true });
  userAgent$1.getUserAgentHeaderName = getUserAgentHeaderName;
  userAgent$1.getUserAgentValue = getUserAgentValue;
  const userAgentPlatform_js_1 = /* @__PURE__ */ requireUserAgentPlatform();
  const constants_js_1 = /* @__PURE__ */ requireConstants$3();
  function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    const runtimeInfo = /* @__PURE__ */ new Map();
    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
  return userAgent$1;
}
var hasRequiredUserAgentPolicy;
function requireUserAgentPolicy() {
  if (hasRequiredUserAgentPolicy) return userAgentPolicy;
  hasRequiredUserAgentPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.userAgentPolicyName = void 0;
    exports.userAgentPolicy = userAgentPolicy2;
    const userAgent_js_1 = /* @__PURE__ */ requireUserAgent$1();
    const UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
    exports.userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy2(options2 = {}) {
      const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options2.userAgentPrefix);
      return {
        name: exports.userAgentPolicyName,
        async sendRequest(request2, next) {
          if (!request2.headers.has(UserAgentHeaderName)) {
            request2.headers.set(UserAgentHeaderName, await userAgentValue);
          }
          return next(request2);
        }
      };
    }
  })(userAgentPolicy);
  return userAgentPolicy;
}
var multipartPolicy = {};
var file = {};
var commonjs$8 = {};
var internal = {};
var sha256 = {};
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256;
  hasRequiredSha256 = 1;
  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.computeSha256Hmac = computeSha256Hmac;
  sha256.computeSha256Hash = computeSha256Hash;
  const node_crypto_1 = require$$0$e;
  async function computeSha256Hmac(key, stringToSign, encoding2) {
    const decodedKey = Buffer.from(key, "base64");
    return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding2);
  }
  async function computeSha256Hash(content, encoding2) {
    return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding2);
  }
  return sha256;
}
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sanitizer = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isBrowser = exports.randomUUID = exports.computeSha256Hmac = exports.computeSha256Hash = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.calculateRetryDelay = void 0;
    var delay_js_1 = /* @__PURE__ */ requireDelay$1();
    Object.defineProperty(exports, "calculateRetryDelay", { enumerable: true, get: function() {
      return delay_js_1.calculateRetryDelay;
    } });
    var random_js_1 = /* @__PURE__ */ requireRandom();
    Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: true, get: function() {
      return random_js_1.getRandomIntegerInclusive;
    } });
    var object_js_1 = /* @__PURE__ */ requireObject();
    Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
      return object_js_1.isObject;
    } });
    var error_js_1 = /* @__PURE__ */ requireError$1();
    Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
      return error_js_1.isError;
    } });
    var sha256_js_1 = /* @__PURE__ */ requireSha256();
    Object.defineProperty(exports, "computeSha256Hash", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hash;
    } });
    Object.defineProperty(exports, "computeSha256Hmac", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hmac;
    } });
    var uuidUtils_js_1 = /* @__PURE__ */ requireUuidUtils();
    Object.defineProperty(exports, "randomUUID", { enumerable: true, get: function() {
      return uuidUtils_js_1.randomUUID;
    } });
    var checkEnvironment_js_1 = /* @__PURE__ */ requireCheckEnvironment();
    Object.defineProperty(exports, "isBrowser", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBrowser;
    } });
    Object.defineProperty(exports, "isBun", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBun;
    } });
    Object.defineProperty(exports, "isNodeLike", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeLike;
    } });
    Object.defineProperty(exports, "isNodeRuntime", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeRuntime;
    } });
    Object.defineProperty(exports, "isDeno", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isDeno;
    } });
    Object.defineProperty(exports, "isReactNative", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isReactNative;
    } });
    Object.defineProperty(exports, "isWebWorker", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isWebWorker;
    } });
    var bytesEncoding_js_1 = /* @__PURE__ */ requireBytesEncoding();
    Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
    Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    var sanitizer_js_1 = /* @__PURE__ */ requireSanitizer();
    Object.defineProperty(exports, "Sanitizer", { enumerable: true, get: function() {
      return sanitizer_js_1.Sanitizer;
    } });
  })(internal);
  return internal;
}
var aborterUtils = {};
var hasRequiredAborterUtils;
function requireAborterUtils() {
  if (hasRequiredAborterUtils) return aborterUtils;
  hasRequiredAborterUtils = 1;
  Object.defineProperty(aborterUtils, "__esModule", { value: true });
  aborterUtils.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options2) {
    const aborter = new AbortController();
    function abortHandler() {
      aborter.abort();
    }
    options2?.abortSignal?.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort();
      options2?.abortSignal?.removeEventListener("abort", abortHandler);
    }
  }
  return aborterUtils;
}
var createAbortablePromise = {};
var commonjs$7 = {};
var AbortError$1 = {};
var hasRequiredAbortError;
function requireAbortError() {
  if (hasRequiredAbortError) return AbortError$1;
  hasRequiredAbortError = 1;
  Object.defineProperty(AbortError$1, "__esModule", { value: true });
  AbortError$1.AbortError = void 0;
  class AbortError2 extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  AbortError$1.AbortError = AbortError2;
  return AbortError$1;
}
var hasRequiredCommonjs$a;
function requireCommonjs$a() {
  if (hasRequiredCommonjs$a) return commonjs$7;
  hasRequiredCommonjs$a = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbortError = void 0;
    var AbortError_js_1 = /* @__PURE__ */ requireAbortError();
    Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
  })(commonjs$7);
  return commonjs$7;
}
var hasRequiredCreateAbortablePromise;
function requireCreateAbortablePromise() {
  if (hasRequiredCreateAbortablePromise) return createAbortablePromise;
  hasRequiredCreateAbortablePromise = 1;
  Object.defineProperty(createAbortablePromise, "__esModule", { value: true });
  createAbortablePromise.createAbortablePromise = createAbortablePromise$1;
  const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
  function createAbortablePromise$1(buildPromise, options2) {
    const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options2 ?? {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal2?.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort?.();
        removeListeners();
        rejectOnAbort();
      }
      if (abortSignal2?.aborted) {
        return rejectOnAbort();
      }
      try {
        buildPromise((x) => {
          removeListeners();
          resolve(x);
        }, (x) => {
          removeListeners();
          reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal2?.addEventListener("abort", onAbort);
    });
  }
  return createAbortablePromise;
}
var delay$1 = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay$1;
  hasRequiredDelay = 1;
  Object.defineProperty(delay$1, "__esModule", { value: true });
  delay$1.delay = delay2;
  delay$1.calculateRetryDelay = calculateRetryDelay;
  const createAbortablePromise_js_1 = /* @__PURE__ */ requireCreateAbortablePromise();
  const util_1 = /* @__PURE__ */ requireInternal();
  const StandardAbortMessage = "The delay was aborted.";
  function delay2(timeInMs, options2) {
    let token;
    const { abortSignal: abortSignal2, abortErrorMsg } = options2 ?? {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal: abortSignal2,
      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
    });
  }
  function calculateRetryDelay(retryAttempt, config2) {
    const exponentialDelay = config2.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config2.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
  return delay$1;
}
var error = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.getErrorMessage = getErrorMessage;
  const util_1 = /* @__PURE__ */ requireInternal();
  function getErrorMessage(e) {
    if ((0, util_1.isError)(e)) {
      return e.message;
    } else {
      let stringified;
      try {
        if (typeof e === "object" && e) {
          stringified = JSON.stringify(e);
        } else {
          stringified = String(e);
        }
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
  return error;
}
var typeGuards = {};
var hasRequiredTypeGuards;
function requireTypeGuards() {
  if (hasRequiredTypeGuards) return typeGuards;
  hasRequiredTypeGuards = 1;
  Object.defineProperty(typeGuards, "__esModule", { value: true });
  typeGuards.isDefined = isDefined;
  typeGuards.isObjectWithProperties = isObjectWithProperties;
  typeGuards.objectHasProperty = objectHasProperty;
  function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
      return false;
    }
    for (const property of properties) {
      if (!objectHasProperty(thing, property)) {
        return false;
      }
    }
    return true;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
  return typeGuards;
}
var hasRequiredCommonjs$9;
function requireCommonjs$9() {
  if (hasRequiredCommonjs$9) return commonjs$8;
  hasRequiredCommonjs$9 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = void 0;
    exports.calculateRetryDelay = calculateRetryDelay;
    exports.computeSha256Hash = computeSha256Hash;
    exports.computeSha256Hmac = computeSha256Hmac;
    exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
    exports.isError = isError;
    exports.isObject = isObject;
    exports.randomUUID = randomUUID;
    exports.uint8ArrayToString = uint8ArrayToString;
    exports.stringToUint8Array = stringToUint8Array;
    const tslib_1 = require$$0$2;
    const tspRuntime = tslib_1.__importStar(/* @__PURE__ */ requireInternal());
    var aborterUtils_js_1 = /* @__PURE__ */ requireAborterUtils();
    Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: true, get: function() {
      return aborterUtils_js_1.cancelablePromiseRace;
    } });
    var createAbortablePromise_js_1 = /* @__PURE__ */ requireCreateAbortablePromise();
    Object.defineProperty(exports, "createAbortablePromise", { enumerable: true, get: function() {
      return createAbortablePromise_js_1.createAbortablePromise;
    } });
    var delay_js_1 = /* @__PURE__ */ requireDelay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_js_1.delay;
    } });
    var error_js_1 = /* @__PURE__ */ requireError();
    Object.defineProperty(exports, "getErrorMessage", { enumerable: true, get: function() {
      return error_js_1.getErrorMessage;
    } });
    var typeGuards_js_1 = /* @__PURE__ */ requireTypeGuards();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return typeGuards_js_1.isDefined;
    } });
    Object.defineProperty(exports, "isObjectWithProperties", { enumerable: true, get: function() {
      return typeGuards_js_1.isObjectWithProperties;
    } });
    Object.defineProperty(exports, "objectHasProperty", { enumerable: true, get: function() {
      return typeGuards_js_1.objectHasProperty;
    } });
    function calculateRetryDelay(retryAttempt, config2) {
      return tspRuntime.calculateRetryDelay(retryAttempt, config2);
    }
    function computeSha256Hash(content, encoding2) {
      return tspRuntime.computeSha256Hash(content, encoding2);
    }
    function computeSha256Hmac(key, stringToSign, encoding2) {
      return tspRuntime.computeSha256Hmac(key, stringToSign, encoding2);
    }
    function getRandomIntegerInclusive(min, max) {
      return tspRuntime.getRandomIntegerInclusive(min, max);
    }
    function isError(e) {
      return tspRuntime.isError(e);
    }
    function isObject(input) {
      return tspRuntime.isObject(input);
    }
    function randomUUID() {
      return tspRuntime.randomUUID();
    }
    exports.isBrowser = tspRuntime.isBrowser;
    exports.isBun = tspRuntime.isBun;
    exports.isDeno = tspRuntime.isDeno;
    exports.isNode = tspRuntime.isNodeLike;
    exports.isNodeLike = tspRuntime.isNodeLike;
    exports.isNodeRuntime = tspRuntime.isNodeRuntime;
    exports.isReactNative = tspRuntime.isReactNative;
    exports.isWebWorker = tspRuntime.isWebWorker;
    function uint8ArrayToString(bytes, format) {
      return tspRuntime.uint8ArrayToString(bytes, format);
    }
    function stringToUint8Array(value, format) {
      return tspRuntime.stringToUint8Array(value, format);
    }
  })(commonjs$8);
  return commonjs$8;
}
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file;
  hasRequiredFile = 1;
  Object.defineProperty(file, "__esModule", { value: true });
  file.hasRawContent = hasRawContent;
  file.getRawContent = getRawContent;
  file.createFileFromStream = createFileFromStream;
  file.createFile = createFile;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x["pipe"] === "function");
  }
  const unimplementedMethods = {
    arrayBuffer: () => {
      throw new Error("Not implemented");
    },
    bytes: () => {
      throw new Error("Not implemented");
    },
    slice: () => {
      throw new Error("Not implemented");
    },
    text: () => {
      throw new Error("Not implemented");
    }
  };
  const rawContent = Symbol("rawContent");
  function hasRawContent(x) {
    return typeof x[rawContent] === "function";
  }
  function getRawContent(blob2) {
    if (hasRawContent(blob2)) {
      return blob2[rawContent]();
    } else {
      return blob2;
    }
  }
  function createFileFromStream(stream, name, options2 = {}) {
    return {
      ...unimplementedMethods,
      type: options2.type ?? "",
      lastModified: options2.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
      webkitRelativePath: options2.webkitRelativePath ?? "",
      size: options2.size ?? -1,
      name,
      stream: () => {
        const s = stream();
        if (isNodeReadableStream(s)) {
          throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
        }
        return s;
      },
      [rawContent]: stream
    };
  }
  function createFile(content, name, options2 = {}) {
    if (core_util_1.isNodeLike) {
      return {
        ...unimplementedMethods,
        type: options2.type ?? "",
        lastModified: options2.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
        webkitRelativePath: options2.webkitRelativePath ?? "",
        size: content.byteLength,
        name,
        arrayBuffer: async () => content.buffer,
        stream: () => new Blob([content]).stream(),
        [rawContent]: () => content
      };
    } else {
      return new File([content], name, options2);
    }
  }
  return file;
}
var hasRequiredMultipartPolicy;
function requireMultipartPolicy() {
  if (hasRequiredMultipartPolicy) return multipartPolicy;
  hasRequiredMultipartPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multipartPolicyName = void 0;
    exports.multipartPolicy = multipartPolicy2;
    const policies_1 = /* @__PURE__ */ requireInternal$1();
    const file_js_1 = /* @__PURE__ */ requireFile();
    exports.multipartPolicyName = policies_1.multipartPolicyName;
    function multipartPolicy2() {
      const tspPolicy = (0, policies_1.multipartPolicy)();
      return {
        name: exports.multipartPolicyName,
        sendRequest: async (request2, next) => {
          if (request2.multipartBody) {
            for (const part of request2.multipartBody.parts) {
              if ((0, file_js_1.hasRawContent)(part.body)) {
                part.body = (0, file_js_1.getRawContent)(part.body);
              }
            }
          }
          return tspPolicy.sendRequest(request2, next);
        }
      };
    }
  })(multipartPolicy);
  return multipartPolicy;
}
var decompressResponsePolicy = {};
var hasRequiredDecompressResponsePolicy;
function requireDecompressResponsePolicy() {
  if (hasRequiredDecompressResponsePolicy) return decompressResponsePolicy;
  hasRequiredDecompressResponsePolicy = 1;
  Object.defineProperty(decompressResponsePolicy, "__esModule", { value: true });
  decompressResponsePolicy.decompressResponsePolicyName = void 0;
  decompressResponsePolicy.decompressResponsePolicy = decompressResponsePolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  decompressResponsePolicy.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
  function decompressResponsePolicy$12() {
    return (0, policies_1.decompressResponsePolicy)();
  }
  return decompressResponsePolicy;
}
var defaultRetryPolicy = {};
var hasRequiredDefaultRetryPolicy;
function requireDefaultRetryPolicy() {
  if (hasRequiredDefaultRetryPolicy) return defaultRetryPolicy;
  hasRequiredDefaultRetryPolicy = 1;
  Object.defineProperty(defaultRetryPolicy, "__esModule", { value: true });
  defaultRetryPolicy.defaultRetryPolicyName = void 0;
  defaultRetryPolicy.defaultRetryPolicy = defaultRetryPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  defaultRetryPolicy.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
  function defaultRetryPolicy$12(options2 = {}) {
    return (0, policies_1.defaultRetryPolicy)(options2);
  }
  return defaultRetryPolicy;
}
var formDataPolicy = {};
var hasRequiredFormDataPolicy;
function requireFormDataPolicy() {
  if (hasRequiredFormDataPolicy) return formDataPolicy;
  hasRequiredFormDataPolicy = 1;
  Object.defineProperty(formDataPolicy, "__esModule", { value: true });
  formDataPolicy.formDataPolicyName = void 0;
  formDataPolicy.formDataPolicy = formDataPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  formDataPolicy.formDataPolicyName = policies_1.formDataPolicyName;
  function formDataPolicy$12() {
    return (0, policies_1.formDataPolicy)();
  }
  return formDataPolicy;
}
var proxyPolicy = {};
var hasRequiredProxyPolicy;
function requireProxyPolicy() {
  if (hasRequiredProxyPolicy) return proxyPolicy;
  hasRequiredProxyPolicy = 1;
  Object.defineProperty(proxyPolicy, "__esModule", { value: true });
  proxyPolicy.proxyPolicyName = void 0;
  proxyPolicy.getDefaultProxySettings = getDefaultProxySettings;
  proxyPolicy.proxyPolicy = proxyPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  proxyPolicy.proxyPolicyName = policies_1.proxyPolicyName;
  function getDefaultProxySettings(proxyUrl) {
    return (0, policies_1.getDefaultProxySettings)(proxyUrl);
  }
  function proxyPolicy$12(proxySettings, options2) {
    return (0, policies_1.proxyPolicy)(proxySettings, options2);
  }
  return proxyPolicy;
}
var setClientRequestIdPolicy = {};
var hasRequiredSetClientRequestIdPolicy;
function requireSetClientRequestIdPolicy() {
  if (hasRequiredSetClientRequestIdPolicy) return setClientRequestIdPolicy;
  hasRequiredSetClientRequestIdPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setClientRequestIdPolicyName = void 0;
    exports.setClientRequestIdPolicy = setClientRequestIdPolicy2;
    exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
    function setClientRequestIdPolicy2(requestIdHeaderName = "x-ms-client-request-id") {
      return {
        name: exports.setClientRequestIdPolicyName,
        async sendRequest(request2, next) {
          if (!request2.headers.has(requestIdHeaderName)) {
            request2.headers.set(requestIdHeaderName, request2.requestId);
          }
          return next(request2);
        }
      };
    }
  })(setClientRequestIdPolicy);
  return setClientRequestIdPolicy;
}
var agentPolicy = {};
var hasRequiredAgentPolicy;
function requireAgentPolicy() {
  if (hasRequiredAgentPolicy) return agentPolicy;
  hasRequiredAgentPolicy = 1;
  Object.defineProperty(agentPolicy, "__esModule", { value: true });
  agentPolicy.agentPolicyName = void 0;
  agentPolicy.agentPolicy = agentPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  agentPolicy.agentPolicyName = policies_1.agentPolicyName;
  function agentPolicy$12(agent2) {
    return (0, policies_1.agentPolicy)(agent2);
  }
  return agentPolicy;
}
var tlsPolicy = {};
var hasRequiredTlsPolicy;
function requireTlsPolicy() {
  if (hasRequiredTlsPolicy) return tlsPolicy;
  hasRequiredTlsPolicy = 1;
  Object.defineProperty(tlsPolicy, "__esModule", { value: true });
  tlsPolicy.tlsPolicyName = void 0;
  tlsPolicy.tlsPolicy = tlsPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  tlsPolicy.tlsPolicyName = policies_1.tlsPolicyName;
  function tlsPolicy$12(tlsSettings) {
    return (0, policies_1.tlsPolicy)(tlsSettings);
  }
  return tlsPolicy;
}
var tracingPolicy = {};
var commonjs$6 = {};
var instrumenter = {};
var tracingContext = {};
var hasRequiredTracingContext;
function requireTracingContext() {
  if (hasRequiredTracingContext) return tracingContext;
  hasRequiredTracingContext = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracingContextImpl = exports.knownContextKeys = void 0;
    exports.createTracingContext = createTracingContext;
    exports.knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    function createTracingContext(options2 = {}) {
      let context = new TracingContextImpl(options2.parentContext);
      if (options2.span) {
        context = context.setValue(exports.knownContextKeys.span, options2.span);
      }
      if (options2.namespace) {
        context = context.setValue(exports.knownContextKeys.namespace, options2.namespace);
      }
      return context;
    }
    class TracingContextImpl {
      _contextMap;
      constructor(initialContext) {
        this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    }
    exports.TracingContextImpl = TracingContextImpl;
  })(tracingContext);
  return tracingContext;
}
var state$1 = {};
var hasRequiredState$1;
function requireState$1() {
  if (hasRequiredState$1) return state$1;
  hasRequiredState$1 = 1;
  Object.defineProperty(state$1, "__esModule", { value: true });
  state$1.state = void 0;
  state$1.state = {
    instrumenterImplementation: void 0
  };
  return state$1;
}
var hasRequiredInstrumenter;
function requireInstrumenter() {
  if (hasRequiredInstrumenter) return instrumenter;
  hasRequiredInstrumenter = 1;
  Object.defineProperty(instrumenter, "__esModule", { value: true });
  instrumenter.createDefaultTracingSpan = createDefaultTracingSpan;
  instrumenter.createDefaultInstrumenter = createDefaultInstrumenter;
  instrumenter.useInstrumenter = useInstrumenter;
  instrumenter.getInstrumenter = getInstrumenter;
  const tracingContext_js_1 = /* @__PURE__ */ requireTracingContext();
  const state_js_1 = /* @__PURE__ */ requireState$1();
  function createDefaultTracingSpan() {
    return {
      end: () => {
      },
      isRecording: () => false,
      recordException: () => {
      },
      setAttribute: () => {
      },
      setStatus: () => {
      },
      addEvent: () => {
      }
    };
  }
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return void 0;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter2) {
    state_js_1.state.instrumenterImplementation = instrumenter2;
  }
  function getInstrumenter() {
    if (!state_js_1.state.instrumenterImplementation) {
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
    }
    return state_js_1.state.instrumenterImplementation;
  }
  return instrumenter;
}
var tracingClient = {};
var hasRequiredTracingClient;
function requireTracingClient() {
  if (hasRequiredTracingClient) return tracingClient;
  hasRequiredTracingClient = 1;
  Object.defineProperty(tracingClient, "__esModule", { value: true });
  tracingClient.createTracingClient = createTracingClient;
  const instrumenter_js_1 = /* @__PURE__ */ requireInstrumenter();
  const tracingContext_js_1 = /* @__PURE__ */ requireTracingContext();
  function createTracingClient(options2) {
    const { namespace, packageName, packageVersion } = options2;
    function startSpan(name, operationOptions, spanOptions) {
      const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, {
        ...spanOptions,
        packageName,
        packageVersion,
        tracingContext: operationOptions?.tracingOptions?.tracingContext
      });
      let tracingContext2 = startSpanResult.tracingContext;
      const span = startSpanResult.span;
      if (!tracingContext2.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
        tracingContext2 = tracingContext2.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      }
      span.setAttribute("az.namespace", tracingContext2.getValue(tracingContext_js_1.knownContextKeys.namespace));
      const updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: { ...operationOptions?.tracingOptions, tracingContext: tracingContext2 }
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        span.setStatus({ status: "success" });
        return result;
      } catch (err) {
        span.setStatus({ status: "error", error: err });
        throw err;
      } finally {
        span.end();
      }
    }
    function withContext(context, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext2) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext2);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
  return tracingClient;
}
var hasRequiredCommonjs$8;
function requireCommonjs$8() {
  if (hasRequiredCommonjs$8) return commonjs$6;
  hasRequiredCommonjs$8 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTracingClient = exports.useInstrumenter = void 0;
    var instrumenter_js_1 = /* @__PURE__ */ requireInstrumenter();
    Object.defineProperty(exports, "useInstrumenter", { enumerable: true, get: function() {
      return instrumenter_js_1.useInstrumenter;
    } });
    var tracingClient_js_1 = /* @__PURE__ */ requireTracingClient();
    Object.defineProperty(exports, "createTracingClient", { enumerable: true, get: function() {
      return tracingClient_js_1.createTracingClient;
    } });
  })(commonjs$6);
  return commonjs$6;
}
var restError = {};
var hasRequiredRestError;
function requireRestError() {
  if (hasRequiredRestError) return restError;
  hasRequiredRestError = 1;
  Object.defineProperty(restError, "__esModule", { value: true });
  restError.RestError = void 0;
  restError.isRestError = isRestError;
  const ts_http_runtime_1 = /* @__PURE__ */ requireCommonjs$c();
  restError.RestError = ts_http_runtime_1.RestError;
  function isRestError(e) {
    return (0, ts_http_runtime_1.isRestError)(e);
  }
  return restError;
}
var hasRequiredTracingPolicy;
function requireTracingPolicy() {
  if (hasRequiredTracingPolicy) return tracingPolicy;
  hasRequiredTracingPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tracingPolicyName = void 0;
    exports.tracingPolicy = tracingPolicy2;
    const core_tracing_1 = /* @__PURE__ */ requireCommonjs$8();
    const constants_js_1 = /* @__PURE__ */ requireConstants$3();
    const userAgent_js_1 = /* @__PURE__ */ requireUserAgent$1();
    const log_js_1 = /* @__PURE__ */ requireLog$3();
    const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
    const restError_js_1 = /* @__PURE__ */ requireRestError();
    const util_1 = /* @__PURE__ */ requireInternal();
    exports.tracingPolicyName = "tracingPolicy";
    function tracingPolicy2(options2 = {}) {
      const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options2.userAgentPrefix);
      const sanitizer2 = new util_1.Sanitizer({
        additionalAllowedQueryParameters: options2.additionalAllowedQueryParameters
      });
      const tracingClient2 = tryCreateTracingClient();
      return {
        name: exports.tracingPolicyName,
        async sendRequest(request2, next) {
          if (!tracingClient2) {
            return next(request2);
          }
          const userAgent2 = await userAgentPromise;
          const spanAttributes = {
            "http.url": sanitizer2.sanitizeUrl(request2.url),
            "http.method": request2.method,
            "http.user_agent": userAgent2,
            requestId: request2.requestId
          };
          if (userAgent2) {
            spanAttributes["http.user_agent"] = userAgent2;
          }
          const { span, tracingContext: tracingContext2 } = tryCreateSpan(tracingClient2, request2, spanAttributes) ?? {};
          if (!span || !tracingContext2) {
            return next(request2);
          }
          try {
            const response2 = await tracingClient2.withContext(tracingContext2, next, request2);
            tryProcessResponse(span, response2);
            return response2;
          } catch (err) {
            tryProcessError(span, err);
            throw err;
          }
        }
      };
    }
    function tryCreateTracingClient() {
      try {
        return (0, core_tracing_1.createTracingClient)({
          namespace: "",
          packageName: "@azure/core-rest-pipeline",
          packageVersion: constants_js_1.SDK_VERSION
        });
      } catch (e) {
        log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
        return void 0;
      }
    }
    function tryCreateSpan(tracingClient2, request2, spanAttributes) {
      try {
        const { span, updatedOptions } = tracingClient2.startSpan(`HTTP ${request2.method}`, { tracingOptions: request2.tracingOptions }, {
          spanKind: "client",
          spanAttributes
        });
        if (!span.isRecording()) {
          span.end();
          return void 0;
        }
        const headers2 = tracingClient2.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers2)) {
          request2.headers.set(key, value);
        }
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
      } catch (e) {
        log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
        return void 0;
      }
    }
    function tryProcessError(span, error2) {
      try {
        span.setStatus({
          status: "error",
          error: (0, core_util_1.isError)(error2) ? error2 : void 0
        });
        if ((0, restError_js_1.isRestError)(error2) && error2.statusCode) {
          span.setAttribute("http.status_code", error2.statusCode);
        }
        span.end();
      } catch (e) {
        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      }
    }
    function tryProcessResponse(span, response2) {
      try {
        span.setAttribute("http.status_code", response2.status);
        const serviceRequestId = response2.headers.get("x-ms-request-id");
        if (serviceRequestId) {
          span.setAttribute("serviceRequestId", serviceRequestId);
        }
        if (response2.status >= 400) {
          span.setStatus({
            status: "error"
          });
        }
        span.end();
      } catch (e) {
        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      }
    }
  })(tracingPolicy);
  return tracingPolicy;
}
var wrapAbortSignalLikePolicy = {};
var wrapAbortSignal = {};
var hasRequiredWrapAbortSignal;
function requireWrapAbortSignal() {
  if (hasRequiredWrapAbortSignal) return wrapAbortSignal;
  hasRequiredWrapAbortSignal = 1;
  Object.defineProperty(wrapAbortSignal, "__esModule", { value: true });
  wrapAbortSignal.wrapAbortSignalLike = wrapAbortSignalLike;
  function wrapAbortSignalLike(abortSignalLike) {
    if (abortSignalLike instanceof AbortSignal) {
      return { abortSignal: abortSignalLike };
    }
    if (abortSignalLike.aborted) {
      return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
    }
    const controller = new AbortController();
    let needsCleanup = true;
    function cleanup() {
      if (needsCleanup) {
        abortSignalLike.removeEventListener("abort", listener);
        needsCleanup = false;
      }
    }
    function listener() {
      controller.abort(abortSignalLike.reason);
      cleanup();
    }
    abortSignalLike.addEventListener("abort", listener);
    return { abortSignal: controller.signal, cleanup };
  }
  return wrapAbortSignal;
}
var hasRequiredWrapAbortSignalLikePolicy;
function requireWrapAbortSignalLikePolicy() {
  if (hasRequiredWrapAbortSignalLikePolicy) return wrapAbortSignalLikePolicy;
  hasRequiredWrapAbortSignalLikePolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapAbortSignalLikePolicyName = void 0;
    exports.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy2;
    const wrapAbortSignal_js_1 = /* @__PURE__ */ requireWrapAbortSignal();
    exports.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
    function wrapAbortSignalLikePolicy2() {
      return {
        name: exports.wrapAbortSignalLikePolicyName,
        sendRequest: async (request2, next) => {
          if (!request2.abortSignal) {
            return next(request2);
          }
          const { abortSignal: abortSignal2, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request2.abortSignal);
          request2.abortSignal = abortSignal2;
          try {
            return await next(request2);
          } finally {
            cleanup?.();
          }
        }
      };
    }
  })(wrapAbortSignalLikePolicy);
  return wrapAbortSignalLikePolicy;
}
var hasRequiredCreatePipelineFromOptions;
function requireCreatePipelineFromOptions() {
  if (hasRequiredCreatePipelineFromOptions) return createPipelineFromOptions;
  hasRequiredCreatePipelineFromOptions = 1;
  Object.defineProperty(createPipelineFromOptions, "__esModule", { value: true });
  createPipelineFromOptions.createPipelineFromOptions = createPipelineFromOptions$12;
  const logPolicy_js_1 = /* @__PURE__ */ requireLogPolicy();
  const pipeline_js_1 = /* @__PURE__ */ requirePipeline$2();
  const redirectPolicy_js_1 = /* @__PURE__ */ requireRedirectPolicy();
  const userAgentPolicy_js_1 = /* @__PURE__ */ requireUserAgentPolicy();
  const multipartPolicy_js_1 = /* @__PURE__ */ requireMultipartPolicy();
  const decompressResponsePolicy_js_1 = /* @__PURE__ */ requireDecompressResponsePolicy();
  const defaultRetryPolicy_js_1 = /* @__PURE__ */ requireDefaultRetryPolicy();
  const formDataPolicy_js_1 = /* @__PURE__ */ requireFormDataPolicy();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const proxyPolicy_js_1 = /* @__PURE__ */ requireProxyPolicy();
  const setClientRequestIdPolicy_js_1 = /* @__PURE__ */ requireSetClientRequestIdPolicy();
  const agentPolicy_js_1 = /* @__PURE__ */ requireAgentPolicy();
  const tlsPolicy_js_1 = /* @__PURE__ */ requireTlsPolicy();
  const tracingPolicy_js_1 = /* @__PURE__ */ requireTracingPolicy();
  const wrapAbortSignalLikePolicy_js_1 = /* @__PURE__ */ requireWrapAbortSignalLikePolicy();
  function createPipelineFromOptions$12(options2) {
    const pipeline2 = (0, pipeline_js_1.createEmptyPipeline)();
    if (core_util_1.isNodeLike) {
      if (options2.agent) {
        pipeline2.addPolicy((0, agentPolicy_js_1.agentPolicy)(options2.agent));
      }
      if (options2.tlsOptions) {
        pipeline2.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options2.tlsOptions));
      }
      pipeline2.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options2.proxyOptions));
      pipeline2.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline2.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
    pipeline2.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline2.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options2.userAgentOptions));
    pipeline2.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options2.telemetryOptions?.clientRequestIdHeaderName));
    pipeline2.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline2.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options2.retryOptions), { phase: "Retry" });
    pipeline2.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({ ...options2.userAgentOptions, ...options2.loggingOptions }), {
      afterPhase: "Retry"
    });
    if (core_util_1.isNodeLike) {
      pipeline2.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options2.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline2.addPolicy((0, logPolicy_js_1.logPolicy)(options2.loggingOptions), { afterPhase: "Sign" });
    return pipeline2;
  }
  return createPipelineFromOptions;
}
var defaultHttpClient = {};
var hasRequiredDefaultHttpClient;
function requireDefaultHttpClient() {
  if (hasRequiredDefaultHttpClient) return defaultHttpClient;
  hasRequiredDefaultHttpClient = 1;
  Object.defineProperty(defaultHttpClient, "__esModule", { value: true });
  defaultHttpClient.createDefaultHttpClient = createDefaultHttpClient;
  const ts_http_runtime_1 = /* @__PURE__ */ requireCommonjs$c();
  const wrapAbortSignal_js_1 = /* @__PURE__ */ requireWrapAbortSignal();
  function createDefaultHttpClient() {
    const client2 = (0, ts_http_runtime_1.createDefaultHttpClient)();
    return {
      async sendRequest(request2) {
        const { abortSignal: abortSignal2, cleanup } = request2.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request2.abortSignal) : {};
        try {
          request2.abortSignal = abortSignal2;
          return await client2.sendRequest(request2);
        } finally {
          cleanup?.();
        }
      }
    };
  }
  return defaultHttpClient;
}
var httpHeaders = {};
var hasRequiredHttpHeaders;
function requireHttpHeaders() {
  if (hasRequiredHttpHeaders) return httpHeaders;
  hasRequiredHttpHeaders = 1;
  Object.defineProperty(httpHeaders, "__esModule", { value: true });
  httpHeaders.createHttpHeaders = createHttpHeaders;
  const ts_http_runtime_1 = /* @__PURE__ */ requireCommonjs$c();
  function createHttpHeaders(rawHeaders) {
    return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
  }
  return httpHeaders;
}
var pipelineRequest = {};
var hasRequiredPipelineRequest;
function requirePipelineRequest() {
  if (hasRequiredPipelineRequest) return pipelineRequest;
  hasRequiredPipelineRequest = 1;
  Object.defineProperty(pipelineRequest, "__esModule", { value: true });
  pipelineRequest.createPipelineRequest = createPipelineRequest;
  const ts_http_runtime_1 = /* @__PURE__ */ requireCommonjs$c();
  function createPipelineRequest(options2) {
    return (0, ts_http_runtime_1.createPipelineRequest)(options2);
  }
  return pipelineRequest;
}
var exponentialRetryPolicy = {};
var hasRequiredExponentialRetryPolicy;
function requireExponentialRetryPolicy() {
  if (hasRequiredExponentialRetryPolicy) return exponentialRetryPolicy;
  hasRequiredExponentialRetryPolicy = 1;
  Object.defineProperty(exponentialRetryPolicy, "__esModule", { value: true });
  exponentialRetryPolicy.exponentialRetryPolicyName = void 0;
  exponentialRetryPolicy.exponentialRetryPolicy = exponentialRetryPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  exponentialRetryPolicy.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
  function exponentialRetryPolicy$12(options2 = {}) {
    return (0, policies_1.exponentialRetryPolicy)(options2);
  }
  return exponentialRetryPolicy;
}
var systemErrorRetryPolicy = {};
var hasRequiredSystemErrorRetryPolicy;
function requireSystemErrorRetryPolicy() {
  if (hasRequiredSystemErrorRetryPolicy) return systemErrorRetryPolicy;
  hasRequiredSystemErrorRetryPolicy = 1;
  Object.defineProperty(systemErrorRetryPolicy, "__esModule", { value: true });
  systemErrorRetryPolicy.systemErrorRetryPolicyName = void 0;
  systemErrorRetryPolicy.systemErrorRetryPolicy = systemErrorRetryPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  systemErrorRetryPolicy.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
  function systemErrorRetryPolicy$12(options2 = {}) {
    return (0, policies_1.systemErrorRetryPolicy)(options2);
  }
  return systemErrorRetryPolicy;
}
var throttlingRetryPolicy = {};
var hasRequiredThrottlingRetryPolicy;
function requireThrottlingRetryPolicy() {
  if (hasRequiredThrottlingRetryPolicy) return throttlingRetryPolicy;
  hasRequiredThrottlingRetryPolicy = 1;
  Object.defineProperty(throttlingRetryPolicy, "__esModule", { value: true });
  throttlingRetryPolicy.throttlingRetryPolicyName = void 0;
  throttlingRetryPolicy.throttlingRetryPolicy = throttlingRetryPolicy$12;
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  throttlingRetryPolicy.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
  function throttlingRetryPolicy$12(options2 = {}) {
    return (0, policies_1.throttlingRetryPolicy)(options2);
  }
  return throttlingRetryPolicy;
}
var retryPolicy = {};
var hasRequiredRetryPolicy;
function requireRetryPolicy() {
  if (hasRequiredRetryPolicy) return retryPolicy;
  hasRequiredRetryPolicy = 1;
  Object.defineProperty(retryPolicy, "__esModule", { value: true });
  retryPolicy.retryPolicy = retryPolicy$12;
  const logger_1 = /* @__PURE__ */ requireCommonjs$b();
  const constants_js_1 = /* @__PURE__ */ requireConstants$3();
  const policies_1 = /* @__PURE__ */ requireInternal$1();
  const retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
  function retryPolicy$12(strategies, options2 = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    return (0, policies_1.retryPolicy)(strategies, {
      logger: retryPolicyLogger,
      ...options2
    });
  }
  return retryPolicy;
}
var bearerTokenAuthenticationPolicy = {};
var tokenCycler = {};
var hasRequiredTokenCycler;
function requireTokenCycler() {
  if (hasRequiredTokenCycler) return tokenCycler;
  hasRequiredTokenCycler = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_CYCLER_OPTIONS = void 0;
    exports.createTokenCycler = createTokenCycler;
    const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
    exports.DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      // Force waiting for a refresh 1s before the token expires
      retryIntervalInMs: 3e3,
      // Allow refresh attempts every 3s
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
    async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
      async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
          try {
            return await getAccessToken();
          } catch {
            return null;
          }
        } else {
          const finalToken = await getAccessToken();
          if (finalToken === null) {
            throw new Error("Failed to refresh access token.");
          }
          return finalToken;
        }
      }
      let token = await tryGetAccessToken();
      while (token === null) {
        await (0, core_util_1.delay)(retryIntervalInMs);
        token = await tryGetAccessToken();
      }
      return token;
    }
    function createTokenCycler(credential, tokenCyclerOptions) {
      let refreshWorker = null;
      let token = null;
      let tenantId;
      const options2 = {
        ...exports.DEFAULT_CYCLER_OPTIONS,
        ...tokenCyclerOptions
      };
      const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
          return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
          if (cycler.isRefreshing) {
            return false;
          }
          if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
            return true;
          }
          return (token?.expiresOnTimestamp ?? 0) - options2.refreshWindowInMs < Date.now();
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
          return token === null || token.expiresOnTimestamp - options2.forcedRefreshWindowInMs < Date.now();
        }
      };
      function refresh(scopes, getTokenOptions) {
        if (!cycler.isRefreshing) {
          const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
          refreshWorker = beginRefresh(
            tryGetAccessToken,
            options2.retryIntervalInMs,
            // If we don't have a token, then we should timeout immediately
            token?.expiresOnTimestamp ?? Date.now()
          ).then((_token) => {
            refreshWorker = null;
            token = _token;
            tenantId = getTokenOptions.tenantId;
            return token;
          }).catch((reason) => {
            refreshWorker = null;
            token = null;
            tenantId = void 0;
            throw reason;
          });
        }
        return refreshWorker;
      }
      return async (scopes, tokenOptions) => {
        const hasClaimChallenge = Boolean(tokenOptions.claims);
        const tenantIdChanged = tenantId !== tokenOptions.tenantId;
        if (hasClaimChallenge) {
          token = null;
        }
        const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
        if (mustRefresh) {
          return refresh(scopes, tokenOptions);
        }
        if (cycler.shouldRefresh) {
          refresh(scopes, tokenOptions);
        }
        return token;
      };
    }
  })(tokenCycler);
  return tokenCycler;
}
var hasRequiredBearerTokenAuthenticationPolicy;
function requireBearerTokenAuthenticationPolicy() {
  if (hasRequiredBearerTokenAuthenticationPolicy) return bearerTokenAuthenticationPolicy;
  hasRequiredBearerTokenAuthenticationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearerTokenAuthenticationPolicyName = void 0;
    exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy2;
    exports.parseChallenges = parseChallenges;
    const tokenCycler_js_1 = /* @__PURE__ */ requireTokenCycler();
    const log_js_1 = /* @__PURE__ */ requireLog$3();
    const restError_js_1 = /* @__PURE__ */ requireRestError();
    exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
    async function trySendRequest(request2, next) {
      try {
        return [await next(request2), void 0];
      } catch (e) {
        if ((0, restError_js_1.isRestError)(e) && e.response) {
          return [e.response, e];
        } else {
          throw e;
        }
      }
    }
    async function defaultAuthorizeRequest(options2) {
      const { scopes, getAccessToken, request: request2 } = options2;
      const getTokenOptions = {
        abortSignal: request2.abortSignal,
        tracingOptions: request2.tracingOptions,
        enableCae: true
      };
      const accessToken = await getAccessToken(scopes, getTokenOptions);
      if (accessToken) {
        options2.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
      }
    }
    function isChallengeResponse(response2) {
      return response2.status === 401 && response2.headers.has("WWW-Authenticate");
    }
    async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
      const { scopes } = onChallengeOptions;
      const accessToken = await onChallengeOptions.getAccessToken(scopes, {
        enableCae: true,
        claims: caeClaims
      });
      if (!accessToken) {
        return false;
      }
      onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
    function bearerTokenAuthenticationPolicy2(options2) {
      const { credential, scopes, challengeCallbacks } = options2;
      const logger2 = options2.logger || log_js_1.logger;
      const callbacks = {
        authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
        authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks)
      };
      const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(
        credential
        /* , options */
      ) : () => Promise.resolve(null);
      return {
        name: exports.bearerTokenAuthenticationPolicyName,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */
        async sendRequest(request2, next) {
          if (!request2.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
          }
          await callbacks.authorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request: request2,
            getAccessToken,
            logger: logger2
          });
          let response2;
          let error2;
          let shouldSendRequest;
          [response2, error2] = await trySendRequest(request2, next);
          if (isChallengeResponse(response2)) {
            let claims = getCaeChallengeClaims(response2.headers.get("WWW-Authenticate"));
            if (claims) {
              let parsedClaim;
              try {
                parsedClaim = atob(claims);
              } catch (e) {
                logger2.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                return response2;
              }
              shouldSendRequest = await authorizeRequestOnCaeChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                response: response2,
                request: request2,
                getAccessToken,
                logger: logger2
              }, parsedClaim);
              if (shouldSendRequest) {
                [response2, error2] = await trySendRequest(request2, next);
              }
            } else if (callbacks.authorizeRequestOnChallenge) {
              shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request: request2,
                response: response2,
                getAccessToken,
                logger: logger2
              });
              if (shouldSendRequest) {
                [response2, error2] = await trySendRequest(request2, next);
              }
              if (isChallengeResponse(response2)) {
                claims = getCaeChallengeClaims(response2.headers.get("WWW-Authenticate"));
                if (claims) {
                  let parsedClaim;
                  try {
                    parsedClaim = atob(claims);
                  } catch (e) {
                    logger2.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                    return response2;
                  }
                  shouldSendRequest = await authorizeRequestOnCaeChallenge({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    response: response2,
                    request: request2,
                    getAccessToken,
                    logger: logger2
                  }, parsedClaim);
                  if (shouldSendRequest) {
                    [response2, error2] = await trySendRequest(request2, next);
                  }
                }
              }
            }
          }
          if (error2) {
            throw error2;
          } else {
            return response2;
          }
        }
      };
    }
    function parseChallenges(challenges) {
      const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
      const paramRegex = /(\w+)="([^"]*)"/g;
      const parsedChallenges = [];
      let match;
      while ((match = challengeRegex.exec(challenges)) !== null) {
        const scheme = match[1];
        const paramsString = match[2];
        const params = {};
        let paramMatch;
        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
          params[paramMatch[1]] = paramMatch[2];
        }
        parsedChallenges.push({ scheme, params });
      }
      return parsedChallenges;
    }
    function getCaeChallengeClaims(challenges) {
      if (!challenges) {
        return;
      }
      const parsedChallenges = parseChallenges(challenges);
      return parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
    }
  })(bearerTokenAuthenticationPolicy);
  return bearerTokenAuthenticationPolicy;
}
var ndJsonPolicy = {};
var hasRequiredNdJsonPolicy;
function requireNdJsonPolicy() {
  if (hasRequiredNdJsonPolicy) return ndJsonPolicy;
  hasRequiredNdJsonPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ndJsonPolicyName = void 0;
    exports.ndJsonPolicy = ndJsonPolicy2;
    exports.ndJsonPolicyName = "ndJsonPolicy";
    function ndJsonPolicy2() {
      return {
        name: exports.ndJsonPolicyName,
        async sendRequest(request2, next) {
          if (typeof request2.body === "string" && request2.body.startsWith("[")) {
            const body2 = JSON.parse(request2.body);
            if (Array.isArray(body2)) {
              request2.body = body2.map((item) => JSON.stringify(item) + "\n").join("");
            }
          }
          return next(request2);
        }
      };
    }
  })(ndJsonPolicy);
  return ndJsonPolicy;
}
var auxiliaryAuthenticationHeaderPolicy = {};
var hasRequiredAuxiliaryAuthenticationHeaderPolicy;
function requireAuxiliaryAuthenticationHeaderPolicy() {
  if (hasRequiredAuxiliaryAuthenticationHeaderPolicy) return auxiliaryAuthenticationHeaderPolicy;
  hasRequiredAuxiliaryAuthenticationHeaderPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auxiliaryAuthenticationHeaderPolicyName = void 0;
    exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy2;
    const tokenCycler_js_1 = /* @__PURE__ */ requireTokenCycler();
    const log_js_1 = /* @__PURE__ */ requireLog$3();
    exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
    const AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
    async function sendAuthorizeRequest(options2) {
      const { scopes, getAccessToken, request: request2 } = options2;
      const getTokenOptions = {
        abortSignal: request2.abortSignal,
        tracingOptions: request2.tracingOptions
      };
      return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
    }
    function auxiliaryAuthenticationHeaderPolicy2(options2) {
      const { credentials: credentials2, scopes } = options2;
      const logger2 = options2.logger || log_js_1.logger;
      const tokenCyclerMap = /* @__PURE__ */ new WeakMap();
      return {
        name: exports.auxiliaryAuthenticationHeaderPolicyName,
        async sendRequest(request2, next) {
          if (!request2.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
          }
          if (!credentials2 || credentials2.length === 0) {
            logger2.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
            return next(request2);
          }
          const tokenPromises = [];
          for (const credential of credentials2) {
            let getAccessToken = tokenCyclerMap.get(credential);
            if (!getAccessToken) {
              getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
              tokenCyclerMap.set(credential, getAccessToken);
            }
            tokenPromises.push(sendAuthorizeRequest({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request: request2,
              getAccessToken
            }));
          }
          const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
          if (auxiliaryTokens.length === 0) {
            logger2.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
            return next(request2);
          }
          request2.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
          return next(request2);
        }
      };
    }
  })(auxiliaryAuthenticationHeaderPolicy);
  return auxiliaryAuthenticationHeaderPolicy;
}
var hasRequiredCommonjs$7;
function requireCommonjs$7() {
  if (hasRequiredCommonjs$7) return commonjs$b;
  hasRequiredCommonjs$7 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileFromStream = exports.createFile = exports.agentPolicyName = exports.agentPolicy = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = void 0;
    var pipeline_js_1 = /* @__PURE__ */ requirePipeline$2();
    Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createEmptyPipeline;
    } });
    var createPipelineFromOptions_js_1 = /* @__PURE__ */ requireCreatePipelineFromOptions();
    Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: true, get: function() {
      return createPipelineFromOptions_js_1.createPipelineFromOptions;
    } });
    var defaultHttpClient_js_1 = /* @__PURE__ */ requireDefaultHttpClient();
    Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
      return defaultHttpClient_js_1.createDefaultHttpClient;
    } });
    var httpHeaders_js_1 = /* @__PURE__ */ requireHttpHeaders();
    Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
      return httpHeaders_js_1.createHttpHeaders;
    } });
    var pipelineRequest_js_1 = /* @__PURE__ */ requirePipelineRequest();
    Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
      return pipelineRequest_js_1.createPipelineRequest;
    } });
    var restError_js_1 = /* @__PURE__ */ requireRestError();
    Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
      return restError_js_1.RestError;
    } });
    Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
      return restError_js_1.isRestError;
    } });
    var decompressResponsePolicy_js_1 = /* @__PURE__ */ requireDecompressResponsePolicy();
    Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicy;
    } });
    Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicyName;
    } });
    var exponentialRetryPolicy_js_1 = /* @__PURE__ */ requireExponentialRetryPolicy();
    Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
    } });
    Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
    } });
    var setClientRequestIdPolicy_js_1 = /* @__PURE__ */ requireSetClientRequestIdPolicy();
    Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: true, get: function() {
      return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
    } });
    Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
      return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
    } });
    var logPolicy_js_1 = /* @__PURE__ */ requireLogPolicy();
    Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicy;
    } });
    Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicyName;
    } });
    var multipartPolicy_js_1 = /* @__PURE__ */ requireMultipartPolicy();
    Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicy;
    } });
    Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicyName;
    } });
    var proxyPolicy_js_1 = /* @__PURE__ */ requireProxyPolicy();
    Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicy;
    } });
    Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicyName;
    } });
    Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
      return proxyPolicy_js_1.getDefaultProxySettings;
    } });
    var redirectPolicy_js_1 = /* @__PURE__ */ requireRedirectPolicy();
    Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicy;
    } });
    Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicyName;
    } });
    var systemErrorRetryPolicy_js_1 = /* @__PURE__ */ requireSystemErrorRetryPolicy();
    Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
    } });
    Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
    } });
    var throttlingRetryPolicy_js_1 = /* @__PURE__ */ requireThrottlingRetryPolicy();
    Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
    } });
    Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
    } });
    var retryPolicy_js_1 = /* @__PURE__ */ requireRetryPolicy();
    Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
      return retryPolicy_js_1.retryPolicy;
    } });
    var tracingPolicy_js_1 = /* @__PURE__ */ requireTracingPolicy();
    Object.defineProperty(exports, "tracingPolicy", { enumerable: true, get: function() {
      return tracingPolicy_js_1.tracingPolicy;
    } });
    Object.defineProperty(exports, "tracingPolicyName", { enumerable: true, get: function() {
      return tracingPolicy_js_1.tracingPolicyName;
    } });
    var defaultRetryPolicy_js_1 = /* @__PURE__ */ requireDefaultRetryPolicy();
    Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicy;
    } });
    var userAgentPolicy_js_1 = /* @__PURE__ */ requireUserAgentPolicy();
    Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicy;
    } });
    Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicyName;
    } });
    var tlsPolicy_js_1 = /* @__PURE__ */ requireTlsPolicy();
    Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicy;
    } });
    Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicyName;
    } });
    var formDataPolicy_js_1 = /* @__PURE__ */ requireFormDataPolicy();
    Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicy;
    } });
    Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicyName;
    } });
    var bearerTokenAuthenticationPolicy_js_1 = /* @__PURE__ */ requireBearerTokenAuthenticationPolicy();
    Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
      return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
    } });
    Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
      return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
    } });
    var ndJsonPolicy_js_1 = /* @__PURE__ */ requireNdJsonPolicy();
    Object.defineProperty(exports, "ndJsonPolicy", { enumerable: true, get: function() {
      return ndJsonPolicy_js_1.ndJsonPolicy;
    } });
    Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: true, get: function() {
      return ndJsonPolicy_js_1.ndJsonPolicyName;
    } });
    var auxiliaryAuthenticationHeaderPolicy_js_1 = /* @__PURE__ */ requireAuxiliaryAuthenticationHeaderPolicy();
    Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
      return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
    } });
    Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
      return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
    } });
    var agentPolicy_js_1 = /* @__PURE__ */ requireAgentPolicy();
    Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicy;
    } });
    Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicyName;
    } });
    var file_js_1 = /* @__PURE__ */ requireFile();
    Object.defineProperty(exports, "createFile", { enumerable: true, get: function() {
      return file_js_1.createFile;
    } });
    Object.defineProperty(exports, "createFileFromStream", { enumerable: true, get: function() {
      return file_js_1.createFileFromStream;
    } });
  })(commonjs$b);
  return commonjs$b;
}
var BlobServiceClient = {};
var commonjs$5 = {};
var azureKeyCredential = {};
var hasRequiredAzureKeyCredential;
function requireAzureKeyCredential() {
  if (hasRequiredAzureKeyCredential) return azureKeyCredential;
  hasRequiredAzureKeyCredential = 1;
  Object.defineProperty(azureKeyCredential, "__esModule", { value: true });
  azureKeyCredential.AzureKeyCredential = void 0;
  class AzureKeyCredential {
    _key;
    /**
     * The value of the key to be used in authentication
     */
    get key() {
      return this._key;
    }
    /**
     * Create an instance of an AzureKeyCredential for use
     * with a service client.
     *
     * @param key - The initial value of the key to use in authentication
     */
    constructor(key) {
      if (!key) {
        throw new Error("key must be a non-empty string");
      }
      this._key = key;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newKey - The new key value to be used
     */
    update(newKey) {
      this._key = newKey;
    }
  }
  azureKeyCredential.AzureKeyCredential = AzureKeyCredential;
  return azureKeyCredential;
}
var keyCredential = {};
var hasRequiredKeyCredential;
function requireKeyCredential() {
  if (hasRequiredKeyCredential) return keyCredential;
  hasRequiredKeyCredential = 1;
  Object.defineProperty(keyCredential, "__esModule", { value: true });
  keyCredential.isKeyCredential = isKeyCredential;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  function isKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
  }
  return keyCredential;
}
var azureNamedKeyCredential = {};
var hasRequiredAzureNamedKeyCredential;
function requireAzureNamedKeyCredential() {
  if (hasRequiredAzureNamedKeyCredential) return azureNamedKeyCredential;
  hasRequiredAzureNamedKeyCredential = 1;
  Object.defineProperty(azureNamedKeyCredential, "__esModule", { value: true });
  azureNamedKeyCredential.AzureNamedKeyCredential = void 0;
  azureNamedKeyCredential.isNamedKeyCredential = isNamedKeyCredential;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  class AzureNamedKeyCredential {
    _key;
    _name;
    /**
     * The value of the key to be used in authentication.
     */
    get key() {
      return this._key;
    }
    /**
     * The value of the name to be used in authentication.
     */
    get name() {
      return this._name;
    }
    /**
     * Create an instance of an AzureNamedKeyCredential for use
     * with a service client.
     *
     * @param name - The initial value of the name to use in authentication.
     * @param key - The initial value of the key to use in authentication.
     */
    constructor(name, key) {
      if (!name || !key) {
        throw new TypeError("name and key must be non-empty strings");
      }
      this._name = name;
      this._key = key;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newName - The new name value to be used.
     * @param newKey - The new key value to be used.
     */
    update(newName, newKey) {
      if (!newName || !newKey) {
        throw new TypeError("newName and newKey must be non-empty strings");
      }
      this._name = newName;
      this._key = newKey;
    }
  }
  azureNamedKeyCredential.AzureNamedKeyCredential = AzureNamedKeyCredential;
  function isNamedKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
  }
  return azureNamedKeyCredential;
}
var azureSASCredential = {};
var hasRequiredAzureSASCredential;
function requireAzureSASCredential() {
  if (hasRequiredAzureSASCredential) return azureSASCredential;
  hasRequiredAzureSASCredential = 1;
  Object.defineProperty(azureSASCredential, "__esModule", { value: true });
  azureSASCredential.AzureSASCredential = void 0;
  azureSASCredential.isSASCredential = isSASCredential;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  class AzureSASCredential {
    _signature;
    /**
     * The value of the shared access signature to be used in authentication
     */
    get signature() {
      return this._signature;
    }
    /**
     * Create an instance of an AzureSASCredential for use
     * with a service client.
     *
     * @param signature - The initial value of the shared access signature to use in authentication
     */
    constructor(signature) {
      if (!signature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = signature;
    }
    /**
     * Change the value of the signature.
     *
     * Updates will take effect upon the next request after
     * updating the signature value.
     *
     * @param newSignature - The new shared access signature value to be used
     */
    update(newSignature) {
      if (!newSignature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = newSignature;
    }
  }
  azureSASCredential.AzureSASCredential = AzureSASCredential;
  function isSASCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
  }
  return azureSASCredential;
}
var tokenCredential = {};
var hasRequiredTokenCredential;
function requireTokenCredential() {
  if (hasRequiredTokenCredential) return tokenCredential;
  hasRequiredTokenCredential = 1;
  Object.defineProperty(tokenCredential, "__esModule", { value: true });
  tokenCredential.isBearerToken = isBearerToken;
  tokenCredential.isPopToken = isPopToken;
  tokenCredential.isTokenCredential = isTokenCredential;
  function isBearerToken(accessToken) {
    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
  }
  function isPopToken(accessToken) {
    return accessToken.tokenType === "pop";
  }
  function isTokenCredential(credential) {
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
  }
  return tokenCredential;
}
var hasRequiredCommonjs$6;
function requireCommonjs$6() {
  if (hasRequiredCommonjs$6) return commonjs$5;
  hasRequiredCommonjs$6 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = void 0;
    var azureKeyCredential_js_1 = /* @__PURE__ */ requireAzureKeyCredential();
    Object.defineProperty(exports, "AzureKeyCredential", { enumerable: true, get: function() {
      return azureKeyCredential_js_1.AzureKeyCredential;
    } });
    var keyCredential_js_1 = /* @__PURE__ */ requireKeyCredential();
    Object.defineProperty(exports, "isKeyCredential", { enumerable: true, get: function() {
      return keyCredential_js_1.isKeyCredential;
    } });
    var azureNamedKeyCredential_js_1 = /* @__PURE__ */ requireAzureNamedKeyCredential();
    Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
    } });
    Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.isNamedKeyCredential;
    } });
    var azureSASCredential_js_1 = /* @__PURE__ */ requireAzureSASCredential();
    Object.defineProperty(exports, "AzureSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.AzureSASCredential;
    } });
    Object.defineProperty(exports, "isSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.isSASCredential;
    } });
    var tokenCredential_js_1 = /* @__PURE__ */ requireTokenCredential();
    Object.defineProperty(exports, "isTokenCredential", { enumerable: true, get: function() {
      return tokenCredential_js_1.isTokenCredential;
    } });
  })(commonjs$5);
  return commonjs$5;
}
var Pipeline = {};
var commonjs$4 = {};
var extendedClient = {};
var disableKeepAlivePolicy = {};
var hasRequiredDisableKeepAlivePolicy;
function requireDisableKeepAlivePolicy() {
  if (hasRequiredDisableKeepAlivePolicy) return disableKeepAlivePolicy;
  hasRequiredDisableKeepAlivePolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.disableKeepAlivePolicyName = void 0;
    exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
    exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
    exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
    function createDisableKeepAlivePolicy() {
      return {
        name: exports.disableKeepAlivePolicyName,
        async sendRequest(request2, next) {
          request2.disableKeepAlive = true;
          return next(request2);
        }
      };
    }
    function pipelineContainsDisableKeepAlivePolicy(pipeline2) {
      return pipeline2.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
    }
  })(disableKeepAlivePolicy);
  return disableKeepAlivePolicy;
}
var commonjs$3 = {};
var serializer = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  Object.defineProperty(base64, "__esModule", { value: true });
  base64.encodeString = encodeString;
  base64.encodeByteArray = encodeByteArray;
  base64.decodeString = decodeString;
  base64.decodeStringToString = decodeStringToString;
  function encodeString(value) {
    return Buffer.from(value).toString("base64");
  }
  function encodeByteArray(value) {
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
  }
  function decodeString(value) {
    return Buffer.from(value, "base64");
  }
  function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
  }
  return base64;
}
var interfaces = {};
var hasRequiredInterfaces;
function requireInterfaces() {
  if (hasRequiredInterfaces) return interfaces;
  hasRequiredInterfaces = 1;
  Object.defineProperty(interfaces, "__esModule", { value: true });
  interfaces.XML_CHARKEY = interfaces.XML_ATTRKEY = void 0;
  interfaces.XML_ATTRKEY = "$";
  interfaces.XML_CHARKEY = "_";
  return interfaces;
}
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.isPrimitiveBody = isPrimitiveBody;
  utils$1.isDuration = isDuration;
  utils$1.isValidUuid = isValidUuid;
  utils$1.flattenResponse = flattenResponse;
  function isPrimitiveBody(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value === void 0 || value === null);
  }
  const validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function isDuration(value) {
    return validateISODuration.test(value);
  }
  const validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
  }
  function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = {
      ...responseObject.headers,
      ...responseObject.body
    };
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
      return responseObject.shouldWrapBody ? { body: null } : null;
    } else {
      return responseObject.shouldWrapBody ? {
        ...responseObject.headers,
        body: responseObject.body
      } : combinedHeadersAndBody;
    }
  }
  function flattenResponse(fullResponse, responseSpec) {
    const parsedHeaders = fullResponse.parsedHeaders;
    if (fullResponse.request.method === "HEAD") {
      return {
        ...parsedHeaders,
        body: fullResponse.parsedBody
      };
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper?.nullable);
    const expectedBodyTypeName = bodyMapper?.type.name;
    if (expectedBodyTypeName === "Stream") {
      return {
        ...parsedHeaders,
        blobBody: fullResponse.blobBody,
        readableStreamBody: fullResponse.readableStreamBody
      };
    }
    const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
      const arrayResponse = fullResponse.parsedBody ?? [];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = fullResponse.parsedBody?.[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
      body: fullResponse.parsedBody,
      headers: parsedHeaders,
      hasNullableType: isNullable,
      shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
    });
  }
  return utils$1;
}
var hasRequiredSerializer;
function requireSerializer() {
  if (hasRequiredSerializer) return serializer;
  hasRequiredSerializer = 1;
  Object.defineProperty(serializer, "__esModule", { value: true });
  serializer.MapperTypeNames = void 0;
  serializer.createSerializer = createSerializer;
  const tslib_1 = require$$0$2;
  const base642 = tslib_1.__importStar(/* @__PURE__ */ requireBase64());
  const interfaces_js_1 = /* @__PURE__ */ requireInterfaces();
  const utils_js_1 = /* @__PURE__ */ requireUtils$1();
  class SerializerImpl {
    modelMappers;
    isXML;
    constructor(modelMappers = {}, isXML = false) {
      this.modelMappers = modelMappers;
      this.isXML = isXML;
    }
    /**
     * @deprecated Removing the constraints validation on client side.
     */
    validateConstraints(mapper, value, objectName) {
      const failValidation = (constraintName, constraintValue) => {
        throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
      };
      if (mapper.constraints && value !== void 0 && value !== null) {
        const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
        if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum) {
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        }
        if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum) {
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        }
        if (InclusiveMaximum !== void 0 && value > InclusiveMaximum) {
          failValidation("InclusiveMaximum", InclusiveMaximum);
        }
        if (InclusiveMinimum !== void 0 && value < InclusiveMinimum) {
          failValidation("InclusiveMinimum", InclusiveMinimum);
        }
        if (MaxItems !== void 0 && value.length > MaxItems) {
          failValidation("MaxItems", MaxItems);
        }
        if (MaxLength !== void 0 && value.length > MaxLength) {
          failValidation("MaxLength", MaxLength);
        }
        if (MinItems !== void 0 && value.length < MinItems) {
          failValidation("MinItems", MinItems);
        }
        if (MinLength !== void 0 && value.length < MinLength) {
          failValidation("MinLength", MinLength);
        }
        if (MultipleOf !== void 0 && value % MultipleOf !== 0) {
          failValidation("MultipleOf", MultipleOf);
        }
        if (Pattern) {
          const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null) {
            failValidation("Pattern", Pattern);
          }
        }
        if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
          failValidation("UniqueItems", UniqueItems);
        }
      }
    }
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param object - A valid Javascript object to be serialized
     *
     * @param objectName - Name of the serialized object
     *
     * @param options - additional options to serialization
     *
     * @returns A valid serialized Javascript object
     */
    serialize(mapper, object2, objectName, options2 = { xml: {} }) {
      const updatedOptions = {
        xml: {
          rootName: options2.xml.rootName ?? "",
          includeRoot: options2.xml.includeRoot ?? false,
          xmlCharKey: options2.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      let payload = {};
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Sequence$/i) !== null) {
        payload = [];
      }
      if (mapper.isConstant) {
        object2 = mapper.defaultValue;
      }
      const { required, nullable } = mapper;
      if (required && nullable && object2 === void 0) {
        throw new Error(`${objectName} cannot be undefined.`);
      }
      if (required && !nullable && (object2 === void 0 || object2 === null)) {
        throw new Error(`${objectName} cannot be null or undefined.`);
      }
      if (!required && nullable === false && object2 === null) {
        throw new Error(`${objectName} cannot be null.`);
      }
      if (object2 === void 0 || object2 === null) {
        payload = object2;
      } else {
        if (mapperType.match(/^any$/i) !== null) {
          payload = object2;
        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
          payload = serializeBasicTypes(mapperType, objectName, object2);
        } else if (mapperType.match(/^Enum$/i) !== null) {
          const enumMapper = mapper;
          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object2);
        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
          payload = serializeDateTypes(mapperType, object2, objectName);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = serializeByteArrayType(objectName, object2);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = serializeBase64UrlType(objectName, object2);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = serializeSequenceType(this, mapper, object2, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = serializeDictionaryType(this, mapper, object2, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Composite$/i) !== null) {
          payload = serializeCompositeType(this, mapper, object2, objectName, Boolean(this.isXML), updatedOptions);
        }
      }
      return payload;
    }
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param responseBody - A valid Javascript entity to be deserialized
     *
     * @param objectName - Name of the deserialized object
     *
     * @param options - Controls behavior of XML parser and builder.
     *
     * @returns A valid deserialized Javascript object
     */
    deserialize(mapper, responseBody, objectName, options2 = { xml: {} }) {
      const updatedOptions = {
        xml: {
          rootName: options2.xml.rootName ?? "",
          includeRoot: options2.xml.includeRoot ?? false,
          xmlCharKey: options2.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        },
        ignoreUnknownProperties: options2.ignoreUnknownProperties ?? false
      };
      if (responseBody === void 0 || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
          responseBody = [];
        }
        if (mapper.defaultValue !== void 0) {
          responseBody = mapper.defaultValue;
        }
        return responseBody;
      }
      let payload;
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Composite$/i) !== null) {
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      } else {
        if (this.isXML) {
          const xmlCharKey = updatedOptions.xml.xmlCharKey;
          if (responseBody[interfaces_js_1.XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0) {
            responseBody = responseBody[xmlCharKey];
          }
        }
        if (mapperType.match(/^Number$/i) !== null) {
          payload = parseFloat(responseBody);
          if (isNaN(payload)) {
            payload = responseBody;
          }
        } else if (mapperType.match(/^Boolean$/i) !== null) {
          if (responseBody === "true") {
            payload = true;
          } else if (responseBody === "false") {
            payload = false;
          } else {
            payload = responseBody;
          }
        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
          payload = responseBody;
        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
          payload = new Date(responseBody);
        } else if (mapperType.match(/^UnixTime$/i) !== null) {
          payload = unixTimeToDate(responseBody);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = base642.decodeString(responseBody);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = base64UrlToByteArray(responseBody);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
      }
      if (mapper.isConstant) {
        payload = mapper.defaultValue;
      }
      return payload;
    }
  }
  function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
  }
  function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
      --len;
    }
    return str.substr(0, len);
  }
  function bufferToBase64Url(buffer) {
    if (!buffer) {
      return void 0;
    }
    if (!(buffer instanceof Uint8Array)) {
      throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    const str = base642.encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64UrlToByteArray(str) {
    if (!str) {
      return void 0;
    }
    if (str && typeof str.valueOf() !== "string") {
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return base642.decodeString(str);
  }
  function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
      const subwords = prop.split(".");
      for (const item of subwords) {
        if (item.charAt(item.length - 1) === "\\") {
          partialclass += item.substr(0, item.length - 1) + ".";
        } else {
          partialclass += item;
          classes.push(partialclass);
          partialclass = "";
        }
      }
    }
    return classes;
  }
  function dateToUnixTime(d) {
    if (!d) {
      return void 0;
    }
    if (typeof d.valueOf() === "string") {
      d = new Date(d);
    }
    return Math.floor(d.getTime() / 1e3);
  }
  function unixTimeToDate(n) {
    if (!n) {
      return void 0;
    }
    return new Date(n * 1e3);
  }
  function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== void 0) {
      if (typeName.match(/^Number$/i) !== null) {
        if (typeof value !== "number") {
          throw new Error(`${objectName} with value ${value} must be of type number.`);
        }
      } else if (typeName.match(/^String$/i) !== null) {
        if (typeof value.valueOf() !== "string") {
          throw new Error(`${objectName} with value "${value}" must be of type string.`);
        }
      } else if (typeName.match(/^Uuid$/i) !== null) {
        if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
          throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
        }
      } else if (typeName.match(/^Boolean$/i) !== null) {
        if (typeof value !== "boolean") {
          throw new Error(`${objectName} with value ${value} must be of type boolean.`);
        }
      } else if (typeName.match(/^Stream$/i) !== null) {
        const objectType = typeof value;
        if (objectType !== "string" && typeof value.pipe !== "function" && // NodeJS.ReadableStream
        typeof value.tee !== "function" && // browser ReadableStream
        !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
        !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
          throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
        }
      }
    }
    return value;
  }
  function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
      throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
      if (typeof item.valueOf() === "string") {
        return item.toLowerCase() === value.toLowerCase();
      }
      return item === value;
    });
    if (!isPresent) {
      throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
  }
  function serializeByteArrayType(objectName, value) {
    if (value !== void 0 && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = base642.encodeByteArray(value);
    }
    return value;
  }
  function serializeBase64UrlType(objectName, value) {
    if (value !== void 0 && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = bufferToBase64Url(value);
    }
    return value;
  }
  function serializeDateTypes(typeName, value, objectName) {
    if (value !== void 0 && value !== null) {
      if (typeName.match(/^Date$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
      } else if (typeName.match(/^DateTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
      } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
        }
        value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
      } else if (typeName.match(/^UnixTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
        }
        value = dateToUnixTime(value);
      } else if (typeName.match(/^TimeSpan$/i) !== null) {
        if (!(0, utils_js_1.isDuration)(value)) {
          throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
        }
      }
    }
    return value;
  }
  function serializeSequenceType(serializer2, mapper, object2, objectName, isXml, options2) {
    if (!Array.isArray(object2)) {
      throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
    }
    if (elementType.type.name === "Composite" && elementType.type.className) {
      elementType = serializer2.modelMappers[elementType.type.className] ?? elementType;
    }
    const tempArray = [];
    for (let i = 0; i < object2.length; i++) {
      const serializedValue = serializer2.serialize(elementType, object2[i], objectName, options2);
      if (isXml && elementType.xmlNamespace) {
        const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
        if (elementType.type.name === "Composite") {
          tempArray[i] = { ...serializedValue };
          tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        } else {
          tempArray[i] = {};
          tempArray[i][options2.xml.xmlCharKey] = serializedValue;
          tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        }
      } else {
        tempArray[i] = serializedValue;
      }
    }
    return tempArray;
  }
  function serializeDictionaryType(serializer2, mapper, object2, objectName, isXml, options2) {
    if (typeof object2 !== "object") {
      throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object2)) {
      const serializedValue = serializer2.serialize(valueType, object2[key], objectName, options2);
      tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options2);
    }
    if (isXml && mapper.xmlNamespace) {
      const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
      const result = tempDictionary;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
      return result;
    }
    return tempDictionary;
  }
  function resolveAdditionalProperties(serializer2, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
      const modelMapper = resolveReferencedMapper(serializer2, mapper, objectName);
      return modelMapper?.type.additionalProperties;
    }
    return additionalProperties;
  }
  function resolveReferencedMapper(serializer2, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
      throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
    }
    return serializer2.modelMappers[className];
  }
  function resolveModelProperties(serializer2, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
      const modelMapper = resolveReferencedMapper(serializer2, mapper, objectName);
      if (!modelMapper) {
        throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
      }
      modelProps = modelMapper?.type.modelProperties;
      if (!modelProps) {
        throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
      }
    }
    return modelProps;
  }
  function serializeCompositeType(serializer2, mapper, object2, objectName, isXml, options2) {
    if (getPolymorphicDiscriminatorRecursively(serializer2, mapper)) {
      mapper = getPolymorphicMapper(serializer2, mapper, object2, "clientName");
    }
    if (object2 !== void 0 && object2 !== null) {
      const payload = {};
      const modelProps = resolveModelProperties(serializer2, mapper, objectName);
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        if (propertyMapper.readOnly) {
          continue;
        }
        let propName;
        let parentObject = payload;
        if (serializer2.isXML) {
          if (propertyMapper.xmlIsWrapped) {
            propName = propertyMapper.xmlName;
          } else {
            propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
          }
        } else {
          const paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (const pathName of paths) {
            const childObject = parentObject[pathName];
            if ((childObject === void 0 || childObject === null) && (object2[key] !== void 0 && object2[key] !== null || propertyMapper.defaultValue !== void 0)) {
              parentObject[pathName] = {};
            }
            parentObject = parentObject[pathName];
          }
        }
        if (parentObject !== void 0 && parentObject !== null) {
          if (isXml && mapper.xmlNamespace) {
            const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
            parentObject[interfaces_js_1.XML_ATTRKEY] = {
              ...parentObject[interfaces_js_1.XML_ATTRKEY],
              [xmlnsKey]: mapper.xmlNamespace
            };
          }
          const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
          let toSerialize = object2[key];
          const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer2, mapper);
          if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) {
            toSerialize = mapper.serializedName;
          }
          const serializedValue = serializer2.serialize(propertyMapper, toSerialize, propertyObjectName, options2);
          if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
            const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options2);
            if (isXml && propertyMapper.xmlIsAttribute) {
              parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
              parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
            } else if (isXml && propertyMapper.xmlIsWrapped) {
              parentObject[propName] = { [propertyMapper.xmlElementName]: value };
            } else {
              parentObject[propName] = value;
            }
          }
        }
      }
      const additionalPropertiesMapper = resolveAdditionalProperties(serializer2, mapper, objectName);
      if (additionalPropertiesMapper) {
        const propNames = Object.keys(modelProps);
        for (const clientPropName in object2) {
          const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
          if (isAdditionalProperty) {
            payload[clientPropName] = serializer2.serialize(additionalPropertiesMapper, object2[clientPropName], objectName + '["' + clientPropName + '"]', options2);
          }
        }
      }
      return payload;
    }
    return object2;
  }
  function getXmlObjectValue(propertyMapper, serializedValue, isXml, options2) {
    if (!isXml || !propertyMapper.xmlNamespace) {
      return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
      if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
        return serializedValue;
      } else {
        const result2 = { ...serializedValue };
        result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
        return result2;
      }
    }
    const result = {};
    result[options2.xml.xmlCharKey] = serializedValue;
    result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
    return result;
  }
  function isSpecialXmlProperty(propertyName, options2) {
    return [interfaces_js_1.XML_ATTRKEY, options2.xml.xmlCharKey].includes(propertyName);
  }
  function deserializeCompositeType(serializer2, mapper, responseBody, objectName, options2) {
    const xmlCharKey = options2.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
    if (getPolymorphicDiscriminatorRecursively(serializer2, mapper)) {
      mapper = getPolymorphicMapper(serializer2, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer2, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      const paths = splitSerializeName(modelProps[key].serializedName);
      handledPropertyNames.push(paths[0]);
      const { serializedName, xmlName, xmlElementName } = propertyMapper;
      let propertyObjectName = objectName;
      if (serializedName !== "" && serializedName !== void 0) {
        propertyObjectName = objectName + "." + serializedName;
      }
      const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
      if (headerCollectionPrefix) {
        const dictionary = {};
        for (const headerKey of Object.keys(responseBody)) {
          if (headerKey.startsWith(headerCollectionPrefix)) {
            dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer2.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options2);
          }
          handledPropertyNames.push(headerKey);
        }
        instance[key] = dictionary;
      } else if (serializer2.isXML) {
        if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
          instance[key] = serializer2.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options2);
        } else if (propertyMapper.xmlIsMsText) {
          if (responseBody[xmlCharKey] !== void 0) {
            instance[key] = responseBody[xmlCharKey];
          } else if (typeof responseBody === "string") {
            instance[key] = responseBody;
          }
        } else {
          const propertyName = xmlElementName || xmlName || serializedName;
          if (propertyMapper.xmlIsWrapped) {
            const wrapped = responseBody[xmlName];
            const elementList = wrapped?.[xmlElementName] ?? [];
            instance[key] = serializer2.deserialize(propertyMapper, elementList, propertyObjectName, options2);
            handledPropertyNames.push(xmlName);
          } else {
            const property = responseBody[propertyName];
            instance[key] = serializer2.deserialize(propertyMapper, property, propertyObjectName, options2);
            handledPropertyNames.push(propertyName);
          }
        }
      } else {
        let propertyInstance;
        let res = responseBody;
        let steps = 0;
        for (const item of paths) {
          if (!res)
            break;
          steps++;
          res = res[item];
        }
        if (res === null && steps < paths.length) {
          res = void 0;
        }
        propertyInstance = res;
        const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
        if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) {
          propertyInstance = mapper.serializedName;
        }
        let serializedValue;
        if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
          propertyInstance = responseBody[key];
          const arrayInstance = serializer2.deserialize(propertyMapper, propertyInstance, propertyObjectName, options2);
          for (const [k, v] of Object.entries(instance)) {
            if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
              arrayInstance[k] = v;
            }
          }
          instance = arrayInstance;
        } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
          serializedValue = serializer2.deserialize(propertyMapper, propertyInstance, propertyObjectName, options2);
          instance[key] = serializedValue;
        }
      }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
      const isAdditionalProperty = (responsePropName) => {
        for (const clientPropName in modelProps) {
          const paths = splitSerializeName(modelProps[clientPropName].serializedName);
          if (paths[0] === responsePropName) {
            return false;
          }
        }
        return true;
      };
      for (const responsePropName in responseBody) {
        if (isAdditionalProperty(responsePropName)) {
          instance[responsePropName] = serializer2.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options2);
        }
      }
    } else if (responseBody && !options2.ignoreUnknownProperties) {
      for (const key of Object.keys(responseBody)) {
        if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options2)) {
          instance[key] = responseBody[key];
        }
      }
    }
    return instance;
  }
  function deserializeDictionaryType(serializer2, mapper, responseBody, objectName, options2) {
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      const tempDictionary = {};
      for (const key of Object.keys(responseBody)) {
        tempDictionary[key] = serializer2.deserialize(value, responseBody[key], objectName, options2);
      }
      return tempDictionary;
    }
    return responseBody;
  }
  function deserializeSequenceType(serializer2, mapper, responseBody, objectName, options2) {
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      if (!Array.isArray(responseBody)) {
        responseBody = [responseBody];
      }
      if (element.type.name === "Composite" && element.type.className) {
        element = serializer2.modelMappers[element.type.className] ?? element;
      }
      const tempArray = [];
      for (let i = 0; i < responseBody.length; i++) {
        tempArray[i] = serializer2.deserialize(element, responseBody[i], `${objectName}[${i}]`, options2);
      }
      return tempArray;
    }
    return responseBody;
  }
  function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
      const currentName = typeNamesToCheck.shift();
      const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
      if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
        return discriminators[indexDiscriminator];
      } else {
        for (const [name, mapper] of Object.entries(discriminators)) {
          if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
            typeNamesToCheck.push(mapper.type.className);
          }
        }
      }
    }
    return void 0;
  }
  function getPolymorphicMapper(serializer2, mapper, object2, polymorphicPropertyName) {
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer2, mapper);
    if (polymorphicDiscriminator) {
      let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
      if (discriminatorName) {
        if (polymorphicPropertyName === "serializedName") {
          discriminatorName = discriminatorName.replace(/\\/gi, "");
        }
        const discriminatorValue = object2[discriminatorName];
        const typeName = mapper.type.uberParent ?? mapper.type.className;
        if (typeof discriminatorValue === "string" && typeName) {
          const polymorphicMapper = getIndexDiscriminator(serializer2.modelMappers.discriminators, discriminatorValue, typeName);
          if (polymorphicMapper) {
            mapper = polymorphicMapper;
          }
        }
      }
    }
    return mapper;
  }
  function getPolymorphicDiscriminatorRecursively(serializer2, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer2, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer2, mapper.type.className);
  }
  function getPolymorphicDiscriminatorSafely(serializer2, typeName) {
    return typeName && serializer2.modelMappers[typeName] && serializer2.modelMappers[typeName].type.polymorphicDiscriminator;
  }
  serializer.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
  };
  return serializer;
}
var serviceClient = {};
var pipeline = {};
var deserializationPolicy = {};
var operationHelpers = {};
var state = {};
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  Object.defineProperty(state, "__esModule", { value: true });
  state.state = void 0;
  state.state = {
    operationRequestMap: /* @__PURE__ */ new WeakMap()
  };
  return state;
}
var hasRequiredOperationHelpers;
function requireOperationHelpers() {
  if (hasRequiredOperationHelpers) return operationHelpers;
  hasRequiredOperationHelpers = 1;
  Object.defineProperty(operationHelpers, "__esModule", { value: true });
  operationHelpers.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
  operationHelpers.getOperationRequestInfo = getOperationRequestInfo;
  const state_js_1 = /* @__PURE__ */ requireState();
  function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
      parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
      if (parameterPath.length > 0) {
        if (parameterMapper.isConstant) {
          value = parameterMapper.defaultValue;
        } else {
          let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
          if (!propertySearchResult.propertyFound && fallbackObject) {
            propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
          }
          let useDefaultValue = false;
          if (!propertySearchResult.propertyFound) {
            useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
          }
          value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
        }
      }
    } else {
      if (parameterMapper.required) {
        value = {};
      }
      for (const propertyName in parameterPath) {
        const propertyMapper = parameterMapper.type.modelProperties[propertyName];
        const propertyPath = parameterPath[propertyName];
        const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
          parameterPath: propertyPath,
          mapper: propertyMapper
        }, fallbackObject);
        if (propertyValue !== void 0) {
          if (!value) {
            value = {};
          }
          value[propertyName] = propertyValue;
        }
      }
    }
    return value;
  }
  function getPropertyFromParameterPath(parent, parameterPath) {
    const result = { propertyFound: false };
    let i = 0;
    for (; i < parameterPath.length; ++i) {
      const parameterPathPart = parameterPath[i];
      if (parent && parameterPathPart in parent) {
        parent = parent[parameterPathPart];
      } else {
        break;
      }
    }
    if (i === parameterPath.length) {
      result.propertyValue = parent;
      result.propertyFound = true;
    }
    return result;
  }
  const originalRequestSymbol = Symbol.for("@azure/core-client original request");
  function hasOriginalRequest(request2) {
    return originalRequestSymbol in request2;
  }
  function getOperationRequestInfo(request2) {
    if (hasOriginalRequest(request2)) {
      return getOperationRequestInfo(request2[originalRequestSymbol]);
    }
    let info = state_js_1.state.operationRequestMap.get(request2);
    if (!info) {
      info = {};
      state_js_1.state.operationRequestMap.set(request2, info);
    }
    return info;
  }
  return operationHelpers;
}
var hasRequiredDeserializationPolicy;
function requireDeserializationPolicy() {
  if (hasRequiredDeserializationPolicy) return deserializationPolicy;
  hasRequiredDeserializationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializationPolicyName = void 0;
    exports.deserializationPolicy = deserializationPolicy2;
    const interfaces_js_1 = /* @__PURE__ */ requireInterfaces();
    const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
    const serializer_js_1 = /* @__PURE__ */ requireSerializer();
    const operationHelpers_js_1 = /* @__PURE__ */ requireOperationHelpers();
    const defaultJsonContentTypes = ["application/json", "text/json"];
    const defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    exports.deserializationPolicyName = "deserializationPolicy";
    function deserializationPolicy2(options2 = {}) {
      const jsonContentTypes = options2.expectedContentTypes?.json ?? defaultJsonContentTypes;
      const xmlContentTypes = options2.expectedContentTypes?.xml ?? defaultXmlContentTypes;
      const parseXML = options2.parseXML;
      const serializerOptions = options2.serializerOptions;
      const updatedOptions = {
        xml: {
          rootName: serializerOptions?.xml.rootName ?? "",
          includeRoot: serializerOptions?.xml.includeRoot ?? false,
          xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      return {
        name: exports.deserializationPolicyName,
        async sendRequest(request2, next) {
          const response2 = await next(request2);
          return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response2, updatedOptions, parseXML);
        }
      };
    }
    function getOperationResponseMap(parsedResponse) {
      let result;
      const request2 = parsedResponse.request;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request2);
      const operationSpec = operationInfo?.operationSpec;
      if (operationSpec) {
        if (!operationInfo?.operationResponseGetter) {
          result = operationSpec.responses[parsedResponse.status];
        } else {
          result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
        }
      }
      return result;
    }
    function shouldDeserializeResponse(parsedResponse) {
      const request2 = parsedResponse.request;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request2);
      const shouldDeserialize = operationInfo?.shouldDeserialize;
      let result;
      if (shouldDeserialize === void 0) {
        result = true;
      } else if (typeof shouldDeserialize === "boolean") {
        result = shouldDeserialize;
      } else {
        result = shouldDeserialize(parsedResponse);
      }
      return result;
    }
    async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response2, options2, parseXML) {
      const parsedResponse = await parse2(jsonContentTypes, xmlContentTypes, response2, options2, parseXML);
      if (!shouldDeserializeResponse(parsedResponse)) {
        return parsedResponse;
      }
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
      const operationSpec = operationInfo?.operationSpec;
      if (!operationSpec || !operationSpec.responses) {
        return parsedResponse;
      }
      const responseSpec = getOperationResponseMap(parsedResponse);
      const { error: error2, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options2);
      if (error2) {
        throw error2;
      } else if (shouldReturnResponse) {
        return parsedResponse;
      }
      if (responseSpec) {
        if (responseSpec.bodyMapper) {
          let valueToDeserialize = parsedResponse.parsedBody;
          if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
          }
          try {
            parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options2);
          } catch (deserializeError) {
            const restError2 = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
              statusCode: parsedResponse.status,
              request: parsedResponse.request,
              response: parsedResponse
            });
            throw restError2;
          }
        } else if (operationSpec.httpMethod === "HEAD") {
          parsedResponse.parsedBody = response2.status >= 200 && response2.status < 300;
        }
        if (responseSpec.headersMapper) {
          parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
        }
      }
      return parsedResponse;
    }
    function isOperationSpecEmpty(operationSpec) {
      const expectedStatusCodes = Object.keys(operationSpec.responses);
      return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
    }
    function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options2) {
      const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
      const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
      if (isExpectedStatusCode) {
        if (responseSpec) {
          if (!responseSpec.isError) {
            return { error: null, shouldReturnResponse: false };
          }
        } else {
          return { error: null, shouldReturnResponse: false };
        }
      }
      const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
      const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
      const error2 = new core_rest_pipeline_1.RestError(initialErrorMessage, {
        statusCode: parsedResponse.status,
        request: parsedResponse.request,
        response: parsedResponse
      });
      if (!errorResponseSpec && !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)) {
        throw error2;
      }
      const defaultBodyMapper = errorResponseSpec?.bodyMapper;
      const defaultHeadersMapper = errorResponseSpec?.headersMapper;
      try {
        if (parsedResponse.parsedBody) {
          const parsedBody = parsedResponse.parsedBody;
          let deserializedError;
          if (defaultBodyMapper) {
            let valueToDeserialize = parsedBody;
            if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
              valueToDeserialize = [];
              const elementName = defaultBodyMapper.xmlElementName;
              if (typeof parsedBody === "object" && elementName) {
                valueToDeserialize = parsedBody[elementName];
              }
            }
            deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options2);
          }
          const internalError = parsedBody.error || deserializedError || parsedBody;
          error2.code = internalError.code;
          if (internalError.message) {
            error2.message = internalError.message;
          }
          if (defaultBodyMapper) {
            error2.response.parsedBody = deserializedError;
          }
        }
        if (parsedResponse.headers && defaultHeadersMapper) {
          error2.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
      } catch (defaultError) {
        error2.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
      }
      return { error: error2, shouldReturnResponse: false };
    }
    async function parse2(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
      if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) && operationResponse.bodyAsText) {
        const text = operationResponse.bodyAsText;
        const contentType = operationResponse.headers.get("Content-Type") || "";
        const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
        try {
          if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
            operationResponse.parsedBody = JSON.parse(text);
            return operationResponse;
          } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
            if (!parseXML) {
              throw new Error("Parsing XML not supported.");
            }
            const body2 = await parseXML(text, opts.xml);
            operationResponse.parsedBody = body2;
            return operationResponse;
          }
        } catch (err) {
          const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
          const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
          const e = new core_rest_pipeline_1.RestError(msg, {
            code: errCode,
            statusCode: operationResponse.status,
            request: operationResponse.request,
            response: operationResponse
          });
          throw e;
        }
      }
      return operationResponse;
    }
  })(deserializationPolicy);
  return deserializationPolicy;
}
var serializationPolicy = {};
var interfaceHelpers = {};
var hasRequiredInterfaceHelpers;
function requireInterfaceHelpers() {
  if (hasRequiredInterfaceHelpers) return interfaceHelpers;
  hasRequiredInterfaceHelpers = 1;
  Object.defineProperty(interfaceHelpers, "__esModule", { value: true });
  interfaceHelpers.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
  interfaceHelpers.getPathStringFromParameter = getPathStringFromParameter;
  const serializer_js_1 = /* @__PURE__ */ requireSerializer();
  function getStreamingResponseStatusCodes(operationSpec) {
    const result = /* @__PURE__ */ new Set();
    for (const statusCode in operationSpec.responses) {
      const operationResponse = operationSpec.responses[statusCode];
      if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
        result.add(Number(statusCode));
      }
    }
    return result;
  }
  function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result;
    if (typeof parameterPath === "string") {
      result = parameterPath;
    } else if (Array.isArray(parameterPath)) {
      result = parameterPath.join(".");
    } else {
      result = mapper.serializedName;
    }
    return result;
  }
  return interfaceHelpers;
}
var hasRequiredSerializationPolicy;
function requireSerializationPolicy() {
  if (hasRequiredSerializationPolicy) return serializationPolicy;
  hasRequiredSerializationPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializationPolicyName = void 0;
    exports.serializationPolicy = serializationPolicy2;
    exports.serializeHeaders = serializeHeaders;
    exports.serializeRequestBody = serializeRequestBody;
    const interfaces_js_1 = /* @__PURE__ */ requireInterfaces();
    const operationHelpers_js_1 = /* @__PURE__ */ requireOperationHelpers();
    const serializer_js_1 = /* @__PURE__ */ requireSerializer();
    const interfaceHelpers_js_1 = /* @__PURE__ */ requireInterfaceHelpers();
    exports.serializationPolicyName = "serializationPolicy";
    function serializationPolicy2(options2 = {}) {
      const stringifyXML = options2.stringifyXML;
      return {
        name: exports.serializationPolicyName,
        async sendRequest(request2, next) {
          const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request2);
          const operationSpec = operationInfo?.operationSpec;
          const operationArguments = operationInfo?.operationArguments;
          if (operationSpec && operationArguments) {
            serializeHeaders(request2, operationArguments, operationSpec);
            serializeRequestBody(request2, operationArguments, operationSpec, stringifyXML);
          }
          return next(request2);
        }
      };
    }
    function serializeHeaders(request2, operationArguments, operationSpec) {
      if (operationSpec.headerParameters) {
        for (const headerParameter of operationSpec.headerParameters) {
          let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
          if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
            if (headerCollectionPrefix) {
              for (const key of Object.keys(headerValue)) {
                request2.headers.set(headerCollectionPrefix + key, headerValue[key]);
              }
            } else {
              request2.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
            }
          }
        }
      }
      const customHeaders = operationArguments.options?.requestOptions?.customHeaders;
      if (customHeaders) {
        for (const customHeaderName of Object.keys(customHeaders)) {
          request2.headers.set(customHeaderName, customHeaders[customHeaderName]);
        }
      }
    }
    function serializeRequestBody(request2, operationArguments, operationSpec, stringifyXML = function() {
      throw new Error("XML serialization unsupported!");
    }) {
      const serializerOptions = operationArguments.options?.serializerOptions;
      const updatedOptions = {
        xml: {
          rootName: serializerOptions?.xml.rootName ?? "",
          includeRoot: serializerOptions?.xml.includeRoot ?? false,
          xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      const xmlCharKey = updatedOptions.xml.xmlCharKey;
      if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        request2.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
        const bodyMapper = operationSpec.requestBody.mapper;
        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
        const typeName = bodyMapper.type.name;
        try {
          if (request2.body !== void 0 && request2.body !== null || nullable && request2.body === null || required) {
            const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
            request2.body = operationSpec.serializer.serialize(bodyMapper, request2.body, requestBodyParameterPathString, updatedOptions);
            const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
            if (operationSpec.isXML) {
              const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
              const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request2.body, updatedOptions);
              if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
                request2.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
              } else if (!isStream) {
                request2.body = stringifyXML(value, {
                  rootName: xmlName || serializedName,
                  xmlCharKey
                });
              }
            } else if (typeName === serializer_js_1.MapperTypeNames.String && (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text")) {
              return;
            } else if (!isStream) {
              request2.body = JSON.stringify(request2.body);
            }
          }
        } catch (error2) {
          throw new Error(`Error "${error2.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
        }
      } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        request2.formData = {};
        for (const formDataParameter of operationSpec.formDataParameters) {
          const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
          if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
            const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
            request2.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
          }
        }
      }
    }
    function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options2) {
      if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
        const result = {};
        result[options2.xml.xmlCharKey] = serializedValue;
        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
        return result;
      }
      return serializedValue;
    }
    function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
      if (!Array.isArray(obj)) {
        obj = [obj];
      }
      if (!xmlNamespaceKey || !xmlNamespace) {
        return { [elementName]: obj };
      }
      const result = { [elementName]: obj };
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
      return result;
    }
  })(serializationPolicy);
  return serializationPolicy;
}
var hasRequiredPipeline$1;
function requirePipeline$1() {
  if (hasRequiredPipeline$1) return pipeline;
  hasRequiredPipeline$1 = 1;
  Object.defineProperty(pipeline, "__esModule", { value: true });
  pipeline.createClientPipeline = createClientPipeline;
  const deserializationPolicy_js_1 = /* @__PURE__ */ requireDeserializationPolicy();
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const serializationPolicy_js_1 = /* @__PURE__ */ requireSerializationPolicy();
  function createClientPipeline(options2 = {}) {
    const pipeline2 = (0, core_rest_pipeline_1.createPipelineFromOptions)(options2 ?? {});
    if (options2.credentialOptions) {
      pipeline2.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
        credential: options2.credentialOptions.credential,
        scopes: options2.credentialOptions.credentialScopes
      }));
    }
    pipeline2.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options2.serializationOptions), { phase: "Serialize" });
    pipeline2.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options2.deserializationOptions), {
      phase: "Deserialize"
    });
    return pipeline2;
  }
  return pipeline;
}
var httpClientCache = {};
var hasRequiredHttpClientCache;
function requireHttpClientCache() {
  if (hasRequiredHttpClientCache) return httpClientCache;
  hasRequiredHttpClientCache = 1;
  Object.defineProperty(httpClientCache, "__esModule", { value: true });
  httpClientCache.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  let cachedHttpClient;
  function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) {
      cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return cachedHttpClient;
  }
  return httpClientCache;
}
var urlHelpers = {};
var hasRequiredUrlHelpers;
function requireUrlHelpers() {
  if (hasRequiredUrlHelpers) return urlHelpers;
  hasRequiredUrlHelpers = 1;
  Object.defineProperty(urlHelpers, "__esModule", { value: true });
  urlHelpers.getRequestUrl = getRequestUrl;
  urlHelpers.appendQueryParams = appendQueryParams;
  const operationHelpers_js_1 = /* @__PURE__ */ requireOperationHelpers();
  const interfaceHelpers_js_1 = /* @__PURE__ */ requireInterfaceHelpers();
  const CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "	",
    Pipes: "|"
  };
  function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
      let path2 = replaceAll(operationSpec.path, urlReplacements);
      if (operationSpec.path === "/{nextLink}" && path2.startsWith("/")) {
        path2 = path2.substring(1);
      }
      if (isAbsoluteUrl(path2)) {
        requestUrl = path2;
        isAbsolutePath = true;
      } else {
        requestUrl = appendPath(requestUrl, path2);
      }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
  }
  function replaceAll(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements) {
      result = result.split(searchValue).join(replaceValue);
    }
    return result;
  }
  function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    const result = /* @__PURE__ */ new Map();
    if (operationSpec.urlParameters?.length) {
      for (const urlParameter of operationSpec.urlParameters) {
        let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
        const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) {
          urlParameterValue = encodeURIComponent(urlParameterValue);
        }
        result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
      }
    }
    return result;
  }
  function isAbsoluteUrl(url) {
    return url.includes("://");
  }
  function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
      return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
      newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
      pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
      const path2 = pathToAppend.substring(0, searchStart);
      const search = pathToAppend.substring(searchStart + 1);
      newPath = newPath + path2;
      if (search) {
        parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
      }
    } else {
      newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
  }
  function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    const result = /* @__PURE__ */ new Map();
    const sequenceParams = /* @__PURE__ */ new Set();
    if (operationSpec.queryParameters?.length) {
      for (const queryParameter of operationSpec.queryParameters) {
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
          sequenceParams.add(queryParameter.mapper.serializedName);
        }
        let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
          const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              if (item === null || item === void 0) {
                return "";
              }
              return item;
            });
          }
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
            continue;
          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          if (!queryParameter.skipEncoding) {
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                return encodeURIComponent(item);
              });
            } else {
              queryParameterValue = encodeURIComponent(queryParameterValue);
            }
          }
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    }
    return {
      queryParams: result,
      sequenceParams
    };
  }
  function simpleParseQueryParams(queryString) {
    const result = /* @__PURE__ */ new Map();
    if (!queryString || queryString[0] !== "?") {
      return result;
    }
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [name, value] = pair.split("=", 2);
      const existingValue = result.get(name);
      if (existingValue) {
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          result.set(name, [existingValue, value]);
        }
      } else {
        result.set(name, value);
      }
    }
    return result;
  }
  function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
      return url;
    }
    const parsedUrl = new URL(url);
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
      const existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue)) {
        if (Array.isArray(value)) {
          existingValue.push(...value);
          const valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else {
          existingValue.push(value);
        }
      } else if (existingValue) {
        if (Array.isArray(value)) {
          value.unshift(existingValue);
        } else if (sequenceParams.has(name)) {
          combinedParams.set(name, [existingValue, value]);
        }
        if (!noOverwrite) {
          combinedParams.set(name, value);
        }
      } else {
        combinedParams.set(name, value);
      }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
      if (typeof value === "string") {
        searchPieces.push(`${name}=${value}`);
      } else if (Array.isArray(value)) {
        for (const subValue of value) {
          searchPieces.push(`${name}=${subValue}`);
        }
      } else {
        searchPieces.push(`${name}=${value}`);
      }
    }
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
  }
  return urlHelpers;
}
var log$2 = {};
var hasRequiredLog$2;
function requireLog$2() {
  if (hasRequiredLog$2) return log$2;
  hasRequiredLog$2 = 1;
  Object.defineProperty(log$2, "__esModule", { value: true });
  log$2.logger = void 0;
  const logger_1 = /* @__PURE__ */ requireCommonjs$b();
  log$2.logger = (0, logger_1.createClientLogger)("core-client");
  return log$2;
}
var hasRequiredServiceClient;
function requireServiceClient() {
  if (hasRequiredServiceClient) return serviceClient;
  hasRequiredServiceClient = 1;
  Object.defineProperty(serviceClient, "__esModule", { value: true });
  serviceClient.ServiceClient = void 0;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const pipeline_js_1 = /* @__PURE__ */ requirePipeline$1();
  const utils_js_1 = /* @__PURE__ */ requireUtils$1();
  const httpClientCache_js_1 = /* @__PURE__ */ requireHttpClientCache();
  const operationHelpers_js_1 = /* @__PURE__ */ requireOperationHelpers();
  const urlHelpers_js_1 = /* @__PURE__ */ requireUrlHelpers();
  const interfaceHelpers_js_1 = /* @__PURE__ */ requireInterfaceHelpers();
  const log_js_1 = /* @__PURE__ */ requireLog$2();
  class ServiceClient {
    /**
     * If specified, this is the base URI that requests will be made against for this ServiceClient.
     * If it is not specified, then all OperationSpecs must contain a baseUrl property.
     */
    _endpoint;
    /**
     * The default request content type for the service.
     * Used if no requestContentType is present on an OperationSpec.
     */
    _requestContentType;
    /**
     * Set to true if the request is sent over HTTP instead of HTTPS
     */
    _allowInsecureConnection;
    /**
     * The HTTP client that will be used to send requests.
     */
    _httpClient;
    /**
     * The pipeline used by this client to make requests
     */
    pipeline;
    /**
     * The ServiceClient constructor
     * @param options - The service client options that govern the behavior of the client.
     */
    constructor(options2 = {}) {
      this._requestContentType = options2.requestContentType;
      this._endpoint = options2.endpoint ?? options2.baseUri;
      if (options2.baseUri) {
        log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
      }
      this._allowInsecureConnection = options2.allowInsecureConnection;
      this._httpClient = options2.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
      this.pipeline = options2.pipeline || createDefaultPipeline(options2);
      if (options2.additionalPolicies?.length) {
        for (const { policy, position } of options2.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : void 0;
          this.pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
    }
    /**
     * Send the provided httpRequest.
     */
    async sendRequest(request2) {
      return this.pipeline.sendRequest(this._httpClient, request2);
    }
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @typeParam T - The typed result of the request, based on the OperationSpec.
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     */
    async sendOperationRequest(operationArguments, operationSpec) {
      const endpoint = operationSpec.baseUrl || this._endpoint;
      if (!endpoint) {
        throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
      }
      const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
      const request2 = (0, core_rest_pipeline_1.createPipelineRequest)({
        url
      });
      request2.method = operationSpec.httpMethod;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request2);
      operationInfo.operationSpec = operationSpec;
      operationInfo.operationArguments = operationArguments;
      const contentType = operationSpec.contentType || this._requestContentType;
      if (contentType && operationSpec.requestBody) {
        request2.headers.set("Content-Type", contentType);
      }
      const options2 = operationArguments.options;
      if (options2) {
        const requestOptions = options2.requestOptions;
        if (requestOptions) {
          if (requestOptions.timeout) {
            request2.timeout = requestOptions.timeout;
          }
          if (requestOptions.onUploadProgress) {
            request2.onUploadProgress = requestOptions.onUploadProgress;
          }
          if (requestOptions.onDownloadProgress) {
            request2.onDownloadProgress = requestOptions.onDownloadProgress;
          }
          if (requestOptions.shouldDeserialize !== void 0) {
            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
          }
          if (requestOptions.allowInsecureConnection) {
            request2.allowInsecureConnection = true;
          }
        }
        if (options2.abortSignal) {
          request2.abortSignal = options2.abortSignal;
        }
        if (options2.tracingOptions) {
          request2.tracingOptions = options2.tracingOptions;
        }
      }
      if (this._allowInsecureConnection) {
        request2.allowInsecureConnection = true;
      }
      if (request2.streamResponseStatusCodes === void 0) {
        request2.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
      }
      try {
        const rawResponse = await this.sendRequest(request2);
        const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
        if (options2?.onResponse) {
          options2.onResponse(rawResponse, flatResponse);
        }
        return flatResponse;
      } catch (error2) {
        if (typeof error2 === "object" && error2?.response) {
          const rawResponse = error2.response;
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error2.statusCode] || operationSpec.responses["default"]);
          error2.details = flatResponse;
          if (options2?.onResponse) {
            options2.onResponse(rawResponse, flatResponse, error2);
          }
        }
        throw error2;
      }
    }
  }
  serviceClient.ServiceClient = ServiceClient;
  function createDefaultPipeline(options2) {
    const credentialScopes = getCredentialScopes(options2);
    const credentialOptions = options2.credential && credentialScopes ? { credentialScopes, credential: options2.credential } : void 0;
    return (0, pipeline_js_1.createClientPipeline)({
      ...options2,
      credentialOptions
    });
  }
  function getCredentialScopes(options2) {
    if (options2.credentialScopes) {
      return options2.credentialScopes;
    }
    if (options2.endpoint) {
      return `${options2.endpoint}/.default`;
    }
    if (options2.baseUri) {
      return `${options2.baseUri}/.default`;
    }
    if (options2.credential && !options2.credentialScopes) {
      throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return void 0;
  }
  return serviceClient;
}
var authorizeRequestOnClaimChallenge = {};
var hasRequiredAuthorizeRequestOnClaimChallenge;
function requireAuthorizeRequestOnClaimChallenge() {
  if (hasRequiredAuthorizeRequestOnClaimChallenge) return authorizeRequestOnClaimChallenge;
  hasRequiredAuthorizeRequestOnClaimChallenge = 1;
  Object.defineProperty(authorizeRequestOnClaimChallenge, "__esModule", { value: true });
  authorizeRequestOnClaimChallenge.parseCAEChallenge = parseCAEChallenge;
  authorizeRequestOnClaimChallenge.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge$1;
  const log_js_1 = /* @__PURE__ */ requireLog$2();
  const base64_js_1 = /* @__PURE__ */ requireBase64();
  function parseCAEChallenge(challenges) {
    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
    return bearerChallenges.map((challenge) => {
      const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
      return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
    });
  }
  async function authorizeRequestOnClaimChallenge$1(onChallengeOptions) {
    const { scopes, response: response2 } = onChallengeOptions;
    const logger2 = onChallengeOptions.logger || log_js_1.logger;
    const challenge = response2.headers.get("WWW-Authenticate");
    if (!challenge) {
      logger2.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const challenges = parseCAEChallenge(challenge) || [];
    const parsedChallenge = challenges.find((x) => x.claims);
    if (!parsedChallenge) {
      logger2.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
      claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
    return true;
  }
  return authorizeRequestOnClaimChallenge;
}
var authorizeRequestOnTenantChallenge = {};
var hasRequiredAuthorizeRequestOnTenantChallenge;
function requireAuthorizeRequestOnTenantChallenge() {
  if (hasRequiredAuthorizeRequestOnTenantChallenge) return authorizeRequestOnTenantChallenge;
  hasRequiredAuthorizeRequestOnTenantChallenge = 1;
  Object.defineProperty(authorizeRequestOnTenantChallenge, "__esModule", { value: true });
  authorizeRequestOnTenantChallenge.authorizeRequestOnTenantChallenge = void 0;
  const Constants = {
    DefaultScope: "/.default",
    /**
     * Defines constants for use with HTTP headers.
     */
    HeaderConstants: {
      /**
       * The Authorization header.
       */
      AUTHORIZATION: "authorization"
    }
  };
  function isUuid(text) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
  }
  const authorizeRequestOnTenantChallenge$1 = async (challengeOptions) => {
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
      const challengeInfo = parseChallenge(challenge);
      const challengeScopes = buildScopes(challengeOptions, challengeInfo);
      const tenantId = extractTenantId(challengeInfo);
      if (!tenantId) {
        return false;
      }
      const accessToken = await challengeOptions.getAccessToken(challengeScopes, {
        ...requestOptions,
        tenantId
      });
      if (!accessToken) {
        return false;
      }
      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
    return false;
  };
  authorizeRequestOnTenantChallenge.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge$1;
  function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    if (tenantId && isUuid(tenantId)) {
      return tenantId;
    }
    return void 0;
  }
  function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_id) {
      return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_id);
    challengeScopes.pathname = Constants.DefaultScope;
    let scope = challengeScopes.toString();
    if (scope === "https://disk.azure.com/.default") {
      scope = "https://disk.azure.com//.default";
    }
    return [scope];
  }
  function getChallenge(response2) {
    const challenge = response2.headers.get("WWW-Authenticate");
    if (response2.status === 401 && challenge) {
      return challenge;
    }
    return;
  }
  function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
  }
  function requestToOptions(request2) {
    return {
      abortSignal: request2.abortSignal,
      requestOptions: {
        timeout: request2.timeout
      },
      tracingOptions: request2.tracingOptions
    };
  }
  return authorizeRequestOnTenantChallenge;
}
var hasRequiredCommonjs$5;
function requireCommonjs$5() {
  if (hasRequiredCommonjs$5) return commonjs$3;
  hasRequiredCommonjs$5 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = void 0;
    var serializer_js_1 = /* @__PURE__ */ requireSerializer();
    Object.defineProperty(exports, "createSerializer", { enumerable: true, get: function() {
      return serializer_js_1.createSerializer;
    } });
    Object.defineProperty(exports, "MapperTypeNames", { enumerable: true, get: function() {
      return serializer_js_1.MapperTypeNames;
    } });
    var serviceClient_js_1 = /* @__PURE__ */ requireServiceClient();
    Object.defineProperty(exports, "ServiceClient", { enumerable: true, get: function() {
      return serviceClient_js_1.ServiceClient;
    } });
    var pipeline_js_1 = /* @__PURE__ */ requirePipeline$1();
    Object.defineProperty(exports, "createClientPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createClientPipeline;
    } });
    var interfaces_js_1 = /* @__PURE__ */ requireInterfaces();
    Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
      return interfaces_js_1.XML_ATTRKEY;
    } });
    Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
      return interfaces_js_1.XML_CHARKEY;
    } });
    var deserializationPolicy_js_1 = /* @__PURE__ */ requireDeserializationPolicy();
    Object.defineProperty(exports, "deserializationPolicy", { enumerable: true, get: function() {
      return deserializationPolicy_js_1.deserializationPolicy;
    } });
    Object.defineProperty(exports, "deserializationPolicyName", { enumerable: true, get: function() {
      return deserializationPolicy_js_1.deserializationPolicyName;
    } });
    var serializationPolicy_js_1 = /* @__PURE__ */ requireSerializationPolicy();
    Object.defineProperty(exports, "serializationPolicy", { enumerable: true, get: function() {
      return serializationPolicy_js_1.serializationPolicy;
    } });
    Object.defineProperty(exports, "serializationPolicyName", { enumerable: true, get: function() {
      return serializationPolicy_js_1.serializationPolicyName;
    } });
    var authorizeRequestOnClaimChallenge_js_1 = /* @__PURE__ */ requireAuthorizeRequestOnClaimChallenge();
    Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
      return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
    } });
    var authorizeRequestOnTenantChallenge_js_1 = /* @__PURE__ */ requireAuthorizeRequestOnTenantChallenge();
    Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
      return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
    } });
  })(commonjs$3);
  return commonjs$3;
}
var response = {};
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  Object.defineProperty(util$1, "__esModule", { value: true });
  util$1.HttpHeaders = void 0;
  util$1.toPipelineRequest = toPipelineRequest;
  util$1.toWebResourceLike = toWebResourceLike;
  util$1.toHttpHeadersLike = toHttpHeadersLike;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const originalRequestSymbol = Symbol("Original PipelineRequest");
  const originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
  function toPipelineRequest(webResource, options2 = {}) {
    const compatWebResource = webResource;
    const request2 = compatWebResource[originalRequestSymbol];
    const headers2 = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
    if (request2) {
      request2.headers = headers2;
      return request2;
    } else {
      const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
        url: webResource.url,
        method: webResource.method,
        headers: headers2,
        withCredentials: webResource.withCredentials,
        timeout: webResource.timeout,
        requestId: webResource.requestId,
        abortSignal: webResource.abortSignal,
        body: webResource.body,
        formData: webResource.formData,
        disableKeepAlive: !!webResource.keepAlive,
        onDownloadProgress: webResource.onDownloadProgress,
        onUploadProgress: webResource.onUploadProgress,
        proxySettings: webResource.proxySettings,
        streamResponseStatusCodes: webResource.streamResponseStatusCodes,
        agent: webResource.agent,
        requestOverrides: webResource.requestOverrides
      });
      if (options2.originalRequest) {
        newRequest[originalClientRequestSymbol] = options2.originalRequest;
      }
      return newRequest;
    }
  }
  function toWebResourceLike(request2, options2) {
    const originalRequest = options2?.originalRequest ?? request2;
    const webResource = {
      url: request2.url,
      method: request2.method,
      headers: toHttpHeadersLike(request2.headers),
      withCredentials: request2.withCredentials,
      timeout: request2.timeout,
      requestId: request2.headers.get("x-ms-client-request-id") || request2.requestId,
      abortSignal: request2.abortSignal,
      body: request2.body,
      formData: request2.formData,
      keepAlive: !!request2.disableKeepAlive,
      onDownloadProgress: request2.onDownloadProgress,
      onUploadProgress: request2.onUploadProgress,
      proxySettings: request2.proxySettings,
      streamResponseStatusCodes: request2.streamResponseStatusCodes,
      agent: request2.agent,
      requestOverrides: request2.requestOverrides,
      clone() {
        throw new Error("Cannot clone a non-proxied WebResourceLike");
      },
      prepare() {
        throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
      },
      validateRequestProperties() {
      }
    };
    if (options2?.createProxy) {
      return new Proxy(webResource, {
        get(target, prop, receiver2) {
          if (prop === originalRequestSymbol) {
            return request2;
          } else if (prop === "clone") {
            return () => {
              return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                createProxy: true,
                originalRequest
              });
            };
          }
          return Reflect.get(target, prop, receiver2);
        },
        set(target, prop, value, receiver2) {
          if (prop === "keepAlive") {
            request2.disableKeepAlive = !value;
          }
          const passThroughProps = [
            "url",
            "method",
            "withCredentials",
            "timeout",
            "requestId",
            "abortSignal",
            "body",
            "formData",
            "onDownloadProgress",
            "onUploadProgress",
            "proxySettings",
            "streamResponseStatusCodes",
            "agent",
            "requestOverrides"
          ];
          if (typeof prop === "string" && passThroughProps.includes(prop)) {
            request2[prop] = value;
          }
          return Reflect.set(target, prop, value, receiver2);
        }
      });
    } else {
      return webResource;
    }
  }
  function toHttpHeadersLike(headers2) {
    return new HttpHeaders(headers2.toJSON({ preserveCase: true }));
  }
  function getHeaderKey(headerName) {
    return headerName.toLowerCase();
  }
  class HttpHeaders {
    _headersMap;
    constructor(rawHeaders) {
      this._headersMap = {};
      if (rawHeaders) {
        for (const headerName in rawHeaders) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param headerName - The name of the header to set. This value is case-insensitive.
     * @param headerValue - The value of the header to set.
     */
    set(headerName, headerValue) {
      this._headersMap[getHeaderKey(headerName)] = {
        name: headerName,
        value: headerValue.toString()
      };
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param headerName - The name of the header.
     */
    get(headerName) {
      const header = this._headersMap[getHeaderKey(headerName)];
      return !header ? void 0 : header.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     */
    contains(headerName) {
      return !!this._headersMap[getHeaderKey(headerName)];
    }
    /**
     * Remove the header with the provided headerName. Return whether or not the header existed and
     * was removed.
     * @param headerName - The name of the header to remove.
     */
    remove(headerName) {
      const result = this.contains(headerName);
      delete this._headersMap[getHeaderKey(headerName)];
      return result;
    }
    /**
     * Get the headers that are contained this collection as an object.
     */
    rawHeaders() {
      return this.toJson({ preserveCase: true });
    }
    /**
     * Get the headers that are contained in this collection as an array.
     */
    headersArray() {
      const headers2 = [];
      for (const headerKey in this._headersMap) {
        headers2.push(this._headersMap[headerKey]);
      }
      return headers2;
    }
    /**
     * Get the header names that are contained in this collection.
     */
    headerNames() {
      const headerNames = [];
      const headers2 = this.headersArray();
      for (let i = 0; i < headers2.length; ++i) {
        headerNames.push(headers2[i].name);
      }
      return headerNames;
    }
    /**
     * Get the header values that are contained in this collection.
     */
    headerValues() {
      const headerValues = [];
      const headers2 = this.headersArray();
      for (let i = 0; i < headers2.length; ++i) {
        headerValues.push(headers2[i].value);
      }
      return headerValues;
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */
    toJson(options2 = {}) {
      const result = {};
      if (options2.preserveCase) {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[header.name] = header.value;
        }
      } else {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[getHeaderKey(header.name)] = header.value;
        }
      }
      return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: true }));
    }
    /**
     * Create a deep clone/copy of this HttpHeaders collection.
     */
    clone() {
      const resultPreservingCasing = {};
      for (const headerKey in this._headersMap) {
        const header = this._headersMap[headerKey];
        resultPreservingCasing[header.name] = header.value;
      }
      return new HttpHeaders(resultPreservingCasing);
    }
  }
  util$1.HttpHeaders = HttpHeaders;
  return util$1;
}
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  Object.defineProperty(response, "__esModule", { value: true });
  response.toCompatResponse = toCompatResponse;
  response.toPipelineResponse = toPipelineResponse;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const util_js_1 = /* @__PURE__ */ requireUtil$1();
  const originalResponse = Symbol("Original FullOperationResponse");
  function toCompatResponse(response2, options2) {
    let request2 = (0, util_js_1.toWebResourceLike)(response2.request);
    let headers2 = (0, util_js_1.toHttpHeadersLike)(response2.headers);
    if (options2?.createProxy) {
      return new Proxy(response2, {
        get(target, prop, receiver2) {
          if (prop === "headers") {
            return headers2;
          } else if (prop === "request") {
            return request2;
          } else if (prop === originalResponse) {
            return response2;
          }
          return Reflect.get(target, prop, receiver2);
        },
        set(target, prop, value, receiver2) {
          if (prop === "headers") {
            headers2 = value;
          } else if (prop === "request") {
            request2 = value;
          }
          return Reflect.set(target, prop, value, receiver2);
        }
      });
    } else {
      return {
        ...response2,
        request: request2,
        headers: headers2
      };
    }
  }
  function toPipelineResponse(compatResponse) {
    const extendedCompatResponse = compatResponse;
    const response2 = extendedCompatResponse[originalResponse];
    const headers2 = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
    if (response2) {
      response2.headers = headers2;
      return response2;
    } else {
      return {
        ...compatResponse,
        headers: headers2,
        request: (0, util_js_1.toPipelineRequest)(compatResponse.request)
      };
    }
  }
  return response;
}
var hasRequiredExtendedClient;
function requireExtendedClient() {
  if (hasRequiredExtendedClient) return extendedClient;
  hasRequiredExtendedClient = 1;
  Object.defineProperty(extendedClient, "__esModule", { value: true });
  extendedClient.ExtendedServiceClient = void 0;
  const disableKeepAlivePolicy_js_1 = /* @__PURE__ */ requireDisableKeepAlivePolicy();
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_client_1 = /* @__PURE__ */ requireCommonjs$5();
  const response_js_1 = /* @__PURE__ */ requireResponse();
  class ExtendedServiceClient extends core_client_1.ServiceClient {
    constructor(options2) {
      super(options2);
      if (options2.keepAliveOptions?.enable === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) {
        this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
      }
      if (options2.redirectOptions?.handleRedirects === false) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_1.redirectPolicyName
        });
      }
    }
    /**
     * Compatible send operation request function.
     *
     * @param operationArguments - Operation arguments
     * @param operationSpec - Operation Spec
     * @returns
     */
    async sendOperationRequest(operationArguments, operationSpec) {
      const userProvidedCallBack = operationArguments?.options?.onResponse;
      let lastResponse;
      function onResponse(rawResponse, flatResponse, error2) {
        lastResponse = rawResponse;
        if (userProvidedCallBack) {
          userProvidedCallBack(rawResponse, flatResponse, error2);
        }
      }
      operationArguments.options = {
        ...operationArguments.options,
        onResponse
      };
      const result = await super.sendOperationRequest(operationArguments, operationSpec);
      if (lastResponse) {
        Object.defineProperty(result, "_response", {
          value: (0, response_js_1.toCompatResponse)(lastResponse)
        });
      }
      return result;
    }
  }
  extendedClient.ExtendedServiceClient = ExtendedServiceClient;
  return extendedClient;
}
var requestPolicyFactoryPolicy = {};
var hasRequiredRequestPolicyFactoryPolicy;
function requireRequestPolicyFactoryPolicy() {
  if (hasRequiredRequestPolicyFactoryPolicy) return requestPolicyFactoryPolicy;
  hasRequiredRequestPolicyFactoryPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = void 0;
    exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
    const util_js_1 = /* @__PURE__ */ requireUtil$1();
    const response_js_1 = /* @__PURE__ */ requireResponse();
    var HttpPipelineLogLevel;
    (function(HttpPipelineLogLevel2) {
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
    })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
    const mockRequestPolicyOptions = {
      log(_logLevel, _message) {
      },
      shouldLog(_logLevel) {
        return false;
      }
    };
    exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
    function createRequestPolicyFactoryPolicy(factories) {
      const orderedFactories = factories.slice().reverse();
      return {
        name: exports.requestPolicyFactoryPolicyName,
        async sendRequest(request2, next) {
          let httpPipeline = {
            async sendRequest(httpRequest) {
              const response3 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
              return (0, response_js_1.toCompatResponse)(response3, { createProxy: true });
            }
          };
          for (const factory of orderedFactories) {
            httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
          }
          const webResourceLike = (0, util_js_1.toWebResourceLike)(request2, { createProxy: true });
          const response2 = await httpPipeline.sendRequest(webResourceLike);
          return (0, response_js_1.toPipelineResponse)(response2);
        }
      };
    }
  })(requestPolicyFactoryPolicy);
  return requestPolicyFactoryPolicy;
}
var httpClientAdapter = {};
var hasRequiredHttpClientAdapter;
function requireHttpClientAdapter() {
  if (hasRequiredHttpClientAdapter) return httpClientAdapter;
  hasRequiredHttpClientAdapter = 1;
  Object.defineProperty(httpClientAdapter, "__esModule", { value: true });
  httpClientAdapter.convertHttpClient = convertHttpClient;
  const response_js_1 = /* @__PURE__ */ requireResponse();
  const util_js_1 = /* @__PURE__ */ requireUtil$1();
  function convertHttpClient(requestPolicyClient) {
    return {
      sendRequest: async (request2) => {
        const response2 = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request2, { createProxy: true }));
        return (0, response_js_1.toPipelineResponse)(response2);
      }
    };
  }
  return httpClientAdapter;
}
var hasRequiredCommonjs$4;
function requireCommonjs$4() {
  if (hasRequiredCommonjs$4) return commonjs$4;
  hasRequiredCommonjs$4 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = void 0;
    var extendedClient_js_1 = /* @__PURE__ */ requireExtendedClient();
    Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: true, get: function() {
      return extendedClient_js_1.ExtendedServiceClient;
    } });
    var requestPolicyFactoryPolicy_js_1 = /* @__PURE__ */ requireRequestPolicyFactoryPolicy();
    Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: true, get: function() {
      return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
    } });
    Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: true, get: function() {
      return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
    } });
    Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: true, get: function() {
      return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
    } });
    var disableKeepAlivePolicy_js_1 = /* @__PURE__ */ requireDisableKeepAlivePolicy();
    Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: true, get: function() {
      return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
    } });
    var httpClientAdapter_js_1 = /* @__PURE__ */ requireHttpClientAdapter();
    Object.defineProperty(exports, "convertHttpClient", { enumerable: true, get: function() {
      return httpClientAdapter_js_1.convertHttpClient;
    } });
    var util_js_1 = /* @__PURE__ */ requireUtil$1();
    Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: true, get: function() {
      return util_js_1.toHttpHeadersLike;
    } });
  })(commonjs$4);
  return commonjs$4;
}
var commonjs$2 = {};
var xml = {};
var fxp = { exports: {} };
var hasRequiredFxp;
function requireFxp() {
  if (hasRequiredFxp) return fxp.exports;
  hasRequiredFxp = 1;
  (() => {
    var t = { d: (e2, n2) => {
      for (var i2 in n2) t.o(n2, i2) && !t.o(e2, i2) && Object.defineProperty(e2, i2, { enumerable: true, get: n2[i2] });
    }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    } }, e = {};
    t.r(e), t.d(e, { XMLBuilder: () => lt, XMLParser: () => tt, XMLValidator: () => pt });
    const n = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i = new RegExp("^[" + n + "][" + n + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
    function r(t2, e2) {
      const n2 = [];
      let i2 = e2.exec(t2);
      for (; i2; ) {
        const r2 = [];
        r2.startIndex = e2.lastIndex - i2[0].length;
        const s2 = i2.length;
        for (let t3 = 0; t3 < s2; t3++) r2.push(i2[t3]);
        n2.push(r2), i2 = e2.exec(t2);
      }
      return n2;
    }
    const s = function(t2) {
      return !(null == i.exec(t2));
    }, o = { allowBooleanAttributes: false, unpairedTags: [] };
    function a(t2, e2) {
      e2 = Object.assign({}, o, e2);
      const n2 = [];
      let i2 = false, r2 = false;
      "\uFEFF" === t2[0] && (t2 = t2.substr(1));
      for (let o2 = 0; o2 < t2.length; o2++) if ("<" === t2[o2] && "?" === t2[o2 + 1]) {
        if (o2 += 2, o2 = u(t2, o2), o2.err) return o2;
      } else {
        if ("<" !== t2[o2]) {
          if (l(t2[o2])) continue;
          return x("InvalidChar", "char '" + t2[o2] + "' is not expected.", N(t2, o2));
        }
        {
          let a2 = o2;
          if (o2++, "!" === t2[o2]) {
            o2 = h(t2, o2);
            continue;
          }
          {
            let d2 = false;
            "/" === t2[o2] && (d2 = true, o2++);
            let p2 = "";
            for (; o2 < t2.length && ">" !== t2[o2] && " " !== t2[o2] && "	" !== t2[o2] && "\n" !== t2[o2] && "\r" !== t2[o2]; o2++) p2 += t2[o2];
            if (p2 = p2.trim(), "/" === p2[p2.length - 1] && (p2 = p2.substring(0, p2.length - 1), o2--), !s(p2)) {
              let e3;
              return e3 = 0 === p2.trim().length ? "Invalid space after '<'." : "Tag '" + p2 + "' is an invalid name.", x("InvalidTag", e3, N(t2, o2));
            }
            const c2 = f(t2, o2);
            if (false === c2) return x("InvalidAttr", "Attributes for '" + p2 + "' have open quote.", N(t2, o2));
            let b2 = c2.value;
            if (o2 = c2.index, "/" === b2[b2.length - 1]) {
              const n3 = o2 - b2.length;
              b2 = b2.substring(0, b2.length - 1);
              const r3 = g(b2, e2);
              if (true !== r3) return x(r3.err.code, r3.err.msg, N(t2, n3 + r3.err.line));
              i2 = true;
            } else if (d2) {
              if (!c2.tagClosed) return x("InvalidTag", "Closing tag '" + p2 + "' doesn't have proper closing.", N(t2, o2));
              if (b2.trim().length > 0) return x("InvalidTag", "Closing tag '" + p2 + "' can't have attributes or invalid starting.", N(t2, a2));
              if (0 === n2.length) return x("InvalidTag", "Closing tag '" + p2 + "' has not been opened.", N(t2, a2));
              {
                const e3 = n2.pop();
                if (p2 !== e3.tagName) {
                  let n3 = N(t2, e3.tagStartPos);
                  return x("InvalidTag", "Expected closing tag '" + e3.tagName + "' (opened in line " + n3.line + ", col " + n3.col + ") instead of closing tag '" + p2 + "'.", N(t2, a2));
                }
                0 == n2.length && (r2 = true);
              }
            } else {
              const s2 = g(b2, e2);
              if (true !== s2) return x(s2.err.code, s2.err.msg, N(t2, o2 - b2.length + s2.err.line));
              if (true === r2) return x("InvalidXml", "Multiple possible root nodes found.", N(t2, o2));
              -1 !== e2.unpairedTags.indexOf(p2) || n2.push({ tagName: p2, tagStartPos: a2 }), i2 = true;
            }
            for (o2++; o2 < t2.length; o2++) if ("<" === t2[o2]) {
              if ("!" === t2[o2 + 1]) {
                o2++, o2 = h(t2, o2);
                continue;
              }
              if ("?" !== t2[o2 + 1]) break;
              if (o2 = u(t2, ++o2), o2.err) return o2;
            } else if ("&" === t2[o2]) {
              const e3 = m(t2, o2);
              if (-1 == e3) return x("InvalidChar", "char '&' is not expected.", N(t2, o2));
              o2 = e3;
            } else if (true === r2 && !l(t2[o2])) return x("InvalidXml", "Extra text at the end", N(t2, o2));
            "<" === t2[o2] && o2--;
          }
        }
      }
      return i2 ? 1 == n2.length ? x("InvalidTag", "Unclosed tag '" + n2[0].tagName + "'.", N(t2, n2[0].tagStartPos)) : !(n2.length > 0) || x("InvalidXml", "Invalid '" + JSON.stringify(n2.map(((t3) => t3.tagName)), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x("InvalidXml", "Start tag expected.", 1);
    }
    function l(t2) {
      return " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2;
    }
    function u(t2, e2) {
      const n2 = e2;
      for (; e2 < t2.length; e2++) if ("?" != t2[e2] && " " != t2[e2]) ;
      else {
        const i2 = t2.substr(n2, e2 - n2);
        if (e2 > 5 && "xml" === i2) return x("InvalidXml", "XML declaration allowed only at the start of the document.", N(t2, e2));
        if ("?" == t2[e2] && ">" == t2[e2 + 1]) {
          e2++;
          break;
        }
      }
      return e2;
    }
    function h(t2, e2) {
      if (t2.length > e2 + 5 && "-" === t2[e2 + 1] && "-" === t2[e2 + 2]) {
        for (e2 += 3; e2 < t2.length; e2++) if ("-" === t2[e2] && "-" === t2[e2 + 1] && ">" === t2[e2 + 2]) {
          e2 += 2;
          break;
        }
      } else if (t2.length > e2 + 8 && "D" === t2[e2 + 1] && "O" === t2[e2 + 2] && "C" === t2[e2 + 3] && "T" === t2[e2 + 4] && "Y" === t2[e2 + 5] && "P" === t2[e2 + 6] && "E" === t2[e2 + 7]) {
        let n2 = 1;
        for (e2 += 8; e2 < t2.length; e2++) if ("<" === t2[e2]) n2++;
        else if (">" === t2[e2] && (n2--, 0 === n2)) break;
      } else if (t2.length > e2 + 9 && "[" === t2[e2 + 1] && "C" === t2[e2 + 2] && "D" === t2[e2 + 3] && "A" === t2[e2 + 4] && "T" === t2[e2 + 5] && "A" === t2[e2 + 6] && "[" === t2[e2 + 7]) {
        for (e2 += 8; e2 < t2.length; e2++) if ("]" === t2[e2] && "]" === t2[e2 + 1] && ">" === t2[e2 + 2]) {
          e2 += 2;
          break;
        }
      }
      return e2;
    }
    const d = '"', p = "'";
    function f(t2, e2) {
      let n2 = "", i2 = "", r2 = false;
      for (; e2 < t2.length; e2++) {
        if (t2[e2] === d || t2[e2] === p) "" === i2 ? i2 = t2[e2] : i2 !== t2[e2] || (i2 = "");
        else if (">" === t2[e2] && "" === i2) {
          r2 = true;
          break;
        }
        n2 += t2[e2];
      }
      return "" === i2 && { value: n2, index: e2, tagClosed: r2 };
    }
    const c = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function g(t2, e2) {
      const n2 = r(t2, c), i2 = {};
      for (let t3 = 0; t3 < n2.length; t3++) {
        if (0 === n2[t3][1].length) return x("InvalidAttr", "Attribute '" + n2[t3][2] + "' has no space in starting.", E(n2[t3]));
        if (void 0 !== n2[t3][3] && void 0 === n2[t3][4]) return x("InvalidAttr", "Attribute '" + n2[t3][2] + "' is without value.", E(n2[t3]));
        if (void 0 === n2[t3][3] && !e2.allowBooleanAttributes) return x("InvalidAttr", "boolean attribute '" + n2[t3][2] + "' is not allowed.", E(n2[t3]));
        const r2 = n2[t3][2];
        if (!b(r2)) return x("InvalidAttr", "Attribute '" + r2 + "' is an invalid name.", E(n2[t3]));
        if (i2.hasOwnProperty(r2)) return x("InvalidAttr", "Attribute '" + r2 + "' is repeated.", E(n2[t3]));
        i2[r2] = 1;
      }
      return true;
    }
    function m(t2, e2) {
      if (";" === t2[++e2]) return -1;
      if ("#" === t2[e2]) return (function(t3, e3) {
        let n3 = /\d/;
        for ("x" === t3[e3] && (e3++, n3 = /[\da-fA-F]/); e3 < t3.length; e3++) {
          if (";" === t3[e3]) return e3;
          if (!t3[e3].match(n3)) break;
        }
        return -1;
      })(t2, ++e2);
      let n2 = 0;
      for (; e2 < t2.length; e2++, n2++) if (!(t2[e2].match(/\w/) && n2 < 20)) {
        if (";" === t2[e2]) break;
        return -1;
      }
      return e2;
    }
    function x(t2, e2, n2) {
      return { err: { code: t2, msg: e2, line: n2.line || n2, col: n2.col } };
    }
    function b(t2) {
      return s(t2);
    }
    function N(t2, e2) {
      const n2 = t2.substring(0, e2).split(/\r?\n/);
      return { line: n2.length, col: n2[n2.length - 1].length + 1 };
    }
    function E(t2) {
      return t2.startIndex + t2[1].length;
    }
    const v = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t2, e2, n2) {
      return t2;
    }, captureMetaData: false };
    let T;
    T = "function" != typeof Symbol ? "@@xmlMetadata" : Symbol("XML Node Metadata");
    class y {
      constructor(t2) {
        this.tagname = t2, this.child = [], this[":@"] = {};
      }
      add(t2, e2) {
        "__proto__" === t2 && (t2 = "#__proto__"), this.child.push({ [t2]: e2 });
      }
      addChild(t2, e2) {
        "__proto__" === t2.tagname && (t2.tagname = "#__proto__"), t2[":@"] && Object.keys(t2[":@"]).length > 0 ? this.child.push({ [t2.tagname]: t2.child, ":@": t2[":@"] }) : this.child.push({ [t2.tagname]: t2.child }), void 0 !== e2 && (this.child[this.child.length - 1][T] = { startIndex: e2 });
      }
      static getMetaDataSymbol() {
        return T;
      }
    }
    class w {
      constructor(t2) {
        this.suppressValidationErr = !t2;
      }
      readDocType(t2, e2) {
        const n2 = {};
        if ("O" !== t2[e2 + 3] || "C" !== t2[e2 + 4] || "T" !== t2[e2 + 5] || "Y" !== t2[e2 + 6] || "P" !== t2[e2 + 7] || "E" !== t2[e2 + 8]) throw new Error("Invalid Tag instead of DOCTYPE");
        {
          e2 += 9;
          let i2 = 1, r2 = false, s2 = false, o2 = "";
          for (; e2 < t2.length; e2++) if ("<" !== t2[e2] || s2) if (">" === t2[e2]) {
            if (s2 ? "-" === t2[e2 - 1] && "-" === t2[e2 - 2] && (s2 = false, i2--) : i2--, 0 === i2) break;
          } else "[" === t2[e2] ? r2 = true : o2 += t2[e2];
          else {
            if (r2 && P(t2, "!ENTITY", e2)) {
              let i3, r3;
              e2 += 7, [i3, r3, e2] = this.readEntityExp(t2, e2 + 1, this.suppressValidationErr), -1 === r3.indexOf("&") && (n2[i3] = { regx: RegExp(`&${i3};`, "g"), val: r3 });
            } else if (r2 && P(t2, "!ELEMENT", e2)) {
              e2 += 8;
              const { index: n3 } = this.readElementExp(t2, e2 + 1);
              e2 = n3;
            } else if (r2 && P(t2, "!ATTLIST", e2)) e2 += 8;
            else if (r2 && P(t2, "!NOTATION", e2)) {
              e2 += 9;
              const { index: n3 } = this.readNotationExp(t2, e2 + 1, this.suppressValidationErr);
              e2 = n3;
            } else {
              if (!P(t2, "!--", e2)) throw new Error("Invalid DOCTYPE");
              s2 = true;
            }
            i2++, o2 = "";
          }
          if (0 !== i2) throw new Error("Unclosed DOCTYPE");
        }
        return { entities: n2, i: e2 };
      }
      readEntityExp(t2, e2) {
        e2 = I(t2, e2);
        let n2 = "";
        for (; e2 < t2.length && !/\s/.test(t2[e2]) && '"' !== t2[e2] && "'" !== t2[e2]; ) n2 += t2[e2], e2++;
        if (O(n2), e2 = I(t2, e2), !this.suppressValidationErr) {
          if ("SYSTEM" === t2.substring(e2, e2 + 6).toUpperCase()) throw new Error("External entities are not supported");
          if ("%" === t2[e2]) throw new Error("Parameter entities are not supported");
        }
        let i2 = "";
        return [e2, i2] = this.readIdentifierVal(t2, e2, "entity"), [n2, i2, --e2];
      }
      readNotationExp(t2, e2) {
        e2 = I(t2, e2);
        let n2 = "";
        for (; e2 < t2.length && !/\s/.test(t2[e2]); ) n2 += t2[e2], e2++;
        !this.suppressValidationErr && O(n2), e2 = I(t2, e2);
        const i2 = t2.substring(e2, e2 + 6).toUpperCase();
        if (!this.suppressValidationErr && "SYSTEM" !== i2 && "PUBLIC" !== i2) throw new Error(`Expected SYSTEM or PUBLIC, found "${i2}"`);
        e2 += i2.length, e2 = I(t2, e2);
        let r2 = null, s2 = null;
        if ("PUBLIC" === i2) [e2, r2] = this.readIdentifierVal(t2, e2, "publicIdentifier"), '"' !== t2[e2 = I(t2, e2)] && "'" !== t2[e2] || ([e2, s2] = this.readIdentifierVal(t2, e2, "systemIdentifier"));
        else if ("SYSTEM" === i2 && ([e2, s2] = this.readIdentifierVal(t2, e2, "systemIdentifier"), !this.suppressValidationErr && !s2)) throw new Error("Missing mandatory system identifier for SYSTEM notation");
        return { notationName: n2, publicIdentifier: r2, systemIdentifier: s2, index: --e2 };
      }
      readIdentifierVal(t2, e2, n2) {
        let i2 = "";
        const r2 = t2[e2];
        if ('"' !== r2 && "'" !== r2) throw new Error(`Expected quoted string, found "${r2}"`);
        for (e2++; e2 < t2.length && t2[e2] !== r2; ) i2 += t2[e2], e2++;
        if (t2[e2] !== r2) throw new Error(`Unterminated ${n2} value`);
        return [++e2, i2];
      }
      readElementExp(t2, e2) {
        e2 = I(t2, e2);
        let n2 = "";
        for (; e2 < t2.length && !/\s/.test(t2[e2]); ) n2 += t2[e2], e2++;
        if (!this.suppressValidationErr && !s(n2)) throw new Error(`Invalid element name: "${n2}"`);
        let i2 = "";
        if ("E" === t2[e2 = I(t2, e2)] && P(t2, "MPTY", e2)) e2 += 4;
        else if ("A" === t2[e2] && P(t2, "NY", e2)) e2 += 2;
        else if ("(" === t2[e2]) {
          for (e2++; e2 < t2.length && ")" !== t2[e2]; ) i2 += t2[e2], e2++;
          if (")" !== t2[e2]) throw new Error("Unterminated content model");
        } else if (!this.suppressValidationErr) throw new Error(`Invalid Element Expression, found "${t2[e2]}"`);
        return { elementName: n2, contentModel: i2.trim(), index: e2 };
      }
      readAttlistExp(t2, e2) {
        e2 = I(t2, e2);
        let n2 = "";
        for (; e2 < t2.length && !/\s/.test(t2[e2]); ) n2 += t2[e2], e2++;
        O(n2), e2 = I(t2, e2);
        let i2 = "";
        for (; e2 < t2.length && !/\s/.test(t2[e2]); ) i2 += t2[e2], e2++;
        if (!O(i2)) throw new Error(`Invalid attribute name: "${i2}"`);
        e2 = I(t2, e2);
        let r2 = "";
        if ("NOTATION" === t2.substring(e2, e2 + 8).toUpperCase()) {
          if (r2 = "NOTATION", "(" !== t2[e2 = I(t2, e2 += 8)]) throw new Error(`Expected '(', found "${t2[e2]}"`);
          e2++;
          let n3 = [];
          for (; e2 < t2.length && ")" !== t2[e2]; ) {
            let i3 = "";
            for (; e2 < t2.length && "|" !== t2[e2] && ")" !== t2[e2]; ) i3 += t2[e2], e2++;
            if (i3 = i3.trim(), !O(i3)) throw new Error(`Invalid notation name: "${i3}"`);
            n3.push(i3), "|" === t2[e2] && (e2++, e2 = I(t2, e2));
          }
          if (")" !== t2[e2]) throw new Error("Unterminated list of notations");
          e2++, r2 += " (" + n3.join("|") + ")";
        } else {
          for (; e2 < t2.length && !/\s/.test(t2[e2]); ) r2 += t2[e2], e2++;
          const n3 = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
          if (!this.suppressValidationErr && !n3.includes(r2.toUpperCase())) throw new Error(`Invalid attribute type: "${r2}"`);
        }
        e2 = I(t2, e2);
        let s2 = "";
        return "#REQUIRED" === t2.substring(e2, e2 + 8).toUpperCase() ? (s2 = "#REQUIRED", e2 += 8) : "#IMPLIED" === t2.substring(e2, e2 + 7).toUpperCase() ? (s2 = "#IMPLIED", e2 += 7) : [e2, s2] = this.readIdentifierVal(t2, e2, "ATTLIST"), { elementName: n2, attributeName: i2, attributeType: r2, defaultValue: s2, index: e2 };
      }
    }
    const I = (t2, e2) => {
      for (; e2 < t2.length && /\s/.test(t2[e2]); ) e2++;
      return e2;
    };
    function P(t2, e2, n2) {
      for (let i2 = 0; i2 < e2.length; i2++) if (e2[i2] !== t2[n2 + i2 + 1]) return false;
      return true;
    }
    function O(t2) {
      if (s(t2)) return t2;
      throw new Error(`Invalid entity name ${t2}`);
    }
    const A = /^[-+]?0x[a-fA-F0-9]+$/, S = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, C = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
    const V = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function $(t2) {
      return "function" == typeof t2 ? t2 : Array.isArray(t2) ? (e2) => {
        for (const n2 of t2) {
          if ("string" == typeof n2 && e2 === n2) return true;
          if (n2 instanceof RegExp && n2.test(e2)) return true;
        }
      } : () => false;
    }
    class D {
      constructor(t2) {
        this.options = t2, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "¢" }, pound: { regex: /&(pound|#163);/g, val: "£" }, yen: { regex: /&(yen|#165);/g, val: "¥" }, euro: { regex: /&(euro|#8364);/g, val: "€" }, copyright: { regex: /&(copy|#169);/g, val: "©" }, reg: { regex: /&(reg|#174);/g, val: "®" }, inr: { regex: /&(inr|#8377);/g, val: "₹" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 16)) } }, this.addExternalEntities = j, this.parseXml = L, this.parseTextData = M, this.resolveNameSpace = F, this.buildAttributesMap = k, this.isItStopNode = Y, this.replaceEntitiesValue = B, this.readStopNodeData = q, this.saveTextToParentTag = R, this.addChild = U, this.ignoreAttributesFn = $(this.options.ignoreAttributes);
      }
    }
    function j(t2) {
      const e2 = Object.keys(t2);
      for (let n2 = 0; n2 < e2.length; n2++) {
        const i2 = e2[n2];
        this.lastEntities[i2] = { regex: new RegExp("&" + i2 + ";", "g"), val: t2[i2] };
      }
    }
    function M(t2, e2, n2, i2, r2, s2, o2) {
      if (void 0 !== t2 && (this.options.trimValues && !i2 && (t2 = t2.trim()), t2.length > 0)) {
        o2 || (t2 = this.replaceEntitiesValue(t2));
        const i3 = this.options.tagValueProcessor(e2, t2, n2, r2, s2);
        return null == i3 ? t2 : typeof i3 != typeof t2 || i3 !== t2 ? i3 : this.options.trimValues || t2.trim() === t2 ? Z(t2, this.options.parseTagValue, this.options.numberParseOptions) : t2;
      }
    }
    function F(t2) {
      if (this.options.removeNSPrefix) {
        const e2 = t2.split(":"), n2 = "/" === t2.charAt(0) ? "/" : "";
        if ("xmlns" === e2[0]) return "";
        2 === e2.length && (t2 = n2 + e2[1]);
      }
      return t2;
    }
    const _ = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function k(t2, e2, n2) {
      if (true !== this.options.ignoreAttributes && "string" == typeof t2) {
        const n3 = r(t2, _), i2 = n3.length, s2 = {};
        for (let t3 = 0; t3 < i2; t3++) {
          const i3 = this.resolveNameSpace(n3[t3][1]);
          if (this.ignoreAttributesFn(i3, e2)) continue;
          let r2 = n3[t3][4], o2 = this.options.attributeNamePrefix + i3;
          if (i3.length) if (this.options.transformAttributeName && (o2 = this.options.transformAttributeName(o2)), "__proto__" === o2 && (o2 = "#__proto__"), void 0 !== r2) {
            this.options.trimValues && (r2 = r2.trim()), r2 = this.replaceEntitiesValue(r2);
            const t4 = this.options.attributeValueProcessor(i3, r2, e2);
            s2[o2] = null == t4 ? r2 : typeof t4 != typeof r2 || t4 !== r2 ? t4 : Z(r2, this.options.parseAttributeValue, this.options.numberParseOptions);
          } else this.options.allowBooleanAttributes && (s2[o2] = true);
        }
        if (!Object.keys(s2).length) return;
        if (this.options.attributesGroupName) {
          const t3 = {};
          return t3[this.options.attributesGroupName] = s2, t3;
        }
        return s2;
      }
    }
    const L = function(t2) {
      t2 = t2.replace(/\r\n?/g, "\n");
      const e2 = new y("!xml");
      let n2 = e2, i2 = "", r2 = "";
      const s2 = new w(this.options.processEntities);
      for (let o2 = 0; o2 < t2.length; o2++) if ("<" === t2[o2]) if ("/" === t2[o2 + 1]) {
        const e3 = G(t2, ">", o2, "Closing Tag is not closed.");
        let s3 = t2.substring(o2 + 2, e3).trim();
        if (this.options.removeNSPrefix) {
          const t3 = s3.indexOf(":");
          -1 !== t3 && (s3 = s3.substr(t3 + 1));
        }
        this.options.transformTagName && (s3 = this.options.transformTagName(s3)), n2 && (i2 = this.saveTextToParentTag(i2, n2, r2));
        const a2 = r2.substring(r2.lastIndexOf(".") + 1);
        if (s3 && -1 !== this.options.unpairedTags.indexOf(s3)) throw new Error(`Unpaired tag can not be used as closing tag: </${s3}>`);
        let l2 = 0;
        a2 && -1 !== this.options.unpairedTags.indexOf(a2) ? (l2 = r2.lastIndexOf(".", r2.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l2 = r2.lastIndexOf("."), r2 = r2.substring(0, l2), n2 = this.tagsNodeStack.pop(), i2 = "", o2 = e3;
      } else if ("?" === t2[o2 + 1]) {
        let e3 = X(t2, o2, false, "?>");
        if (!e3) throw new Error("Pi Tag is not closed.");
        if (i2 = this.saveTextToParentTag(i2, n2, r2), this.options.ignoreDeclaration && "?xml" === e3.tagName || this.options.ignorePiTags) ;
        else {
          const t3 = new y(e3.tagName);
          t3.add(this.options.textNodeName, ""), e3.tagName !== e3.tagExp && e3.attrExpPresent && (t3[":@"] = this.buildAttributesMap(e3.tagExp, r2, e3.tagName)), this.addChild(n2, t3, r2, o2);
        }
        o2 = e3.closeIndex + 1;
      } else if ("!--" === t2.substr(o2 + 1, 3)) {
        const e3 = G(t2, "-->", o2 + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const s3 = t2.substring(o2 + 4, e3 - 2);
          i2 = this.saveTextToParentTag(i2, n2, r2), n2.add(this.options.commentPropName, [{ [this.options.textNodeName]: s3 }]);
        }
        o2 = e3;
      } else if ("!D" === t2.substr(o2 + 1, 2)) {
        const e3 = s2.readDocType(t2, o2);
        this.docTypeEntities = e3.entities, o2 = e3.i;
      } else if ("![" === t2.substr(o2 + 1, 2)) {
        const e3 = G(t2, "]]>", o2, "CDATA is not closed.") - 2, s3 = t2.substring(o2 + 9, e3);
        i2 = this.saveTextToParentTag(i2, n2, r2);
        let a2 = this.parseTextData(s3, n2.tagname, r2, true, false, true, true);
        null == a2 && (a2 = ""), this.options.cdataPropName ? n2.add(this.options.cdataPropName, [{ [this.options.textNodeName]: s3 }]) : n2.add(this.options.textNodeName, a2), o2 = e3 + 2;
      } else {
        let s3 = X(t2, o2, this.options.removeNSPrefix), a2 = s3.tagName;
        const l2 = s3.rawTagName;
        let u2 = s3.tagExp, h2 = s3.attrExpPresent, d2 = s3.closeIndex;
        this.options.transformTagName && (a2 = this.options.transformTagName(a2)), n2 && i2 && "!xml" !== n2.tagname && (i2 = this.saveTextToParentTag(i2, n2, r2, false));
        const p2 = n2;
        p2 && -1 !== this.options.unpairedTags.indexOf(p2.tagname) && (n2 = this.tagsNodeStack.pop(), r2 = r2.substring(0, r2.lastIndexOf("."))), a2 !== e2.tagname && (r2 += r2 ? "." + a2 : a2);
        const f2 = o2;
        if (this.isItStopNode(this.options.stopNodes, r2, a2)) {
          let e3 = "";
          if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1) "/" === a2[a2.length - 1] ? (a2 = a2.substr(0, a2.length - 1), r2 = r2.substr(0, r2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), o2 = s3.closeIndex;
          else if (-1 !== this.options.unpairedTags.indexOf(a2)) o2 = s3.closeIndex;
          else {
            const n3 = this.readStopNodeData(t2, l2, d2 + 1);
            if (!n3) throw new Error(`Unexpected end of ${l2}`);
            o2 = n3.i, e3 = n3.tagContent;
          }
          const i3 = new y(a2);
          a2 !== u2 && h2 && (i3[":@"] = this.buildAttributesMap(u2, r2, a2)), e3 && (e3 = this.parseTextData(e3, a2, r2, true, h2, true, true)), r2 = r2.substr(0, r2.lastIndexOf(".")), i3.add(this.options.textNodeName, e3), this.addChild(n2, i3, r2, f2);
        } else {
          if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1) {
            "/" === a2[a2.length - 1] ? (a2 = a2.substr(0, a2.length - 1), r2 = r2.substr(0, r2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), this.options.transformTagName && (a2 = this.options.transformTagName(a2));
            const t3 = new y(a2);
            a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, r2, a2)), this.addChild(n2, t3, r2, f2), r2 = r2.substr(0, r2.lastIndexOf("."));
          } else {
            const t3 = new y(a2);
            this.tagsNodeStack.push(n2), a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, r2, a2)), this.addChild(n2, t3, r2, f2), n2 = t3;
          }
          i2 = "", o2 = d2;
        }
      }
      else i2 += t2[o2];
      return e2.child;
    };
    function U(t2, e2, n2, i2) {
      this.options.captureMetaData || (i2 = void 0);
      const r2 = this.options.updateTag(e2.tagname, n2, e2[":@"]);
      false === r2 || ("string" == typeof r2 ? (e2.tagname = r2, t2.addChild(e2, i2)) : t2.addChild(e2, i2));
    }
    const B = function(t2) {
      if (this.options.processEntities) {
        for (let e2 in this.docTypeEntities) {
          const n2 = this.docTypeEntities[e2];
          t2 = t2.replace(n2.regx, n2.val);
        }
        for (let e2 in this.lastEntities) {
          const n2 = this.lastEntities[e2];
          t2 = t2.replace(n2.regex, n2.val);
        }
        if (this.options.htmlEntities) for (let e2 in this.htmlEntities) {
          const n2 = this.htmlEntities[e2];
          t2 = t2.replace(n2.regex, n2.val);
        }
        t2 = t2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return t2;
    };
    function R(t2, e2, n2, i2) {
      return t2 && (void 0 === i2 && (i2 = 0 === e2.child.length), void 0 !== (t2 = this.parseTextData(t2, e2.tagname, n2, false, !!e2[":@"] && 0 !== Object.keys(e2[":@"]).length, i2)) && "" !== t2 && e2.add(this.options.textNodeName, t2), t2 = ""), t2;
    }
    function Y(t2, e2, n2) {
      const i2 = "*." + n2;
      for (const n3 in t2) {
        const r2 = t2[n3];
        if (i2 === r2 || e2 === r2) return true;
      }
      return false;
    }
    function G(t2, e2, n2, i2) {
      const r2 = t2.indexOf(e2, n2);
      if (-1 === r2) throw new Error(i2);
      return r2 + e2.length - 1;
    }
    function X(t2, e2, n2, i2 = ">") {
      const r2 = (function(t3, e3, n3 = ">") {
        let i3, r3 = "";
        for (let s3 = e3; s3 < t3.length; s3++) {
          let e4 = t3[s3];
          if (i3) e4 === i3 && (i3 = "");
          else if ('"' === e4 || "'" === e4) i3 = e4;
          else if (e4 === n3[0]) {
            if (!n3[1]) return { data: r3, index: s3 };
            if (t3[s3 + 1] === n3[1]) return { data: r3, index: s3 };
          } else "	" === e4 && (e4 = " ");
          r3 += e4;
        }
      })(t2, e2 + 1, i2);
      if (!r2) return;
      let s2 = r2.data;
      const o2 = r2.index, a2 = s2.search(/\s/);
      let l2 = s2, u2 = true;
      -1 !== a2 && (l2 = s2.substring(0, a2), s2 = s2.substring(a2 + 1).trimStart());
      const h2 = l2;
      if (n2) {
        const t3 = l2.indexOf(":");
        -1 !== t3 && (l2 = l2.substr(t3 + 1), u2 = l2 !== r2.data.substr(t3 + 1));
      }
      return { tagName: l2, tagExp: s2, closeIndex: o2, attrExpPresent: u2, rawTagName: h2 };
    }
    function q(t2, e2, n2) {
      const i2 = n2;
      let r2 = 1;
      for (; n2 < t2.length; n2++) if ("<" === t2[n2]) if ("/" === t2[n2 + 1]) {
        const s2 = G(t2, ">", n2, `${e2} is not closed`);
        if (t2.substring(n2 + 2, s2).trim() === e2 && (r2--, 0 === r2)) return { tagContent: t2.substring(i2, n2), i: s2 };
        n2 = s2;
      } else if ("?" === t2[n2 + 1]) n2 = G(t2, "?>", n2 + 1, "StopNode is not closed.");
      else if ("!--" === t2.substr(n2 + 1, 3)) n2 = G(t2, "-->", n2 + 3, "StopNode is not closed.");
      else if ("![" === t2.substr(n2 + 1, 2)) n2 = G(t2, "]]>", n2, "StopNode is not closed.") - 2;
      else {
        const i3 = X(t2, n2, ">");
        i3 && ((i3 && i3.tagName) === e2 && "/" !== i3.tagExp[i3.tagExp.length - 1] && r2++, n2 = i3.closeIndex);
      }
    }
    function Z(t2, e2, n2) {
      if (e2 && "string" == typeof t2) {
        const e3 = t2.trim();
        return "true" === e3 || "false" !== e3 && (function(t3, e4 = {}) {
          if (e4 = Object.assign({}, C, e4), !t3 || "string" != typeof t3) return t3;
          let n3 = t3.trim();
          if (void 0 !== e4.skipLike && e4.skipLike.test(n3)) return t3;
          if ("0" === t3) return 0;
          if (e4.hex && A.test(n3)) return (function(t4) {
            if (parseInt) return parseInt(t4, 16);
            if (Number.parseInt) return Number.parseInt(t4, 16);
            if (window && window.parseInt) return window.parseInt(t4, 16);
            throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
          })(n3);
          if (-1 !== n3.search(/.+[eE].+/)) return (function(t4, e5, n4) {
            if (!n4.eNotation) return t4;
            const i3 = e5.match(V);
            if (i3) {
              let r2 = i3[1] || "";
              const s2 = -1 === i3[3].indexOf("e") ? "E" : "e", o2 = i3[2], a2 = r2 ? t4[o2.length + 1] === s2 : t4[o2.length] === s2;
              return o2.length > 1 && a2 ? t4 : 1 !== o2.length || !i3[3].startsWith(`.${s2}`) && i3[3][0] !== s2 ? n4.leadingZeros && !a2 ? (e5 = (i3[1] || "") + i3[3], Number(e5)) : t4 : Number(e5);
            }
            return t4;
          })(t3, n3, e4);
          {
            const r2 = S.exec(n3);
            if (r2) {
              const s2 = r2[1] || "", o2 = r2[2];
              let a2 = (i2 = r2[3]) && -1 !== i2.indexOf(".") ? ("." === (i2 = i2.replace(/0+$/, "")) ? i2 = "0" : "." === i2[0] ? i2 = "0" + i2 : "." === i2[i2.length - 1] && (i2 = i2.substring(0, i2.length - 1)), i2) : i2;
              const l2 = s2 ? "." === t3[o2.length + 1] : "." === t3[o2.length];
              if (!e4.leadingZeros && (o2.length > 1 || 1 === o2.length && !l2)) return t3;
              {
                const i3 = Number(n3), r3 = String(i3);
                if (0 === i3 || -0 === i3) return i3;
                if (-1 !== r3.search(/[eE]/)) return e4.eNotation ? i3 : t3;
                if (-1 !== n3.indexOf(".")) return "0" === r3 || r3 === a2 || r3 === `${s2}${a2}` ? i3 : t3;
                let l3 = o2 ? a2 : n3;
                return o2 ? l3 === r3 || s2 + l3 === r3 ? i3 : t3 : l3 === r3 || l3 === s2 + r3 ? i3 : t3;
              }
            }
            return t3;
          }
          var i2;
        })(t2, n2);
      }
      return void 0 !== t2 ? t2 : "";
    }
    const W = y.getMetaDataSymbol();
    function K(t2, e2) {
      return Q(t2, e2);
    }
    function Q(t2, e2, n2) {
      let i2;
      const r2 = {};
      for (let s2 = 0; s2 < t2.length; s2++) {
        const o2 = t2[s2], a2 = z(o2);
        let l2 = "";
        if (l2 = void 0 === n2 ? a2 : n2 + "." + a2, a2 === e2.textNodeName) void 0 === i2 ? i2 = o2[a2] : i2 += "" + o2[a2];
        else {
          if (void 0 === a2) continue;
          if (o2[a2]) {
            let t3 = Q(o2[a2], e2, l2);
            const n3 = H(t3, e2);
            void 0 !== o2[W] && (t3[W] = o2[W]), o2[":@"] ? J(t3, o2[":@"], l2, e2) : 1 !== Object.keys(t3).length || void 0 === t3[e2.textNodeName] || e2.alwaysCreateTextNode ? 0 === Object.keys(t3).length && (e2.alwaysCreateTextNode ? t3[e2.textNodeName] = "" : t3 = "") : t3 = t3[e2.textNodeName], void 0 !== r2[a2] && r2.hasOwnProperty(a2) ? (Array.isArray(r2[a2]) || (r2[a2] = [r2[a2]]), r2[a2].push(t3)) : e2.isArray(a2, l2, n3) ? r2[a2] = [t3] : r2[a2] = t3;
          }
        }
      }
      return "string" == typeof i2 ? i2.length > 0 && (r2[e2.textNodeName] = i2) : void 0 !== i2 && (r2[e2.textNodeName] = i2), r2;
    }
    function z(t2) {
      const e2 = Object.keys(t2);
      for (let t3 = 0; t3 < e2.length; t3++) {
        const n2 = e2[t3];
        if (":@" !== n2) return n2;
      }
    }
    function J(t2, e2, n2, i2) {
      if (e2) {
        const r2 = Object.keys(e2), s2 = r2.length;
        for (let o2 = 0; o2 < s2; o2++) {
          const s3 = r2[o2];
          i2.isArray(s3, n2 + "." + s3, true, true) ? t2[s3] = [e2[s3]] : t2[s3] = e2[s3];
        }
      }
    }
    function H(t2, e2) {
      const { textNodeName: n2 } = e2, i2 = Object.keys(t2).length;
      return 0 === i2 || !(1 !== i2 || !t2[n2] && "boolean" != typeof t2[n2] && 0 !== t2[n2]);
    }
    class tt {
      constructor(t2) {
        this.externalEntities = {}, this.options = (function(t3) {
          return Object.assign({}, v, t3);
        })(t2);
      }
      parse(t2, e2) {
        if ("string" != typeof t2 && t2.toString) t2 = t2.toString();
        else if ("string" != typeof t2) throw new Error("XML data is accepted in String or Bytes[] form.");
        if (e2) {
          true === e2 && (e2 = {});
          const n3 = a(t2, e2);
          if (true !== n3) throw Error(`${n3.err.msg}:${n3.err.line}:${n3.err.col}`);
        }
        const n2 = new D(this.options);
        n2.addExternalEntities(this.externalEntities);
        const i2 = n2.parseXml(t2);
        return this.options.preserveOrder || void 0 === i2 ? i2 : K(i2, this.options);
      }
      addEntity(t2, e2) {
        if (-1 !== e2.indexOf("&")) throw new Error("Entity value can't have '&'");
        if (-1 !== t2.indexOf("&") || -1 !== t2.indexOf(";")) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if ("&" === e2) throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t2] = e2;
      }
      static getMetaDataSymbol() {
        return y.getMetaDataSymbol();
      }
    }
    function et(t2, e2) {
      let n2 = "";
      return e2.format && e2.indentBy.length > 0 && (n2 = "\n"), nt(t2, e2, "", n2);
    }
    function nt(t2, e2, n2, i2) {
      let r2 = "", s2 = false;
      for (let o2 = 0; o2 < t2.length; o2++) {
        const a2 = t2[o2], l2 = it(a2);
        if (void 0 === l2) continue;
        let u2 = "";
        if (u2 = 0 === n2.length ? l2 : `${n2}.${l2}`, l2 === e2.textNodeName) {
          let t3 = a2[l2];
          st(u2, e2) || (t3 = e2.tagValueProcessor(l2, t3), t3 = ot(t3, e2)), s2 && (r2 += i2), r2 += t3, s2 = false;
          continue;
        }
        if (l2 === e2.cdataPropName) {
          s2 && (r2 += i2), r2 += `<![CDATA[${a2[l2][0][e2.textNodeName]}]]>`, s2 = false;
          continue;
        }
        if (l2 === e2.commentPropName) {
          r2 += i2 + `<!--${a2[l2][0][e2.textNodeName]}-->`, s2 = true;
          continue;
        }
        if ("?" === l2[0]) {
          const t3 = rt(a2[":@"], e2), n3 = "?xml" === l2 ? "" : i2;
          let o3 = a2[l2][0][e2.textNodeName];
          o3 = 0 !== o3.length ? " " + o3 : "", r2 += n3 + `<${l2}${o3}${t3}?>`, s2 = true;
          continue;
        }
        let h2 = i2;
        "" !== h2 && (h2 += e2.indentBy);
        const d2 = i2 + `<${l2}${rt(a2[":@"], e2)}`, p2 = nt(a2[l2], e2, u2, h2);
        -1 !== e2.unpairedTags.indexOf(l2) ? e2.suppressUnpairedNode ? r2 += d2 + ">" : r2 += d2 + "/>" : p2 && 0 !== p2.length || !e2.suppressEmptyNode ? p2 && p2.endsWith(">") ? r2 += d2 + `>${p2}${i2}</${l2}>` : (r2 += d2 + ">", p2 && "" !== i2 && (p2.includes("/>") || p2.includes("</")) ? r2 += i2 + e2.indentBy + p2 + i2 : r2 += p2, r2 += `</${l2}>`) : r2 += d2 + "/>", s2 = true;
      }
      return r2;
    }
    function it(t2) {
      const e2 = Object.keys(t2);
      for (let n2 = 0; n2 < e2.length; n2++) {
        const i2 = e2[n2];
        if (t2.hasOwnProperty(i2) && ":@" !== i2) return i2;
      }
    }
    function rt(t2, e2) {
      let n2 = "";
      if (t2 && !e2.ignoreAttributes) for (let i2 in t2) {
        if (!t2.hasOwnProperty(i2)) continue;
        let r2 = e2.attributeValueProcessor(i2, t2[i2]);
        r2 = ot(r2, e2), true === r2 && e2.suppressBooleanAttributes ? n2 += ` ${i2.substr(e2.attributeNamePrefix.length)}` : n2 += ` ${i2.substr(e2.attributeNamePrefix.length)}="${r2}"`;
      }
      return n2;
    }
    function st(t2, e2) {
      let n2 = (t2 = t2.substr(0, t2.length - e2.textNodeName.length - 1)).substr(t2.lastIndexOf(".") + 1);
      for (let i2 in e2.stopNodes) if (e2.stopNodes[i2] === t2 || e2.stopNodes[i2] === "*." + n2) return true;
      return false;
    }
    function ot(t2, e2) {
      if (t2 && t2.length > 0 && e2.processEntities) for (let n2 = 0; n2 < e2.entities.length; n2++) {
        const i2 = e2.entities[n2];
        t2 = t2.replace(i2.regex, i2.val);
      }
      return t2;
    }
    const at = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
    function lt(t2) {
      this.options = Object.assign({}, at, t2), true === this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
        return false;
      } : (this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = dt), this.processTextOrObjNode = ut, this.options.format ? (this.indentate = ht, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function() {
        return "";
      }, this.tagEndChar = ">", this.newLine = "");
    }
    function ut(t2, e2, n2, i2) {
      const r2 = this.j2x(t2, n2 + 1, i2.concat(e2));
      return void 0 !== t2[this.options.textNodeName] && 1 === Object.keys(t2).length ? this.buildTextValNode(t2[this.options.textNodeName], e2, r2.attrStr, n2) : this.buildObjectNode(r2.val, e2, r2.attrStr, n2);
    }
    function ht(t2) {
      return this.options.indentBy.repeat(t2);
    }
    function dt(t2) {
      return !(!t2.startsWith(this.options.attributeNamePrefix) || t2 === this.options.textNodeName) && t2.substr(this.attrPrefixLen);
    }
    lt.prototype.build = function(t2) {
      return this.options.preserveOrder ? et(t2, this.options) : (Array.isArray(t2) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t2 = { [this.options.arrayNodeName]: t2 }), this.j2x(t2, 0, []).val);
    }, lt.prototype.j2x = function(t2, e2, n2) {
      let i2 = "", r2 = "";
      const s2 = n2.join(".");
      for (let o2 in t2) if (Object.prototype.hasOwnProperty.call(t2, o2)) if (void 0 === t2[o2]) this.isAttribute(o2) && (r2 += "");
      else if (null === t2[o2]) this.isAttribute(o2) || o2 === this.options.cdataPropName ? r2 += "" : "?" === o2[0] ? r2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : r2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
      else if (t2[o2] instanceof Date) r2 += this.buildTextValNode(t2[o2], o2, "", e2);
      else if ("object" != typeof t2[o2]) {
        const n3 = this.isAttribute(o2);
        if (n3 && !this.ignoreAttributesFn(n3, s2)) i2 += this.buildAttrPairStr(n3, "" + t2[o2]);
        else if (!n3) if (o2 === this.options.textNodeName) {
          let e3 = this.options.tagValueProcessor(o2, "" + t2[o2]);
          r2 += this.replaceEntitiesValue(e3);
        } else r2 += this.buildTextValNode(t2[o2], o2, "", e2);
      } else if (Array.isArray(t2[o2])) {
        const i3 = t2[o2].length;
        let s3 = "", a2 = "";
        for (let l2 = 0; l2 < i3; l2++) {
          const i4 = t2[o2][l2];
          if (void 0 === i4) ;
          else if (null === i4) "?" === o2[0] ? r2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : r2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
          else if ("object" == typeof i4) if (this.options.oneListGroup) {
            const t3 = this.j2x(i4, e2 + 1, n2.concat(o2));
            s3 += t3.val, this.options.attributesGroupName && i4.hasOwnProperty(this.options.attributesGroupName) && (a2 += t3.attrStr);
          } else s3 += this.processTextOrObjNode(i4, o2, e2, n2);
          else if (this.options.oneListGroup) {
            let t3 = this.options.tagValueProcessor(o2, i4);
            t3 = this.replaceEntitiesValue(t3), s3 += t3;
          } else s3 += this.buildTextValNode(i4, o2, "", e2);
        }
        this.options.oneListGroup && (s3 = this.buildObjectNode(s3, o2, a2, e2)), r2 += s3;
      } else if (this.options.attributesGroupName && o2 === this.options.attributesGroupName) {
        const e3 = Object.keys(t2[o2]), n3 = e3.length;
        for (let r3 = 0; r3 < n3; r3++) i2 += this.buildAttrPairStr(e3[r3], "" + t2[o2][e3[r3]]);
      } else r2 += this.processTextOrObjNode(t2[o2], o2, e2, n2);
      return { attrStr: i2, val: r2 };
    }, lt.prototype.buildAttrPairStr = function(t2, e2) {
      return e2 = this.options.attributeValueProcessor(t2, "" + e2), e2 = this.replaceEntitiesValue(e2), this.options.suppressBooleanAttributes && "true" === e2 ? " " + t2 : " " + t2 + '="' + e2 + '"';
    }, lt.prototype.buildObjectNode = function(t2, e2, n2, i2) {
      if ("" === t2) return "?" === e2[0] ? this.indentate(i2) + "<" + e2 + n2 + "?" + this.tagEndChar : this.indentate(i2) + "<" + e2 + n2 + this.closeTag(e2) + this.tagEndChar;
      {
        let r2 = "</" + e2 + this.tagEndChar, s2 = "";
        return "?" === e2[0] && (s2 = "?", r2 = ""), !n2 && "" !== n2 || -1 !== t2.indexOf("<") ? false !== this.options.commentPropName && e2 === this.options.commentPropName && 0 === s2.length ? this.indentate(i2) + `<!--${t2}-->` + this.newLine : this.indentate(i2) + "<" + e2 + n2 + s2 + this.tagEndChar + t2 + this.indentate(i2) + r2 : this.indentate(i2) + "<" + e2 + n2 + s2 + ">" + t2 + r2;
      }
    }, lt.prototype.closeTag = function(t2) {
      let e2 = "";
      return -1 !== this.options.unpairedTags.indexOf(t2) ? this.options.suppressUnpairedNode || (e2 = "/") : e2 = this.options.suppressEmptyNode ? "/" : `></${t2}`, e2;
    }, lt.prototype.buildTextValNode = function(t2, e2, n2, i2) {
      if (false !== this.options.cdataPropName && e2 === this.options.cdataPropName) return this.indentate(i2) + `<![CDATA[${t2}]]>` + this.newLine;
      if (false !== this.options.commentPropName && e2 === this.options.commentPropName) return this.indentate(i2) + `<!--${t2}-->` + this.newLine;
      if ("?" === e2[0]) return this.indentate(i2) + "<" + e2 + n2 + "?" + this.tagEndChar;
      {
        let r2 = this.options.tagValueProcessor(e2, t2);
        return r2 = this.replaceEntitiesValue(r2), "" === r2 ? this.indentate(i2) + "<" + e2 + n2 + this.closeTag(e2) + this.tagEndChar : this.indentate(i2) + "<" + e2 + n2 + ">" + r2 + "</" + e2 + this.tagEndChar;
      }
    }, lt.prototype.replaceEntitiesValue = function(t2) {
      if (t2 && t2.length > 0 && this.options.processEntities) for (let e2 = 0; e2 < this.options.entities.length; e2++) {
        const n2 = this.options.entities[e2];
        t2 = t2.replace(n2.regex, n2.val);
      }
      return t2;
    };
    const pt = { validate: a };
    fxp.exports = e;
  })();
  return fxp.exports;
}
var xml_common = {};
var hasRequiredXml_common;
function requireXml_common() {
  if (hasRequiredXml_common) return xml_common;
  hasRequiredXml_common = 1;
  Object.defineProperty(xml_common, "__esModule", { value: true });
  xml_common.XML_CHARKEY = xml_common.XML_ATTRKEY = void 0;
  xml_common.XML_ATTRKEY = "$";
  xml_common.XML_CHARKEY = "_";
  return xml_common;
}
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  Object.defineProperty(xml, "__esModule", { value: true });
  xml.stringifyXML = stringifyXML;
  xml.parseXML = parseXML;
  const fast_xml_parser_1 = /* @__PURE__ */ requireFxp();
  const xml_common_js_1 = /* @__PURE__ */ requireXml_common();
  function getCommonOptions(options2) {
    var _a;
    return {
      attributesGroupName: xml_common_js_1.XML_ATTRKEY,
      textNodeName: (_a = options2.xmlCharKey) !== null && _a !== void 0 ? _a : xml_common_js_1.XML_CHARKEY,
      ignoreAttributes: false,
      suppressBooleanAttributes: false
    };
  }
  function getSerializerOptions(options2 = {}) {
    var _a, _b;
    return Object.assign(Object.assign({}, getCommonOptions(options2)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a = options2.rootName) !== null && _a !== void 0 ? _a : "root", cdataPropName: (_b = options2.cdataPropName) !== null && _b !== void 0 ? _b : "__cdata" });
  }
  function getParserOptions(options2 = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options2)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options2.stopNodes, processEntities: true, trimValues: false });
  }
  function stringifyXML(obj, opts = {}) {
    const parserOptions = getSerializerOptions(opts);
    const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
    const node2 = { [parserOptions.rootNodeName]: obj };
    const xmlData = j2x.build(node2);
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
  }
  async function parseXML(str, opts = {}) {
    if (!str) {
      throw new Error("Document is empty");
    }
    const validation = fast_xml_parser_1.XMLValidator.validate(str);
    if (validation !== true) {
      throw validation;
    }
    const parser = new fast_xml_parser_1.XMLParser(getParserOptions(opts));
    const parsedXml = parser.parse(str);
    if (parsedXml["?xml"]) {
      delete parsedXml["?xml"];
    }
    if (!opts.includeRoot) {
      for (const key of Object.keys(parsedXml)) {
        const value = parsedXml[key];
        return typeof value === "object" ? Object.assign({}, value) : value;
      }
    }
    return parsedXml;
  }
  return xml;
}
var hasRequiredCommonjs$3;
function requireCommonjs$3() {
  if (hasRequiredCommonjs$3) return commonjs$2;
  hasRequiredCommonjs$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = void 0;
    var xml_js_1 = /* @__PURE__ */ requireXml();
    Object.defineProperty(exports, "stringifyXML", { enumerable: true, get: function() {
      return xml_js_1.stringifyXML;
    } });
    Object.defineProperty(exports, "parseXML", { enumerable: true, get: function() {
      return xml_js_1.parseXML;
    } });
    var xml_common_js_1 = /* @__PURE__ */ requireXml_common();
    Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
      return xml_common_js_1.XML_ATTRKEY;
    } });
    Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
      return xml_common_js_1.XML_CHARKEY;
    } });
  })(commonjs$2);
  return commonjs$2;
}
var log$1 = {};
var hasRequiredLog$1;
function requireLog$1() {
  if (hasRequiredLog$1) return log$1;
  hasRequiredLog$1 = 1;
  Object.defineProperty(log$1, "__esModule", { value: true });
  log$1.logger = void 0;
  const logger_1 = /* @__PURE__ */ requireCommonjs$b();
  log$1.logger = (0, logger_1.createClientLogger)("storage-blob");
  return log$1;
}
var StorageRetryPolicyFactory$1 = {};
var StorageRetryPolicy$1 = {};
var RequestPolicy$1 = {};
var hasRequiredRequestPolicy$1;
function requireRequestPolicy$1() {
  if (hasRequiredRequestPolicy$1) return RequestPolicy$1;
  hasRequiredRequestPolicy$1 = 1;
  Object.defineProperty(RequestPolicy$1, "__esModule", { value: true });
  RequestPolicy$1.BaseRequestPolicy = void 0;
  class BaseRequestPolicy {
    _nextPolicy;
    _options;
    /**
     * The main method to implement that manipulates a request/response.
     */
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy;
      this._options = _options;
    }
    /**
     * Get whether or not a log with the provided log level should be logged.
     * @param logLevel - The log level of the log that will be logged.
     * @returns Whether or not a log with the provided log level should be logged.
     */
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    /**
     * Attempt to log the provided message to the provided logger. If no logger was provided or if
     * the log level does not meat the logger's threshold, then nothing will be logged.
     * @param logLevel - The log level of this log.
     * @param message - The message of this log.
     */
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  RequestPolicy$1.BaseRequestPolicy = BaseRequestPolicy;
  return RequestPolicy$1;
}
var constants$2 = {};
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$2;
  hasRequiredConstants$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PathStylePorts = exports.BlobDoesNotUseCustomerSpecifiedEncryption = exports.BlobUsesCustomerSpecifiedEncryptionMsg = exports.StorageBlobLoggingAllowedQueryParameters = exports.StorageBlobLoggingAllowedHeaderNames = exports.DevelopmentConnectionString = exports.EncryptionAlgorithmAES25 = exports.HTTP_VERSION_1_1 = exports.HTTP_LINE_ENDING = exports.BATCH_MAX_PAYLOAD_IN_BYTES = exports.BATCH_MAX_REQUEST = exports.SIZE_1_MB = exports.ETagAny = exports.ETagNone = exports.HeaderConstants = exports.HTTPURLConnection = exports.URLConstants = exports.StorageOAuthScopes = exports.REQUEST_TIMEOUT = exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = exports.BLOCK_BLOB_MAX_BLOCKS = exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = exports.SERVICE_VERSION = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "12.29.1";
    exports.SERVICE_VERSION = "2025-11-05";
    exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
    exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4e3 * 1024 * 1024;
    exports.BLOCK_BLOB_MAX_BLOCKS = 5e4;
    exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
    exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
    exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
    exports.REQUEST_TIMEOUT = 100 * 1e3;
    exports.StorageOAuthScopes = "https://storage.azure.com/.default";
    exports.URLConstants = {
      Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SIGNATURE: "sig",
        SNAPSHOT: "snapshot",
        VERSIONID: "versionid",
        TIMEOUT: "timeout"
      }
    };
    exports.HTTPURLConnection = {
      HTTP_ACCEPTED: 202,
      HTTP_CONFLICT: 409,
      HTTP_NOT_FOUND: 404,
      HTTP_PRECON_FAILED: 412,
      HTTP_RANGE_NOT_SATISFIABLE: 416
    };
    exports.HeaderConstants = {
      AUTHORIZATION: "Authorization",
      AUTHORIZATION_SCHEME: "Bearer",
      CONTENT_ENCODING: "Content-Encoding",
      CONTENT_ID: "Content-ID",
      CONTENT_LANGUAGE: "Content-Language",
      CONTENT_LENGTH: "Content-Length",
      CONTENT_MD5: "Content-Md5",
      CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
      CONTENT_TYPE: "Content-Type",
      COOKIE: "Cookie",
      DATE: "date",
      IF_MATCH: "if-match",
      IF_MODIFIED_SINCE: "if-modified-since",
      IF_NONE_MATCH: "if-none-match",
      IF_UNMODIFIED_SINCE: "if-unmodified-since",
      PREFIX_FOR_STORAGE: "x-ms-",
      RANGE: "Range",
      USER_AGENT: "User-Agent",
      X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
      X_MS_COPY_SOURCE: "x-ms-copy-source",
      X_MS_DATE: "x-ms-date",
      X_MS_ERROR_CODE: "x-ms-error-code",
      X_MS_VERSION: "x-ms-version",
      X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
    };
    exports.ETagNone = "";
    exports.ETagAny = "*";
    exports.SIZE_1_MB = 1 * 1024 * 1024;
    exports.BATCH_MAX_REQUEST = 256;
    exports.BATCH_MAX_PAYLOAD_IN_BYTES = 4 * exports.SIZE_1_MB;
    exports.HTTP_LINE_ENDING = "\r\n";
    exports.HTTP_VERSION_1_1 = "HTTP/1.1";
    exports.EncryptionAlgorithmAES25 = "AES256";
    exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
    exports.StorageBlobLoggingAllowedHeaderNames = [
      "Access-Control-Allow-Origin",
      "Cache-Control",
      "Content-Length",
      "Content-Type",
      "Date",
      "Request-Id",
      "traceparent",
      "Transfer-Encoding",
      "User-Agent",
      "x-ms-client-request-id",
      "x-ms-date",
      "x-ms-error-code",
      "x-ms-request-id",
      "x-ms-return-client-request-id",
      "x-ms-version",
      "Accept-Ranges",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-MD5",
      "Content-Range",
      "ETag",
      "Last-Modified",
      "Server",
      "Vary",
      "x-ms-content-crc64",
      "x-ms-copy-action",
      "x-ms-copy-completion-time",
      "x-ms-copy-id",
      "x-ms-copy-progress",
      "x-ms-copy-status",
      "x-ms-has-immutability-policy",
      "x-ms-has-legal-hold",
      "x-ms-lease-state",
      "x-ms-lease-status",
      "x-ms-range",
      "x-ms-request-server-encrypted",
      "x-ms-server-encrypted",
      "x-ms-snapshot",
      "x-ms-source-range",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "x-ms-access-tier",
      "x-ms-access-tier-change-time",
      "x-ms-access-tier-inferred",
      "x-ms-account-kind",
      "x-ms-archive-status",
      "x-ms-blob-append-offset",
      "x-ms-blob-cache-control",
      "x-ms-blob-committed-block-count",
      "x-ms-blob-condition-appendpos",
      "x-ms-blob-condition-maxsize",
      "x-ms-blob-content-disposition",
      "x-ms-blob-content-encoding",
      "x-ms-blob-content-language",
      "x-ms-blob-content-length",
      "x-ms-blob-content-md5",
      "x-ms-blob-content-type",
      "x-ms-blob-public-access",
      "x-ms-blob-sequence-number",
      "x-ms-blob-type",
      "x-ms-copy-destination-snapshot",
      "x-ms-creation-time",
      "x-ms-default-encryption-scope",
      "x-ms-delete-snapshots",
      "x-ms-delete-type-permanent",
      "x-ms-deny-encryption-scope-override",
      "x-ms-encryption-algorithm",
      "x-ms-if-sequence-number-eq",
      "x-ms-if-sequence-number-le",
      "x-ms-if-sequence-number-lt",
      "x-ms-incremental-copy",
      "x-ms-lease-action",
      "x-ms-lease-break-period",
      "x-ms-lease-duration",
      "x-ms-lease-id",
      "x-ms-lease-time",
      "x-ms-page-write",
      "x-ms-proposed-lease-id",
      "x-ms-range-get-content-md5",
      "x-ms-rehydrate-priority",
      "x-ms-sequence-number-action",
      "x-ms-sku-name",
      "x-ms-source-content-md5",
      "x-ms-source-if-match",
      "x-ms-source-if-modified-since",
      "x-ms-source-if-none-match",
      "x-ms-source-if-unmodified-since",
      "x-ms-tag-count",
      "x-ms-encryption-key-sha256",
      "x-ms-copy-source-error-code",
      "x-ms-copy-source-status-code",
      "x-ms-if-tags",
      "x-ms-source-if-tags"
    ];
    exports.StorageBlobLoggingAllowedQueryParameters = [
      "comp",
      "maxresults",
      "rscc",
      "rscd",
      "rsce",
      "rscl",
      "rsct",
      "se",
      "si",
      "sip",
      "sp",
      "spr",
      "sr",
      "srt",
      "ss",
      "st",
      "sv",
      "include",
      "marker",
      "prefix",
      "copyid",
      "restype",
      "blockid",
      "blocklisttype",
      "delimiter",
      "prevsnapshot",
      "ske",
      "skoid",
      "sks",
      "skt",
      "sktid",
      "skv",
      "snapshot"
    ];
    exports.BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
    exports.BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
    exports.PathStylePorts = [
      "10000",
      "10001",
      "10002",
      "10003",
      "10004",
      "10100",
      "10101",
      "10102",
      "10103",
      "10104",
      "11000",
      "11001",
      "11002",
      "11003",
      "11004",
      "11100",
      "11101",
      "11102",
      "11103",
      "11104"
    ];
  })(constants$2);
  return constants$2;
}
var utils_common$2 = {};
var hasRequiredUtils_common$2;
function requireUtils_common$2() {
  if (hasRequiredUtils_common$2) return utils_common$2;
  hasRequiredUtils_common$2 = 1;
  Object.defineProperty(utils_common$2, "__esModule", { value: true });
  utils_common$2.escapeURLPath = escapeURLPath;
  utils_common$2.getValueInConnString = getValueInConnString;
  utils_common$2.extractConnectionStringParts = extractConnectionStringParts;
  utils_common$2.appendToURLPath = appendToURLPath;
  utils_common$2.setURLParameter = setURLParameter;
  utils_common$2.getURLParameter = getURLParameter;
  utils_common$2.setURLHost = setURLHost;
  utils_common$2.getURLPath = getURLPath;
  utils_common$2.getURLScheme = getURLScheme;
  utils_common$2.getURLPathAndQuery = getURLPathAndQuery;
  utils_common$2.getURLQueries = getURLQueries;
  utils_common$2.appendToURLQuery = appendToURLQuery;
  utils_common$2.truncatedISO8061Date = truncatedISO8061Date;
  utils_common$2.base64encode = base64encode2;
  utils_common$2.base64decode = base64decode2;
  utils_common$2.generateBlockID = generateBlockID;
  utils_common$2.delay = delay2;
  utils_common$2.padStart = padStart;
  utils_common$2.sanitizeURL = sanitizeURL;
  utils_common$2.sanitizeHeaders = sanitizeHeaders;
  utils_common$2.iEqual = iEqual;
  utils_common$2.getAccountNameFromUrl = getAccountNameFromUrl;
  utils_common$2.isIpEndpointStyle = isIpEndpointStyle;
  utils_common$2.toBlobTagsString = toBlobTagsString;
  utils_common$2.toBlobTags = toBlobTags;
  utils_common$2.toTags = toTags;
  utils_common$2.toQuerySerialization = toQuerySerialization;
  utils_common$2.parseObjectReplicationRecord = parseObjectReplicationRecord;
  utils_common$2.attachCredential = attachCredential;
  utils_common$2.httpAuthorizationToString = httpAuthorizationToString;
  utils_common$2.BlobNameToString = BlobNameToString;
  utils_common$2.ConvertInternalResponseOfListBlobFlat = ConvertInternalResponseOfListBlobFlat;
  utils_common$2.ConvertInternalResponseOfListBlobHierarchy = ConvertInternalResponseOfListBlobHierarchy;
  utils_common$2.ExtractPageRangeInfoItems = ExtractPageRangeInfoItems;
  utils_common$2.EscapePath = EscapePath;
  utils_common$2.assertResponse = assertResponse;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  function escapeURLPath(url) {
    const urlParsed = new URL(url);
    let path2 = urlParsed.pathname;
    path2 = path2 || "/";
    path2 = escape(path2);
    urlParsed.pathname = path2;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = constants_js_1.DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url, name) {
    const urlParsed = new URL(url);
    let path2 = urlParsed.pathname;
    path2 = path2 ? path2.endsWith("/") ? `${path2}${name}` : `${path2}/${name}` : name;
    urlParsed.pathname = path2;
    return urlParsed.toString();
  }
  function setURLParameter(url, name, value) {
    const urlParsed = new URL(url);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : void 0;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url, name) {
    const urlParsed = new URL(url);
    return urlParsed.searchParams.get(name) ?? void 0;
  }
  function setURLHost(url, host) {
    const urlParsed = new URL(url);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.pathname;
    } catch (e) {
      return void 0;
    }
  }
  function getURLScheme(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return void 0;
    }
  }
  function getURLPathAndQuery(url) {
    const urlParsed = new URL(url);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url, queryParts) {
    const urlParsed = new URL(url);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode2(content) {
    return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function base64decode2(encodedString) {
    return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode2(res);
  }
  async function delay2(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout;
      const abortHandler = () => {
        if (timeout !== void 0) {
          clearTimeout(timeout);
        }
        reject(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== void 0) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve();
      };
      timeout = setTimeout(resolveHandler, timeInMs);
      if (aborter !== void 0) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) {
      safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
    }
    return safeURL;
  }
  function sanitizeHeaders(originalHeader) {
    const headers2 = (0, core_rest_pipeline_1.createHttpHeaders)();
    for (const [name, value] of originalHeader) {
      if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) {
        headers2.set(name, "*****");
      } else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) {
        headers2.set(name, sanitizeURL(value));
      } else {
        headers2.set(name, value);
      }
    }
    return headers2;
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url) {
    const parsedUrl = new URL(url);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error2) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
  }
  function toBlobTagsString(tags) {
    if (tags === void 0) {
      return void 0;
    }
    const tagPairs = [];
    for (const key in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, key)) {
        const value = tags[key];
        tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    }
    return tagPairs.join("&");
  }
  function toBlobTags(tags) {
    if (tags === void 0) {
      return void 0;
    }
    const res = {
      blobTagSet: []
    };
    for (const key in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, key)) {
        const value = tags[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    }
    return res;
  }
  function toTags(tags) {
    if (tags === void 0) {
      return void 0;
    }
    const res = {};
    for (const blobTag of tags.blobTagSet) {
      res[blobTag.key] = blobTag.value;
    }
    return res;
  }
  function toQuerySerialization(textConfiguration) {
    if (textConfiguration === void 0) {
      return void 0;
    }
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || false
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord) {
      return void 0;
    }
    if ("policy-id" in objectReplicationRecord) {
      return void 0;
    }
    const orProperties = [];
    for (const key in objectReplicationRecord) {
      const ids = key.split("_");
      const policyPrefix = "or-";
      if (ids[0].startsWith(policyPrefix)) {
        ids[0] = ids[0].substring(policyPrefix.length);
      }
      const rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key]
      };
      const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
      if (policyIndex > -1) {
        orProperties[policyIndex].rules.push(rule);
      } else {
        orProperties.push({
          policyId: ids[0],
          rules: [rule]
        });
      }
    }
    return orProperties;
  }
  function attachCredential(thing, credential) {
    thing.credential = credential;
    return thing;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
  }
  function BlobNameToString(name) {
    if (name.encoded) {
      return decodeURIComponent(name.content);
    } else {
      return name.content;
    }
  }
  function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return {
      ...internalResponse,
      segment: {
        blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
          const blobItem = {
            ...blobItemInteral,
            name: BlobNameToString(blobItemInteral.name)
          };
          return blobItem;
        })
      }
    };
  }
  function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    return {
      ...internalResponse,
      segment: {
        blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {
          const blobPrefix = {
            ...blobPrefixInternal,
            name: BlobNameToString(blobPrefixInternal.name)
          };
          return blobPrefix;
        }),
        blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
          const blobItem = {
            ...blobItemInteral,
            name: BlobNameToString(blobItemInteral.name)
          };
          return blobItem;
        })
      }
    };
  }
  function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [];
    let clearRange = [];
    if (getPageRangesSegment.pageRange)
      pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange)
      clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0;
    let clearRangeIndex = 0;
    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {
      if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: false
        };
        ++pageRangeIndex;
      } else {
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: true
        };
        ++clearRangeIndex;
      }
    }
    for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {
      yield {
        start: pageRange[pageRangeIndex].start,
        end: pageRange[pageRangeIndex].end,
        isClear: false
      };
    }
    for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {
      yield {
        start: clearRange[clearRangeIndex].start,
        end: clearRange[clearRangeIndex].end,
        isClear: true
      };
    }
  }
  function EscapePath(blobName) {
    const split = blobName.split("/");
    for (let i = 0; i < split.length; i++) {
      split[i] = encodeURIComponent(split[i]);
    }
    return split.join("/");
  }
  function assertResponse(response2) {
    if (`_response` in response2) {
      return response2;
    }
    throw new TypeError(`Unexpected response object ${response2}`);
  }
  return utils_common$2;
}
var StorageRetryPolicyType$1 = {};
var hasRequiredStorageRetryPolicyType$1;
function requireStorageRetryPolicyType$1() {
  if (hasRequiredStorageRetryPolicyType$1) return StorageRetryPolicyType$1;
  hasRequiredStorageRetryPolicyType$1 = 1;
  Object.defineProperty(StorageRetryPolicyType$1, "__esModule", { value: true });
  StorageRetryPolicyType$1.StorageRetryPolicyType = void 0;
  var StorageRetryPolicyType2;
  (function(StorageRetryPolicyType3) {
    StorageRetryPolicyType3[StorageRetryPolicyType3["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType3[StorageRetryPolicyType3["FIXED"] = 1] = "FIXED";
  })(StorageRetryPolicyType2 || (StorageRetryPolicyType$1.StorageRetryPolicyType = StorageRetryPolicyType2 = {}));
  return StorageRetryPolicyType$1;
}
var hasRequiredStorageRetryPolicy$1;
function requireStorageRetryPolicy$1() {
  if (hasRequiredStorageRetryPolicy$1) return StorageRetryPolicy$1;
  hasRequiredStorageRetryPolicy$1 = 1;
  Object.defineProperty(StorageRetryPolicy$1, "__esModule", { value: true });
  StorageRetryPolicy$1.StorageRetryPolicy = void 0;
  StorageRetryPolicy$1.NewRetryPolicyFactory = NewRetryPolicyFactory;
  const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
  const RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy$1();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  const log_js_1 = /* @__PURE__ */ requireLog$1();
  const StorageRetryPolicyType_js_1 = /* @__PURE__ */ requireStorageRetryPolicyType$1();
  function NewRetryPolicyFactory(retryOptions) {
    return {
      create: (nextPolicy, options2) => {
        return new StorageRetryPolicy2(nextPolicy, options2, retryOptions);
      }
    };
  }
  const DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1e3,
    maxTries: 4,
    retryDelayInMs: 4 * 1e3,
    retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: void 0
    // Use server side default timeout strategy
  };
  const RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
  class StorageRetryPolicy2 extends RequestPolicy_js_1.BaseRequestPolicy {
    /**
     * RetryOptions.
     */
    retryOptions;
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param retryOptions -
     */
    constructor(nextPolicy, options2, retryOptions = DEFAULT_RETRY_OPTIONS) {
      super(nextPolicy, options2);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
      };
    }
    /**
     * Sends request.
     *
     * @param request -
     */
    async sendRequest(request2) {
      return this.attemptSendRequest(request2, false, 1);
    }
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @param request -
     * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     */
    async attemptSendRequest(request2, secondaryHas404, attempt) {
      const newRequest = request2.clone();
      const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request2.method === "GET" || request2.method === "HEAD" || request2.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry) {
        newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
      }
      if (this.retryOptions.tryTimeoutInMs) {
        newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString());
      }
      let response2;
      try {
        log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
        response2 = await this._nextPolicy.sendRequest(newRequest);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response2)) {
          return response2;
        }
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response2.status === 404;
      } catch (err) {
        log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response2, err)) {
          throw err;
        }
      }
      await this.delay(isPrimaryRetry, attempt, request2.abortSignal);
      return this.attemptSendRequest(request2, secondaryHas404, ++attempt);
    }
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param response -
     * @param err -
     */
    shouldRetry(isPrimaryRetry, attempt, response2, err) {
      if (attempt >= this.retryOptions.maxTries) {
        log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
        return false;
      }
      const retriableErrors = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
        // For default xhr based http client provided in ms-rest-js
      ];
      if (err) {
        for (const retriableError of retriableErrors) {
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
            log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
      }
      if (response2 || err) {
        const statusCode = response2 ? response2.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if (response2) {
        if (response2?.status >= 400) {
          const copySourceError = response2.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== void 0) {
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return true;
            }
          }
        }
      }
      if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
        log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
        return true;
      }
      return false;
    }
    /**
     * Delay a calculated time between retries.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param abortSignal -
     */
    async delay(isPrimaryRetry, attempt, abortSignal2) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (this.retryOptions.retryPolicyType) {
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1e3;
      }
      log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal2, RETRY_ABORT_ERROR);
    }
  }
  StorageRetryPolicy$1.StorageRetryPolicy = StorageRetryPolicy2;
  return StorageRetryPolicy$1;
}
var hasRequiredStorageRetryPolicyFactory$1;
function requireStorageRetryPolicyFactory$1() {
  if (hasRequiredStorageRetryPolicyFactory$1) return StorageRetryPolicyFactory$1;
  hasRequiredStorageRetryPolicyFactory$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
    const StorageRetryPolicy_js_1 = /* @__PURE__ */ requireStorageRetryPolicy$1();
    Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: true, get: function() {
      return StorageRetryPolicy_js_1.StorageRetryPolicy;
    } });
    const StorageRetryPolicyType_js_1 = /* @__PURE__ */ requireStorageRetryPolicyType$1();
    Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: true, get: function() {
      return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
    } });
    class StorageRetryPolicyFactory2 {
      retryOptions;
      /**
       * Creates an instance of StorageRetryPolicyFactory.
       * @param retryOptions -
       */
      constructor(retryOptions) {
        this.retryOptions = retryOptions;
      }
      /**
       * Creates a StorageRetryPolicy object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options2) {
        return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options2, this.retryOptions);
      }
    }
    exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory2;
  })(StorageRetryPolicyFactory$1);
  return StorageRetryPolicyFactory$1;
}
var StorageSharedKeyCredential$1 = {};
var StorageSharedKeyCredentialPolicy$1 = {};
var CredentialPolicy$1 = {};
var hasRequiredCredentialPolicy$1;
function requireCredentialPolicy$1() {
  if (hasRequiredCredentialPolicy$1) return CredentialPolicy$1;
  hasRequiredCredentialPolicy$1 = 1;
  Object.defineProperty(CredentialPolicy$1, "__esModule", { value: true });
  CredentialPolicy$1.CredentialPolicy = void 0;
  const RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy$1();
  class CredentialPolicy2 extends RequestPolicy_js_1.BaseRequestPolicy {
    /**
     * Sends out request.
     *
     * @param request -
     */
    sendRequest(request2) {
      return this._nextPolicy.sendRequest(this.signRequest(request2));
    }
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @param request -
     */
    signRequest(request2) {
      return request2;
    }
  }
  CredentialPolicy$1.CredentialPolicy = CredentialPolicy2;
  return CredentialPolicy$1;
}
var SharedKeyComparator$1 = {};
var hasRequiredSharedKeyComparator$1;
function requireSharedKeyComparator$1() {
  if (hasRequiredSharedKeyComparator$1) return SharedKeyComparator$1;
  hasRequiredSharedKeyComparator$1 = 1;
  Object.defineProperty(SharedKeyComparator$1, "__esModule", { value: true });
  SharedKeyComparator$1.compareHeader = compareHeader;
  const table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]);
  const table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  const table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    const tables = [table_lv0, table_lv2, table_lv4];
    let curr_level = 0;
    let i = 0;
    let j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i !== j) {
        return i > j;
      }
      const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1;
      const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1) {
        i = 0;
        j = 0;
        ++curr_level;
      } else if (weight1 === weight2) {
        ++i;
        ++j;
      } else if (weight1 === 0) {
        ++i;
      } else if (weight2 === 0) {
        ++j;
      } else {
        return weight1 < weight2;
      }
    }
    return false;
  }
  return SharedKeyComparator$1;
}
var hasRequiredStorageSharedKeyCredentialPolicy$1;
function requireStorageSharedKeyCredentialPolicy$1() {
  if (hasRequiredStorageSharedKeyCredentialPolicy$1) return StorageSharedKeyCredentialPolicy$1;
  hasRequiredStorageSharedKeyCredentialPolicy$1 = 1;
  Object.defineProperty(StorageSharedKeyCredentialPolicy$1, "__esModule", { value: true });
  StorageSharedKeyCredentialPolicy$1.StorageSharedKeyCredentialPolicy = void 0;
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  const CredentialPolicy_js_1 = /* @__PURE__ */ requireCredentialPolicy$1();
  const SharedKeyComparator_js_1 = /* @__PURE__ */ requireSharedKeyComparator$1();
  class StorageSharedKeyCredentialPolicy2 extends CredentialPolicy_js_1.CredentialPolicy {
    /**
     * Reference to StorageSharedKeyCredential which generates StorageSharedKeyCredentialPolicy
     */
    factory;
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     * @param factory -
     */
    constructor(nextPolicy, options2, factory) {
      super(nextPolicy, options2);
      this.factory = factory;
    }
    /**
     * Signs request.
     *
     * @param request -
     */
    signRequest(request2) {
      request2.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
      if (request2.body && (typeof request2.body === "string" || request2.body !== void 0) && request2.body.length > 0) {
        request2.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request2.body));
      }
      const stringToSign = [
        request2.method.toUpperCase(),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.DATE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.RANGE)
      ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request2) + this.getCanonicalizedResourceString(request2);
      const signature = this.factory.computeHMACSHA256(stringToSign);
      request2.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
      return request2;
    }
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://learn.microsoft.com/rest/api/storageservices/authenticate-with-shared-key
     *
     * @param request -
     * @param headerName -
     */
    getHeaderValueToSign(request2, headerName) {
      const value = request2.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @param request -
     */
    getCanonicalizedHeadersString(request2) {
      let headersArray = request2.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @param request -
     */
    getCanonicalizedResourceString(request2) {
      const path2 = (0, utils_common_js_1.getURLPath)(request2.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path2}`;
      const queries = (0, utils_common_js_1.getURLQueries)(request2.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
  }
  StorageSharedKeyCredentialPolicy$1.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy2;
  return StorageSharedKeyCredentialPolicy$1;
}
var Credential$1 = {};
var hasRequiredCredential$1;
function requireCredential$1() {
  if (hasRequiredCredential$1) return Credential$1;
  hasRequiredCredential$1 = 1;
  Object.defineProperty(Credential$1, "__esModule", { value: true });
  Credential$1.Credential = void 0;
  class Credential2 {
    /**
     * Creates a RequestPolicy object.
     *
     * @param _nextPolicy -
     * @param _options -
     */
    create(_nextPolicy, _options) {
      throw new Error("Method should be implemented in children classes.");
    }
  }
  Credential$1.Credential = Credential2;
  return Credential$1;
}
var hasRequiredStorageSharedKeyCredential$1;
function requireStorageSharedKeyCredential$1() {
  if (hasRequiredStorageSharedKeyCredential$1) return StorageSharedKeyCredential$1;
  hasRequiredStorageSharedKeyCredential$1 = 1;
  Object.defineProperty(StorageSharedKeyCredential$1, "__esModule", { value: true });
  StorageSharedKeyCredential$1.StorageSharedKeyCredential = void 0;
  const node_crypto_1 = require$$0$e;
  const StorageSharedKeyCredentialPolicy_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredentialPolicy$1();
  const Credential_js_1 = /* @__PURE__ */ requireCredential$1();
  class StorageSharedKeyCredential2 extends Credential_js_1.Credential {
    /**
     * Azure Storage account name; readonly.
     */
    accountName;
    /**
     * Azure Storage account key; readonly.
     */
    accountKey;
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param accountName -
     * @param accountKey -
     */
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName;
      this.accountKey = Buffer.from(accountKey, "base64");
    }
    /**
     * Creates a StorageSharedKeyCredentialPolicy object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options2) {
      return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options2, this);
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }
  StorageSharedKeyCredential$1.StorageSharedKeyCredential = StorageSharedKeyCredential2;
  return StorageSharedKeyCredential$1;
}
var AnonymousCredential$1 = {};
var AnonymousCredentialPolicy$1 = {};
var hasRequiredAnonymousCredentialPolicy$1;
function requireAnonymousCredentialPolicy$1() {
  if (hasRequiredAnonymousCredentialPolicy$1) return AnonymousCredentialPolicy$1;
  hasRequiredAnonymousCredentialPolicy$1 = 1;
  Object.defineProperty(AnonymousCredentialPolicy$1, "__esModule", { value: true });
  AnonymousCredentialPolicy$1.AnonymousCredentialPolicy = void 0;
  const CredentialPolicy_js_1 = /* @__PURE__ */ requireCredentialPolicy$1();
  class AnonymousCredentialPolicy2 extends CredentialPolicy_js_1.CredentialPolicy {
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     */
    // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
    constructor(nextPolicy, options2) {
      super(nextPolicy, options2);
    }
  }
  AnonymousCredentialPolicy$1.AnonymousCredentialPolicy = AnonymousCredentialPolicy2;
  return AnonymousCredentialPolicy$1;
}
var hasRequiredAnonymousCredential$1;
function requireAnonymousCredential$1() {
  if (hasRequiredAnonymousCredential$1) return AnonymousCredential$1;
  hasRequiredAnonymousCredential$1 = 1;
  Object.defineProperty(AnonymousCredential$1, "__esModule", { value: true });
  AnonymousCredential$1.AnonymousCredential = void 0;
  const AnonymousCredentialPolicy_js_1 = /* @__PURE__ */ requireAnonymousCredentialPolicy$1();
  const Credential_js_1 = /* @__PURE__ */ requireCredential$1();
  class AnonymousCredential2 extends Credential_js_1.Credential {
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options2) {
      return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options2);
    }
  }
  AnonymousCredential$1.AnonymousCredential = AnonymousCredential2;
  return AnonymousCredential$1;
}
var commonjs$1 = {};
var BufferScheduler = {};
var PooledBuffer = {};
var BuffersStream = {};
var hasRequiredBuffersStream;
function requireBuffersStream() {
  if (hasRequiredBuffersStream) return BuffersStream;
  hasRequiredBuffersStream = 1;
  Object.defineProperty(BuffersStream, "__esModule", { value: true });
  BuffersStream.BuffersStream = void 0;
  const node_stream_1 = require$$0$b;
  let BuffersStream$1 = class BuffersStream extends node_stream_1.Readable {
    buffers;
    byteLength;
    /**
     * The offset of data to be read in the current buffer.
     */
    byteOffsetInCurrentBuffer;
    /**
     * The index of buffer to be read in the array of buffers.
     */
    bufferIndex;
    /**
     * The total length of data already read.
     */
    pushedBytesLength;
    /**
     * Creates an instance of BuffersStream that will emit the data
     * contained in the array of buffers.
     *
     * @param buffers - Array of buffers containing the data
     * @param byteLength - The total length of data contained in the buffers
     */
    constructor(buffers, byteLength, options2) {
      super(options2);
      this.buffers = buffers;
      this.byteLength = byteLength;
      this.byteOffsetInCurrentBuffer = 0;
      this.bufferIndex = 0;
      this.pushedBytesLength = 0;
      let buffersLength = 0;
      for (const buf of this.buffers) {
        buffersLength += buf.byteLength;
      }
      if (buffersLength < this.byteLength) {
        throw new Error("Data size shouldn't be larger than the total length of buffers.");
      }
    }
    /**
     * Internal _read() that will be called when the stream wants to pull more data in.
     *
     * @param size - Optional. The size of data to be read
     */
    _read(size) {
      if (this.pushedBytesLength >= this.byteLength) {
        this.push(null);
      }
      if (!size) {
        size = this.readableHighWaterMark;
      }
      const outBuffers = [];
      let i = 0;
      while (i < size && this.pushedBytesLength < this.byteLength) {
        const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
        const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
        const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
        if (remaining > size - i) {
          const end = this.byteOffsetInCurrentBuffer + size - i;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          this.pushedBytesLength += size - i;
          this.byteOffsetInCurrentBuffer = end;
          i = size;
          break;
        } else {
          const end = this.byteOffsetInCurrentBuffer + remaining;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          if (remaining === remainingCapacityInThisBuffer) {
            this.byteOffsetInCurrentBuffer = 0;
            this.bufferIndex++;
          } else {
            this.byteOffsetInCurrentBuffer = end;
          }
          this.pushedBytesLength += remaining;
          i += remaining;
        }
      }
      if (outBuffers.length > 1) {
        this.push(Buffer.concat(outBuffers));
      } else if (outBuffers.length === 1) {
        this.push(outBuffers[0]);
      }
    }
  };
  BuffersStream.BuffersStream = BuffersStream$1;
  return BuffersStream;
}
var hasRequiredPooledBuffer;
function requirePooledBuffer() {
  if (hasRequiredPooledBuffer) return PooledBuffer;
  hasRequiredPooledBuffer = 1;
  Object.defineProperty(PooledBuffer, "__esModule", { value: true });
  PooledBuffer.PooledBuffer = void 0;
  const tslib_1 = require$$0$2;
  const BuffersStream_js_1 = /* @__PURE__ */ requireBuffersStream();
  const node_buffer_1 = tslib_1.__importDefault(require$$2$5);
  const maxBufferLength = node_buffer_1.default.constants.MAX_LENGTH;
  let PooledBuffer$1 = class PooledBuffer {
    /**
     * Internal buffers used to keep the data.
     * Each buffer has a length of the maxBufferLength except last one.
     */
    buffers = [];
    /**
     * The total size of internal buffers.
     */
    capacity;
    /**
     * The total size of data contained in internal buffers.
     */
    _size;
    /**
     * The size of the data contained in the pooled buffers.
     */
    get size() {
      return this._size;
    }
    constructor(capacity, buffers, totalLength) {
      this.capacity = capacity;
      this._size = 0;
      const bufferNum = Math.ceil(capacity / maxBufferLength);
      for (let i = 0; i < bufferNum; i++) {
        let len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
        if (len === 0) {
          len = maxBufferLength;
        }
        this.buffers.push(Buffer.allocUnsafe(len));
      }
      if (buffers) {
        this.fill(buffers, totalLength);
      }
    }
    /**
     * Fill the internal buffers with data in the input buffers serially
     * with respect to the total length and the total capacity of the internal buffers.
     * Data copied will be shift out of the input buffers.
     *
     * @param buffers - Input buffers containing the data to be filled in the pooled buffer
     * @param totalLength - Total length of the data to be filled in.
     *
     */
    fill(buffers, totalLength) {
      this._size = Math.min(this.capacity, totalLength);
      let i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
      while (totalCopiedNum < this._size) {
        const source = buffers[i];
        const target = this.buffers[j];
        const copiedNum = source.copy(target, targetOffset, sourceOffset);
        totalCopiedNum += copiedNum;
        sourceOffset += copiedNum;
        targetOffset += copiedNum;
        if (sourceOffset === source.length) {
          i++;
          sourceOffset = 0;
        }
        if (targetOffset === target.length) {
          j++;
          targetOffset = 0;
        }
      }
      buffers.splice(0, i);
      if (buffers.length > 0) {
        buffers[0] = buffers[0].slice(sourceOffset);
      }
    }
    /**
     * Get the readable stream assembled from all the data in the internal buffers.
     *
     */
    getReadableStream() {
      return new BuffersStream_js_1.BuffersStream(this.buffers, this.size);
    }
  };
  PooledBuffer.PooledBuffer = PooledBuffer$1;
  return PooledBuffer;
}
var hasRequiredBufferScheduler;
function requireBufferScheduler() {
  if (hasRequiredBufferScheduler) return BufferScheduler;
  hasRequiredBufferScheduler = 1;
  Object.defineProperty(BufferScheduler, "__esModule", { value: true });
  BufferScheduler.BufferScheduler = void 0;
  const events_1 = require$$0$6;
  const PooledBuffer_js_1 = /* @__PURE__ */ requirePooledBuffer();
  let BufferScheduler$1 = class BufferScheduler {
    /**
     * Size of buffers in incoming and outgoing queues. This class will try to align
     * data read from Readable stream into buffer chunks with bufferSize defined.
     */
    bufferSize;
    /**
     * How many buffers can be created or maintained.
     */
    maxBuffers;
    /**
     * A Node.js Readable stream.
     */
    readable;
    /**
     * OutgoingHandler is an async function triggered by BufferScheduler when there
     * are available buffers in outgoing array.
     */
    outgoingHandler;
    /**
     * An internal event emitter.
     */
    emitter = new events_1.EventEmitter();
    /**
     * Concurrency of executing outgoingHandlers. (0 lesser than concurrency lesser than or equal to maxBuffers)
     */
    concurrency;
    /**
     * An internal offset marker to track data offset in bytes of next outgoingHandler.
     */
    offset = 0;
    /**
     * An internal marker to track whether stream is end.
     */
    isStreamEnd = false;
    /**
     * An internal marker to track whether stream or outgoingHandler returns error.
     */
    isError = false;
    /**
     * How many handlers are executing.
     */
    executingOutgoingHandlers = 0;
    /**
     * Encoding of the input Readable stream which has string data type instead of Buffer.
     */
    encoding;
    /**
     * How many buffers have been allocated.
     */
    numBuffers = 0;
    /**
     * Because this class doesn't know how much data every time stream pops, which
     * is defined by highWaterMarker of the stream. So BufferScheduler will cache
     * data received from the stream, when data in unresolvedDataArray exceeds the
     * blockSize defined, it will try to concat a blockSize of buffer, fill into available
     * buffers from incoming and push to outgoing array.
     */
    unresolvedDataArray = [];
    /**
     * How much data consisted in unresolvedDataArray.
     */
    unresolvedLength = 0;
    /**
     * The array includes all the available buffers can be used to fill data from stream.
     */
    incoming = [];
    /**
     * The array (queue) includes all the buffers filled from stream data.
     */
    outgoing = [];
    /**
     * Creates an instance of BufferScheduler.
     *
     * @param readable - A Node.js Readable stream
     * @param bufferSize - Buffer size of every maintained buffer
     * @param maxBuffers - How many buffers can be allocated
     * @param outgoingHandler - An async function scheduled to be
     *                                          triggered when a buffer fully filled
     *                                          with stream data
     * @param concurrency - Concurrency of executing outgoingHandlers (&gt;0)
     * @param encoding - [Optional] Encoding of Readable stream when it's a string stream
     */
    constructor(readable2, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding2) {
      if (bufferSize <= 0) {
        throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
      }
      if (maxBuffers <= 0) {
        throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
      }
      if (concurrency <= 0) {
        throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
      }
      this.bufferSize = bufferSize;
      this.maxBuffers = maxBuffers;
      this.readable = readable2;
      this.outgoingHandler = outgoingHandler;
      this.concurrency = concurrency;
      this.encoding = encoding2;
    }
    /**
     * Start the scheduler, will return error when stream of any of the outgoingHandlers
     * returns error.
     *
     */
    async do() {
      return new Promise((resolve, reject) => {
        this.readable.on("data", (data) => {
          data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
          this.appendUnresolvedData(data);
          if (!this.resolveData()) {
            this.readable.pause();
          }
        });
        this.readable.on("error", (err) => {
          this.emitter.emit("error", err);
        });
        this.readable.on("end", () => {
          this.isStreamEnd = true;
          this.emitter.emit("checkEnd");
        });
        this.emitter.on("error", (err) => {
          this.isError = true;
          this.readable.pause();
          reject(err);
        });
        this.emitter.on("checkEnd", () => {
          if (this.outgoing.length > 0) {
            this.triggerOutgoingHandlers();
            return;
          }
          if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
            if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
              const buffer = this.shiftBufferFromUnresolvedDataArray();
              this.outgoingHandler(() => buffer.getReadableStream(), buffer.size, this.offset).then(resolve).catch(reject);
            } else if (this.unresolvedLength >= this.bufferSize) {
              return;
            } else {
              resolve();
            }
          }
        });
      });
    }
    /**
     * Insert a new data into unresolved array.
     *
     * @param data -
     */
    appendUnresolvedData(data) {
      this.unresolvedDataArray.push(data);
      this.unresolvedLength += data.length;
    }
    /**
     * Try to shift a buffer with size in blockSize. The buffer returned may be less
     * than blockSize when data in unresolvedDataArray is less than bufferSize.
     *
     */
    shiftBufferFromUnresolvedDataArray(buffer) {
      if (!buffer) {
        buffer = new PooledBuffer_js_1.PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
      } else {
        buffer.fill(this.unresolvedDataArray, this.unresolvedLength);
      }
      this.unresolvedLength -= buffer.size;
      return buffer;
    }
    /**
     * Resolve data in unresolvedDataArray. For every buffer with size in blockSize
     * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,
     * then push it into outgoing to be handled by outgoing handler.
     *
     * Return false when available buffers in incoming are not enough, else true.
     *
     * @returns Return false when buffers in incoming are not enough, else true.
     */
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let buffer;
        if (this.incoming.length > 0) {
          buffer = this.incoming.shift();
          this.shiftBufferFromUnresolvedDataArray(buffer);
        } else {
          if (this.numBuffers < this.maxBuffers) {
            buffer = this.shiftBufferFromUnresolvedDataArray();
            this.numBuffers++;
          } else {
            return false;
          }
        }
        this.outgoing.push(buffer);
        this.triggerOutgoingHandlers();
      }
      return true;
    }
    /**
     * Try to trigger a outgoing handler for every buffer in outgoing. Stop when
     * concurrency reaches.
     */
    async triggerOutgoingHandlers() {
      let buffer;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency) {
          return;
        }
        buffer = this.outgoing.shift();
        if (buffer) {
          this.triggerOutgoingHandler(buffer);
        }
      } while (buffer);
    }
    /**
     * Trigger a outgoing handler for a buffer shifted from outgoing.
     *
     * @param buffer -
     */
    async triggerOutgoingHandler(buffer) {
      const bufferLength = buffer.size;
      this.executingOutgoingHandlers++;
      this.offset += bufferLength;
      try {
        await this.outgoingHandler(() => buffer.getReadableStream(), bufferLength, this.offset - bufferLength);
      } catch (err) {
        this.emitter.emit("error", err);
        return;
      }
      this.executingOutgoingHandlers--;
      this.reuseBuffer(buffer);
      this.emitter.emit("checkEnd");
    }
    /**
     * Return buffer used by outgoing handler into incoming.
     *
     * @param buffer -
     */
    reuseBuffer(buffer) {
      this.incoming.push(buffer);
      if (!this.isError && this.resolveData() && !this.isStreamEnd) {
        this.readable.resume();
      }
    }
  };
  BufferScheduler.BufferScheduler = BufferScheduler$1;
  return BufferScheduler;
}
var cache$1 = {};
var hasRequiredCache$2;
function requireCache$2() {
  if (hasRequiredCache$2) return cache$1;
  hasRequiredCache$2 = 1;
  Object.defineProperty(cache$1, "__esModule", { value: true });
  cache$1.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  let _defaultHttpClient;
  function getCachedDefaultHttpClient() {
    if (!_defaultHttpClient) {
      _defaultHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return _defaultHttpClient;
  }
  return cache$1;
}
var StorageBrowserPolicyFactory$1 = {};
var StorageBrowserPolicy$1 = {};
var RequestPolicy = {};
var hasRequiredRequestPolicy;
function requireRequestPolicy() {
  if (hasRequiredRequestPolicy) return RequestPolicy;
  hasRequiredRequestPolicy = 1;
  Object.defineProperty(RequestPolicy, "__esModule", { value: true });
  RequestPolicy.BaseRequestPolicy = void 0;
  class BaseRequestPolicy {
    _nextPolicy;
    _options;
    /**
     * The main method to implement that manipulates a request/response.
     */
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy;
      this._options = _options;
    }
    /**
     * Get whether or not a log with the provided log level should be logged.
     * @param logLevel - The log level of the log that will be logged.
     * @returns Whether or not a log with the provided log level should be logged.
     */
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    /**
     * Attempt to log the provided message to the provided logger. If no logger was provided or if
     * the log level does not meat the logger's threshold, then nothing will be logged.
     * @param logLevel - The log level of this log.
     * @param message - The message of this log.
     */
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  RequestPolicy.BaseRequestPolicy = BaseRequestPolicy;
  return RequestPolicy;
}
var constants$1 = {};
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  Object.defineProperty(constants$1, "__esModule", { value: true });
  constants$1.PathStylePorts = constants$1.DevelopmentConnectionString = constants$1.HeaderConstants = constants$1.URLConstants = constants$1.SDK_VERSION = void 0;
  constants$1.SDK_VERSION = "1.0.0";
  constants$1.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  constants$1.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  constants$1.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
  constants$1.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
  return constants$1;
}
var utils_common$1 = {};
var hasRequiredUtils_common$1;
function requireUtils_common$1() {
  if (hasRequiredUtils_common$1) return utils_common$1;
  hasRequiredUtils_common$1 = 1;
  Object.defineProperty(utils_common$1, "__esModule", { value: true });
  utils_common$1.escapeURLPath = escapeURLPath;
  utils_common$1.getValueInConnString = getValueInConnString;
  utils_common$1.extractConnectionStringParts = extractConnectionStringParts;
  utils_common$1.appendToURLPath = appendToURLPath;
  utils_common$1.setURLParameter = setURLParameter;
  utils_common$1.getURLParameter = getURLParameter;
  utils_common$1.setURLHost = setURLHost;
  utils_common$1.getURLPath = getURLPath;
  utils_common$1.getURLScheme = getURLScheme;
  utils_common$1.getURLPathAndQuery = getURLPathAndQuery;
  utils_common$1.getURLQueries = getURLQueries;
  utils_common$1.appendToURLQuery = appendToURLQuery;
  utils_common$1.truncatedISO8061Date = truncatedISO8061Date;
  utils_common$1.base64encode = base64encode2;
  utils_common$1.base64decode = base64decode2;
  utils_common$1.generateBlockID = generateBlockID;
  utils_common$1.delay = delay2;
  utils_common$1.padStart = padStart;
  utils_common$1.sanitizeURL = sanitizeURL;
  utils_common$1.sanitizeHeaders = sanitizeHeaders;
  utils_common$1.iEqual = iEqual;
  utils_common$1.getAccountNameFromUrl = getAccountNameFromUrl;
  utils_common$1.isIpEndpointStyle = isIpEndpointStyle;
  utils_common$1.attachCredential = attachCredential;
  utils_common$1.httpAuthorizationToString = httpAuthorizationToString;
  utils_common$1.EscapePath = EscapePath;
  utils_common$1.assertResponse = assertResponse;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const constants_js_1 = /* @__PURE__ */ requireConstants$1();
  function escapeURLPath(url) {
    const urlParsed = new URL(url);
    let path2 = urlParsed.pathname;
    path2 = path2 || "/";
    path2 = escape(path2);
    urlParsed.pathname = path2;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = constants_js_1.DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url, name) {
    const urlParsed = new URL(url);
    let path2 = urlParsed.pathname;
    path2 = path2 ? path2.endsWith("/") ? `${path2}${name}` : `${path2}/${name}` : name;
    urlParsed.pathname = path2;
    return urlParsed.toString();
  }
  function setURLParameter(url, name, value) {
    const urlParsed = new URL(url);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : void 0;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url, name) {
    const urlParsed = new URL(url);
    return urlParsed.searchParams.get(name) ?? void 0;
  }
  function setURLHost(url, host) {
    const urlParsed = new URL(url);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.pathname;
    } catch (e) {
      return void 0;
    }
  }
  function getURLScheme(url) {
    try {
      const urlParsed = new URL(url);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return void 0;
    }
  }
  function getURLPathAndQuery(url) {
    const urlParsed = new URL(url);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url, queryParts) {
    const urlParsed = new URL(url);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode2(content) {
    return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function base64decode2(encodedString) {
    return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode2(res);
  }
  async function delay2(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout;
      const abortHandler = () => {
        if (timeout !== void 0) {
          clearTimeout(timeout);
        }
        reject(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== void 0) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve();
      };
      timeout = setTimeout(resolveHandler, timeInMs);
      if (aborter !== void 0) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) {
      safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
    }
    return safeURL;
  }
  function sanitizeHeaders(originalHeader) {
    const headers2 = (0, core_rest_pipeline_1.createHttpHeaders)();
    for (const [name, value] of originalHeader) {
      if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) {
        headers2.set(name, "*****");
      } else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) {
        headers2.set(name, sanitizeURL(value));
      } else {
        headers2.set(name, value);
      }
    }
    return headers2;
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url) {
    const parsedUrl = new URL(url);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error2) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
  }
  function attachCredential(thing, credential) {
    thing.credential = credential;
    return thing;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
  }
  function EscapePath(blobName) {
    const split = blobName.split("/");
    for (let i = 0; i < split.length; i++) {
      split[i] = encodeURIComponent(split[i]);
    }
    return split.join("/");
  }
  function assertResponse(response2) {
    if (`_response` in response2) {
      return response2;
    }
    throw new TypeError(`Unexpected response object ${response2}`);
  }
  return utils_common$1;
}
var hasRequiredStorageBrowserPolicy$1;
function requireStorageBrowserPolicy$1() {
  if (hasRequiredStorageBrowserPolicy$1) return StorageBrowserPolicy$1;
  hasRequiredStorageBrowserPolicy$1 = 1;
  Object.defineProperty(StorageBrowserPolicy$1, "__esModule", { value: true });
  StorageBrowserPolicy$1.StorageBrowserPolicy = void 0;
  const RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const constants_js_1 = /* @__PURE__ */ requireConstants$1();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$1();
  class StorageBrowserPolicy2 extends RequestPolicy_js_1.BaseRequestPolicy {
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param nextPolicy -
     * @param options -
     */
    // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
    constructor(nextPolicy, options2) {
      super(nextPolicy, options2);
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    async sendRequest(request2) {
      if (core_util_1.isNodeLike) {
        return this._nextPolicy.sendRequest(request2);
      }
      if (request2.method.toUpperCase() === "GET" || request2.method.toUpperCase() === "HEAD") {
        request2.url = (0, utils_common_js_1.setURLParameter)(request2.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
      }
      request2.headers.remove(constants_js_1.HeaderConstants.COOKIE);
      request2.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
      return this._nextPolicy.sendRequest(request2);
    }
  }
  StorageBrowserPolicy$1.StorageBrowserPolicy = StorageBrowserPolicy2;
  return StorageBrowserPolicy$1;
}
var hasRequiredStorageBrowserPolicyFactory$1;
function requireStorageBrowserPolicyFactory$1() {
  if (hasRequiredStorageBrowserPolicyFactory$1) return StorageBrowserPolicyFactory$1;
  hasRequiredStorageBrowserPolicyFactory$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
    const StorageBrowserPolicy_js_1 = /* @__PURE__ */ requireStorageBrowserPolicy$1();
    Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: true, get: function() {
      return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
    } });
    class StorageBrowserPolicyFactory2 {
      /**
       * Creates a StorageBrowserPolicyFactory object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options2) {
        return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options2);
      }
    }
    exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory2;
  })(StorageBrowserPolicyFactory$1);
  return StorageBrowserPolicyFactory$1;
}
var AnonymousCredential = {};
var AnonymousCredentialPolicy = {};
var CredentialPolicy = {};
var hasRequiredCredentialPolicy;
function requireCredentialPolicy() {
  if (hasRequiredCredentialPolicy) return CredentialPolicy;
  hasRequiredCredentialPolicy = 1;
  Object.defineProperty(CredentialPolicy, "__esModule", { value: true });
  CredentialPolicy.CredentialPolicy = void 0;
  const RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy();
  let CredentialPolicy$12 = class CredentialPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    /**
     * Sends out request.
     *
     * @param request -
     */
    sendRequest(request2) {
      return this._nextPolicy.sendRequest(this.signRequest(request2));
    }
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @param request -
     */
    signRequest(request2) {
      return request2;
    }
  };
  CredentialPolicy.CredentialPolicy = CredentialPolicy$12;
  return CredentialPolicy;
}
var hasRequiredAnonymousCredentialPolicy;
function requireAnonymousCredentialPolicy() {
  if (hasRequiredAnonymousCredentialPolicy) return AnonymousCredentialPolicy;
  hasRequiredAnonymousCredentialPolicy = 1;
  Object.defineProperty(AnonymousCredentialPolicy, "__esModule", { value: true });
  AnonymousCredentialPolicy.AnonymousCredentialPolicy = void 0;
  const CredentialPolicy_js_1 = /* @__PURE__ */ requireCredentialPolicy();
  let AnonymousCredentialPolicy$12 = class AnonymousCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     */
    // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
    constructor(nextPolicy, options2) {
      super(nextPolicy, options2);
    }
  };
  AnonymousCredentialPolicy.AnonymousCredentialPolicy = AnonymousCredentialPolicy$12;
  return AnonymousCredentialPolicy;
}
var Credential = {};
var hasRequiredCredential;
function requireCredential() {
  if (hasRequiredCredential) return Credential;
  hasRequiredCredential = 1;
  Object.defineProperty(Credential, "__esModule", { value: true });
  Credential.Credential = void 0;
  let Credential$12 = class Credential {
    /**
     * Creates a RequestPolicy object.
     *
     * @param _nextPolicy -
     * @param _options -
     */
    create(_nextPolicy, _options) {
      throw new Error("Method should be implemented in children classes.");
    }
  };
  Credential.Credential = Credential$12;
  return Credential;
}
var hasRequiredAnonymousCredential;
function requireAnonymousCredential() {
  if (hasRequiredAnonymousCredential) return AnonymousCredential;
  hasRequiredAnonymousCredential = 1;
  Object.defineProperty(AnonymousCredential, "__esModule", { value: true });
  AnonymousCredential.AnonymousCredential = void 0;
  const AnonymousCredentialPolicy_js_1 = /* @__PURE__ */ requireAnonymousCredentialPolicy();
  const Credential_js_1 = /* @__PURE__ */ requireCredential();
  let AnonymousCredential$12 = class AnonymousCredential extends Credential_js_1.Credential {
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options2) {
      return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options2);
    }
  };
  AnonymousCredential.AnonymousCredential = AnonymousCredential$12;
  return AnonymousCredential;
}
var StorageSharedKeyCredential = {};
var StorageSharedKeyCredentialPolicy = {};
var SharedKeyComparator = {};
var hasRequiredSharedKeyComparator;
function requireSharedKeyComparator() {
  if (hasRequiredSharedKeyComparator) return SharedKeyComparator;
  hasRequiredSharedKeyComparator = 1;
  Object.defineProperty(SharedKeyComparator, "__esModule", { value: true });
  SharedKeyComparator.compareHeader = compareHeader;
  const table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]);
  const table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  const table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    const tables = [table_lv0, table_lv2, table_lv4];
    let curr_level = 0;
    let i = 0;
    let j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i !== j) {
        return i > j;
      }
      const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1;
      const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1) {
        i = 0;
        j = 0;
        ++curr_level;
      } else if (weight1 === weight2) {
        ++i;
        ++j;
      } else if (weight1 === 0) {
        ++i;
      } else if (weight2 === 0) {
        ++j;
      } else {
        return weight1 < weight2;
      }
    }
    return false;
  }
  return SharedKeyComparator;
}
var hasRequiredStorageSharedKeyCredentialPolicy;
function requireStorageSharedKeyCredentialPolicy() {
  if (hasRequiredStorageSharedKeyCredentialPolicy) return StorageSharedKeyCredentialPolicy;
  hasRequiredStorageSharedKeyCredentialPolicy = 1;
  Object.defineProperty(StorageSharedKeyCredentialPolicy, "__esModule", { value: true });
  StorageSharedKeyCredentialPolicy.StorageSharedKeyCredentialPolicy = void 0;
  const constants_js_1 = /* @__PURE__ */ requireConstants$1();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$1();
  const CredentialPolicy_js_1 = /* @__PURE__ */ requireCredentialPolicy();
  const SharedKeyComparator_js_1 = /* @__PURE__ */ requireSharedKeyComparator();
  let StorageSharedKeyCredentialPolicy$12 = class StorageSharedKeyCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    /**
     * Reference to StorageSharedKeyCredential which generates StorageSharedKeyCredentialPolicy
     */
    factory;
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     * @param factory -
     */
    constructor(nextPolicy, options2, factory) {
      super(nextPolicy, options2);
      this.factory = factory;
    }
    /**
     * Signs request.
     *
     * @param request -
     */
    signRequest(request2) {
      request2.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
      if (request2.body && (typeof request2.body === "string" || request2.body !== void 0) && request2.body.length > 0) {
        request2.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request2.body));
      }
      const stringToSign = [
        request2.method.toUpperCase(),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.DATE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request2, constants_js_1.HeaderConstants.RANGE)
      ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request2) + this.getCanonicalizedResourceString(request2);
      const signature = this.factory.computeHMACSHA256(stringToSign);
      request2.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
      return request2;
    }
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://learn.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @param request -
     * @param headerName -
     */
    getHeaderValueToSign(request2, headerName) {
      const value = request2.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @param request -
     */
    getCanonicalizedHeadersString(request2) {
      let headersArray = request2.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @param request -
     */
    getCanonicalizedResourceString(request2) {
      const path2 = (0, utils_common_js_1.getURLPath)(request2.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path2}`;
      const queries = (0, utils_common_js_1.getURLQueries)(request2.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
  };
  StorageSharedKeyCredentialPolicy.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy$12;
  return StorageSharedKeyCredentialPolicy;
}
var hasRequiredStorageSharedKeyCredential;
function requireStorageSharedKeyCredential() {
  if (hasRequiredStorageSharedKeyCredential) return StorageSharedKeyCredential;
  hasRequiredStorageSharedKeyCredential = 1;
  Object.defineProperty(StorageSharedKeyCredential, "__esModule", { value: true });
  StorageSharedKeyCredential.StorageSharedKeyCredential = void 0;
  const node_crypto_1 = require$$0$e;
  const StorageSharedKeyCredentialPolicy_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredentialPolicy();
  const Credential_js_1 = /* @__PURE__ */ requireCredential();
  let StorageSharedKeyCredential$12 = class StorageSharedKeyCredential extends Credential_js_1.Credential {
    /**
     * Azure Storage account name; readonly.
     */
    accountName;
    /**
     * Azure Storage account key; readonly.
     */
    accountKey;
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param accountName -
     * @param accountKey -
     */
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName;
      this.accountKey = Buffer.from(accountKey, "base64");
    }
    /**
     * Creates a StorageSharedKeyCredentialPolicy object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options2) {
      return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options2, this);
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  };
  StorageSharedKeyCredential.StorageSharedKeyCredential = StorageSharedKeyCredential$12;
  return StorageSharedKeyCredential;
}
var StorageRetryPolicyFactory = {};
var StorageRetryPolicy = {};
var log = {};
var hasRequiredLog;
function requireLog() {
  if (hasRequiredLog) return log;
  hasRequiredLog = 1;
  Object.defineProperty(log, "__esModule", { value: true });
  log.logger = void 0;
  const logger_1 = /* @__PURE__ */ requireCommonjs$b();
  log.logger = (0, logger_1.createClientLogger)("storage-common");
  return log;
}
var StorageRetryPolicyType = {};
var hasRequiredStorageRetryPolicyType;
function requireStorageRetryPolicyType() {
  if (hasRequiredStorageRetryPolicyType) return StorageRetryPolicyType;
  hasRequiredStorageRetryPolicyType = 1;
  Object.defineProperty(StorageRetryPolicyType, "__esModule", { value: true });
  StorageRetryPolicyType.StorageRetryPolicyType = void 0;
  var StorageRetryPolicyType$12;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(StorageRetryPolicyType$12 || (StorageRetryPolicyType.StorageRetryPolicyType = StorageRetryPolicyType$12 = {}));
  return StorageRetryPolicyType;
}
var hasRequiredStorageRetryPolicy;
function requireStorageRetryPolicy() {
  if (hasRequiredStorageRetryPolicy) return StorageRetryPolicy;
  hasRequiredStorageRetryPolicy = 1;
  Object.defineProperty(StorageRetryPolicy, "__esModule", { value: true });
  StorageRetryPolicy.StorageRetryPolicy = void 0;
  StorageRetryPolicy.NewRetryPolicyFactory = NewRetryPolicyFactory;
  const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
  const RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy();
  const constants_js_1 = /* @__PURE__ */ requireConstants$1();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$1();
  const log_js_1 = /* @__PURE__ */ requireLog();
  const StorageRetryPolicyType_js_1 = /* @__PURE__ */ requireStorageRetryPolicyType();
  function NewRetryPolicyFactory(retryOptions) {
    return {
      create: (nextPolicy, options2) => {
        return new StorageRetryPolicy$12(nextPolicy, options2, retryOptions);
      }
    };
  }
  const DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1e3,
    maxTries: 4,
    retryDelayInMs: 4 * 1e3,
    retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: void 0
    // Use server side default timeout strategy
  };
  const RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
  let StorageRetryPolicy$12 = class StorageRetryPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    /**
     * RetryOptions.
     */
    retryOptions;
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param retryOptions -
     */
    constructor(nextPolicy, options2, retryOptions = DEFAULT_RETRY_OPTIONS) {
      super(nextPolicy, options2);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
      };
    }
    /**
     * Sends request.
     *
     * @param request -
     */
    async sendRequest(request2) {
      return this.attemptSendRequest(request2, false, 1);
    }
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @param request -
     * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     */
    async attemptSendRequest(request2, secondaryHas404, attempt) {
      const newRequest = request2.clone();
      const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request2.method === "GET" || request2.method === "HEAD" || request2.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry) {
        newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
      }
      if (this.retryOptions.tryTimeoutInMs) {
        newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString());
      }
      let response2;
      try {
        log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
        response2 = await this._nextPolicy.sendRequest(newRequest);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response2)) {
          return response2;
        }
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response2.status === 404;
      } catch (err) {
        log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response2, err)) {
          throw err;
        }
      }
      await this.delay(isPrimaryRetry, attempt, request2.abortSignal);
      return this.attemptSendRequest(request2, secondaryHas404, ++attempt);
    }
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param response -
     * @param err -
     */
    shouldRetry(isPrimaryRetry, attempt, response2, err) {
      if (attempt >= this.retryOptions.maxTries) {
        log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
        return false;
      }
      const retriableErrors = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
        // For default xhr based http client provided in ms-rest-js
      ];
      if (err) {
        for (const retriableError of retriableErrors) {
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
            log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
      }
      if (response2 || err) {
        const statusCode = response2 ? response2.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if (response2) {
        if (response2?.status >= 400) {
          const copySourceError = response2.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== void 0) {
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return true;
            }
          }
        }
      }
      if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
        log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
        return true;
      }
      return false;
    }
    /**
     * Delay a calculated time between retries.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param abortSignal -
     */
    async delay(isPrimaryRetry, attempt, abortSignal2) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (this.retryOptions.retryPolicyType) {
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1e3;
      }
      log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal2, RETRY_ABORT_ERROR);
    }
  };
  StorageRetryPolicy.StorageRetryPolicy = StorageRetryPolicy$12;
  return StorageRetryPolicy;
}
var hasRequiredStorageRetryPolicyFactory;
function requireStorageRetryPolicyFactory() {
  if (hasRequiredStorageRetryPolicyFactory) return StorageRetryPolicyFactory;
  hasRequiredStorageRetryPolicyFactory = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
    const StorageRetryPolicy_js_1 = /* @__PURE__ */ requireStorageRetryPolicy();
    Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: true, get: function() {
      return StorageRetryPolicy_js_1.StorageRetryPolicy;
    } });
    const StorageRetryPolicyType_js_1 = /* @__PURE__ */ requireStorageRetryPolicyType();
    Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: true, get: function() {
      return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
    } });
    class StorageRetryPolicyFactory2 {
      retryOptions;
      /**
       * Creates an instance of StorageRetryPolicyFactory.
       * @param retryOptions -
       */
      constructor(retryOptions) {
        this.retryOptions = retryOptions;
      }
      /**
       * Creates a StorageRetryPolicy object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options2) {
        return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options2, this.retryOptions);
      }
    }
    exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory2;
  })(StorageRetryPolicyFactory);
  return StorageRetryPolicyFactory;
}
var StorageBrowserPolicyV2$1 = {};
var hasRequiredStorageBrowserPolicyV2$1;
function requireStorageBrowserPolicyV2$1() {
  if (hasRequiredStorageBrowserPolicyV2$1) return StorageBrowserPolicyV2$1;
  hasRequiredStorageBrowserPolicyV2$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageBrowserPolicyName = void 0;
    exports.storageBrowserPolicy = storageBrowserPolicy;
    const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
    const constants_js_1 = /* @__PURE__ */ requireConstants$1();
    const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$1();
    exports.storageBrowserPolicyName = "storageBrowserPolicy";
    function storageBrowserPolicy() {
      return {
        name: exports.storageBrowserPolicyName,
        async sendRequest(request2, next) {
          if (core_util_1.isNodeLike) {
            return next(request2);
          }
          if (request2.method === "GET" || request2.method === "HEAD") {
            request2.url = (0, utils_common_js_1.setURLParameter)(request2.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
          }
          request2.headers.delete(constants_js_1.HeaderConstants.COOKIE);
          request2.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
          return next(request2);
        }
      };
    }
  })(StorageBrowserPolicyV2$1);
  return StorageBrowserPolicyV2$1;
}
var StorageCorrectContentLengthPolicy$1 = {};
var hasRequiredStorageCorrectContentLengthPolicy$1;
function requireStorageCorrectContentLengthPolicy$1() {
  if (hasRequiredStorageCorrectContentLengthPolicy$1) return StorageCorrectContentLengthPolicy$1;
  hasRequiredStorageCorrectContentLengthPolicy$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageCorrectContentLengthPolicyName = void 0;
    exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
    const constants_js_1 = /* @__PURE__ */ requireConstants$1();
    exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
    function storageCorrectContentLengthPolicy() {
      function correctContentLength(request2) {
        if (request2.body && (typeof request2.body === "string" || Buffer.isBuffer(request2.body)) && request2.body.length > 0) {
          request2.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request2.body));
        }
      }
      return {
        name: exports.storageCorrectContentLengthPolicyName,
        async sendRequest(request2, next) {
          correctContentLength(request2);
          return next(request2);
        }
      };
    }
  })(StorageCorrectContentLengthPolicy$1);
  return StorageCorrectContentLengthPolicy$1;
}
var StorageRetryPolicyV2$1 = {};
var hasRequiredStorageRetryPolicyV2$1;
function requireStorageRetryPolicyV2$1() {
  if (hasRequiredStorageRetryPolicyV2$1) return StorageRetryPolicyV2$1;
  hasRequiredStorageRetryPolicyV2$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageRetryPolicyName = void 0;
    exports.storageRetryPolicy = storageRetryPolicy;
    const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
    const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
    const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
    const StorageRetryPolicyFactory_js_1 = /* @__PURE__ */ requireStorageRetryPolicyFactory();
    const constants_js_1 = /* @__PURE__ */ requireConstants$1();
    const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$1();
    const log_js_1 = /* @__PURE__ */ requireLog();
    exports.storageRetryPolicyName = "storageRetryPolicy";
    const DEFAULT_RETRY_OPTIONS = {
      maxRetryDelayInMs: 120 * 1e3,
      maxTries: 4,
      retryDelayInMs: 4 * 1e3,
      retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0
      // Use server side default timeout strategy
    };
    const retriableErrors = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
    ];
    const RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
    function storageRetryPolicy(options2 = {}) {
      const retryPolicyType = options2.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
      const maxTries = options2.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
      const retryDelayInMs = options2.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
      const maxRetryDelayInMs = options2.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
      const secondaryHost = options2.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
      const tryTimeoutInMs = options2.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
      function shouldRetry({ isPrimaryRetry, attempt, response: response2, error: error2 }) {
        if (attempt >= maxTries) {
          log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
          return false;
        }
        if (error2) {
          for (const retriableError of retriableErrors) {
            if (error2.name.toUpperCase().includes(retriableError) || error2.message.toUpperCase().includes(retriableError) || error2.code && error2.code.toString().toUpperCase() === retriableError) {
              log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
              return true;
            }
          }
          if (error2?.code === "PARSE_ERROR" && error2?.message.startsWith(`Error "Error: Unclosed root tag`)) {
            log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
          }
        }
        if (response2 || error2) {
          const statusCode = response2?.status ?? error2?.statusCode ?? 0;
          if (!isPrimaryRetry && statusCode === 404) {
            log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
            return true;
          }
          if (statusCode === 503 || statusCode === 500) {
            log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
            return true;
          }
        }
        if (response2) {
          if (response2?.status >= 400) {
            const copySourceError = response2.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
            if (copySourceError !== void 0) {
              switch (copySourceError) {
                case "InternalError":
                case "OperationTimedOut":
                case "ServerBusy":
                  return true;
              }
            }
          }
        }
        return false;
      }
      function calculateDelay(isPrimaryRetry, attempt) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
          switch (retryPolicyType) {
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
              break;
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
              delayTimeInMs = retryDelayInMs;
              break;
          }
        } else {
          delayTimeInMs = Math.random() * 1e3;
        }
        log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return delayTimeInMs;
      }
      return {
        name: exports.storageRetryPolicyName,
        async sendRequest(request2, next) {
          if (tryTimeoutInMs) {
            request2.url = (0, utils_common_js_1.setURLParameter)(request2.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1e3)));
          }
          const primaryUrl = request2.url;
          const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request2.url, secondaryHost) : void 0;
          let secondaryHas404 = false;
          let attempt = 1;
          let retryAgain = true;
          let response2;
          let error2;
          while (retryAgain) {
            const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request2.method) || attempt % 2 === 1;
            request2.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
            response2 = void 0;
            error2 = void 0;
            try {
              log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
              response2 = await next(request2);
              secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response2.status === 404;
            } catch (e) {
              if ((0, core_rest_pipeline_1.isRestError)(e)) {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
                error2 = e;
              } else {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`);
                throw e;
              }
            }
            retryAgain = shouldRetry({ isPrimaryRetry, attempt, response: response2, error: error2 });
            if (retryAgain) {
              await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request2.abortSignal, RETRY_ABORT_ERROR);
            }
            attempt++;
          }
          if (response2) {
            return response2;
          }
          throw error2 ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
        }
      };
    }
  })(StorageRetryPolicyV2$1);
  return StorageRetryPolicyV2$1;
}
var StorageSharedKeyCredentialPolicyV2$1 = {};
var hasRequiredStorageSharedKeyCredentialPolicyV2$1;
function requireStorageSharedKeyCredentialPolicyV2$1() {
  if (hasRequiredStorageSharedKeyCredentialPolicyV2$1) return StorageSharedKeyCredentialPolicyV2$1;
  hasRequiredStorageSharedKeyCredentialPolicyV2$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageSharedKeyCredentialPolicyName = void 0;
    exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
    const node_crypto_1 = require$$0$e;
    const constants_js_1 = /* @__PURE__ */ requireConstants$1();
    const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$1();
    const SharedKeyComparator_js_1 = /* @__PURE__ */ requireSharedKeyComparator();
    exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
    function storageSharedKeyCredentialPolicy(options2) {
      function signRequest(request2) {
        request2.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
        if (request2.body && (typeof request2.body === "string" || Buffer.isBuffer(request2.body)) && request2.body.length > 0) {
          request2.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request2.body));
        }
        const stringToSign = [
          request2.method.toUpperCase(),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_ENCODING),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LENGTH),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_MD5),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_TYPE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.DATE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MATCH),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_NONE_MATCH),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.RANGE)
        ].join("\n") + "\n" + getCanonicalizedHeadersString(request2) + getCanonicalizedResourceString(request2);
        const signature = (0, node_crypto_1.createHmac)("sha256", options2.accountKey).update(stringToSign, "utf8").digest("base64");
        request2.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options2.accountName}:${signature}`);
      }
      function getHeaderValueToSign(request2, headerName) {
        const value = request2.headers.get(headerName);
        if (!value) {
          return "";
        }
        if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
          return "";
        }
        return value;
      }
      function getCanonicalizedHeadersString(request2) {
        let headersArray = [];
        for (const [name, value] of request2.headers) {
          if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) {
            headersArray.push({ name, value });
          }
        }
        headersArray.sort((a, b) => {
          return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
        });
        headersArray = headersArray.filter((value, index, array) => {
          if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
            return false;
          }
          return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
          canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
        });
        return canonicalizedHeadersStringToSign;
      }
      function getCanonicalizedResourceString(request2) {
        const path2 = (0, utils_common_js_1.getURLPath)(request2.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${options2.accountName}${path2}`;
        const queries = (0, utils_common_js_1.getURLQueries)(request2.url);
        const lowercaseQueries = {};
        if (queries) {
          const queryKeys = [];
          for (const key in queries) {
            if (Object.prototype.hasOwnProperty.call(queries, key)) {
              const lowercaseKey = key.toLowerCase();
              lowercaseQueries[lowercaseKey] = queries[key];
              queryKeys.push(lowercaseKey);
            }
          }
          queryKeys.sort();
          for (const key of queryKeys) {
            canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
          }
        }
        return canonicalizedResourceString;
      }
      return {
        name: exports.storageSharedKeyCredentialPolicyName,
        async sendRequest(request2, next) {
          signRequest(request2);
          return next(request2);
        }
      };
    }
  })(StorageSharedKeyCredentialPolicyV2$1);
  return StorageSharedKeyCredentialPolicyV2$1;
}
var StorageRequestFailureDetailsParserPolicy = {};
var hasRequiredStorageRequestFailureDetailsParserPolicy;
function requireStorageRequestFailureDetailsParserPolicy() {
  if (hasRequiredStorageRequestFailureDetailsParserPolicy) return StorageRequestFailureDetailsParserPolicy;
  hasRequiredStorageRequestFailureDetailsParserPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageRequestFailureDetailsParserPolicyName = void 0;
    exports.storageRequestFailureDetailsParserPolicy = storageRequestFailureDetailsParserPolicy;
    exports.storageRequestFailureDetailsParserPolicyName = "storageRequestFailureDetailsParserPolicy";
    function storageRequestFailureDetailsParserPolicy() {
      return {
        name: exports.storageRequestFailureDetailsParserPolicyName,
        async sendRequest(request2, next) {
          try {
            const response2 = await next(request2);
            return response2;
          } catch (err) {
            if (typeof err === "object" && err !== null && err.response && err.response.parsedBody) {
              if (err.response.parsedBody.code === "InvalidHeaderValue" && err.response.parsedBody.HeaderName === "x-ms-version") {
                err.message = "The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.\n";
              }
            }
            throw err;
          }
        }
      };
    }
  })(StorageRequestFailureDetailsParserPolicy);
  return StorageRequestFailureDetailsParserPolicy;
}
var hasRequiredCommonjs$2;
function requireCommonjs$2() {
  if (hasRequiredCommonjs$2) return commonjs$1;
  hasRequiredCommonjs$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseRequestPolicy = exports.getCachedDefaultHttpClient = void 0;
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(/* @__PURE__ */ requireBufferScheduler(), exports);
    var cache_js_1 = /* @__PURE__ */ requireCache$2();
    Object.defineProperty(exports, "getCachedDefaultHttpClient", { enumerable: true, get: function() {
      return cache_js_1.getCachedDefaultHttpClient;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageBrowserPolicyFactory$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAnonymousCredential(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireCredential(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageSharedKeyCredential(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicyFactory(), exports);
    var RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy();
    Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: true, get: function() {
      return RequestPolicy_js_1.BaseRequestPolicy;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireAnonymousCredentialPolicy(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireCredentialPolicy(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageBrowserPolicy$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageBrowserPolicyV2$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageCorrectContentLengthPolicy$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicyType(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicy(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicyV2$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageSharedKeyCredentialPolicy(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageSharedKeyCredentialPolicyV2$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicyFactory(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRequestFailureDetailsParserPolicy(), exports);
  })(commonjs$1);
  return commonjs$1;
}
var StorageBrowserPolicyV2 = {};
var hasRequiredStorageBrowserPolicyV2;
function requireStorageBrowserPolicyV2() {
  if (hasRequiredStorageBrowserPolicyV2) return StorageBrowserPolicyV2;
  hasRequiredStorageBrowserPolicyV2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageBrowserPolicyName = void 0;
    exports.storageBrowserPolicy = storageBrowserPolicy;
    const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
    const constants_js_1 = /* @__PURE__ */ requireConstants$2();
    const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
    exports.storageBrowserPolicyName = "storageBrowserPolicy";
    function storageBrowserPolicy() {
      return {
        name: exports.storageBrowserPolicyName,
        async sendRequest(request2, next) {
          if (core_util_1.isNodeLike) {
            return next(request2);
          }
          if (request2.method === "GET" || request2.method === "HEAD") {
            request2.url = (0, utils_common_js_1.setURLParameter)(request2.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
          }
          request2.headers.delete(constants_js_1.HeaderConstants.COOKIE);
          request2.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
          return next(request2);
        }
      };
    }
  })(StorageBrowserPolicyV2);
  return StorageBrowserPolicyV2;
}
var StorageRetryPolicyV2 = {};
var hasRequiredStorageRetryPolicyV2;
function requireStorageRetryPolicyV2() {
  if (hasRequiredStorageRetryPolicyV2) return StorageRetryPolicyV2;
  hasRequiredStorageRetryPolicyV2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageRetryPolicyName = void 0;
    exports.storageRetryPolicy = storageRetryPolicy;
    const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
    const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
    const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
    const StorageRetryPolicyFactory_js_1 = /* @__PURE__ */ requireStorageRetryPolicyFactory$1();
    const constants_js_1 = /* @__PURE__ */ requireConstants$2();
    const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
    const log_js_1 = /* @__PURE__ */ requireLog$1();
    exports.storageRetryPolicyName = "storageRetryPolicy";
    const DEFAULT_RETRY_OPTIONS = {
      maxRetryDelayInMs: 120 * 1e3,
      maxTries: 4,
      retryDelayInMs: 4 * 1e3,
      retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0
      // Use server side default timeout strategy
    };
    const retriableErrors = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR"
    ];
    const RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
    function storageRetryPolicy(options2 = {}) {
      const retryPolicyType = options2.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
      const maxTries = options2.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
      const retryDelayInMs = options2.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
      const maxRetryDelayInMs = options2.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
      const secondaryHost = options2.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
      const tryTimeoutInMs = options2.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
      function shouldRetry({ isPrimaryRetry, attempt, response: response2, error: error2 }) {
        if (attempt >= maxTries) {
          log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
          return false;
        }
        if (error2) {
          for (const retriableError of retriableErrors) {
            if (error2.name.toUpperCase().includes(retriableError) || error2.message.toUpperCase().includes(retriableError) || error2.code && error2.code.toString().toUpperCase() === retriableError) {
              log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
              return true;
            }
          }
          if (error2?.code === "PARSE_ERROR" && error2?.message.startsWith(`Error "Error: Unclosed root tag`)) {
            log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
          }
        }
        if (response2 || error2) {
          const statusCode = response2?.status ?? error2?.statusCode ?? 0;
          if (!isPrimaryRetry && statusCode === 404) {
            log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
            return true;
          }
          if (statusCode === 503 || statusCode === 500) {
            log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
            return true;
          }
        }
        if (response2) {
          if (response2?.status >= 400) {
            const copySourceError = response2.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
            if (copySourceError !== void 0) {
              switch (copySourceError) {
                case "InternalError":
                case "OperationTimedOut":
                case "ServerBusy":
                  return true;
              }
            }
          }
        }
        return false;
      }
      function calculateDelay(isPrimaryRetry, attempt) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
          switch (retryPolicyType) {
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
              break;
            case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
              delayTimeInMs = retryDelayInMs;
              break;
          }
        } else {
          delayTimeInMs = Math.random() * 1e3;
        }
        log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return delayTimeInMs;
      }
      return {
        name: exports.storageRetryPolicyName,
        async sendRequest(request2, next) {
          if (tryTimeoutInMs) {
            request2.url = (0, utils_common_js_1.setURLParameter)(request2.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1e3)));
          }
          const primaryUrl = request2.url;
          const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request2.url, secondaryHost) : void 0;
          let secondaryHas404 = false;
          let attempt = 1;
          let retryAgain = true;
          let response2;
          let error2;
          while (retryAgain) {
            const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request2.method) || attempt % 2 === 1;
            request2.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
            response2 = void 0;
            error2 = void 0;
            try {
              log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
              response2 = await next(request2);
              secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response2.status === 404;
            } catch (e) {
              if ((0, core_rest_pipeline_1.isRestError)(e)) {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
                error2 = e;
              } else {
                log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`);
                throw e;
              }
            }
            retryAgain = shouldRetry({ isPrimaryRetry, attempt, response: response2, error: error2 });
            if (retryAgain) {
              await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request2.abortSignal, RETRY_ABORT_ERROR);
            }
            attempt++;
          }
          if (response2) {
            return response2;
          }
          throw error2 ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
        }
      };
    }
  })(StorageRetryPolicyV2);
  return StorageRetryPolicyV2;
}
var StorageSharedKeyCredentialPolicyV2 = {};
var hasRequiredStorageSharedKeyCredentialPolicyV2;
function requireStorageSharedKeyCredentialPolicyV2() {
  if (hasRequiredStorageSharedKeyCredentialPolicyV2) return StorageSharedKeyCredentialPolicyV2;
  hasRequiredStorageSharedKeyCredentialPolicyV2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageSharedKeyCredentialPolicyName = void 0;
    exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
    const node_crypto_1 = require$$0$e;
    const constants_js_1 = /* @__PURE__ */ requireConstants$2();
    const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
    const SharedKeyComparator_js_1 = /* @__PURE__ */ requireSharedKeyComparator$1();
    exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
    function storageSharedKeyCredentialPolicy(options2) {
      function signRequest(request2) {
        request2.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
        if (request2.body && (typeof request2.body === "string" || Buffer.isBuffer(request2.body)) && request2.body.length > 0) {
          request2.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request2.body));
        }
        const stringToSign = [
          request2.method.toUpperCase(),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_ENCODING),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_LENGTH),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_MD5),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.CONTENT_TYPE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.DATE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_MATCH),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_NONE_MATCH),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
          getHeaderValueToSign(request2, constants_js_1.HeaderConstants.RANGE)
        ].join("\n") + "\n" + getCanonicalizedHeadersString(request2) + getCanonicalizedResourceString(request2);
        const signature = (0, node_crypto_1.createHmac)("sha256", options2.accountKey).update(stringToSign, "utf8").digest("base64");
        request2.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options2.accountName}:${signature}`);
      }
      function getHeaderValueToSign(request2, headerName) {
        const value = request2.headers.get(headerName);
        if (!value) {
          return "";
        }
        if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0") {
          return "";
        }
        return value;
      }
      function getCanonicalizedHeadersString(request2) {
        let headersArray = [];
        for (const [name, value] of request2.headers) {
          if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) {
            headersArray.push({ name, value });
          }
        }
        headersArray.sort((a, b) => {
          return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
        });
        headersArray = headersArray.filter((value, index, array) => {
          if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
            return false;
          }
          return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
          canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
        });
        return canonicalizedHeadersStringToSign;
      }
      function getCanonicalizedResourceString(request2) {
        const path2 = (0, utils_common_js_1.getURLPath)(request2.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${options2.accountName}${path2}`;
        const queries = (0, utils_common_js_1.getURLQueries)(request2.url);
        const lowercaseQueries = {};
        if (queries) {
          const queryKeys = [];
          for (const key in queries) {
            if (Object.prototype.hasOwnProperty.call(queries, key)) {
              const lowercaseKey = key.toLowerCase();
              lowercaseQueries[lowercaseKey] = queries[key];
              queryKeys.push(lowercaseKey);
            }
          }
          queryKeys.sort();
          for (const key of queryKeys) {
            canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
          }
        }
        return canonicalizedResourceString;
      }
      return {
        name: exports.storageSharedKeyCredentialPolicyName,
        async sendRequest(request2, next) {
          signRequest(request2);
          return next(request2);
        }
      };
    }
  })(StorageSharedKeyCredentialPolicyV2);
  return StorageSharedKeyCredentialPolicyV2;
}
var StorageBrowserPolicyFactory = {};
var StorageBrowserPolicy = {};
var hasRequiredStorageBrowserPolicy;
function requireStorageBrowserPolicy() {
  if (hasRequiredStorageBrowserPolicy) return StorageBrowserPolicy;
  hasRequiredStorageBrowserPolicy = 1;
  Object.defineProperty(StorageBrowserPolicy, "__esModule", { value: true });
  StorageBrowserPolicy.StorageBrowserPolicy = void 0;
  const RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy$1();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  let StorageBrowserPolicy$12 = class StorageBrowserPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param nextPolicy -
     * @param options -
     */
    // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
    constructor(nextPolicy, options2) {
      super(nextPolicy, options2);
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    async sendRequest(request2) {
      if (core_util_1.isNodeLike) {
        return this._nextPolicy.sendRequest(request2);
      }
      if (request2.method.toUpperCase() === "GET" || request2.method.toUpperCase() === "HEAD") {
        request2.url = (0, utils_common_js_1.setURLParameter)(request2.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
      }
      request2.headers.remove(constants_js_1.HeaderConstants.COOKIE);
      request2.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
      return this._nextPolicy.sendRequest(request2);
    }
  };
  StorageBrowserPolicy.StorageBrowserPolicy = StorageBrowserPolicy$12;
  return StorageBrowserPolicy;
}
var hasRequiredStorageBrowserPolicyFactory;
function requireStorageBrowserPolicyFactory() {
  if (hasRequiredStorageBrowserPolicyFactory) return StorageBrowserPolicyFactory;
  hasRequiredStorageBrowserPolicyFactory = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
    const StorageBrowserPolicy_js_1 = /* @__PURE__ */ requireStorageBrowserPolicy();
    Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: true, get: function() {
      return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
    } });
    class StorageBrowserPolicyFactory2 {
      /**
       * Creates a StorageBrowserPolicyFactory object.
       *
       * @param nextPolicy -
       * @param options -
       */
      create(nextPolicy, options2) {
        return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options2);
      }
    }
    exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory2;
  })(StorageBrowserPolicyFactory);
  return StorageBrowserPolicyFactory;
}
var StorageCorrectContentLengthPolicy = {};
var hasRequiredStorageCorrectContentLengthPolicy;
function requireStorageCorrectContentLengthPolicy() {
  if (hasRequiredStorageCorrectContentLengthPolicy) return StorageCorrectContentLengthPolicy;
  hasRequiredStorageCorrectContentLengthPolicy = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageCorrectContentLengthPolicyName = void 0;
    exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
    const constants_js_1 = /* @__PURE__ */ requireConstants$2();
    exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
    function storageCorrectContentLengthPolicy() {
      function correctContentLength(request2) {
        if (request2.body && (typeof request2.body === "string" || Buffer.isBuffer(request2.body)) && request2.body.length > 0) {
          request2.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request2.body));
        }
      }
      return {
        name: exports.storageCorrectContentLengthPolicyName,
        async sendRequest(request2, next) {
          correctContentLength(request2);
          return next(request2);
        }
      };
    }
  })(StorageCorrectContentLengthPolicy);
  return StorageCorrectContentLengthPolicy;
}
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return Pipeline;
  hasRequiredPipeline = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pipeline = exports.StorageOAuthScopes = void 0;
    exports.isPipelineLike = isPipelineLike;
    exports.newPipeline = newPipeline;
    exports.getCoreClientOptions = getCoreClientOptions;
    exports.getCredentialFromPipeline = getCredentialFromPipeline;
    const core_http_compat_1 = /* @__PURE__ */ requireCommonjs$4();
    const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
    const core_client_1 = /* @__PURE__ */ requireCommonjs$5();
    const core_xml_1 = /* @__PURE__ */ requireCommonjs$3();
    const core_auth_1 = /* @__PURE__ */ requireCommonjs$6();
    const log_js_1 = /* @__PURE__ */ requireLog$1();
    const StorageRetryPolicyFactory_js_1 = /* @__PURE__ */ requireStorageRetryPolicyFactory$1();
    const StorageSharedKeyCredential_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredential$1();
    const AnonymousCredential_js_1 = /* @__PURE__ */ requireAnonymousCredential$1();
    const constants_js_1 = /* @__PURE__ */ requireConstants$2();
    Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: true, get: function() {
      return constants_js_1.StorageOAuthScopes;
    } });
    const storage_common_1 = /* @__PURE__ */ requireCommonjs$2();
    const StorageBrowserPolicyV2_js_1 = /* @__PURE__ */ requireStorageBrowserPolicyV2();
    const StorageRetryPolicyV2_js_1 = /* @__PURE__ */ requireStorageRetryPolicyV2();
    const StorageSharedKeyCredentialPolicyV2_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredentialPolicyV2();
    const StorageBrowserPolicyFactory_js_1 = /* @__PURE__ */ requireStorageBrowserPolicyFactory();
    const StorageCorrectContentLengthPolicy_js_1 = /* @__PURE__ */ requireStorageCorrectContentLengthPolicy();
    function isPipelineLike(pipeline2) {
      if (!pipeline2 || typeof pipeline2 !== "object") {
        return false;
      }
      const castPipeline = pipeline2;
      return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
    }
    class Pipeline2 {
      /**
       * A list of chained request policy factories.
       */
      factories;
      /**
       * Configures pipeline logger and HTTP client.
       */
      options;
      /**
       * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
       *
       * @param factories -
       * @param options -
       */
      constructor(factories, options2 = {}) {
        this.factories = factories;
        this.options = options2;
      }
      /**
       * Transfer Pipeline object to ServiceClientOptions object which is required by
       * ServiceClient constructor.
       *
       * @returns The ServiceClientOptions object from this Pipeline.
       */
      toServiceClientOptions() {
        return {
          httpClient: this.options.httpClient,
          requestPolicyFactories: this.factories
        };
      }
    }
    exports.Pipeline = Pipeline2;
    function newPipeline(credential, pipelineOptions = {}) {
      if (!credential) {
        credential = new AnonymousCredential_js_1.AnonymousCredential();
      }
      const pipeline2 = new Pipeline2([], pipelineOptions);
      pipeline2._credential = credential;
      return pipeline2;
    }
    function processDownlevelPipeline(pipeline2) {
      const knownFactoryFunctions = [
        isAnonymousCredential,
        isStorageSharedKeyCredential,
        isCoreHttpBearerTokenFactory,
        isStorageBrowserPolicyFactory,
        isStorageRetryPolicyFactory,
        isStorageTelemetryPolicyFactory,
        isCoreHttpPolicyFactory
      ];
      if (pipeline2.factories.length) {
        const novelFactories = pipeline2.factories.filter((factory) => {
          return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
        });
        if (novelFactories.length) {
          const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
          return {
            wrappedPolicies: (0, core_http_compat_1.createRequestPolicyFactoryPolicy)(novelFactories),
            afterRetry: hasInjector
          };
        }
      }
      return void 0;
    }
    function getCoreClientOptions(pipeline2) {
      const { httpClient: v1Client, ...restOptions } = pipeline2.options;
      let httpClient = pipeline2._coreHttpClient;
      if (!httpClient) {
        httpClient = v1Client ? (0, core_http_compat_1.convertHttpClient)(v1Client) : (0, storage_common_1.getCachedDefaultHttpClient)();
        pipeline2._coreHttpClient = httpClient;
      }
      let corePipeline = pipeline2._corePipeline;
      if (!corePipeline) {
        const packageDetails = `azsdk-js-azure-storage-blob/${constants_js_1.SDK_VERSION}`;
        const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        corePipeline = (0, core_client_1.createClientPipeline)({
          ...restOptions,
          loggingOptions: {
            additionalAllowedHeaderNames: constants_js_1.StorageBlobLoggingAllowedHeaderNames,
            additionalAllowedQueryParameters: constants_js_1.StorageBlobLoggingAllowedQueryParameters,
            logger: log_js_1.logger.info
          },
          userAgentOptions: {
            userAgentPrefix
          },
          serializationOptions: {
            stringifyXML: core_xml_1.stringifyXML,
            serializerOptions: {
              xml: {
                // Use customized XML char key of "#" so we can deserialize metadata
                // with "_" key
                xmlCharKey: "#"
              }
            }
          },
          deserializationOptions: {
            parseXML: core_xml_1.parseXML,
            serializerOptions: {
              xml: {
                // Use customized XML char key of "#" so we can deserialize metadata
                // with "_" key
                xmlCharKey: "#"
              }
            }
          }
        });
        corePipeline.removePolicy({ phase: "Retry" });
        corePipeline.removePolicy({ name: core_rest_pipeline_1.decompressResponsePolicyName });
        corePipeline.addPolicy((0, StorageCorrectContentLengthPolicy_js_1.storageCorrectContentLengthPolicy)());
        corePipeline.addPolicy((0, StorageRetryPolicyV2_js_1.storageRetryPolicy)(restOptions.retryOptions), { phase: "Retry" });
        corePipeline.addPolicy((0, storage_common_1.storageRequestFailureDetailsParserPolicy)());
        corePipeline.addPolicy((0, StorageBrowserPolicyV2_js_1.storageBrowserPolicy)());
        const downlevelResults = processDownlevelPipeline(pipeline2);
        if (downlevelResults) {
          corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : void 0);
        }
        const credential = getCredentialFromPipeline(pipeline2);
        if ((0, core_auth_1.isTokenCredential)(credential)) {
          corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
            credential,
            scopes: restOptions.audience ?? constants_js_1.StorageOAuthScopes,
            challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
          }), { phase: "Sign" });
        } else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) {
          corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
            accountName: credential.accountName,
            accountKey: credential.accountKey
          }), { phase: "Sign" });
        }
        pipeline2._corePipeline = corePipeline;
      }
      return {
        ...restOptions,
        allowInsecureConnection: true,
        httpClient,
        pipeline: corePipeline
      };
    }
    function getCredentialFromPipeline(pipeline2) {
      if (pipeline2._credential) {
        return pipeline2._credential;
      }
      let credential = new AnonymousCredential_js_1.AnonymousCredential();
      for (const factory of pipeline2.factories) {
        if ((0, core_auth_1.isTokenCredential)(factory.credential)) {
          credential = factory.credential;
        } else if (isStorageSharedKeyCredential(factory)) {
          return factory;
        }
      }
      return credential;
    }
    function isStorageSharedKeyCredential(factory) {
      if (factory instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) {
        return true;
      }
      return factory.constructor.name === "StorageSharedKeyCredential";
    }
    function isAnonymousCredential(factory) {
      if (factory instanceof AnonymousCredential_js_1.AnonymousCredential) {
        return true;
      }
      return factory.constructor.name === "AnonymousCredential";
    }
    function isCoreHttpBearerTokenFactory(factory) {
      return (0, core_auth_1.isTokenCredential)(factory.credential);
    }
    function isStorageBrowserPolicyFactory(factory) {
      if (factory instanceof StorageBrowserPolicyFactory_js_1.StorageBrowserPolicyFactory) {
        return true;
      }
      return factory.constructor.name === "StorageBrowserPolicyFactory";
    }
    function isStorageRetryPolicyFactory(factory) {
      if (factory instanceof StorageRetryPolicyFactory_js_1.StorageRetryPolicyFactory) {
        return true;
      }
      return factory.constructor.name === "StorageRetryPolicyFactory";
    }
    function isStorageTelemetryPolicyFactory(factory) {
      return factory.constructor.name === "TelemetryPolicyFactory";
    }
    function isInjectorPolicyFactory(factory) {
      return factory.constructor.name === "InjectorPolicyFactory";
    }
    function isCoreHttpPolicyFactory(factory) {
      const knownPolicies = [
        "GenerateClientRequestIdPolicy",
        "TracingPolicy",
        "LogPolicy",
        "ProxyPolicy",
        "DisableResponseDecompressionPolicy",
        "KeepAlivePolicy",
        "DeserializationPolicy"
      ];
      const mockHttpClient = {
        sendRequest: async (request2) => {
          return {
            request: request2,
            headers: request2.headers.clone(),
            status: 500
          };
        }
      };
      const mockRequestPolicyOptions = {
        log(_logLevel, _message) {
        },
        shouldLog(_logLevel) {
          return false;
        }
      };
      const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
      const policyName = policyInstance.constructor.name;
      return knownPolicies.some((knownPolicyName) => {
        return policyName.startsWith(knownPolicyName);
      });
    }
  })(Pipeline);
  return Pipeline;
}
var ContainerClient = {};
var StorageClient = {};
var StorageContextClient = {};
var src$1 = {};
var models$1 = {};
var hasRequiredModels$1;
function requireModels$1() {
  if (hasRequiredModels$1) return models$1;
  hasRequiredModels$1 = 1;
  Object.defineProperty(models$1, "__esModule", { value: true });
  models$1.KnownStorageErrorCode = models$1.KnownBlobExpiryOptions = models$1.KnownFileShareTokenIntent = models$1.KnownEncryptionAlgorithmType = void 0;
  var KnownEncryptionAlgorithmType;
  (function(KnownEncryptionAlgorithmType2) {
    KnownEncryptionAlgorithmType2["AES256"] = "AES256";
  })(KnownEncryptionAlgorithmType || (models$1.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
  var KnownFileShareTokenIntent;
  (function(KnownFileShareTokenIntent2) {
    KnownFileShareTokenIntent2["Backup"] = "backup";
  })(KnownFileShareTokenIntent || (models$1.KnownFileShareTokenIntent = KnownFileShareTokenIntent = {}));
  var KnownBlobExpiryOptions;
  (function(KnownBlobExpiryOptions2) {
    KnownBlobExpiryOptions2["NeverExpire"] = "NeverExpire";
    KnownBlobExpiryOptions2["RelativeToCreation"] = "RelativeToCreation";
    KnownBlobExpiryOptions2["RelativeToNow"] = "RelativeToNow";
    KnownBlobExpiryOptions2["Absolute"] = "Absolute";
  })(KnownBlobExpiryOptions || (models$1.KnownBlobExpiryOptions = KnownBlobExpiryOptions = {}));
  var KnownStorageErrorCode;
  (function(KnownStorageErrorCode2) {
    KnownStorageErrorCode2["AccountAlreadyExists"] = "AccountAlreadyExists";
    KnownStorageErrorCode2["AccountBeingCreated"] = "AccountBeingCreated";
    KnownStorageErrorCode2["AccountIsDisabled"] = "AccountIsDisabled";
    KnownStorageErrorCode2["AuthenticationFailed"] = "AuthenticationFailed";
    KnownStorageErrorCode2["AuthorizationFailure"] = "AuthorizationFailure";
    KnownStorageErrorCode2["ConditionHeadersNotSupported"] = "ConditionHeadersNotSupported";
    KnownStorageErrorCode2["ConditionNotMet"] = "ConditionNotMet";
    KnownStorageErrorCode2["EmptyMetadataKey"] = "EmptyMetadataKey";
    KnownStorageErrorCode2["InsufficientAccountPermissions"] = "InsufficientAccountPermissions";
    KnownStorageErrorCode2["InternalError"] = "InternalError";
    KnownStorageErrorCode2["InvalidAuthenticationInfo"] = "InvalidAuthenticationInfo";
    KnownStorageErrorCode2["InvalidHeaderValue"] = "InvalidHeaderValue";
    KnownStorageErrorCode2["InvalidHttpVerb"] = "InvalidHttpVerb";
    KnownStorageErrorCode2["InvalidInput"] = "InvalidInput";
    KnownStorageErrorCode2["InvalidMd5"] = "InvalidMd5";
    KnownStorageErrorCode2["InvalidMetadata"] = "InvalidMetadata";
    KnownStorageErrorCode2["InvalidQueryParameterValue"] = "InvalidQueryParameterValue";
    KnownStorageErrorCode2["InvalidRange"] = "InvalidRange";
    KnownStorageErrorCode2["InvalidResourceName"] = "InvalidResourceName";
    KnownStorageErrorCode2["InvalidUri"] = "InvalidUri";
    KnownStorageErrorCode2["InvalidXmlDocument"] = "InvalidXmlDocument";
    KnownStorageErrorCode2["InvalidXmlNodeValue"] = "InvalidXmlNodeValue";
    KnownStorageErrorCode2["Md5Mismatch"] = "Md5Mismatch";
    KnownStorageErrorCode2["MetadataTooLarge"] = "MetadataTooLarge";
    KnownStorageErrorCode2["MissingContentLengthHeader"] = "MissingContentLengthHeader";
    KnownStorageErrorCode2["MissingRequiredQueryParameter"] = "MissingRequiredQueryParameter";
    KnownStorageErrorCode2["MissingRequiredHeader"] = "MissingRequiredHeader";
    KnownStorageErrorCode2["MissingRequiredXmlNode"] = "MissingRequiredXmlNode";
    KnownStorageErrorCode2["MultipleConditionHeadersNotSupported"] = "MultipleConditionHeadersNotSupported";
    KnownStorageErrorCode2["OperationTimedOut"] = "OperationTimedOut";
    KnownStorageErrorCode2["OutOfRangeInput"] = "OutOfRangeInput";
    KnownStorageErrorCode2["OutOfRangeQueryParameterValue"] = "OutOfRangeQueryParameterValue";
    KnownStorageErrorCode2["RequestBodyTooLarge"] = "RequestBodyTooLarge";
    KnownStorageErrorCode2["ResourceTypeMismatch"] = "ResourceTypeMismatch";
    KnownStorageErrorCode2["RequestUrlFailedToParse"] = "RequestUrlFailedToParse";
    KnownStorageErrorCode2["ResourceAlreadyExists"] = "ResourceAlreadyExists";
    KnownStorageErrorCode2["ResourceNotFound"] = "ResourceNotFound";
    KnownStorageErrorCode2["ServerBusy"] = "ServerBusy";
    KnownStorageErrorCode2["UnsupportedHeader"] = "UnsupportedHeader";
    KnownStorageErrorCode2["UnsupportedXmlNode"] = "UnsupportedXmlNode";
    KnownStorageErrorCode2["UnsupportedQueryParameter"] = "UnsupportedQueryParameter";
    KnownStorageErrorCode2["UnsupportedHttpVerb"] = "UnsupportedHttpVerb";
    KnownStorageErrorCode2["AppendPositionConditionNotMet"] = "AppendPositionConditionNotMet";
    KnownStorageErrorCode2["BlobAlreadyExists"] = "BlobAlreadyExists";
    KnownStorageErrorCode2["BlobImmutableDueToPolicy"] = "BlobImmutableDueToPolicy";
    KnownStorageErrorCode2["BlobNotFound"] = "BlobNotFound";
    KnownStorageErrorCode2["BlobOverwritten"] = "BlobOverwritten";
    KnownStorageErrorCode2["BlobTierInadequateForContentLength"] = "BlobTierInadequateForContentLength";
    KnownStorageErrorCode2["BlobUsesCustomerSpecifiedEncryption"] = "BlobUsesCustomerSpecifiedEncryption";
    KnownStorageErrorCode2["BlockCountExceedsLimit"] = "BlockCountExceedsLimit";
    KnownStorageErrorCode2["BlockListTooLong"] = "BlockListTooLong";
    KnownStorageErrorCode2["CannotChangeToLowerTier"] = "CannotChangeToLowerTier";
    KnownStorageErrorCode2["CannotVerifyCopySource"] = "CannotVerifyCopySource";
    KnownStorageErrorCode2["ContainerAlreadyExists"] = "ContainerAlreadyExists";
    KnownStorageErrorCode2["ContainerBeingDeleted"] = "ContainerBeingDeleted";
    KnownStorageErrorCode2["ContainerDisabled"] = "ContainerDisabled";
    KnownStorageErrorCode2["ContainerNotFound"] = "ContainerNotFound";
    KnownStorageErrorCode2["ContentLengthLargerThanTierLimit"] = "ContentLengthLargerThanTierLimit";
    KnownStorageErrorCode2["CopyAcrossAccountsNotSupported"] = "CopyAcrossAccountsNotSupported";
    KnownStorageErrorCode2["CopyIdMismatch"] = "CopyIdMismatch";
    KnownStorageErrorCode2["FeatureVersionMismatch"] = "FeatureVersionMismatch";
    KnownStorageErrorCode2["IncrementalCopyBlobMismatch"] = "IncrementalCopyBlobMismatch";
    KnownStorageErrorCode2["IncrementalCopyOfEarlierVersionSnapshotNotAllowed"] = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed";
    KnownStorageErrorCode2["IncrementalCopySourceMustBeSnapshot"] = "IncrementalCopySourceMustBeSnapshot";
    KnownStorageErrorCode2["InfiniteLeaseDurationRequired"] = "InfiniteLeaseDurationRequired";
    KnownStorageErrorCode2["InvalidBlobOrBlock"] = "InvalidBlobOrBlock";
    KnownStorageErrorCode2["InvalidBlobTier"] = "InvalidBlobTier";
    KnownStorageErrorCode2["InvalidBlobType"] = "InvalidBlobType";
    KnownStorageErrorCode2["InvalidBlockId"] = "InvalidBlockId";
    KnownStorageErrorCode2["InvalidBlockList"] = "InvalidBlockList";
    KnownStorageErrorCode2["InvalidOperation"] = "InvalidOperation";
    KnownStorageErrorCode2["InvalidPageRange"] = "InvalidPageRange";
    KnownStorageErrorCode2["InvalidSourceBlobType"] = "InvalidSourceBlobType";
    KnownStorageErrorCode2["InvalidSourceBlobUrl"] = "InvalidSourceBlobUrl";
    KnownStorageErrorCode2["InvalidVersionForPageBlobOperation"] = "InvalidVersionForPageBlobOperation";
    KnownStorageErrorCode2["LeaseAlreadyPresent"] = "LeaseAlreadyPresent";
    KnownStorageErrorCode2["LeaseAlreadyBroken"] = "LeaseAlreadyBroken";
    KnownStorageErrorCode2["LeaseIdMismatchWithBlobOperation"] = "LeaseIdMismatchWithBlobOperation";
    KnownStorageErrorCode2["LeaseIdMismatchWithContainerOperation"] = "LeaseIdMismatchWithContainerOperation";
    KnownStorageErrorCode2["LeaseIdMismatchWithLeaseOperation"] = "LeaseIdMismatchWithLeaseOperation";
    KnownStorageErrorCode2["LeaseIdMissing"] = "LeaseIdMissing";
    KnownStorageErrorCode2["LeaseIsBreakingAndCannotBeAcquired"] = "LeaseIsBreakingAndCannotBeAcquired";
    KnownStorageErrorCode2["LeaseIsBreakingAndCannotBeChanged"] = "LeaseIsBreakingAndCannotBeChanged";
    KnownStorageErrorCode2["LeaseIsBrokenAndCannotBeRenewed"] = "LeaseIsBrokenAndCannotBeRenewed";
    KnownStorageErrorCode2["LeaseLost"] = "LeaseLost";
    KnownStorageErrorCode2["LeaseNotPresentWithBlobOperation"] = "LeaseNotPresentWithBlobOperation";
    KnownStorageErrorCode2["LeaseNotPresentWithContainerOperation"] = "LeaseNotPresentWithContainerOperation";
    KnownStorageErrorCode2["LeaseNotPresentWithLeaseOperation"] = "LeaseNotPresentWithLeaseOperation";
    KnownStorageErrorCode2["MaxBlobSizeConditionNotMet"] = "MaxBlobSizeConditionNotMet";
    KnownStorageErrorCode2["NoAuthenticationInformation"] = "NoAuthenticationInformation";
    KnownStorageErrorCode2["NoPendingCopyOperation"] = "NoPendingCopyOperation";
    KnownStorageErrorCode2["OperationNotAllowedOnIncrementalCopyBlob"] = "OperationNotAllowedOnIncrementalCopyBlob";
    KnownStorageErrorCode2["PendingCopyOperation"] = "PendingCopyOperation";
    KnownStorageErrorCode2["PreviousSnapshotCannotBeNewer"] = "PreviousSnapshotCannotBeNewer";
    KnownStorageErrorCode2["PreviousSnapshotNotFound"] = "PreviousSnapshotNotFound";
    KnownStorageErrorCode2["PreviousSnapshotOperationNotSupported"] = "PreviousSnapshotOperationNotSupported";
    KnownStorageErrorCode2["SequenceNumberConditionNotMet"] = "SequenceNumberConditionNotMet";
    KnownStorageErrorCode2["SequenceNumberIncrementTooLarge"] = "SequenceNumberIncrementTooLarge";
    KnownStorageErrorCode2["SnapshotCountExceeded"] = "SnapshotCountExceeded";
    KnownStorageErrorCode2["SnapshotOperationRateExceeded"] = "SnapshotOperationRateExceeded";
    KnownStorageErrorCode2["SnapshotsPresent"] = "SnapshotsPresent";
    KnownStorageErrorCode2["SourceConditionNotMet"] = "SourceConditionNotMet";
    KnownStorageErrorCode2["SystemInUse"] = "SystemInUse";
    KnownStorageErrorCode2["TargetConditionNotMet"] = "TargetConditionNotMet";
    KnownStorageErrorCode2["UnauthorizedBlobOverwrite"] = "UnauthorizedBlobOverwrite";
    KnownStorageErrorCode2["BlobBeingRehydrated"] = "BlobBeingRehydrated";
    KnownStorageErrorCode2["BlobArchived"] = "BlobArchived";
    KnownStorageErrorCode2["BlobNotArchived"] = "BlobNotArchived";
    KnownStorageErrorCode2["AuthorizationSourceIPMismatch"] = "AuthorizationSourceIPMismatch";
    KnownStorageErrorCode2["AuthorizationProtocolMismatch"] = "AuthorizationProtocolMismatch";
    KnownStorageErrorCode2["AuthorizationPermissionMismatch"] = "AuthorizationPermissionMismatch";
    KnownStorageErrorCode2["AuthorizationServiceMismatch"] = "AuthorizationServiceMismatch";
    KnownStorageErrorCode2["AuthorizationResourceTypeMismatch"] = "AuthorizationResourceTypeMismatch";
    KnownStorageErrorCode2["BlobAccessTierNotSupportedForAccountType"] = "BlobAccessTierNotSupportedForAccountType";
  })(KnownStorageErrorCode || (models$1.KnownStorageErrorCode = KnownStorageErrorCode = {}));
  return models$1;
}
var storageClient = {};
var operations = {};
var service$1 = {};
var mappers = {};
var hasRequiredMappers;
function requireMappers() {
  if (hasRequiredMappers) return mappers;
  hasRequiredMappers = 1;
  Object.defineProperty(mappers, "__esModule", { value: true });
  mappers.ServiceGetUserDelegationKeyHeaders = mappers.ServiceListContainersSegmentExceptionHeaders = mappers.ServiceListContainersSegmentHeaders = mappers.ServiceGetStatisticsExceptionHeaders = mappers.ServiceGetStatisticsHeaders = mappers.ServiceGetPropertiesExceptionHeaders = mappers.ServiceGetPropertiesHeaders = mappers.ServiceSetPropertiesExceptionHeaders = mappers.ServiceSetPropertiesHeaders = mappers.ArrowField = mappers.ArrowConfiguration = mappers.JsonTextConfiguration = mappers.DelimitedTextConfiguration = mappers.QueryFormat = mappers.QuerySerialization = mappers.QueryRequest = mappers.ClearRange = mappers.PageRange = mappers.PageList = mappers.Block = mappers.BlockList = mappers.BlockLookupList = mappers.BlobPrefix = mappers.BlobHierarchyListSegment = mappers.ListBlobsHierarchySegmentResponse = mappers.BlobPropertiesInternal = mappers.BlobName = mappers.BlobItemInternal = mappers.BlobFlatListSegment = mappers.ListBlobsFlatSegmentResponse = mappers.AccessPolicy = mappers.SignedIdentifier = mappers.BlobTag = mappers.BlobTags = mappers.FilterBlobItem = mappers.FilterBlobSegment = mappers.UserDelegationKey = mappers.KeyInfo = mappers.ContainerProperties = mappers.ContainerItem = mappers.ListContainersSegmentResponse = mappers.GeoReplication = mappers.BlobServiceStatistics = mappers.StorageError = mappers.StaticWebsite = mappers.CorsRule = mappers.Metrics = mappers.RetentionPolicy = mappers.Logging = mappers.BlobServiceProperties = void 0;
  mappers.BlobUndeleteHeaders = mappers.BlobDeleteExceptionHeaders = mappers.BlobDeleteHeaders = mappers.BlobGetPropertiesExceptionHeaders = mappers.BlobGetPropertiesHeaders = mappers.BlobDownloadExceptionHeaders = mappers.BlobDownloadHeaders = mappers.ContainerGetAccountInfoExceptionHeaders = mappers.ContainerGetAccountInfoHeaders = mappers.ContainerListBlobHierarchySegmentExceptionHeaders = mappers.ContainerListBlobHierarchySegmentHeaders = mappers.ContainerListBlobFlatSegmentExceptionHeaders = mappers.ContainerListBlobFlatSegmentHeaders = mappers.ContainerChangeLeaseExceptionHeaders = mappers.ContainerChangeLeaseHeaders = mappers.ContainerBreakLeaseExceptionHeaders = mappers.ContainerBreakLeaseHeaders = mappers.ContainerRenewLeaseExceptionHeaders = mappers.ContainerRenewLeaseHeaders = mappers.ContainerReleaseLeaseExceptionHeaders = mappers.ContainerReleaseLeaseHeaders = mappers.ContainerAcquireLeaseExceptionHeaders = mappers.ContainerAcquireLeaseHeaders = mappers.ContainerFilterBlobsExceptionHeaders = mappers.ContainerFilterBlobsHeaders = mappers.ContainerSubmitBatchExceptionHeaders = mappers.ContainerSubmitBatchHeaders = mappers.ContainerRenameExceptionHeaders = mappers.ContainerRenameHeaders = mappers.ContainerRestoreExceptionHeaders = mappers.ContainerRestoreHeaders = mappers.ContainerSetAccessPolicyExceptionHeaders = mappers.ContainerSetAccessPolicyHeaders = mappers.ContainerGetAccessPolicyExceptionHeaders = mappers.ContainerGetAccessPolicyHeaders = mappers.ContainerSetMetadataExceptionHeaders = mappers.ContainerSetMetadataHeaders = mappers.ContainerDeleteExceptionHeaders = mappers.ContainerDeleteHeaders = mappers.ContainerGetPropertiesExceptionHeaders = mappers.ContainerGetPropertiesHeaders = mappers.ContainerCreateExceptionHeaders = mappers.ContainerCreateHeaders = mappers.ServiceFilterBlobsExceptionHeaders = mappers.ServiceFilterBlobsHeaders = mappers.ServiceSubmitBatchExceptionHeaders = mappers.ServiceSubmitBatchHeaders = mappers.ServiceGetAccountInfoExceptionHeaders = mappers.ServiceGetAccountInfoHeaders = mappers.ServiceGetUserDelegationKeyExceptionHeaders = void 0;
  mappers.PageBlobGetPageRangesHeaders = mappers.PageBlobUploadPagesFromURLExceptionHeaders = mappers.PageBlobUploadPagesFromURLHeaders = mappers.PageBlobClearPagesExceptionHeaders = mappers.PageBlobClearPagesHeaders = mappers.PageBlobUploadPagesExceptionHeaders = mappers.PageBlobUploadPagesHeaders = mappers.PageBlobCreateExceptionHeaders = mappers.PageBlobCreateHeaders = mappers.BlobSetTagsExceptionHeaders = mappers.BlobSetTagsHeaders = mappers.BlobGetTagsExceptionHeaders = mappers.BlobGetTagsHeaders = mappers.BlobQueryExceptionHeaders = mappers.BlobQueryHeaders = mappers.BlobGetAccountInfoExceptionHeaders = mappers.BlobGetAccountInfoHeaders = mappers.BlobSetTierExceptionHeaders = mappers.BlobSetTierHeaders = mappers.BlobAbortCopyFromURLExceptionHeaders = mappers.BlobAbortCopyFromURLHeaders = mappers.BlobCopyFromURLExceptionHeaders = mappers.BlobCopyFromURLHeaders = mappers.BlobStartCopyFromURLExceptionHeaders = mappers.BlobStartCopyFromURLHeaders = mappers.BlobCreateSnapshotExceptionHeaders = mappers.BlobCreateSnapshotHeaders = mappers.BlobBreakLeaseExceptionHeaders = mappers.BlobBreakLeaseHeaders = mappers.BlobChangeLeaseExceptionHeaders = mappers.BlobChangeLeaseHeaders = mappers.BlobRenewLeaseExceptionHeaders = mappers.BlobRenewLeaseHeaders = mappers.BlobReleaseLeaseExceptionHeaders = mappers.BlobReleaseLeaseHeaders = mappers.BlobAcquireLeaseExceptionHeaders = mappers.BlobAcquireLeaseHeaders = mappers.BlobSetMetadataExceptionHeaders = mappers.BlobSetMetadataHeaders = mappers.BlobSetLegalHoldExceptionHeaders = mappers.BlobSetLegalHoldHeaders = mappers.BlobDeleteImmutabilityPolicyExceptionHeaders = mappers.BlobDeleteImmutabilityPolicyHeaders = mappers.BlobSetImmutabilityPolicyExceptionHeaders = mappers.BlobSetImmutabilityPolicyHeaders = mappers.BlobSetHttpHeadersExceptionHeaders = mappers.BlobSetHttpHeadersHeaders = mappers.BlobSetExpiryExceptionHeaders = mappers.BlobSetExpiryHeaders = mappers.BlobUndeleteExceptionHeaders = void 0;
  mappers.BlockBlobGetBlockListExceptionHeaders = mappers.BlockBlobGetBlockListHeaders = mappers.BlockBlobCommitBlockListExceptionHeaders = mappers.BlockBlobCommitBlockListHeaders = mappers.BlockBlobStageBlockFromURLExceptionHeaders = mappers.BlockBlobStageBlockFromURLHeaders = mappers.BlockBlobStageBlockExceptionHeaders = mappers.BlockBlobStageBlockHeaders = mappers.BlockBlobPutBlobFromUrlExceptionHeaders = mappers.BlockBlobPutBlobFromUrlHeaders = mappers.BlockBlobUploadExceptionHeaders = mappers.BlockBlobUploadHeaders = mappers.AppendBlobSealExceptionHeaders = mappers.AppendBlobSealHeaders = mappers.AppendBlobAppendBlockFromUrlExceptionHeaders = mappers.AppendBlobAppendBlockFromUrlHeaders = mappers.AppendBlobAppendBlockExceptionHeaders = mappers.AppendBlobAppendBlockHeaders = mappers.AppendBlobCreateExceptionHeaders = mappers.AppendBlobCreateHeaders = mappers.PageBlobCopyIncrementalExceptionHeaders = mappers.PageBlobCopyIncrementalHeaders = mappers.PageBlobUpdateSequenceNumberExceptionHeaders = mappers.PageBlobUpdateSequenceNumberHeaders = mappers.PageBlobResizeExceptionHeaders = mappers.PageBlobResizeHeaders = mappers.PageBlobGetPageRangesDiffExceptionHeaders = mappers.PageBlobGetPageRangesDiffHeaders = mappers.PageBlobGetPageRangesExceptionHeaders = void 0;
  mappers.BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: {
            name: "Composite",
            className: "Logging"
          }
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: true,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "CorsRule"
              }
            }
          }
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: {
            name: "String"
          }
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: {
            name: "Composite",
            className: "StaticWebsite"
          }
        }
      }
    }
  };
  mappers.Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: true,
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        deleteProperty: {
          serializedName: "Delete",
          required: true,
          xmlName: "Delete",
          type: {
            name: "Boolean"
          }
        },
        read: {
          serializedName: "Read",
          required: true,
          xmlName: "Read",
          type: {
            name: "Boolean"
          }
        },
        write: {
          serializedName: "Write",
          required: true,
          xmlName: "Write",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  mappers.RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        days: {
          constraints: {
            InclusiveMinimum: 1
          },
          serializedName: "Days",
          xmlName: "Days",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  mappers.CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: true,
          xmlName: "AllowedOrigins",
          type: {
            name: "String"
          }
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: true,
          xmlName: "AllowedMethods",
          type: {
            name: "String"
          }
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: true,
          xmlName: "AllowedHeaders",
          type: {
            name: "String"
          }
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: true,
          xmlName: "ExposedHeaders",
          type: {
            name: "String"
          }
        },
        maxAgeInSeconds: {
          constraints: {
            InclusiveMinimum: 0
          },
          serializedName: "MaxAgeInSeconds",
          required: true,
          xmlName: "MaxAgeInSeconds",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: {
            name: "String"
          }
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: {
            name: "String"
          }
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "CopySourceStatusCode",
          xmlName: "CopySourceStatusCode",
          type: {
            name: "Number"
          }
        },
        copySourceErrorCode: {
          serializedName: "CopySourceErrorCode",
          xmlName: "CopySourceErrorCode",
          type: {
            name: "String"
          }
        },
        copySourceErrorMessage: {
          serializedName: "CopySourceErrorMessage",
          xmlName: "CopySourceErrorMessage",
          type: {
            name: "String"
          }
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: {
            name: "String"
          }
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: {
            name: "Composite",
            className: "GeoReplication"
          }
        }
      }
    }
  };
  mappers.GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: true,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"]
          }
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: true,
          xmlName: "LastSyncTime",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: true,
          xmlName: "Containers",
          xmlIsWrapped: true,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ContainerItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "ContainerProperties"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        }
      }
    }
  };
  mappers.ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: {
            name: "String"
          }
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: {
            name: "Boolean"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          required: true,
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: true,
          xmlName: "SignedOid",
          type: {
            name: "String"
          }
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: true,
          xmlName: "SignedTid",
          type: {
            name: "String"
          }
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: true,
          xmlName: "SignedStart",
          type: {
            name: "String"
          }
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: true,
          xmlName: "SignedExpiry",
          type: {
            name: "String"
          }
        },
        signedService: {
          serializedName: "SignedService",
          required: true,
          xmlName: "SignedService",
          type: {
            name: "String"
          }
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: true,
          xmlName: "SignedVersion",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        where: {
          serializedName: "Where",
          required: true,
          xmlName: "Where",
          type: {
            name: "String"
          }
        },
        blobs: {
          serializedName: "Blobs",
          required: true,
          xmlName: "Blobs",
          xmlIsWrapped: true,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "FilterBlobItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          type: {
            name: "String"
          }
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        }
      }
    }
  };
  mappers.BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: true,
          xmlName: "TagSet",
          xmlIsWrapped: true,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobTag"
              }
            }
          }
        }
      }
    }
  };
  mappers.BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: true,
          xmlName: "Key",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: true,
          xmlName: "Id",
          type: {
            name: "String"
          }
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: {
            name: "Composite",
            className: "AccessPolicy"
          }
        }
      }
    }
  };
  mappers.AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobFlatListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  mappers.BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        },
        deleted: {
          serializedName: "Deleted",
          required: true,
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        snapshot: {
          serializedName: "Snapshot",
          required: true,
          xmlName: "Snapshot",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: {
            name: "Boolean"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "BlobPropertiesInternal"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: true,
          type: {
            name: "Boolean"
          }
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: true,
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: {
            name: "String"
          }
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: {
            name: "ByteArray"
          }
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: {
            name: "String"
          }
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: {
            name: "String"
          }
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: {
            name: "Boolean"
          }
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: {
            name: "String"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold"
            ]
          }
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold"
            ]
          }
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: {
            name: "String"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobHierarchyListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobPrefix"
              }
            }
          }
        },
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  mappers.BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        }
      }
    }
  };
  mappers.BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        }
      }
    }
  };
  mappers.BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        }
      }
    }
  };
  mappers.Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        size: {
          serializedName: "Size",
          required: true,
          xmlName: "Size",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "PageRange"
              }
            }
          }
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ClearRange"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: true,
          xmlName: "QueryType",
          type: {
            name: "String"
          }
        },
        expression: {
          serializedName: "Expression",
          required: true,
          xmlName: "Expression",
          type: {
            name: "String"
          }
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        }
      }
    }
  };
  mappers.QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: {
            name: "Composite",
            className: "QueryFormat"
          }
        }
      }
    }
  };
  mappers.QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"]
          }
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: {
            name: "Composite",
            className: "DelimitedTextConfiguration"
          }
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: {
            name: "Composite",
            className: "JsonTextConfiguration"
          }
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: {
            name: "Composite",
            className: "ArrowConfiguration"
          }
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
          }
        }
      }
    }
  };
  mappers.DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: {
            name: "String"
          }
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: {
            name: "String"
          }
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: {
            name: "String"
          }
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: true,
          xmlName: "Schema",
          xmlIsWrapped: true,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ArrowField"
              }
            }
          }
        }
      }
    }
  };
  mappers.ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "String"
          }
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: {
            name: "Number"
          }
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: {
            name: "String"
          }
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: {
            name: "Boolean"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  mappers.BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: {
            name: "String"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: {
            name: "String"
          }
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        }
      }
    }
  };
  mappers.BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  mappers.BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: true,
          serializedName: "x-ms-copy-status",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  mappers.BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  mappers.AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  mappers.BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  mappers.BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  return mappers;
}
var parameters = {};
var hasRequiredParameters;
function requireParameters() {
  if (hasRequiredParameters) return parameters;
  hasRequiredParameters = 1;
  Object.defineProperty(parameters, "__esModule", { value: true });
  parameters.action3 = parameters.action2 = parameters.leaseId1 = parameters.action1 = parameters.proposedLeaseId = parameters.duration = parameters.action = parameters.comp10 = parameters.sourceLeaseId = parameters.sourceContainerName = parameters.comp9 = parameters.deletedContainerVersion = parameters.deletedContainerName = parameters.comp8 = parameters.containerAcl = parameters.comp7 = parameters.comp6 = parameters.ifUnmodifiedSince = parameters.ifModifiedSince = parameters.leaseId = parameters.preventEncryptionScopeOverride = parameters.defaultEncryptionScope = parameters.access = parameters.metadata = parameters.restype2 = parameters.where = parameters.comp5 = parameters.multipartContentType = parameters.contentLength = parameters.comp4 = parameters.body = parameters.restype1 = parameters.comp3 = parameters.keyInfo = parameters.include = parameters.maxPageSize = parameters.marker = parameters.prefix = parameters.comp2 = parameters.comp1 = parameters.accept1 = parameters.requestId = parameters.version = parameters.timeoutInSeconds = parameters.comp = parameters.restype = parameters.url = parameters.accept = parameters.blobServiceProperties = parameters.contentType = void 0;
  parameters.fileRequestIntent = parameters.copySourceTags = parameters.copySourceAuthorization = parameters.sourceContentMD5 = parameters.xMsRequiresSync = parameters.legalHold1 = parameters.sealBlob = parameters.blobTagsString = parameters.copySource = parameters.sourceIfTags = parameters.sourceIfNoneMatch = parameters.sourceIfMatch = parameters.sourceIfUnmodifiedSince = parameters.sourceIfModifiedSince = parameters.rehydratePriority = parameters.tier = parameters.comp14 = parameters.encryptionScope = parameters.legalHold = parameters.comp13 = parameters.immutabilityPolicyMode = parameters.immutabilityPolicyExpiry = parameters.comp12 = parameters.blobContentDisposition = parameters.blobContentLanguage = parameters.blobContentEncoding = parameters.blobContentMD5 = parameters.blobContentType = parameters.blobCacheControl = parameters.expiresOn = parameters.expiryOptions = parameters.comp11 = parameters.blobDeleteType = parameters.deleteSnapshots = parameters.ifTags = parameters.ifNoneMatch = parameters.ifMatch = parameters.encryptionAlgorithm = parameters.encryptionKeySha256 = parameters.encryptionKey = parameters.rangeGetContentCRC64 = parameters.rangeGetContentMD5 = parameters.range = parameters.versionId = parameters.snapshot = parameters.delimiter = parameters.include1 = parameters.proposedLeaseId1 = parameters.action4 = parameters.breakPeriod = void 0;
  parameters.listType = parameters.comp25 = parameters.blocks = parameters.blockId = parameters.comp24 = parameters.copySourceBlobProperties = parameters.blobType2 = parameters.comp23 = parameters.sourceRange1 = parameters.appendPosition = parameters.maxSize = parameters.comp22 = parameters.blobType1 = parameters.comp21 = parameters.sequenceNumberAction = parameters.prevSnapshotUrl = parameters.prevsnapshot = parameters.comp20 = parameters.range1 = parameters.sourceContentCrc64 = parameters.sourceRange = parameters.sourceUrl = parameters.pageWrite1 = parameters.ifSequenceNumberEqualTo = parameters.ifSequenceNumberLessThan = parameters.ifSequenceNumberLessThanOrEqualTo = parameters.pageWrite = parameters.comp19 = parameters.accept2 = parameters.body1 = parameters.contentType1 = parameters.blobSequenceNumber = parameters.blobContentLength = parameters.blobType = parameters.transactionalContentCrc64 = parameters.transactionalContentMD5 = parameters.tags = parameters.comp18 = parameters.comp17 = parameters.queryRequest = parameters.tier1 = parameters.comp16 = parameters.copyId = parameters.copyActionAbortConstant = parameters.comp15 = void 0;
  const mappers_js_1 = /* @__PURE__ */ requireMappers();
  parameters.contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: mappers_js_1.BlobServiceProperties
  };
  parameters.accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  parameters.url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: true,
      xmlName: "url",
      type: {
        name: "String"
      }
    },
    skipEncoding: true
  };
  parameters.restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: {
        InclusiveMinimum: 0
      },
      serializedName: "timeout",
      xmlName: "timeout",
      type: {
        name: "Number"
      }
    }
  };
  parameters.version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2025-11-05",
      isConstant: true,
      serializedName: "x-ms-version",
      type: {
        name: "String"
      }
    }
  };
  parameters.requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: {
        name: "String"
      }
    }
  };
  parameters.accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: {
        name: "String"
      }
    }
  };
  parameters.marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: {
        name: "String"
      }
    }
  };
  parameters.maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: {
        InclusiveMinimum: 1
      },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: {
        name: "Number"
      }
    }
  };
  parameters.include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  parameters.keyInfo = {
    parameterPath: "keyInfo",
    mapper: mappers_js_1.KeyInfo
  };
  parameters.comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  parameters.body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  parameters.comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: true,
      xmlName: "Content-Length",
      type: {
        name: "Number"
      }
    }
  };
  parameters.multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: true,
      xmlName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: {
        name: "String"
      }
    }
  };
  parameters.restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  parameters.metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: {
        name: "Dictionary",
        value: { type: { name: "String" } }
      }
    }
  };
  parameters.access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: {
        name: "Enum",
        allowedValues: ["container", "blob"]
      }
    }
  };
  parameters.defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope"
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  parameters.preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride"
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  parameters.ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  parameters.ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  parameters.comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: true,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  };
  parameters.comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: {
        name: "String"
      }
    }
  };
  parameters.deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: true,
      xmlName: "x-ms-source-container-name",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  parameters.duration = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: {
        name: "Number"
      }
    }
  };
  parameters.proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  parameters.action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  parameters.leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: true,
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  parameters.action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  parameters.action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  parameters.breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: {
        name: "Number"
      }
    }
  };
  parameters.action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  parameters.proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: true,
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  parameters.include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions"
            ]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  parameters.delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: true,
      xmlName: "delimiter",
      type: {
        name: "String"
      }
    }
  };
  parameters.snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: {
        name: "String"
      }
    }
  };
  parameters.versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: {
        name: "String"
      }
    }
  };
  parameters.range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  parameters.rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: {
        name: "String"
      }
    }
  };
  parameters.encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: {
        name: "String"
      }
    }
  };
  parameters.encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: {
        name: "String"
      }
    }
  };
  parameters.ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: {
        name: "String"
      }
    }
  };
  parameters.ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: {
        name: "String"
      }
    }
  };
  parameters.ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: {
        name: "String"
      }
    }
  };
  parameters.deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: {
        name: "Enum",
        allowedValues: ["include", "only"]
      }
    }
  };
  parameters.blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: true,
      xmlName: "x-ms-expiry-option",
      type: {
        name: "String"
      }
    }
  };
  parameters.expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  parameters.blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  parameters.immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: {
        name: "Enum",
        allowedValues: ["Mutable", "Unlocked", "Locked"]
      }
    }
  };
  parameters.comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: true,
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  parameters.rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: {
        name: "Enum",
        allowedValues: ["High", "Standard"]
      }
    }
  };
  parameters.sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  parameters.sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  parameters.sourceIfMatch = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch"
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceIfTags = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: {
        name: "String"
      }
    }
  };
  parameters.copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: {
        name: "String"
      }
    }
  };
  parameters.sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: true,
      serializedName: "x-ms-requires-sync",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  parameters.copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: {
        name: "String"
      }
    }
  };
  parameters.copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: {
        name: "Enum",
        allowedValues: ["REPLACE", "COPY"]
      }
    }
  };
  parameters.fileRequestIntent = {
    parameterPath: ["options", "fileRequestIntent"],
    mapper: {
      serializedName: "x-ms-file-request-intent",
      xmlName: "x-ms-file-request-intent",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: true,
      serializedName: "x-ms-copy-action",
      type: {
        name: "String"
      }
    }
  };
  parameters.copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: true,
      xmlName: "copyid",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: true,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  parameters.queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: mappers_js_1.QueryRequest
  };
  parameters.comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.tags = {
    parameterPath: ["options", "tags"],
    mapper: mappers_js_1.BlobTags
  };
  parameters.transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: {
        name: "ByteArray"
      }
    }
  };
  parameters.transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  parameters.blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: true,
      xmlName: "x-ms-blob-content-length",
      type: {
        name: "Number"
      }
    }
  };
  parameters.blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: {
        name: "Number"
      }
    }
  };
  parameters.contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  parameters.body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  parameters.accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  parameters.ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: {
        name: "Number"
      }
    }
  };
  parameters.ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: {
        name: "Number"
      }
    }
  };
  parameters.ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: {
        name: "Number"
      }
    }
  };
  parameters.pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: true,
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  parameters.sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  parameters.range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: true,
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: {
        name: "String"
      }
    }
  };
  parameters.prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: {
        name: "String"
      }
    }
  };
  parameters.sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: true,
      xmlName: "x-ms-sequence-number-action",
      type: {
        name: "Enum",
        allowedValues: ["max", "update", "increment"]
      }
    }
  };
  parameters.comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: {
        name: "Number"
      }
    }
  };
  parameters.appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition"
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: {
        name: "Number"
      }
    }
  };
  parameters.sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  parameters.comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  parameters.copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: {
        name: "Boolean"
      }
    }
  };
  parameters.comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: true,
      xmlName: "blockid",
      type: {
        name: "String"
      }
    }
  };
  parameters.blocks = {
    parameterPath: "blocks",
    mapper: mappers_js_1.BlockLookupList
  };
  parameters.comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  parameters.listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: true,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"]
      }
    }
  };
  return parameters;
}
var hasRequiredService$1;
function requireService$1() {
  if (hasRequiredService$1) return service$1;
  hasRequiredService$1 = 1;
  Object.defineProperty(service$1, "__esModule", { value: true });
  service$1.ServiceImpl = void 0;
  const tslib_1 = require$$0$2;
  const coreClient = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$5());
  const Mappers = tslib_1.__importStar(/* @__PURE__ */ requireMappers());
  const Parameters = tslib_1.__importStar(/* @__PURE__ */ requireParameters());
  class ServiceImpl {
    client;
    /**
     * Initialize a new instance of the class Service class.
     * @param client Reference to the service client
     */
    constructor(client2) {
      this.client = client2;
    }
    /**
     * Sets properties for a storage account's Blob service endpoint, including properties for Storage
     * Analytics and CORS (Cross-Origin Resource Sharing) rules
     * @param blobServiceProperties The StorageService properties.
     * @param options The options parameters.
     */
    setProperties(blobServiceProperties, options2) {
      return this.client.sendOperationRequest({ blobServiceProperties, options: options2 }, setPropertiesOperationSpec);
    }
    /**
     * gets the properties of a storage account's Blob service, including properties for Storage Analytics
     * and CORS (Cross-Origin Resource Sharing) rules.
     * @param options The options parameters.
     */
    getProperties(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getPropertiesOperationSpec);
    }
    /**
     * Retrieves statistics related to replication for the Blob service. It is only available on the
     * secondary location endpoint when read-access geo-redundant replication is enabled for the storage
     * account.
     * @param options The options parameters.
     */
    getStatistics(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getStatisticsOperationSpec);
    }
    /**
     * The List Containers Segment operation returns a list of the containers under the specified account
     * @param options The options parameters.
     */
    listContainersSegment(options2) {
      return this.client.sendOperationRequest({ options: options2 }, listContainersSegmentOperationSpec);
    }
    /**
     * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
     * bearer token authentication.
     * @param keyInfo Key information
     * @param options The options parameters.
     */
    getUserDelegationKey(keyInfo, options2) {
      return this.client.sendOperationRequest({ keyInfo, options: options2 }, getUserDelegationKeyOperationSpec);
    }
    /**
     * Returns the sku name and account kind
     * @param options The options parameters.
     */
    getAccountInfo(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getAccountInfoOperationSpec);
    }
    /**
     * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
     * @param contentLength The length of the request.
     * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
     *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
     * @param body Initial data
     * @param options The options parameters.
     */
    submitBatch(contentLength, multipartContentType, body2, options2) {
      return this.client.sendOperationRequest({ contentLength, multipartContentType, body: body2, options: options2 }, submitBatchOperationSpec);
    }
    /**
     * The Filter Blobs operation enables callers to list blobs across all containers whose tags match a
     * given search expression.  Filter blobs searches across all containers within a storage account but
     * can be scoped within the expression to a single container.
     * @param options The options parameters.
     */
    filterBlobs(options2) {
      return this.client.sendOperationRequest({ options: options2 }, filterBlobsOperationSpec);
    }
  }
  service$1.ServiceImpl = ServiceImpl;
  const xmlSerializer = coreClient.createSerializer(
    Mappers,
    /* isXml */
    true
  );
  const setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.ServiceSetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceSetPropertiesExceptionHeaders
      }
    },
    requestBody: Parameters.blobServiceProperties,
    queryParameters: [
      Parameters.restype,
      Parameters.comp,
      Parameters.timeoutInSeconds
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const getPropertiesOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobServiceProperties,
        headersMapper: Mappers.ServiceGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.restype,
      Parameters.comp,
      Parameters.timeoutInSeconds
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobServiceStatistics,
        headersMapper: Mappers.ServiceGetStatisticsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetStatisticsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.restype,
      Parameters.timeoutInSeconds,
      Parameters.comp1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const listContainersSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListContainersSegmentResponse,
        headersMapper: Mappers.ServiceListContainersSegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceListContainersSegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.include
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getUserDelegationKeyOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.UserDelegationKey,
        headersMapper: Mappers.ServiceGetUserDelegationKeyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetUserDelegationKeyExceptionHeaders
      }
    },
    requestBody: Parameters.keyInfo,
    queryParameters: [
      Parameters.restype,
      Parameters.timeoutInSeconds,
      Parameters.comp3
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const getAccountInfoOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ServiceGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const submitBatchOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.ServiceSubmitBatchHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceSubmitBatchExceptionHeaders
      }
    },
    requestBody: Parameters.body,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp4],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const filterBlobsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.FilterBlobSegment,
        headersMapper: Mappers.ServiceFilterBlobsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.comp5,
      Parameters.where
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  return service$1;
}
var container$1 = {};
var hasRequiredContainer$1;
function requireContainer$1() {
  if (hasRequiredContainer$1) return container$1;
  hasRequiredContainer$1 = 1;
  Object.defineProperty(container$1, "__esModule", { value: true });
  container$1.ContainerImpl = void 0;
  const tslib_1 = require$$0$2;
  const coreClient = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$5());
  const Mappers = tslib_1.__importStar(/* @__PURE__ */ requireMappers());
  const Parameters = tslib_1.__importStar(/* @__PURE__ */ requireParameters());
  class ContainerImpl {
    client;
    /**
     * Initialize a new instance of the class Container class.
     * @param client Reference to the service client
     */
    constructor(client2) {
      this.client = client2;
    }
    /**
     * creates a new container under the specified account. If the container with the same name already
     * exists, the operation fails
     * @param options The options parameters.
     */
    create(options2) {
      return this.client.sendOperationRequest({ options: options2 }, createOperationSpec);
    }
    /**
     * returns all user-defined metadata and system properties for the specified container. The data
     * returned does not include the container's list of blobs
     * @param options The options parameters.
     */
    getProperties(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getPropertiesOperationSpec);
    }
    /**
     * operation marks the specified container for deletion. The container and any blobs contained within
     * it are later deleted during garbage collection
     * @param options The options parameters.
     */
    delete(options2) {
      return this.client.sendOperationRequest({ options: options2 }, deleteOperationSpec);
    }
    /**
     * operation sets one or more user-defined name-value pairs for the specified container.
     * @param options The options parameters.
     */
    setMetadata(options2) {
      return this.client.sendOperationRequest({ options: options2 }, setMetadataOperationSpec);
    }
    /**
     * gets the permissions for the specified container. The permissions indicate whether container data
     * may be accessed publicly.
     * @param options The options parameters.
     */
    getAccessPolicy(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getAccessPolicyOperationSpec);
    }
    /**
     * sets the permissions for the specified container. The permissions indicate whether blobs in a
     * container may be accessed publicly.
     * @param options The options parameters.
     */
    setAccessPolicy(options2) {
      return this.client.sendOperationRequest({ options: options2 }, setAccessPolicyOperationSpec);
    }
    /**
     * Restores a previously-deleted container.
     * @param options The options parameters.
     */
    restore(options2) {
      return this.client.sendOperationRequest({ options: options2 }, restoreOperationSpec);
    }
    /**
     * Renames an existing container.
     * @param sourceContainerName Required.  Specifies the name of the container to rename.
     * @param options The options parameters.
     */
    rename(sourceContainerName, options2) {
      return this.client.sendOperationRequest({ sourceContainerName, options: options2 }, renameOperationSpec);
    }
    /**
     * The Batch operation allows multiple API calls to be embedded into a single HTTP request.
     * @param contentLength The length of the request.
     * @param multipartContentType Required. The value of this header must be multipart/mixed with a batch
     *                             boundary. Example header value: multipart/mixed; boundary=batch_<GUID>
     * @param body Initial data
     * @param options The options parameters.
     */
    submitBatch(contentLength, multipartContentType, body2, options2) {
      return this.client.sendOperationRequest({ contentLength, multipartContentType, body: body2, options: options2 }, submitBatchOperationSpec);
    }
    /**
     * The Filter Blobs operation enables callers to list blobs in a container whose tags match a given
     * search expression.  Filter blobs searches within the given container.
     * @param options The options parameters.
     */
    filterBlobs(options2) {
      return this.client.sendOperationRequest({ options: options2 }, filterBlobsOperationSpec);
    }
    /**
     * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
     * be 15 to 60 seconds, or can be infinite
     * @param options The options parameters.
     */
    acquireLease(options2) {
      return this.client.sendOperationRequest({ options: options2 }, acquireLeaseOperationSpec);
    }
    /**
     * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
     * be 15 to 60 seconds, or can be infinite
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    releaseLease(leaseId, options2) {
      return this.client.sendOperationRequest({ leaseId, options: options2 }, releaseLeaseOperationSpec);
    }
    /**
     * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
     * be 15 to 60 seconds, or can be infinite
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    renewLease(leaseId, options2) {
      return this.client.sendOperationRequest({ leaseId, options: options2 }, renewLeaseOperationSpec);
    }
    /**
     * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
     * be 15 to 60 seconds, or can be infinite
     * @param options The options parameters.
     */
    breakLease(options2) {
      return this.client.sendOperationRequest({ options: options2 }, breakLeaseOperationSpec);
    }
    /**
     * [Update] establishes and manages a lock on a container for delete operations. The lock duration can
     * be 15 to 60 seconds, or can be infinite
     * @param leaseId Specifies the current lease ID on the resource.
     * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
     *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
     *                        (String) for a list of valid GUID string formats.
     * @param options The options parameters.
     */
    changeLease(leaseId, proposedLeaseId, options2) {
      return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options: options2 }, changeLeaseOperationSpec);
    }
    /**
     * [Update] The List Blobs operation returns a list of the blobs under the specified container
     * @param options The options parameters.
     */
    listBlobFlatSegment(options2) {
      return this.client.sendOperationRequest({ options: options2 }, listBlobFlatSegmentOperationSpec);
    }
    /**
     * [Update] The List Blobs operation returns a list of the blobs under the specified container
     * @param delimiter When the request includes this parameter, the operation returns a BlobPrefix
     *                  element in the response body that acts as a placeholder for all blobs whose names begin with the
     *                  same substring up to the appearance of the delimiter character. The delimiter may be a single
     *                  character or a string.
     * @param options The options parameters.
     */
    listBlobHierarchySegment(delimiter, options2) {
      return this.client.sendOperationRequest({ delimiter, options: options2 }, listBlobHierarchySegmentOperationSpec);
    }
    /**
     * Returns the sku name and account kind
     * @param options The options parameters.
     */
    getAccountInfo(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getAccountInfoOperationSpec);
    }
  }
  container$1.ContainerImpl = ContainerImpl;
  const xmlSerializer = coreClient.createSerializer(
    Mappers,
    /* isXml */
    true
  );
  const createOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.access,
      Parameters.defaultEncryptionScope,
      Parameters.preventEncryptionScopeOverride
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getPropertiesOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ContainerGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const deleteOperationSpec = {
    path: "/{containerName}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: Mappers.ContainerDeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerDeleteExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setMetadataOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerSetMetadataHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSetMetadataExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp6
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "SignedIdentifier" }
            }
          },
          serializedName: "SignedIdentifiers",
          xmlName: "SignedIdentifiers",
          xmlIsWrapped: true,
          xmlElementName: "SignedIdentifier"
        },
        headersMapper: Mappers.ContainerGetAccessPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetAccessPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp7
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerSetAccessPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSetAccessPolicyExceptionHeaders
      }
    },
    requestBody: Parameters.containerAcl,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp7
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.access,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const restoreOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerRestoreHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRestoreExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp8
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.deletedContainerName,
      Parameters.deletedContainerVersion
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const renameOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerRenameHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRenameExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp9
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.sourceContainerName,
      Parameters.sourceLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const submitBatchOperationSpec = {
    path: "/{containerName}",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.ContainerSubmitBatchHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSubmitBatchExceptionHeaders
      }
    },
    requestBody: Parameters.body,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp4,
      Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const filterBlobsOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.FilterBlobSegment,
        headersMapper: Mappers.ContainerFilterBlobsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.comp5,
      Parameters.where,
      Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const acquireLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerAcquireLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action,
      Parameters.duration,
      Parameters.proposedLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const releaseLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerReleaseLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action1,
      Parameters.leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const renewLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerRenewLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action2
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const breakLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.ContainerBreakLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action3,
      Parameters.breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const changeLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerChangeLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action4,
      Parameters.proposedLeaseId1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const listBlobFlatSegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListBlobsFlatSegmentResponse,
        headersMapper: Mappers.ContainerListBlobFlatSegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerListBlobFlatSegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.restype2,
      Parameters.include1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const listBlobHierarchySegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListBlobsHierarchySegmentResponse,
        headersMapper: Mappers.ContainerListBlobHierarchySegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerListBlobHierarchySegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.restype2,
      Parameters.include1,
      Parameters.delimiter
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getAccountInfoOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ContainerGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  return container$1;
}
var blob$1 = {};
var hasRequiredBlob$1;
function requireBlob$1() {
  if (hasRequiredBlob$1) return blob$1;
  hasRequiredBlob$1 = 1;
  Object.defineProperty(blob$1, "__esModule", { value: true });
  blob$1.BlobImpl = void 0;
  const tslib_1 = require$$0$2;
  const coreClient = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$5());
  const Mappers = tslib_1.__importStar(/* @__PURE__ */ requireMappers());
  const Parameters = tslib_1.__importStar(/* @__PURE__ */ requireParameters());
  class BlobImpl {
    client;
    /**
     * Initialize a new instance of the class Blob class.
     * @param client Reference to the service client
     */
    constructor(client2) {
      this.client = client2;
    }
    /**
     * The Download operation reads or downloads a blob from the system, including its metadata and
     * properties. You can also call Download to read a snapshot.
     * @param options The options parameters.
     */
    download(options2) {
      return this.client.sendOperationRequest({ options: options2 }, downloadOperationSpec);
    }
    /**
     * The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system
     * properties for the blob. It does not return the content of the blob.
     * @param options The options parameters.
     */
    getProperties(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getPropertiesOperationSpec);
    }
    /**
     * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
     * permanently removed from the storage account. If the storage account's soft delete feature is
     * enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
     * immediately. However, the blob service retains the blob or snapshot for the number of days specified
     * by the DeleteRetentionPolicy section of [Storage service properties]
     * (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is
     * permanently removed from the storage account. Note that you continue to be charged for the
     * soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the
     * "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You
     * can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a
     * soft-deleted blob or snapshot causes the service to return an HTTP status code of 404
     * (ResourceNotFound).
     * @param options The options parameters.
     */
    delete(options2) {
      return this.client.sendOperationRequest({ options: options2 }, deleteOperationSpec);
    }
    /**
     * Undelete a blob that was previously soft deleted
     * @param options The options parameters.
     */
    undelete(options2) {
      return this.client.sendOperationRequest({ options: options2 }, undeleteOperationSpec);
    }
    /**
     * Sets the time a blob will expire and be deleted.
     * @param expiryOptions Required. Indicates mode of the expiry time
     * @param options The options parameters.
     */
    setExpiry(expiryOptions, options2) {
      return this.client.sendOperationRequest({ expiryOptions, options: options2 }, setExpiryOperationSpec);
    }
    /**
     * The Set HTTP Headers operation sets system properties on the blob
     * @param options The options parameters.
     */
    setHttpHeaders(options2) {
      return this.client.sendOperationRequest({ options: options2 }, setHttpHeadersOperationSpec);
    }
    /**
     * The Set Immutability Policy operation sets the immutability policy on the blob
     * @param options The options parameters.
     */
    setImmutabilityPolicy(options2) {
      return this.client.sendOperationRequest({ options: options2 }, setImmutabilityPolicyOperationSpec);
    }
    /**
     * The Delete Immutability Policy operation deletes the immutability policy on the blob
     * @param options The options parameters.
     */
    deleteImmutabilityPolicy(options2) {
      return this.client.sendOperationRequest({ options: options2 }, deleteImmutabilityPolicyOperationSpec);
    }
    /**
     * The Set Legal Hold operation sets a legal hold on the blob.
     * @param legalHold Specified if a legal hold should be set on the blob.
     * @param options The options parameters.
     */
    setLegalHold(legalHold, options2) {
      return this.client.sendOperationRequest({ legalHold, options: options2 }, setLegalHoldOperationSpec);
    }
    /**
     * The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more
     * name-value pairs
     * @param options The options parameters.
     */
    setMetadata(options2) {
      return this.client.sendOperationRequest({ options: options2 }, setMetadataOperationSpec);
    }
    /**
     * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
     * operations
     * @param options The options parameters.
     */
    acquireLease(options2) {
      return this.client.sendOperationRequest({ options: options2 }, acquireLeaseOperationSpec);
    }
    /**
     * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    releaseLease(leaseId, options2) {
      return this.client.sendOperationRequest({ leaseId, options: options2 }, releaseLeaseOperationSpec);
    }
    /**
     * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    renewLease(leaseId, options2) {
      return this.client.sendOperationRequest({ leaseId, options: options2 }, renewLeaseOperationSpec);
    }
    /**
     * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
     *                        (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
     *                        (String) for a list of valid GUID string formats.
     * @param options The options parameters.
     */
    changeLease(leaseId, proposedLeaseId, options2) {
      return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options: options2 }, changeLeaseOperationSpec);
    }
    /**
     * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
     * operations
     * @param options The options parameters.
     */
    breakLease(options2) {
      return this.client.sendOperationRequest({ options: options2 }, breakLeaseOperationSpec);
    }
    /**
     * The Create Snapshot operation creates a read-only snapshot of a blob
     * @param options The options parameters.
     */
    createSnapshot(options2) {
      return this.client.sendOperationRequest({ options: options2 }, createSnapshotOperationSpec);
    }
    /**
     * The Start Copy From URL operation copies a blob or an internet resource to a new blob.
     * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
     *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
     *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
     *                   access signature.
     * @param options The options parameters.
     */
    startCopyFromURL(copySource, options2) {
      return this.client.sendOperationRequest({ copySource, options: options2 }, startCopyFromURLOperationSpec);
    }
    /**
     * The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return
     * a response until the copy is complete.
     * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
     *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
     *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
     *                   access signature.
     * @param options The options parameters.
     */
    copyFromURL(copySource, options2) {
      return this.client.sendOperationRequest({ copySource, options: options2 }, copyFromURLOperationSpec);
    }
    /**
     * The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination
     * blob with zero length and full metadata.
     * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy Blob
     *               operation.
     * @param options The options parameters.
     */
    abortCopyFromURL(copyId, options2) {
      return this.client.sendOperationRequest({ copyId, options: options2 }, abortCopyFromURLOperationSpec);
    }
    /**
     * The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium
     * storage account and on a block blob in a blob storage account (locally redundant storage only). A
     * premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block
     * blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's
     * ETag.
     * @param tier Indicates the tier to be set on the blob.
     * @param options The options parameters.
     */
    setTier(tier, options2) {
      return this.client.sendOperationRequest({ tier, options: options2 }, setTierOperationSpec);
    }
    /**
     * Returns the sku name and account kind
     * @param options The options parameters.
     */
    getAccountInfo(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getAccountInfoOperationSpec);
    }
    /**
     * The Query operation enables users to select/project on blob data by providing simple query
     * expressions.
     * @param options The options parameters.
     */
    query(options2) {
      return this.client.sendOperationRequest({ options: options2 }, queryOperationSpec);
    }
    /**
     * The Get Tags operation enables users to get the tags associated with a blob.
     * @param options The options parameters.
     */
    getTags(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getTagsOperationSpec);
    }
    /**
     * The Set Tags operation enables users to set tags on a blob.
     * @param options The options parameters.
     */
    setTags(options2) {
      return this.client.sendOperationRequest({ options: options2 }, setTagsOperationSpec);
    }
  }
  blob$1.BlobImpl = BlobImpl;
  const xmlSerializer = coreClient.createSerializer(
    Mappers,
    /* isXml */
    true
  );
  const downloadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobDownloadHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobDownloadHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDownloadExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.rangeGetContentMD5,
      Parameters.rangeGetContentCRC64,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getPropertiesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "HEAD",
    responses: {
      200: {
        headersMapper: Mappers.BlobGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const deleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: Mappers.BlobDeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDeleteExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.blobDeleteType
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const undeleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobUndeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobUndeleteExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp8],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setExpiryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetExpiryHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetExpiryExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp11],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.expiryOptions,
      Parameters.expiresOn
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setHttpHeadersOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetHttpHeadersHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetHttpHeadersExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp12
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifUnmodifiedSince,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const deleteImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      200: {
        headersMapper: Mappers.BlobDeleteImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDeleteImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp12
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setLegalHoldOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetLegalHoldHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetLegalHoldExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp13
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.legalHold
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setMetadataOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetMetadataHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetMetadataExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp6],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const acquireLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlobAcquireLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action,
      Parameters.duration,
      Parameters.proposedLeaseId,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const releaseLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobReleaseLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action1,
      Parameters.leaseId1,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const renewLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobRenewLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action2,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const changeLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobChangeLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action4,
      Parameters.proposedLeaseId1,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const breakLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobBreakLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action3,
      Parameters.breakPeriod,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const createSnapshotOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlobCreateSnapshotHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobCreateSnapshotExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp14],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const startCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobStartCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobStartCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.tier,
      Parameters.rehydratePriority,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceIfTags,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.sealBlob,
      Parameters.legalHold1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const copyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.xMsRequiresSync,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.copySourceTags,
      Parameters.fileRequestIntent
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const abortCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: Mappers.BlobAbortCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobAbortCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp15,
      Parameters.copyId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setTierOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetTierHeaders
      },
      202: {
        headersMapper: Mappers.BlobSetTierHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetTierExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp16
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.rehydratePriority,
      Parameters.tier1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getAccountInfoOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.BlobGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const queryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobQueryHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobQueryHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobQueryExceptionHeaders
      }
    },
    requestBody: Parameters.queryRequest,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.comp17
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const getTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobTags,
        headersMapper: Mappers.BlobGetTagsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetTagsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp18
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const setTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: Mappers.BlobSetTagsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetTagsExceptionHeaders
      }
    },
    requestBody: Parameters.tags,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.versionId,
      Parameters.comp18
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  return blob$1;
}
var pageBlob$1 = {};
var hasRequiredPageBlob$1;
function requirePageBlob$1() {
  if (hasRequiredPageBlob$1) return pageBlob$1;
  hasRequiredPageBlob$1 = 1;
  Object.defineProperty(pageBlob$1, "__esModule", { value: true });
  pageBlob$1.PageBlobImpl = void 0;
  const tslib_1 = require$$0$2;
  const coreClient = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$5());
  const Mappers = tslib_1.__importStar(/* @__PURE__ */ requireMappers());
  const Parameters = tslib_1.__importStar(/* @__PURE__ */ requireParameters());
  class PageBlobImpl {
    client;
    /**
     * Initialize a new instance of the class PageBlob class.
     * @param client Reference to the service client
     */
    constructor(client2) {
      this.client = client2;
    }
    /**
     * The Create operation creates a new page blob.
     * @param contentLength The length of the request.
     * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
     *                          page blob size must be aligned to a 512-byte boundary.
     * @param options The options parameters.
     */
    create(contentLength, blobContentLength, options2) {
      return this.client.sendOperationRequest({ contentLength, blobContentLength, options: options2 }, createOperationSpec);
    }
    /**
     * The Upload Pages operation writes a range of pages to a page blob
     * @param contentLength The length of the request.
     * @param body Initial data
     * @param options The options parameters.
     */
    uploadPages(contentLength, body2, options2) {
      return this.client.sendOperationRequest({ contentLength, body: body2, options: options2 }, uploadPagesOperationSpec);
    }
    /**
     * The Clear Pages operation clears a set of pages from a page blob
     * @param contentLength The length of the request.
     * @param options The options parameters.
     */
    clearPages(contentLength, options2) {
      return this.client.sendOperationRequest({ contentLength, options: options2 }, clearPagesOperationSpec);
    }
    /**
     * The Upload Pages operation writes a range of pages to a page blob where the contents are read from a
     * URL
     * @param sourceUrl Specify a URL to the copy source.
     * @param sourceRange Bytes of source data in the specified range. The length of this range should
     *                    match the ContentLength header and x-ms-range/Range destination range header.
     * @param contentLength The length of the request.
     * @param range The range of bytes to which the source range would be written. The range should be 512
     *              aligned and range-end is required.
     * @param options The options parameters.
     */
    uploadPagesFromURL(sourceUrl, sourceRange, contentLength, range, options2) {
      return this.client.sendOperationRequest({ sourceUrl, sourceRange, contentLength, range, options: options2 }, uploadPagesFromURLOperationSpec);
    }
    /**
     * The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a
     * page blob
     * @param options The options parameters.
     */
    getPageRanges(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getPageRangesOperationSpec);
    }
    /**
     * The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were
     * changed between target blob and previous snapshot.
     * @param options The options parameters.
     */
    getPageRangesDiff(options2) {
      return this.client.sendOperationRequest({ options: options2 }, getPageRangesDiffOperationSpec);
    }
    /**
     * Resize the Blob
     * @param blobContentLength This header specifies the maximum size for the page blob, up to 1 TB. The
     *                          page blob size must be aligned to a 512-byte boundary.
     * @param options The options parameters.
     */
    resize(blobContentLength, options2) {
      return this.client.sendOperationRequest({ blobContentLength, options: options2 }, resizeOperationSpec);
    }
    /**
     * Update the sequence number of the blob
     * @param sequenceNumberAction Required if the x-ms-blob-sequence-number header is set for the request.
     *                             This property applies to page blobs only. This property indicates how the service should modify the
     *                             blob's sequence number
     * @param options The options parameters.
     */
    updateSequenceNumber(sequenceNumberAction, options2) {
      return this.client.sendOperationRequest({ sequenceNumberAction, options: options2 }, updateSequenceNumberOperationSpec);
    }
    /**
     * The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob.
     * The snapshot is copied such that only the differential changes between the previously copied
     * snapshot are transferred to the destination. The copied snapshots are complete copies of the
     * original snapshot and can be read or copied from as usual. This API is supported since REST version
     * 2016-05-31.
     * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
     *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
     *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
     *                   access signature.
     * @param options The options parameters.
     */
    copyIncremental(copySource, options2) {
      return this.client.sendOperationRequest({ copySource, options: options2 }, copyIncrementalOperationSpec);
    }
  }
  pageBlob$1.PageBlobImpl = PageBlobImpl;
  const xmlSerializer = coreClient.createSerializer(
    Mappers,
    /* isXml */
    true
  );
  const createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.blobType,
      Parameters.blobContentLength,
      Parameters.blobSequenceNumber
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const uploadPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobUploadPagesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUploadPagesExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.pageWrite,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  const clearPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobClearPagesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobClearPagesExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo,
      Parameters.pageWrite1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const uploadPagesFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobUploadPagesFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUploadPagesFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.pageWrite,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo,
      Parameters.sourceUrl,
      Parameters.sourceRange,
      Parameters.sourceContentCrc64,
      Parameters.range1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getPageRangesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.PageList,
        headersMapper: Mappers.PageBlobGetPageRangesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobGetPageRangesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.snapshot,
      Parameters.comp20
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const getPageRangesDiffOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.PageList,
        headersMapper: Mappers.PageBlobGetPageRangesDiffHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobGetPageRangesDiffExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.snapshot,
      Parameters.comp20,
      Parameters.prevsnapshot
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.prevSnapshotUrl
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const resizeOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.PageBlobResizeHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobResizeExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.blobContentLength
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const updateSequenceNumberOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.PageBlobUpdateSequenceNumberHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUpdateSequenceNumberExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobSequenceNumber,
      Parameters.sequenceNumberAction
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const copyIncrementalOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.PageBlobCopyIncrementalHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobCopyIncrementalExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp21],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.copySource
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  return pageBlob$1;
}
var appendBlob$1 = {};
var hasRequiredAppendBlob$1;
function requireAppendBlob$1() {
  if (hasRequiredAppendBlob$1) return appendBlob$1;
  hasRequiredAppendBlob$1 = 1;
  Object.defineProperty(appendBlob$1, "__esModule", { value: true });
  appendBlob$1.AppendBlobImpl = void 0;
  const tslib_1 = require$$0$2;
  const coreClient = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$5());
  const Mappers = tslib_1.__importStar(/* @__PURE__ */ requireMappers());
  const Parameters = tslib_1.__importStar(/* @__PURE__ */ requireParameters());
  class AppendBlobImpl {
    client;
    /**
     * Initialize a new instance of the class AppendBlob class.
     * @param client Reference to the service client
     */
    constructor(client2) {
      this.client = client2;
    }
    /**
     * The Create Append Blob operation creates a new append blob.
     * @param contentLength The length of the request.
     * @param options The options parameters.
     */
    create(contentLength, options2) {
      return this.client.sendOperationRequest({ contentLength, options: options2 }, createOperationSpec);
    }
    /**
     * The Append Block operation commits a new block of data to the end of an existing append blob. The
     * Append Block operation is permitted only if the blob was created with x-ms-blob-type set to
     * AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
     * @param contentLength The length of the request.
     * @param body Initial data
     * @param options The options parameters.
     */
    appendBlock(contentLength, body2, options2) {
      return this.client.sendOperationRequest({ contentLength, body: body2, options: options2 }, appendBlockOperationSpec);
    }
    /**
     * The Append Block operation commits a new block of data to the end of an existing append blob where
     * the contents are read from a source url. The Append Block operation is permitted only if the blob
     * was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version
     * 2015-02-21 version or later.
     * @param sourceUrl Specify a URL to the copy source.
     * @param contentLength The length of the request.
     * @param options The options parameters.
     */
    appendBlockFromUrl(sourceUrl, contentLength, options2) {
      return this.client.sendOperationRequest({ sourceUrl, contentLength, options: options2 }, appendBlockFromUrlOperationSpec);
    }
    /**
     * The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version
     * 2019-12-12 version or later.
     * @param options The options parameters.
     */
    seal(options2) {
      return this.client.sendOperationRequest({ options: options2 }, sealOperationSpec);
    }
  }
  appendBlob$1.AppendBlobImpl = AppendBlobImpl;
  const xmlSerializer = coreClient.createSerializer(
    Mappers,
    /* isXml */
    true
  );
  const createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.blobType1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const appendBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobAppendBlockHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobAppendBlockExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.maxSize,
      Parameters.appendPosition
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  const appendBlockFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobAppendBlockFromUrlHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobAppendBlockFromUrlExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.transactionalContentMD5,
      Parameters.sourceUrl,
      Parameters.sourceContentCrc64,
      Parameters.maxSize,
      Parameters.appendPosition,
      Parameters.sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const sealOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.AppendBlobSealHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobSealExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp23],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.appendPosition
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  return appendBlob$1;
}
var blockBlob$1 = {};
var hasRequiredBlockBlob$1;
function requireBlockBlob$1() {
  if (hasRequiredBlockBlob$1) return blockBlob$1;
  hasRequiredBlockBlob$1 = 1;
  Object.defineProperty(blockBlob$1, "__esModule", { value: true });
  blockBlob$1.BlockBlobImpl = void 0;
  const tslib_1 = require$$0$2;
  const coreClient = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$5());
  const Mappers = tslib_1.__importStar(/* @__PURE__ */ requireMappers());
  const Parameters = tslib_1.__importStar(/* @__PURE__ */ requireParameters());
  class BlockBlobImpl {
    client;
    /**
     * Initialize a new instance of the class BlockBlob class.
     * @param client Reference to the service client
     */
    constructor(client2) {
      this.client = client2;
    }
    /**
     * The Upload Block Blob operation updates the content of an existing block blob. Updating an existing
     * block blob overwrites any existing metadata on the blob. Partial updates are not supported with Put
     * Blob; the content of the existing blob is overwritten with the content of the new blob. To perform a
     * partial update of the content of a block blob, use the Put Block List operation.
     * @param contentLength The length of the request.
     * @param body Initial data
     * @param options The options parameters.
     */
    upload(contentLength, body2, options2) {
      return this.client.sendOperationRequest({ contentLength, body: body2, options: options2 }, uploadOperationSpec);
    }
    /**
     * The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read
     * from a given URL.  This API is supported beginning with the 2020-04-08 version. Partial updates are
     * not supported with Put Blob from URL; the content of an existing blob is overwritten with the
     * content of the new blob.  To perform partial updates to a block blob’s contents using a source URL,
     * use the Put Block from URL API in conjunction with Put Block List.
     * @param contentLength The length of the request.
     * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up to
     *                   2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would
     *                   appear in a request URI. The source blob must either be public or must be authenticated via a shared
     *                   access signature.
     * @param options The options parameters.
     */
    putBlobFromUrl(contentLength, copySource, options2) {
      return this.client.sendOperationRequest({ contentLength, copySource, options: options2 }, putBlobFromUrlOperationSpec);
    }
    /**
     * The Stage Block operation creates a new block to be committed as part of a blob
     * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
     *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
     *                for the blockid parameter must be the same size for each block.
     * @param contentLength The length of the request.
     * @param body Initial data
     * @param options The options parameters.
     */
    stageBlock(blockId, contentLength, body2, options2) {
      return this.client.sendOperationRequest({ blockId, contentLength, body: body2, options: options2 }, stageBlockOperationSpec);
    }
    /**
     * The Stage Block operation creates a new block to be committed as part of a blob where the contents
     * are read from a URL.
     * @param blockId A valid Base64 string value that identifies the block. Prior to encoding, the string
     *                must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified
     *                for the blockid parameter must be the same size for each block.
     * @param contentLength The length of the request.
     * @param sourceUrl Specify a URL to the copy source.
     * @param options The options parameters.
     */
    stageBlockFromURL(blockId, contentLength, sourceUrl, options2) {
      return this.client.sendOperationRequest({ blockId, contentLength, sourceUrl, options: options2 }, stageBlockFromURLOperationSpec);
    }
    /**
     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the
     * blob. In order to be written as part of a blob, a block must have been successfully written to the
     * server in a prior Put Block operation. You can call Put Block List to update a blob by uploading
     * only those blocks that have changed, then committing the new and existing blocks together. You can
     * do this by specifying whether to commit a block from the committed block list or from the
     * uncommitted block list, or to commit the most recently uploaded version of the block, whichever list
     * it may belong to.
     * @param blocks Blob Blocks.
     * @param options The options parameters.
     */
    commitBlockList(blocks, options2) {
      return this.client.sendOperationRequest({ blocks, options: options2 }, commitBlockListOperationSpec);
    }
    /**
     * The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block
     * blob
     * @param listType Specifies whether to return the list of committed blocks, the list of uncommitted
     *                 blocks, or both lists together.
     * @param options The options parameters.
     */
    getBlockList(listType, options2) {
      return this.client.sendOperationRequest({ listType, options: options2 }, getBlockListOperationSpec);
    }
  }
  blockBlob$1.BlockBlobImpl = BlockBlobImpl;
  const xmlSerializer = coreClient.createSerializer(
    Mappers,
    /* isXml */
    true
  );
  const uploadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobUploadHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobUploadExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.blobType2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  const putBlobFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobPutBlobFromUrlHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobPutBlobFromUrlExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceIfTags,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.copySourceTags,
      Parameters.fileRequestIntent,
      Parameters.transactionalContentMD5,
      Parameters.blobType2,
      Parameters.copySourceBlobProperties
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const stageBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobStageBlockHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobStageBlockExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp24,
      Parameters.blockId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  const stageBlockFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobStageBlockFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobStageBlockFromURLExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp24,
      Parameters.blockId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.sourceUrl,
      Parameters.sourceContentCrc64,
      Parameters.sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  const commitBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobCommitBlockListHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobCommitBlockListExceptionHeaders
      }
    },
    requestBody: Parameters.blocks,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp25],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  const getBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlockList,
        headersMapper: Mappers.BlockBlobGetBlockListHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobGetBlockListExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.comp25,
      Parameters.listType
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  return blockBlob$1;
}
var hasRequiredOperations;
function requireOperations() {
  if (hasRequiredOperations) return operations;
  hasRequiredOperations = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(/* @__PURE__ */ requireService$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireContainer$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlob$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requirePageBlob$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAppendBlob$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlockBlob$1(), exports);
  })(operations);
  return operations;
}
var hasRequiredStorageClient$1;
function requireStorageClient$1() {
  if (hasRequiredStorageClient$1) return storageClient;
  hasRequiredStorageClient$1 = 1;
  Object.defineProperty(storageClient, "__esModule", { value: true });
  storageClient.StorageClient = void 0;
  const tslib_1 = require$$0$2;
  const coreHttpCompat = tslib_1.__importStar(/* @__PURE__ */ requireCommonjs$4());
  const index_js_1 = /* @__PURE__ */ requireOperations();
  class StorageClient2 extends coreHttpCompat.ExtendedServiceClient {
    url;
    version;
    /**
     * Initializes a new instance of the StorageClient class.
     * @param url The URL of the service account, container, or blob that is the target of the desired
     *            operation.
     * @param options The parameter options
     */
    constructor(url, options2) {
      if (url === void 0) {
        throw new Error("'url' cannot be null");
      }
      if (!options2) {
        options2 = {};
      }
      const defaults = {
        requestContentType: "application/json; charset=utf-8"
      };
      const packageDetails = `azsdk-js-azure-storage-blob/12.29.1`;
      const userAgentPrefix = options2.userAgentOptions && options2.userAgentOptions.userAgentPrefix ? `${options2.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      const optionsWithDefaults = {
        ...defaults,
        ...options2,
        userAgentOptions: {
          userAgentPrefix
        },
        endpoint: options2.endpoint ?? options2.baseUri ?? "{url}"
      };
      super(optionsWithDefaults);
      this.url = url;
      this.version = options2.version || "2025-11-05";
      this.service = new index_js_1.ServiceImpl(this);
      this.container = new index_js_1.ContainerImpl(this);
      this.blob = new index_js_1.BlobImpl(this);
      this.pageBlob = new index_js_1.PageBlobImpl(this);
      this.appendBlob = new index_js_1.AppendBlobImpl(this);
      this.blockBlob = new index_js_1.BlockBlobImpl(this);
    }
    service;
    container;
    blob;
    pageBlob;
    appendBlob;
    blockBlob;
  }
  storageClient.StorageClient = StorageClient2;
  return storageClient;
}
var operationsInterfaces = {};
var service = {};
var hasRequiredService;
function requireService() {
  if (hasRequiredService) return service;
  hasRequiredService = 1;
  Object.defineProperty(service, "__esModule", { value: true });
  return service;
}
var container = {};
var hasRequiredContainer;
function requireContainer() {
  if (hasRequiredContainer) return container;
  hasRequiredContainer = 1;
  Object.defineProperty(container, "__esModule", { value: true });
  return container;
}
var blob = {};
var hasRequiredBlob;
function requireBlob() {
  if (hasRequiredBlob) return blob;
  hasRequiredBlob = 1;
  Object.defineProperty(blob, "__esModule", { value: true });
  return blob;
}
var pageBlob = {};
var hasRequiredPageBlob;
function requirePageBlob() {
  if (hasRequiredPageBlob) return pageBlob;
  hasRequiredPageBlob = 1;
  Object.defineProperty(pageBlob, "__esModule", { value: true });
  return pageBlob;
}
var appendBlob = {};
var hasRequiredAppendBlob;
function requireAppendBlob() {
  if (hasRequiredAppendBlob) return appendBlob;
  hasRequiredAppendBlob = 1;
  Object.defineProperty(appendBlob, "__esModule", { value: true });
  return appendBlob;
}
var blockBlob = {};
var hasRequiredBlockBlob;
function requireBlockBlob() {
  if (hasRequiredBlockBlob) return blockBlob;
  hasRequiredBlockBlob = 1;
  Object.defineProperty(blockBlob, "__esModule", { value: true });
  return blockBlob;
}
var hasRequiredOperationsInterfaces;
function requireOperationsInterfaces() {
  if (hasRequiredOperationsInterfaces) return operationsInterfaces;
  hasRequiredOperationsInterfaces = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(/* @__PURE__ */ requireService(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireContainer(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlob(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requirePageBlob(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAppendBlob(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlockBlob(), exports);
  })(operationsInterfaces);
  return operationsInterfaces;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src$1;
  hasRequiredSrc = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageClient = void 0;
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(/* @__PURE__ */ requireModels$1(), exports);
    var storageClient_js_1 = /* @__PURE__ */ requireStorageClient$1();
    Object.defineProperty(exports, "StorageClient", { enumerable: true, get: function() {
      return storageClient_js_1.StorageClient;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireOperationsInterfaces(), exports);
  })(src$1);
  return src$1;
}
var hasRequiredStorageContextClient;
function requireStorageContextClient() {
  if (hasRequiredStorageContextClient) return StorageContextClient;
  hasRequiredStorageContextClient = 1;
  Object.defineProperty(StorageContextClient, "__esModule", { value: true });
  StorageContextClient.StorageContextClient = void 0;
  const index_js_1 = /* @__PURE__ */ requireSrc();
  let StorageContextClient$1 = class StorageContextClient extends index_js_1.StorageClient {
    async sendOperationRequest(operationArguments, operationSpec) {
      const operationSpecToSend = { ...operationSpec };
      if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
        operationSpecToSend.path = "";
      }
      return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
  };
  StorageContextClient.StorageContextClient = StorageContextClient$1;
  return StorageContextClient;
}
var hasRequiredStorageClient;
function requireStorageClient() {
  if (hasRequiredStorageClient) return StorageClient;
  hasRequiredStorageClient = 1;
  Object.defineProperty(StorageClient, "__esModule", { value: true });
  StorageClient.StorageClient = void 0;
  const StorageContextClient_js_1 = /* @__PURE__ */ requireStorageContextClient();
  const Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  let StorageClient$1 = class StorageClient {
    /**
     * Encoded URL string value.
     */
    url;
    accountName;
    /**
     * Request policy pipeline.
     *
     * @internal
     */
    pipeline;
    /**
     * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
     */
    credential;
    /**
     * StorageClient is a reference to protocol layer operations entry, which is
     * generated by AutoRest generator.
     */
    storageClientContext;
    /**
     */
    isHttps;
    /**
     * Creates an instance of StorageClient.
     * @param url - url to resource
     * @param pipeline - request policy pipeline.
     */
    constructor(url, pipeline2) {
      this.url = (0, utils_common_js_1.escapeURLPath)(url);
      this.accountName = (0, utils_common_js_1.getAccountNameFromUrl)(url);
      this.pipeline = pipeline2;
      this.storageClientContext = new StorageContextClient_js_1.StorageContextClient(this.url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline2));
      this.isHttps = (0, utils_common_js_1.iEqual)((0, utils_common_js_1.getURLScheme)(this.url) || "", "https");
      this.credential = (0, Pipeline_js_1.getCredentialFromPipeline)(pipeline2);
      const storageClientContext = this.storageClientContext;
      storageClientContext.requestContentType = void 0;
    }
  };
  StorageClient.StorageClient = StorageClient$1;
  return StorageClient;
}
var tracing = {};
var hasRequiredTracing;
function requireTracing() {
  if (hasRequiredTracing) return tracing;
  hasRequiredTracing = 1;
  Object.defineProperty(tracing, "__esModule", { value: true });
  tracing.tracingClient = void 0;
  const core_tracing_1 = /* @__PURE__ */ requireCommonjs$8();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  tracing.tracingClient = (0, core_tracing_1.createTracingClient)({
    packageName: "@azure/storage-blob",
    packageVersion: constants_js_1.SDK_VERSION,
    namespace: "Microsoft.Storage"
  });
  return tracing;
}
var BlobSASSignatureValues = {};
var BlobSASPermissions = {};
var hasRequiredBlobSASPermissions;
function requireBlobSASPermissions() {
  if (hasRequiredBlobSASPermissions) return BlobSASPermissions;
  hasRequiredBlobSASPermissions = 1;
  Object.defineProperty(BlobSASPermissions, "__esModule", { value: true });
  BlobSASPermissions.BlobSASPermissions = void 0;
  let BlobSASPermissions$1 = class BlobSASPermissions2 {
    /**
     * Creates a {@link BlobSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    static parse(permissions) {
      const blobSASPermissions = new BlobSASPermissions2();
      for (const char of permissions) {
        switch (char) {
          case "r":
            blobSASPermissions.read = true;
            break;
          case "a":
            blobSASPermissions.add = true;
            break;
          case "c":
            blobSASPermissions.create = true;
            break;
          case "w":
            blobSASPermissions.write = true;
            break;
          case "d":
            blobSASPermissions.delete = true;
            break;
          case "x":
            blobSASPermissions.deleteVersion = true;
            break;
          case "t":
            blobSASPermissions.tag = true;
            break;
          case "m":
            blobSASPermissions.move = true;
            break;
          case "e":
            blobSASPermissions.execute = true;
            break;
          case "i":
            blobSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            blobSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission: ${char}`);
        }
      }
      return blobSASPermissions;
    }
    /**
     * Creates a {@link BlobSASPermissions} from a raw object which contains same keys as it
     * and boolean values for them.
     *
     * @param permissionLike -
     */
    static from(permissionLike) {
      const blobSASPermissions = new BlobSASPermissions2();
      if (permissionLike.read) {
        blobSASPermissions.read = true;
      }
      if (permissionLike.add) {
        blobSASPermissions.add = true;
      }
      if (permissionLike.create) {
        blobSASPermissions.create = true;
      }
      if (permissionLike.write) {
        blobSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        blobSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        blobSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        blobSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        blobSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        blobSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        blobSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        blobSASPermissions.permanentDelete = true;
      }
      return blobSASPermissions;
    }
    /**
     * Specifies Read access granted.
     */
    read = false;
    /**
     * Specifies Add access granted.
     */
    add = false;
    /**
     * Specifies Create access granted.
     */
    create = false;
    /**
     * Specifies Write access granted.
     */
    write = false;
    /**
     * Specifies Delete access granted.
     */
    delete = false;
    /**
     * Specifies Delete version access granted.
     */
    deleteVersion = false;
    /**
     * Specfies Tag access granted.
     */
    tag = false;
    /**
     * Specifies Move access granted.
     */
    move = false;
    /**
     * Specifies Execute access granted.
     */
    execute = false;
    /**
     * Specifies SetImmutabilityPolicy access granted.
     */
    setImmutabilityPolicy = false;
    /**
     * Specifies that Permanent Delete is permitted.
     */
    permanentDelete = false;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns A string which represents the BlobSASPermissions
     */
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  };
  BlobSASPermissions.BlobSASPermissions = BlobSASPermissions$1;
  return BlobSASPermissions;
}
var ContainerSASPermissions = {};
var hasRequiredContainerSASPermissions;
function requireContainerSASPermissions() {
  if (hasRequiredContainerSASPermissions) return ContainerSASPermissions;
  hasRequiredContainerSASPermissions = 1;
  Object.defineProperty(ContainerSASPermissions, "__esModule", { value: true });
  ContainerSASPermissions.ContainerSASPermissions = void 0;
  let ContainerSASPermissions$1 = class ContainerSASPermissions2 {
    /**
     * Creates an {@link ContainerSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    static parse(permissions) {
      const containerSASPermissions = new ContainerSASPermissions2();
      for (const char of permissions) {
        switch (char) {
          case "r":
            containerSASPermissions.read = true;
            break;
          case "a":
            containerSASPermissions.add = true;
            break;
          case "c":
            containerSASPermissions.create = true;
            break;
          case "w":
            containerSASPermissions.write = true;
            break;
          case "d":
            containerSASPermissions.delete = true;
            break;
          case "l":
            containerSASPermissions.list = true;
            break;
          case "t":
            containerSASPermissions.tag = true;
            break;
          case "x":
            containerSASPermissions.deleteVersion = true;
            break;
          case "m":
            containerSASPermissions.move = true;
            break;
          case "e":
            containerSASPermissions.execute = true;
            break;
          case "i":
            containerSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            containerSASPermissions.permanentDelete = true;
            break;
          case "f":
            containerSASPermissions.filterByTags = true;
            break;
          default:
            throw new RangeError(`Invalid permission ${char}`);
        }
      }
      return containerSASPermissions;
    }
    /**
     * Creates a {@link ContainerSASPermissions} from a raw object which contains same keys as it
     * and boolean values for them.
     *
     * @param permissionLike -
     */
    static from(permissionLike) {
      const containerSASPermissions = new ContainerSASPermissions2();
      if (permissionLike.read) {
        containerSASPermissions.read = true;
      }
      if (permissionLike.add) {
        containerSASPermissions.add = true;
      }
      if (permissionLike.create) {
        containerSASPermissions.create = true;
      }
      if (permissionLike.write) {
        containerSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        containerSASPermissions.delete = true;
      }
      if (permissionLike.list) {
        containerSASPermissions.list = true;
      }
      if (permissionLike.deleteVersion) {
        containerSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        containerSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        containerSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        containerSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        containerSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        containerSASPermissions.permanentDelete = true;
      }
      if (permissionLike.filterByTags) {
        containerSASPermissions.filterByTags = true;
      }
      return containerSASPermissions;
    }
    /**
     * Specifies Read access granted.
     */
    read = false;
    /**
     * Specifies Add access granted.
     */
    add = false;
    /**
     * Specifies Create access granted.
     */
    create = false;
    /**
     * Specifies Write access granted.
     */
    write = false;
    /**
     * Specifies Delete access granted.
     */
    delete = false;
    /**
     * Specifies Delete version access granted.
     */
    deleteVersion = false;
    /**
     * Specifies List access granted.
     */
    list = false;
    /**
     * Specfies Tag access granted.
     */
    tag = false;
    /**
     * Specifies Move access granted.
     */
    move = false;
    /**
     * Specifies Execute access granted.
     */
    execute = false;
    /**
     * Specifies SetImmutabilityPolicy access granted.
     */
    setImmutabilityPolicy = false;
    /**
     * Specifies that Permanent Delete is permitted.
     */
    permanentDelete = false;
    /**
     * Specifies that Filter Blobs by Tags is permitted.
     */
    filterByTags = false;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     */
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      if (this.filterByTags) {
        permissions.push("f");
      }
      return permissions.join("");
    }
  };
  ContainerSASPermissions.ContainerSASPermissions = ContainerSASPermissions$1;
  return ContainerSASPermissions;
}
var UserDelegationKeyCredential = {};
var hasRequiredUserDelegationKeyCredential;
function requireUserDelegationKeyCredential() {
  if (hasRequiredUserDelegationKeyCredential) return UserDelegationKeyCredential;
  hasRequiredUserDelegationKeyCredential = 1;
  Object.defineProperty(UserDelegationKeyCredential, "__esModule", { value: true });
  UserDelegationKeyCredential.UserDelegationKeyCredential = void 0;
  const node_crypto_1 = require$$0$e;
  let UserDelegationKeyCredential$1 = class UserDelegationKeyCredential {
    /**
     * Azure Storage account name; readonly.
     */
    accountName;
    /**
     * Azure Storage user delegation key; readonly.
     */
    userDelegationKey;
    /**
     * Key value in Buffer type.
     */
    key;
    /**
     * Creates an instance of UserDelegationKeyCredential.
     * @param accountName -
     * @param userDelegationKey -
     */
    constructor(accountName, userDelegationKey) {
      this.accountName = accountName;
      this.userDelegationKey = userDelegationKey;
      this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
  };
  UserDelegationKeyCredential.UserDelegationKeyCredential = UserDelegationKeyCredential$1;
  return UserDelegationKeyCredential;
}
var SasIPRange = {};
var hasRequiredSasIPRange;
function requireSasIPRange() {
  if (hasRequiredSasIPRange) return SasIPRange;
  hasRequiredSasIPRange = 1;
  Object.defineProperty(SasIPRange, "__esModule", { value: true });
  SasIPRange.ipRangeToString = ipRangeToString;
  function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
  }
  return SasIPRange;
}
var SASQueryParameters = {};
var hasRequiredSASQueryParameters;
function requireSASQueryParameters() {
  if (hasRequiredSASQueryParameters) return SASQueryParameters;
  hasRequiredSASQueryParameters = 1;
  Object.defineProperty(SASQueryParameters, "__esModule", { value: true });
  SASQueryParameters.SASQueryParameters = SASQueryParameters.SASProtocol = void 0;
  const SasIPRange_js_1 = /* @__PURE__ */ requireSasIPRange();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  var SASProtocol;
  (function(SASProtocol2) {
    SASProtocol2["Https"] = "https";
    SASProtocol2["HttpsAndHttp"] = "https,http";
  })(SASProtocol || (SASQueryParameters.SASProtocol = SASProtocol = {}));
  let SASQueryParameters$1 = class SASQueryParameters {
    /**
     * The storage API version.
     */
    version;
    /**
     * Optional. The allowed HTTP protocol(s).
     */
    protocol;
    /**
     * Optional. The start time for this SAS token.
     */
    startsOn;
    /**
     * Optional only when identifier is provided. The expiry time for this SAS token.
     */
    expiresOn;
    /**
     * Optional only when identifier is provided.
     * Please refer to {@link AccountSASPermissions}, {@link BlobSASPermissions}, or {@link ContainerSASPermissions} for
     * more details.
     */
    permissions;
    /**
     * Optional. The storage services being accessed (only for Account SAS). Please refer to {@link AccountSASServices}
     * for more details.
     */
    services;
    /**
     * Optional. The storage resource types being accessed (only for Account SAS). Please refer to
     * {@link AccountSASResourceTypes} for more details.
     */
    resourceTypes;
    /**
     * Optional. The signed identifier (only for {@link BlobSASSignatureValues}).
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/establishing-a-stored-access-policy
     */
    identifier;
    /**
     * Optional. Encryption scope to use when sending requests authorized with this SAS URI.
     */
    encryptionScope;
    /**
     * Optional. Specifies which resources are accessible via the SAS (only for {@link BlobSASSignatureValues}).
     * @see https://learn.microsoft.com/rest/api/storageservices/create-service-sas#specifying-the-signed-resource-blob-service-only
     */
    resource;
    /**
     * The signature for the SAS token.
     */
    signature;
    /**
     * Value for cache-control header in Blob/File Service SAS.
     */
    cacheControl;
    /**
     * Value for content-disposition header in Blob/File Service SAS.
     */
    contentDisposition;
    /**
     * Value for content-encoding header in Blob/File Service SAS.
     */
    contentEncoding;
    /**
     * Value for content-length header in Blob/File Service SAS.
     */
    contentLanguage;
    /**
     * Value for content-type header in Blob/File Service SAS.
     */
    contentType;
    /**
     * Inner value of getter ipRange.
     */
    ipRangeInner;
    /**
     * The Azure Active Directory object ID in GUID format.
     * Property of user delegation key.
     */
    signedOid;
    /**
     * The Azure Active Directory tenant ID in GUID format.
     * Property of user delegation key.
     */
    signedTenantId;
    /**
     * The date-time the key is active.
     * Property of user delegation key.
     */
    signedStartsOn;
    /**
     * The date-time the key expires.
     * Property of user delegation key.
     */
    signedExpiresOn;
    /**
     * Abbreviation of the Azure Storage service that accepts the user delegation key.
     * Property of user delegation key.
     */
    signedService;
    /**
     * The service version that created the user delegation key.
     * Property of user delegation key.
     */
    signedVersion;
    /**
     * Authorized AAD Object ID in GUID format. The AAD Object ID of a user authorized by the owner of the User Delegation Key
     * to perform the action granted by the SAS. The Azure Storage service will ensure that the owner of the user delegation key
     * has the required permissions before granting access but no additional permission check for the user specified in
     * this value will be performed. This is only used for User Delegation SAS.
     */
    preauthorizedAgentObjectId;
    /**
     * A GUID value that will be logged in the storage diagnostic logs and can be used to correlate SAS generation with storage resource access.
     * This is only used for User Delegation SAS.
     */
    correlationId;
    /**
     * Optional. IP range allowed for this SAS.
     *
     * @readonly
     */
    get ipRange() {
      if (this.ipRangeInner) {
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
      }
      return void 0;
    }
    constructor(version2, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope) {
      this.version = version2;
      this.signature = signature;
      if (permissionsOrOptions !== void 0 && typeof permissionsOrOptions !== "string") {
        this.permissions = permissionsOrOptions.permissions;
        this.services = permissionsOrOptions.services;
        this.resourceTypes = permissionsOrOptions.resourceTypes;
        this.protocol = permissionsOrOptions.protocol;
        this.startsOn = permissionsOrOptions.startsOn;
        this.expiresOn = permissionsOrOptions.expiresOn;
        this.ipRangeInner = permissionsOrOptions.ipRange;
        this.identifier = permissionsOrOptions.identifier;
        this.encryptionScope = permissionsOrOptions.encryptionScope;
        this.resource = permissionsOrOptions.resource;
        this.cacheControl = permissionsOrOptions.cacheControl;
        this.contentDisposition = permissionsOrOptions.contentDisposition;
        this.contentEncoding = permissionsOrOptions.contentEncoding;
        this.contentLanguage = permissionsOrOptions.contentLanguage;
        this.contentType = permissionsOrOptions.contentType;
        if (permissionsOrOptions.userDelegationKey) {
          this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
          this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
          this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
          this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
          this.signedService = permissionsOrOptions.userDelegationKey.signedService;
          this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
          this.correlationId = permissionsOrOptions.correlationId;
        }
      } else {
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn;
        this.permissions = permissionsOrOptions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.encryptionScope = encryptionScope;
        this.identifier = identifier;
        this.resource = resource;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
        if (userDelegationKey) {
          this.signedOid = userDelegationKey.signedObjectId;
          this.signedTenantId = userDelegationKey.signedTenantId;
          this.signedStartsOn = userDelegationKey.signedStartsOn;
          this.signedExpiresOn = userDelegationKey.signedExpiresOn;
          this.signedService = userDelegationKey.signedService;
          this.signedVersion = userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
          this.correlationId = correlationId;
        }
      }
    }
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     */
    toString() {
      const params = [
        "sv",
        "ss",
        "srt",
        "spr",
        "st",
        "se",
        "sip",
        "si",
        "ses",
        "skoid",
        // Signed object ID
        "sktid",
        // Signed tenant ID
        "skt",
        // Signed key start time
        "ske",
        // Signed key expiry time
        "sks",
        // Signed key service
        "skv",
        // Signed key version
        "sr",
        "sp",
        "sig",
        "rscc",
        "rscd",
        "rsce",
        "rscl",
        "rsct",
        "saoid",
        "scid"
      ];
      const queries = [];
      for (const param of params) {
        switch (param) {
          case "sv":
            this.tryAppendQueryParameter(queries, param, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(queries, param, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(queries, param, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(queries, param, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(queries, param, this.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.startsOn, false) : void 0);
            break;
          case "se":
            this.tryAppendQueryParameter(queries, param, this.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.expiresOn, false) : void 0);
            break;
          case "sip":
            this.tryAppendQueryParameter(queries, param, this.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(this.ipRange) : void 0);
            break;
          case "si":
            this.tryAppendQueryParameter(queries, param, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(queries, param, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(queries, param, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(queries, param, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedStartsOn, false) : void 0);
            break;
          case "ske":
            this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedExpiresOn, false) : void 0);
            break;
          case "sks":
            this.tryAppendQueryParameter(queries, param, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(queries, param, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(queries, param, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(queries, param, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(queries, param, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(queries, param, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(queries, param, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(queries, param, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(queries, param, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(queries, param, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(queries, param, this.correlationId);
            break;
        }
      }
      return queries.join("&");
    }
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @param queries -
     * @param key -
     * @param value -
     */
    tryAppendQueryParameter(queries, key, value) {
      if (!value) {
        return;
      }
      key = encodeURIComponent(key);
      value = encodeURIComponent(value);
      if (key.length > 0 && value.length > 0) {
        queries.push(`${key}=${value}`);
      }
    }
  };
  SASQueryParameters.SASQueryParameters = SASQueryParameters$1;
  return SASQueryParameters;
}
var hasRequiredBlobSASSignatureValues;
function requireBlobSASSignatureValues() {
  if (hasRequiredBlobSASSignatureValues) return BlobSASSignatureValues;
  hasRequiredBlobSASSignatureValues = 1;
  Object.defineProperty(BlobSASSignatureValues, "__esModule", { value: true });
  BlobSASSignatureValues.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
  BlobSASSignatureValues.generateBlobSASQueryParametersInternal = generateBlobSASQueryParametersInternal;
  const BlobSASPermissions_js_1 = /* @__PURE__ */ requireBlobSASPermissions();
  const ContainerSASPermissions_js_1 = /* @__PURE__ */ requireContainerSASPermissions();
  const StorageSharedKeyCredential_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredential$1();
  const UserDelegationKeyCredential_js_1 = /* @__PURE__ */ requireUserDelegationKeyCredential();
  const SasIPRange_js_1 = /* @__PURE__ */ requireSasIPRange();
  const SASQueryParameters_js_1 = /* @__PURE__ */ requireSASQueryParameters();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
  }
  function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : void 0;
    let userDelegationKeyCredential;
    if (sharedKeyCredential === void 0 && accountName !== void 0) {
      userDelegationKeyCredential = new UserDelegationKeyCredential_js_1.UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === void 0 && userDelegationKeyCredential === void 0) {
      throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    if (version2 >= "2020-12-06") {
      if (sharedKeyCredential !== void 0) {
        return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version2 >= "2025-07-05") {
          return generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version2 >= "2018-11-09") {
      if (sharedKeyCredential !== void 0) {
        return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version2 >= "2020-02-10") {
          return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version2 >= "2015-04-05") {
      if (sharedKeyCredential !== void 0) {
        return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
      } else {
        throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
      }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
  }
  function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    if (blobSASSignatureValues.blobName) {
      resource = "b";
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, void 0, void 0, void 0, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      void 0,
      // agentObjectId
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      void 0,
      // agentObjectId
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      void 0,
      // agentObjectId
      blobSASSignatureValues.correlationId,
      void 0,
      // SignedKeyDelegatedUserTenantId, will be added in a future release.
      void 0,
      // SignedDelegatedUserObjectId, will be added in future release.
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function getCanonicalName(accountName, containerName, blobName) {
    const elements = [`/blob/${accountName}/${containerName}`];
    if (blobName) {
      elements.push(`/${blobName}`);
    }
    return elements.join("");
  }
  function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    if (blobSASSignatureValues.snapshotTime && version2 < "2018-11-09") {
      throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.snapshotTime) {
      throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.versionId && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.versionId) {
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    }
    if (version2 < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    }
    if (version2 < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
      throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    }
    if (version2 < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    }
    if (blobSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    blobSASSignatureValues.version = version2;
    return blobSASSignatureValues;
  }
  return BlobSASSignatureValues;
}
var BlobLeaseClient = {};
var hasRequiredBlobLeaseClient;
function requireBlobLeaseClient() {
  if (hasRequiredBlobLeaseClient) return BlobLeaseClient;
  hasRequiredBlobLeaseClient = 1;
  Object.defineProperty(BlobLeaseClient, "__esModule", { value: true });
  BlobLeaseClient.BlobLeaseClient = void 0;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const tracing_js_1 = /* @__PURE__ */ requireTracing();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  let BlobLeaseClient$1 = class BlobLeaseClient {
    _leaseId;
    _url;
    _containerOrBlobOperation;
    _isContainer;
    /**
     * Gets the lease Id.
     *
     * @readonly
     */
    get leaseId() {
      return this._leaseId;
    }
    /**
     * Gets the url.
     *
     * @readonly
     */
    get url() {
      return this._url;
    }
    /**
     * Creates an instance of BlobLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */
    constructor(client2, leaseId) {
      const clientContext = client2.storageClientContext;
      this._url = client2.url;
      if (client2.name === void 0) {
        this._isContainer = true;
        this._containerOrBlobOperation = clientContext.container;
      } else {
        this._isContainer = false;
        this._containerOrBlobOperation = clientContext.blob;
      }
      if (!leaseId) {
        leaseId = (0, core_util_1.randomUUID)();
      }
      this._leaseId = leaseId;
    }
    /**
     * Establishes and manages a lock on a container for delete operations, or on a blob
     * for write and delete operations.
     * The lock duration can be 15 to 60 seconds, or can be infinite.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param duration - Must be between 15 to 60 seconds, or infinite (-1)
     * @param options - option to configure lease management operations.
     * @returns Response data for acquire lease operation.
     */
    async acquireLease(duration, options2 = {}) {
      if (this._isContainer && (options2.conditions?.ifMatch && options2.conditions?.ifMatch !== constants_js_1.ETagNone || options2.conditions?.ifNoneMatch && options2.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options2.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-acquireLease", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.acquireLease({
          abortSignal: options2.abortSignal,
          duration,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          proposedLeaseId: this._leaseId,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * To change the ID of the lease.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - option to configure lease management operations.
     * @returns Response data for change lease operation.
     */
    async changeLease(proposedLeaseId, options2 = {}) {
      if (this._isContainer && (options2.conditions?.ifMatch && options2.conditions?.ifMatch !== constants_js_1.ETagNone || options2.conditions?.ifNoneMatch && options2.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options2.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-changeLease", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
          abortSignal: options2.abortSignal,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        this._leaseId = proposedLeaseId;
        return response2;
      });
    }
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease against the container or the blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param options - option to configure lease management operations.
     * @returns Response data for release lease operation.
     */
    async releaseLease(options2 = {}) {
      if (this._isContainer && (options2.conditions?.ifMatch && options2.conditions?.ifMatch !== constants_js_1.ETagNone || options2.conditions?.ifNoneMatch && options2.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options2.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-releaseLease", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
          abortSignal: options2.abortSignal,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * To renew the lease.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param options - Optional option to configure lease management operations.
     * @returns Response data for renew lease operation.
     */
    async renewLease(options2 = {}) {
      if (this._isContainer && (options2.conditions?.ifMatch && options2.conditions?.ifMatch !== constants_js_1.ETagNone || options2.conditions?.ifNoneMatch && options2.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options2.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-renewLease", options2, async (updatedOptions) => {
        return this._containerOrBlobOperation.renewLease(this._leaseId, {
          abortSignal: options2.abortSignal,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    /**
     * To end the lease but ensure that another client cannot acquire a new lease
     * until the current lease period has expired.
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-container
     * and
     * @see https://learn.microsoft.com/rest/api/storageservices/lease-blob
     *
     * @param breakPeriod - Break period
     * @param options - Optional options to configure lease management operations.
     * @returns Response data for break lease operation.
     */
    async breakLease(breakPeriod, options2 = {}) {
      if (this._isContainer && (options2.conditions?.ifMatch && options2.conditions?.ifMatch !== constants_js_1.ETagNone || options2.conditions?.ifNoneMatch && options2.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options2.conditions?.tagConditions)) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-breakLease", options2, async (updatedOptions) => {
        const operationOptions = {
          abortSignal: options2.abortSignal,
          breakPeriod,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        };
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.breakLease(operationOptions));
      });
    }
  };
  BlobLeaseClient.BlobLeaseClient = BlobLeaseClient$1;
  return BlobLeaseClient;
}
var Clients = {};
var BlobDownloadResponse = {};
var RetriableReadableStream = {};
var hasRequiredRetriableReadableStream;
function requireRetriableReadableStream() {
  if (hasRequiredRetriableReadableStream) return RetriableReadableStream;
  hasRequiredRetriableReadableStream = 1;
  Object.defineProperty(RetriableReadableStream, "__esModule", { value: true });
  RetriableReadableStream.RetriableReadableStream = void 0;
  const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
  const node_stream_1 = require$$0$b;
  let RetriableReadableStream$1 = class RetriableReadableStream extends node_stream_1.Readable {
    start;
    offset;
    end;
    getter;
    source;
    retries = 0;
    maxRetryRequests;
    onProgress;
    options;
    /**
     * Creates an instance of RetriableReadableStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param getter - A method calling downloading request returning
     *                                      a new ReadableStream from specified offset
     * @param offset - Offset position in original data source to read
     * @param count - How much data in original data source to read
     * @param options -
     */
    constructor(source, getter, offset, count, options2 = {}) {
      super({ highWaterMark: options2.highWaterMark });
      this.getter = getter;
      this.source = source;
      this.start = offset;
      this.offset = offset;
      this.end = offset + count - 1;
      this.maxRetryRequests = options2.maxRetryRequests && options2.maxRetryRequests >= 0 ? options2.maxRetryRequests : 0;
      this.onProgress = options2.onProgress;
      this.options = options2;
      this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler);
      this.source.on("end", this.sourceErrorOrEndHandler);
      this.source.on("error", this.sourceErrorOrEndHandler);
      this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler);
      this.source.removeListener("end", this.sourceErrorOrEndHandler);
      this.source.removeListener("error", this.sourceErrorOrEndHandler);
      this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    sourceDataHandler = (data) => {
      if (this.options.doInjectErrorOnce) {
        this.options.doInjectErrorOnce = void 0;
        this.source.pause();
        this.sourceErrorOrEndHandler();
        this.source.destroy();
        return;
      }
      this.offset += data.length;
      if (this.onProgress) {
        this.onProgress({ loadedBytes: this.offset - this.start });
      }
      if (!this.push(data)) {
        this.source.pause();
      }
    };
    sourceAbortedHandler = () => {
      const abortError = new abort_controller_1.AbortError("The operation was aborted.");
      this.destroy(abortError);
    };
    sourceErrorOrEndHandler = (err) => {
      if (err && err.name === "AbortError") {
        this.destroy(err);
        return;
      }
      this.removeSourceEventHandlers();
      if (this.offset - 1 === this.end) {
        this.push(null);
      } else if (this.offset <= this.end) {
        if (this.retries < this.maxRetryRequests) {
          this.retries += 1;
          this.getter(this.offset).then((newSource) => {
            this.source = newSource;
            this.setSourceEventHandlers();
            return;
          }).catch((error2) => {
            this.destroy(error2);
          });
        } else {
          this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
        }
      } else {
        this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
      }
    };
    _destroy(error2, callback) {
      this.removeSourceEventHandlers();
      this.source.destroy();
      callback(error2 === null ? void 0 : error2);
    }
  };
  RetriableReadableStream.RetriableReadableStream = RetriableReadableStream$1;
  return RetriableReadableStream;
}
var hasRequiredBlobDownloadResponse;
function requireBlobDownloadResponse() {
  if (hasRequiredBlobDownloadResponse) return BlobDownloadResponse;
  hasRequiredBlobDownloadResponse = 1;
  Object.defineProperty(BlobDownloadResponse, "__esModule", { value: true });
  BlobDownloadResponse.BlobDownloadResponse = void 0;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const RetriableReadableStream_js_1 = /* @__PURE__ */ requireRetriableReadableStream();
  let BlobDownloadResponse$1 = class BlobDownloadResponse {
    /**
     * Indicates that the service supports
     * requests for partial file content.
     *
     * @readonly
     */
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    /**
     * Returns if it was previously specified
     * for the file.
     *
     * @readonly
     */
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    /**
     * Returns the value that was specified
     * for the 'x-ms-content-disposition' header and specifies how to process the
     * response.
     *
     * @readonly
     */
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    /**
     * Returns the value that was specified
     * for the Content-Encoding request header.
     *
     * @readonly
     */
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    /**
     * Returns the value that was specified
     * for the Content-Language request header.
     *
     * @readonly
     */
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    /**
     * The current sequence number for a
     * page blob. This header is not returned for block blobs or append blobs.
     *
     * @readonly
     */
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    /**
     * The blob's type. Possible values include:
     * 'BlockBlob', 'PageBlob', 'AppendBlob'.
     *
     * @readonly
     */
    get blobType() {
      return this.originalResponse.blobType;
    }
    /**
     * The number of bytes present in the
     * response body.
     *
     * @readonly
     */
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    /**
     * If the file has an MD5 hash and the
     * request is to read the full file, this response header is returned so that
     * the client can check for message content integrity. If the request is to
     * read a specified range and the 'x-ms-range-get-content-md5' is set to
     * true, then the request returns an MD5 hash for the range, as long as the
     * range size is less than or equal to 4 MB. If neither of these sets of
     * conditions is true, then no value is returned for the 'Content-MD5'
     * header.
     *
     * @readonly
     */
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    /**
     * Indicates the range of bytes returned if
     * the client requested a subset of the file by setting the Range request
     * header.
     *
     * @readonly
     */
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    /**
     * The content type specified for the file.
     * The default content type is 'application/octet-stream'
     *
     * @readonly
     */
    get contentType() {
      return this.originalResponse.contentType;
    }
    /**
     * Conclusion time of the last attempted
     * Copy File operation where this file was the destination file. This value
     * can specify the time of a completed, aborted, or failed copy attempt.
     *
     * @readonly
     */
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    /**
     * String identifier for the last attempted Copy
     * File operation where this file was the destination file.
     *
     * @readonly
     */
    get copyId() {
      return this.originalResponse.copyId;
    }
    /**
     * Contains the number of bytes copied and
     * the total bytes in the source in the last attempted Copy File operation
     * where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     *
     * @readonly
     */
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    /**
     * URL up to 2KB in length that specifies the
     * source file used in the last attempted Copy File operation where this file
     * was the destination file.
     *
     * @readonly
     */
    get copySource() {
      return this.originalResponse.copySource;
    }
    /**
     * State of the copy operation
     * identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     *
     * @readonly
     */
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    /**
     * Only appears when
     * x-ms-copy-status is failed or pending. Describes cause of fatal or
     * non-fatal copy operation failure.
     *
     * @readonly
     */
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    /**
     * When a blob is leased,
     * specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'.
     *
     * @readonly
     */
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    /**
     * Lease state of the blob. Possible
     * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
     *
     * @readonly
     */
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    /**
     * The current lease status of the
     * blob. Possible values include: 'locked', 'unlocked'.
     *
     * @readonly
     */
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    /**
     * A UTC date/time value generated by the service that
     * indicates the time at which the response was initiated.
     *
     * @readonly
     */
    get date() {
      return this.originalResponse.date;
    }
    /**
     * The number of committed blocks
     * present in the blob. This header is returned only for append blobs.
     *
     * @readonly
     */
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    /**
     * The ETag contains a value that you can use to
     * perform operations conditionally, in quotes.
     *
     * @readonly
     */
    get etag() {
      return this.originalResponse.etag;
    }
    /**
     * The number of tags associated with the blob
     *
     * @readonly
     */
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    /**
     * The error code.
     *
     * @readonly
     */
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    /**
     * The value of this header is set to
     * true if the file data and application metadata are completely encrypted
     * using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata
     * are encrypted).
     *
     * @readonly
     */
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    /**
     * If the blob has a MD5 hash, and if
     * request contains range header (Range or x-ms-range), this response header
     * is returned with the value of the whole blob's MD5 value. This value may
     * or may not be equal to the value returned in Content-MD5 header, with the
     * latter calculated from the requested range.
     *
     * @readonly
     */
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    /**
     * Returns the date and time the file was last
     * modified. Any operation that modifies the file or its properties updates
     * the last modified time.
     *
     * @readonly
     */
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    /**
     * Returns the UTC date and time generated by the service that indicates the time at which the blob was
     * last read or written to.
     *
     * @readonly
     */
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    /**
     * Returns the date and time the blob was created.
     *
     * @readonly
     */
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    /**
     * A name-value pair
     * to associate with a file storage object.
     *
     * @readonly
     */
    get metadata() {
      return this.originalResponse.metadata;
    }
    /**
     * This header uniquely identifies the request
     * that was made and can be used for troubleshooting the request.
     *
     * @readonly
     */
    get requestId() {
      return this.originalResponse.requestId;
    }
    /**
     * If a client request id header is sent in the request, this header will be present in the
     * response with the same value.
     *
     * @readonly
     */
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    /**
     * Indicates the version of the Blob service used
     * to execute the request.
     *
     * @readonly
     */
    get version() {
      return this.originalResponse.version;
    }
    /**
     * Indicates the versionId of the downloaded blob version.
     *
     * @readonly
     */
    get versionId() {
      return this.originalResponse.versionId;
    }
    /**
     * Indicates whether version of this blob is a current version.
     *
     * @readonly
     */
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    /**
     * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
     * when the blob was encrypted with a customer-provided key.
     *
     * @readonly
     */
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    /**
     * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
     * true, then the request returns a crc64 for the range, as long as the range size is less than
     * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
     * specified in the same request, it will fail with 400(Bad Request)
     */
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    /**
     * Object Replication Policy Id of the destination blob.
     *
     * @readonly
     */
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    /**
     * Parsed Object Replication Policy Id, Rule Id(s) and status of the source blob.
     *
     * @readonly
     */
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    /**
     * If this blob has been sealed.
     *
     * @readonly
     */
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    /**
     * UTC date/time value generated by the service that indicates the time at which the blob immutability policy will expire.
     *
     * @readonly
     */
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    /**
     * Indicates immutability policy mode.
     *
     * @readonly
     */
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    /**
     * Indicates if a legal hold is present on the blob.
     *
     * @readonly
     */
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    /**
     * The response body as a browser Blob.
     * Always undefined in node.js.
     *
     * @readonly
     */
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    /**
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     *
     * It will automatically retry when internal read stream unexpected ends.
     *
     * @readonly
     */
    get readableStreamBody() {
      return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
    }
    /**
     * The HTTP response.
     */
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    /**
     * Creates an instance of BlobDownloadResponse.
     *
     * @param originalResponse -
     * @param getter -
     * @param offset -
     * @param count -
     * @param options -
     */
    constructor(originalResponse, getter, offset, count, options2 = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new RetriableReadableStream_js_1.RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options2);
    }
  };
  BlobDownloadResponse.BlobDownloadResponse = BlobDownloadResponse$1;
  return BlobDownloadResponse;
}
var BlobQueryResponse = {};
var BlobQuickQueryStream = {};
var internalAvro = {};
var AvroReader = {};
var AvroConstants = {};
var hasRequiredAvroConstants;
function requireAvroConstants() {
  if (hasRequiredAvroConstants) return AvroConstants;
  hasRequiredAvroConstants = 1;
  Object.defineProperty(AvroConstants, "__esModule", { value: true });
  AvroConstants.AVRO_SCHEMA_KEY = AvroConstants.AVRO_CODEC_KEY = AvroConstants.AVRO_INIT_BYTES = AvroConstants.AVRO_SYNC_MARKER_SIZE = void 0;
  AvroConstants.AVRO_SYNC_MARKER_SIZE = 16;
  AvroConstants.AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  AvroConstants.AVRO_CODEC_KEY = "avro.codec";
  AvroConstants.AVRO_SCHEMA_KEY = "avro.schema";
  return AvroConstants;
}
var AvroParser = {};
var hasRequiredAvroParser;
function requireAvroParser() {
  if (hasRequiredAvroParser) return AvroParser;
  hasRequiredAvroParser = 1;
  Object.defineProperty(AvroParser, "__esModule", { value: true });
  AvroParser.AvroType = AvroParser.AvroParser = void 0;
  let AvroParser$1 = class AvroParser2 {
    /**
     * Reads a fixed number of bytes from the stream.
     *
     * @param stream -
     * @param length -
     * @param options -
     */
    static async readFixedBytes(stream, length, options2 = {}) {
      const bytes = await stream.read(length, { abortSignal: options2.abortSignal });
      if (bytes.length !== length) {
        throw new Error("Hit stream end.");
      }
      return bytes;
    }
    /**
     * Reads a single byte from the stream.
     *
     * @param stream -
     * @param options -
     */
    static async readByte(stream, options2 = {}) {
      const buf = await AvroParser2.readFixedBytes(stream, 1, options2);
      return buf[0];
    }
    // int and long are stored in variable-length zig-zag coding.
    // variable-length: https://lucene.apache.org/core/3_5_0/fileformats.html#VInt
    // zig-zag: https://developers.google.com/protocol-buffers/docs/encoding?csw=1#types
    static async readZigZagLong(stream, options2 = {}) {
      let zigZagEncoded = 0;
      let significanceInBit = 0;
      let byte, haveMoreByte, significanceInFloat;
      do {
        byte = await AvroParser2.readByte(stream, options2);
        haveMoreByte = byte & 128;
        zigZagEncoded |= (byte & 127) << significanceInBit;
        significanceInBit += 7;
      } while (haveMoreByte && significanceInBit < 28);
      if (haveMoreByte) {
        zigZagEncoded = zigZagEncoded;
        significanceInFloat = 268435456;
        do {
          byte = await AvroParser2.readByte(stream, options2);
          zigZagEncoded += (byte & 127) * significanceInFloat;
          significanceInFloat *= 128;
        } while (byte & 128);
        const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
        if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
          throw new Error("Integer overflow.");
        }
        return res;
      }
      return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream, options2 = {}) {
      return AvroParser2.readZigZagLong(stream, options2);
    }
    static async readInt(stream, options2 = {}) {
      return AvroParser2.readZigZagLong(stream, options2);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(stream, options2 = {}) {
      const b = await AvroParser2.readByte(stream, options2);
      if (b === 1) {
        return true;
      } else if (b === 0) {
        return false;
      } else {
        throw new Error("Byte was not a boolean.");
      }
    }
    static async readFloat(stream, options2 = {}) {
      const u8arr = await AvroParser2.readFixedBytes(stream, 4, options2);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat32(0, true);
    }
    static async readDouble(stream, options2 = {}) {
      const u8arr = await AvroParser2.readFixedBytes(stream, 8, options2);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat64(0, true);
    }
    static async readBytes(stream, options2 = {}) {
      const size = await AvroParser2.readLong(stream, options2);
      if (size < 0) {
        throw new Error("Bytes size was negative.");
      }
      return stream.read(size, { abortSignal: options2.abortSignal });
    }
    static async readString(stream, options2 = {}) {
      const u8arr = await AvroParser2.readBytes(stream, options2);
      const utf8decoder = new TextDecoder();
      return utf8decoder.decode(u8arr);
    }
    static async readMapPair(stream, readItemMethod, options2 = {}) {
      const key = await AvroParser2.readString(stream, options2);
      const value = await readItemMethod(stream, options2);
      return { key, value };
    }
    static async readMap(stream, readItemMethod, options2 = {}) {
      const readPairMethod = (s, opts = {}) => {
        return AvroParser2.readMapPair(s, readItemMethod, opts);
      };
      const pairs = await AvroParser2.readArray(stream, readPairMethod, options2);
      const dict = {};
      for (const pair of pairs) {
        dict[pair.key] = pair.value;
      }
      return dict;
    }
    static async readArray(stream, readItemMethod, options2 = {}) {
      const items = [];
      for (let count = await AvroParser2.readLong(stream, options2); count !== 0; count = await AvroParser2.readLong(stream, options2)) {
        if (count < 0) {
          await AvroParser2.readLong(stream, options2);
          count = -count;
        }
        while (count--) {
          const item = await readItemMethod(stream, options2);
          items.push(item);
        }
      }
      return items;
    }
  };
  AvroParser.AvroParser = AvroParser$1;
  var AvroComplex;
  (function(AvroComplex2) {
    AvroComplex2["RECORD"] = "record";
    AvroComplex2["ENUM"] = "enum";
    AvroComplex2["ARRAY"] = "array";
    AvroComplex2["MAP"] = "map";
    AvroComplex2["UNION"] = "union";
    AvroComplex2["FIXED"] = "fixed";
  })(AvroComplex || (AvroComplex = {}));
  var AvroPrimitive;
  (function(AvroPrimitive2) {
    AvroPrimitive2["NULL"] = "null";
    AvroPrimitive2["BOOLEAN"] = "boolean";
    AvroPrimitive2["INT"] = "int";
    AvroPrimitive2["LONG"] = "long";
    AvroPrimitive2["FLOAT"] = "float";
    AvroPrimitive2["DOUBLE"] = "double";
    AvroPrimitive2["BYTES"] = "bytes";
    AvroPrimitive2["STRING"] = "string";
  })(AvroPrimitive || (AvroPrimitive = {}));
  class AvroType {
    /**
     * Determines the AvroType from the Avro Schema.
     */
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    static fromSchema(schema) {
      if (typeof schema === "string") {
        return AvroType.fromStringSchema(schema);
      } else if (Array.isArray(schema)) {
        return AvroType.fromArraySchema(schema);
      } else {
        return AvroType.fromObjectSchema(schema);
      }
    }
    static fromStringSchema(schema) {
      switch (schema) {
        case AvroPrimitive.NULL:
        case AvroPrimitive.BOOLEAN:
        case AvroPrimitive.INT:
        case AvroPrimitive.LONG:
        case AvroPrimitive.FLOAT:
        case AvroPrimitive.DOUBLE:
        case AvroPrimitive.BYTES:
        case AvroPrimitive.STRING:
          return new AvroPrimitiveType(schema);
        default:
          throw new Error(`Unexpected Avro type ${schema}`);
      }
    }
    static fromArraySchema(schema) {
      return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
      const type = schema.type;
      try {
        return AvroType.fromStringSchema(type);
      } catch {
      }
      switch (type) {
        case AvroComplex.RECORD:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.name) {
            throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
          }
          const fields = {};
          if (!schema.fields) {
            throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
          }
          for (const field of schema.fields) {
            fields[field.name] = AvroType.fromSchema(field.type);
          }
          return new AvroRecordType(fields, schema.name);
        case AvroComplex.ENUM:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.symbols) {
            throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
          }
          return new AvroEnumType(schema.symbols);
        case AvroComplex.MAP:
          if (!schema.values) {
            throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
          }
          return new AvroMapType(AvroType.fromSchema(schema.values));
        case AvroComplex.ARRAY:
        // Unused today
        case AvroComplex.FIXED:
        // Unused today
        default:
          throw new Error(`Unexpected Avro type ${type} in ${schema}`);
      }
    }
  }
  AvroParser.AvroType = AvroType;
  class AvroPrimitiveType extends AvroType {
    _primitive;
    constructor(primitive) {
      super();
      this._primitive = primitive;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    read(stream, options2 = {}) {
      switch (this._primitive) {
        case AvroPrimitive.NULL:
          return AvroParser$1.readNull();
        case AvroPrimitive.BOOLEAN:
          return AvroParser$1.readBoolean(stream, options2);
        case AvroPrimitive.INT:
          return AvroParser$1.readInt(stream, options2);
        case AvroPrimitive.LONG:
          return AvroParser$1.readLong(stream, options2);
        case AvroPrimitive.FLOAT:
          return AvroParser$1.readFloat(stream, options2);
        case AvroPrimitive.DOUBLE:
          return AvroParser$1.readDouble(stream, options2);
        case AvroPrimitive.BYTES:
          return AvroParser$1.readBytes(stream, options2);
        case AvroPrimitive.STRING:
          return AvroParser$1.readString(stream, options2);
        default:
          throw new Error("Unknown Avro Primitive");
      }
    }
  }
  class AvroEnumType extends AvroType {
    _symbols;
    constructor(symbols2) {
      super();
      this._symbols = symbols2;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    async read(stream, options2 = {}) {
      const value = await AvroParser$1.readInt(stream, options2);
      return this._symbols[value];
    }
  }
  class AvroUnionType extends AvroType {
    _types;
    constructor(types) {
      super();
      this._types = types;
    }
    async read(stream, options2 = {}) {
      const typeIndex = await AvroParser$1.readInt(stream, options2);
      return this._types[typeIndex].read(stream, options2);
    }
  }
  class AvroMapType extends AvroType {
    _itemType;
    constructor(itemType) {
      super();
      this._itemType = itemType;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    read(stream, options2 = {}) {
      const readItemMethod = (s, opts) => {
        return this._itemType.read(s, opts);
      };
      return AvroParser$1.readMap(stream, readItemMethod, options2);
    }
  }
  class AvroRecordType extends AvroType {
    _name;
    _fields;
    constructor(fields, name) {
      super();
      this._fields = fields;
      this._name = name;
    }
    // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
    async read(stream, options2 = {}) {
      const record = {};
      record["$schema"] = this._name;
      for (const key in this._fields) {
        if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
          record[key] = await this._fields[key].read(stream, options2);
        }
      }
      return record;
    }
  }
  return AvroParser;
}
var utils_common = {};
var hasRequiredUtils_common;
function requireUtils_common() {
  if (hasRequiredUtils_common) return utils_common;
  hasRequiredUtils_common = 1;
  Object.defineProperty(utils_common, "__esModule", { value: true });
  utils_common.arraysEqual = arraysEqual;
  function arraysEqual(a, b) {
    if (a === b)
      return true;
    if (a == null || b == null)
      return false;
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  return utils_common;
}
var hasRequiredAvroReader;
function requireAvroReader() {
  if (hasRequiredAvroReader) return AvroReader;
  hasRequiredAvroReader = 1;
  Object.defineProperty(AvroReader, "__esModule", { value: true });
  AvroReader.AvroReader = void 0;
  const AvroConstants_js_1 = /* @__PURE__ */ requireAvroConstants();
  const AvroParser_js_1 = /* @__PURE__ */ requireAvroParser();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common();
  let AvroReader$1 = class AvroReader {
    _dataStream;
    _headerStream;
    _syncMarker;
    _metadata;
    _itemType;
    _itemsRemainingInBlock;
    // Remembers where we started if partial data stream was provided.
    _initialBlockOffset;
    /// The byte offset within the Avro file (both header and data)
    /// of the start of the current block.
    _blockOffset;
    get blockOffset() {
      return this._blockOffset;
    }
    _objectIndex;
    get objectIndex() {
      return this._objectIndex;
    }
    _initialized;
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
      this._dataStream = dataStream;
      this._headerStream = headerStream || dataStream;
      this._initialized = false;
      this._blockOffset = currentBlockOffset || 0;
      this._objectIndex = indexWithinCurrentBlock || 0;
      this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options2 = {}) {
      const header = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_INIT_BYTES.length, {
        abortSignal: options2.abortSignal
      });
      if (!(0, utils_common_js_1.arraysEqual)(header, AvroConstants_js_1.AVRO_INIT_BYTES)) {
        throw new Error("Stream is not an Avro file.");
      }
      this._metadata = await AvroParser_js_1.AvroParser.readMap(this._headerStream, AvroParser_js_1.AvroParser.readString, {
        abortSignal: options2.abortSignal
      });
      const codec = this._metadata[AvroConstants_js_1.AVRO_CODEC_KEY];
      if (!(codec === void 0 || codec === null || codec === "null")) {
        throw new Error("Codecs are not supported");
      }
      this._syncMarker = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
        abortSignal: options2.abortSignal
      });
      const schema = JSON.parse(this._metadata[AvroConstants_js_1.AVRO_SCHEMA_KEY]);
      this._itemType = AvroParser_js_1.AvroType.fromSchema(schema);
      if (this._blockOffset === 0) {
        this._blockOffset = this._initialBlockOffset + this._dataStream.position;
      }
      this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
        abortSignal: options2.abortSignal
      });
      await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options2.abortSignal });
      this._initialized = true;
      if (this._objectIndex && this._objectIndex > 0) {
        for (let i = 0; i < this._objectIndex; i++) {
          await this._itemType.read(this._dataStream, { abortSignal: options2.abortSignal });
          this._itemsRemainingInBlock--;
        }
      }
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    async *parseObjects(options2 = {}) {
      if (!this._initialized) {
        await this.initialize(options2);
      }
      while (this.hasNext()) {
        const result = await this._itemType.read(this._dataStream, {
          abortSignal: options2.abortSignal
        });
        this._itemsRemainingInBlock--;
        this._objectIndex++;
        if (this._itemsRemainingInBlock === 0) {
          const marker = await AvroParser_js_1.AvroParser.readFixedBytes(this._dataStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
            abortSignal: options2.abortSignal
          });
          this._blockOffset = this._initialBlockOffset + this._dataStream.position;
          this._objectIndex = 0;
          if (!(0, utils_common_js_1.arraysEqual)(this._syncMarker, marker)) {
            throw new Error("Stream is not a valid Avro file.");
          }
          try {
            this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
              abortSignal: options2.abortSignal
            });
          } catch {
            this._itemsRemainingInBlock = 0;
          }
          if (this._itemsRemainingInBlock > 0) {
            await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options2.abortSignal });
          }
        }
        yield result;
      }
    }
  };
  AvroReader.AvroReader = AvroReader$1;
  return AvroReader;
}
var AvroReadable = {};
var hasRequiredAvroReadable;
function requireAvroReadable() {
  if (hasRequiredAvroReadable) return AvroReadable;
  hasRequiredAvroReadable = 1;
  Object.defineProperty(AvroReadable, "__esModule", { value: true });
  AvroReadable.AvroReadable = void 0;
  let AvroReadable$1 = class AvroReadable {
  };
  AvroReadable.AvroReadable = AvroReadable$1;
  return AvroReadable;
}
var AvroReadableFromStream = {};
var hasRequiredAvroReadableFromStream;
function requireAvroReadableFromStream() {
  if (hasRequiredAvroReadableFromStream) return AvroReadableFromStream;
  hasRequiredAvroReadableFromStream = 1;
  Object.defineProperty(AvroReadableFromStream, "__esModule", { value: true });
  AvroReadableFromStream.AvroReadableFromStream = void 0;
  const AvroReadable_js_1 = /* @__PURE__ */ requireAvroReadable();
  const abort_controller_1 = /* @__PURE__ */ requireCommonjs$a();
  const buffer_1 = require$$7;
  const ABORT_ERROR = new abort_controller_1.AbortError("Reading from the avro stream was aborted.");
  let AvroReadableFromStream$1 = class AvroReadableFromStream extends AvroReadable_js_1.AvroReadable {
    _position;
    _readable;
    toUint8Array(data) {
      if (typeof data === "string") {
        return buffer_1.Buffer.from(data);
      }
      return data;
    }
    constructor(readable2) {
      super();
      this._readable = readable2;
      this._position = 0;
    }
    get position() {
      return this._position;
    }
    async read(size, options2 = {}) {
      if (options2.abortSignal?.aborted) {
        throw ABORT_ERROR;
      }
      if (size < 0) {
        throw new Error(`size parameter should be positive: ${size}`);
      }
      if (size === 0) {
        return new Uint8Array();
      }
      if (!this._readable.readable) {
        throw new Error("Stream no longer readable.");
      }
      const chunk = this._readable.read(size);
      if (chunk) {
        this._position += chunk.length;
        return this.toUint8Array(chunk);
      } else {
        return new Promise((resolve, reject) => {
          const cleanUp = () => {
            this._readable.removeListener("readable", readableCallback);
            this._readable.removeListener("error", rejectCallback);
            this._readable.removeListener("end", rejectCallback);
            this._readable.removeListener("close", rejectCallback);
            if (options2.abortSignal) {
              options2.abortSignal.removeEventListener("abort", abortHandler);
            }
          };
          const readableCallback = () => {
            const callbackChunk = this._readable.read(size);
            if (callbackChunk) {
              this._position += callbackChunk.length;
              cleanUp();
              resolve(this.toUint8Array(callbackChunk));
            }
          };
          const rejectCallback = () => {
            cleanUp();
            reject();
          };
          const abortHandler = () => {
            cleanUp();
            reject(ABORT_ERROR);
          };
          this._readable.on("readable", readableCallback);
          this._readable.once("error", rejectCallback);
          this._readable.once("end", rejectCallback);
          this._readable.once("close", rejectCallback);
          if (options2.abortSignal) {
            options2.abortSignal.addEventListener("abort", abortHandler);
          }
        });
      }
    }
  };
  AvroReadableFromStream.AvroReadableFromStream = AvroReadableFromStream$1;
  return AvroReadableFromStream;
}
var hasRequiredInternalAvro;
function requireInternalAvro() {
  if (hasRequiredInternalAvro) return internalAvro;
  hasRequiredInternalAvro = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AvroReadableFromStream = exports.AvroReadable = exports.AvroReader = void 0;
    var AvroReader_js_1 = /* @__PURE__ */ requireAvroReader();
    Object.defineProperty(exports, "AvroReader", { enumerable: true, get: function() {
      return AvroReader_js_1.AvroReader;
    } });
    var AvroReadable_js_1 = /* @__PURE__ */ requireAvroReadable();
    Object.defineProperty(exports, "AvroReadable", { enumerable: true, get: function() {
      return AvroReadable_js_1.AvroReadable;
    } });
    var AvroReadableFromStream_js_1 = /* @__PURE__ */ requireAvroReadableFromStream();
    Object.defineProperty(exports, "AvroReadableFromStream", { enumerable: true, get: function() {
      return AvroReadableFromStream_js_1.AvroReadableFromStream;
    } });
  })(internalAvro);
  return internalAvro;
}
var hasRequiredBlobQuickQueryStream;
function requireBlobQuickQueryStream() {
  if (hasRequiredBlobQuickQueryStream) return BlobQuickQueryStream;
  hasRequiredBlobQuickQueryStream = 1;
  Object.defineProperty(BlobQuickQueryStream, "__esModule", { value: true });
  BlobQuickQueryStream.BlobQuickQueryStream = void 0;
  const node_stream_1 = require$$0$b;
  const index_js_1 = /* @__PURE__ */ requireInternalAvro();
  let BlobQuickQueryStream$1 = class BlobQuickQueryStream extends node_stream_1.Readable {
    source;
    avroReader;
    avroIter;
    avroPaused = true;
    onProgress;
    onError;
    /**
     * Creates an instance of BlobQuickQueryStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param options -
     */
    constructor(source, options2 = {}) {
      super();
      this.source = source;
      this.onProgress = options2.onProgress;
      this.onError = options2.onError;
      this.avroReader = new index_js_1.AvroReader(new index_js_1.AvroReadableFromStream(this.source));
      this.avroIter = this.avroReader.parseObjects({ abortSignal: options2.abortSignal });
    }
    _read() {
      if (this.avroPaused) {
        this.readInternal().catch((err) => {
          this.emit("error", err);
        });
      }
    }
    async readInternal() {
      this.avroPaused = false;
      let avroNext;
      do {
        avroNext = await this.avroIter.next();
        if (avroNext.done) {
          break;
        }
        const obj = avroNext.value;
        const schema = obj.$schema;
        if (typeof schema !== "string") {
          throw Error("Missing schema in avro record.");
        }
        switch (schema) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              const data = obj.data;
              if (data instanceof Uint8Array === false) {
                throw Error("Invalid data in avro result record.");
              }
              if (!this.push(Buffer.from(data))) {
                this.avroPaused = true;
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              const bytesScanned = obj.bytesScanned;
              if (typeof bytesScanned !== "number") {
                throw Error("Invalid bytesScanned in avro progress record.");
              }
              if (this.onProgress) {
                this.onProgress({ loadedBytes: bytesScanned });
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              const totalBytes = obj.totalBytes;
              if (typeof totalBytes !== "number") {
                throw Error("Invalid totalBytes in avro end record.");
              }
              this.onProgress({ loadedBytes: totalBytes });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              const fatal = obj.fatal;
              if (typeof fatal !== "boolean") {
                throw Error("Invalid fatal in avro error record.");
              }
              const name = obj.name;
              if (typeof name !== "string") {
                throw Error("Invalid name in avro error record.");
              }
              const description = obj.description;
              if (typeof description !== "string") {
                throw Error("Invalid description in avro error record.");
              }
              const position = obj.position;
              if (typeof position !== "number") {
                throw Error("Invalid position in avro error record.");
              }
              this.onError({
                position,
                name,
                isFatal: fatal,
                description
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${schema} in avro progress record.`);
        }
      } while (!avroNext.done && !this.avroPaused);
    }
  };
  BlobQuickQueryStream.BlobQuickQueryStream = BlobQuickQueryStream$1;
  return BlobQuickQueryStream;
}
var hasRequiredBlobQueryResponse;
function requireBlobQueryResponse() {
  if (hasRequiredBlobQueryResponse) return BlobQueryResponse;
  hasRequiredBlobQueryResponse = 1;
  Object.defineProperty(BlobQueryResponse, "__esModule", { value: true });
  BlobQueryResponse.BlobQueryResponse = void 0;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const BlobQuickQueryStream_js_1 = /* @__PURE__ */ requireBlobQuickQueryStream();
  let BlobQueryResponse$1 = class BlobQueryResponse {
    /**
     * Indicates that the service supports
     * requests for partial file content.
     *
     * @readonly
     */
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    /**
     * Returns if it was previously specified
     * for the file.
     *
     * @readonly
     */
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    /**
     * Returns the value that was specified
     * for the 'x-ms-content-disposition' header and specifies how to process the
     * response.
     *
     * @readonly
     */
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    /**
     * Returns the value that was specified
     * for the Content-Encoding request header.
     *
     * @readonly
     */
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    /**
     * Returns the value that was specified
     * for the Content-Language request header.
     *
     * @readonly
     */
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    /**
     * The current sequence number for a
     * page blob. This header is not returned for block blobs or append blobs.
     *
     * @readonly
     */
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    /**
     * The blob's type. Possible values include:
     * 'BlockBlob', 'PageBlob', 'AppendBlob'.
     *
     * @readonly
     */
    get blobType() {
      return this.originalResponse.blobType;
    }
    /**
     * The number of bytes present in the
     * response body.
     *
     * @readonly
     */
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    /**
     * If the file has an MD5 hash and the
     * request is to read the full file, this response header is returned so that
     * the client can check for message content integrity. If the request is to
     * read a specified range and the 'x-ms-range-get-content-md5' is set to
     * true, then the request returns an MD5 hash for the range, as long as the
     * range size is less than or equal to 4 MB. If neither of these sets of
     * conditions is true, then no value is returned for the 'Content-MD5'
     * header.
     *
     * @readonly
     */
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    /**
     * Indicates the range of bytes returned if
     * the client requested a subset of the file by setting the Range request
     * header.
     *
     * @readonly
     */
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    /**
     * The content type specified for the file.
     * The default content type is 'application/octet-stream'
     *
     * @readonly
     */
    get contentType() {
      return this.originalResponse.contentType;
    }
    /**
     * Conclusion time of the last attempted
     * Copy File operation where this file was the destination file. This value
     * can specify the time of a completed, aborted, or failed copy attempt.
     *
     * @readonly
     */
    get copyCompletedOn() {
      return void 0;
    }
    /**
     * String identifier for the last attempted Copy
     * File operation where this file was the destination file.
     *
     * @readonly
     */
    get copyId() {
      return this.originalResponse.copyId;
    }
    /**
     * Contains the number of bytes copied and
     * the total bytes in the source in the last attempted Copy File operation
     * where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     *
     * @readonly
     */
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    /**
     * URL up to 2KB in length that specifies the
     * source file used in the last attempted Copy File operation where this file
     * was the destination file.
     *
     * @readonly
     */
    get copySource() {
      return this.originalResponse.copySource;
    }
    /**
     * State of the copy operation
     * identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     *
     * @readonly
     */
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    /**
     * Only appears when
     * x-ms-copy-status is failed or pending. Describes cause of fatal or
     * non-fatal copy operation failure.
     *
     * @readonly
     */
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    /**
     * When a blob is leased,
     * specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'.
     *
     * @readonly
     */
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    /**
     * Lease state of the blob. Possible
     * values include: 'available', 'leased', 'expired', 'breaking', 'broken'.
     *
     * @readonly
     */
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    /**
     * The current lease status of the
     * blob. Possible values include: 'locked', 'unlocked'.
     *
     * @readonly
     */
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    /**
     * A UTC date/time value generated by the service that
     * indicates the time at which the response was initiated.
     *
     * @readonly
     */
    get date() {
      return this.originalResponse.date;
    }
    /**
     * The number of committed blocks
     * present in the blob. This header is returned only for append blobs.
     *
     * @readonly
     */
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    /**
     * The ETag contains a value that you can use to
     * perform operations conditionally, in quotes.
     *
     * @readonly
     */
    get etag() {
      return this.originalResponse.etag;
    }
    /**
     * The error code.
     *
     * @readonly
     */
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    /**
     * The value of this header is set to
     * true if the file data and application metadata are completely encrypted
     * using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata
     * are encrypted).
     *
     * @readonly
     */
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    /**
     * If the blob has a MD5 hash, and if
     * request contains range header (Range or x-ms-range), this response header
     * is returned with the value of the whole blob's MD5 value. This value may
     * or may not be equal to the value returned in Content-MD5 header, with the
     * latter calculated from the requested range.
     *
     * @readonly
     */
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    /**
     * Returns the date and time the file was last
     * modified. Any operation that modifies the file or its properties updates
     * the last modified time.
     *
     * @readonly
     */
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    /**
     * A name-value pair
     * to associate with a file storage object.
     *
     * @readonly
     */
    get metadata() {
      return this.originalResponse.metadata;
    }
    /**
     * This header uniquely identifies the request
     * that was made and can be used for troubleshooting the request.
     *
     * @readonly
     */
    get requestId() {
      return this.originalResponse.requestId;
    }
    /**
     * If a client request id header is sent in the request, this header will be present in the
     * response with the same value.
     *
     * @readonly
     */
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    /**
     * Indicates the version of the File service used
     * to execute the request.
     *
     * @readonly
     */
    get version() {
      return this.originalResponse.version;
    }
    /**
     * The SHA-256 hash of the encryption key used to encrypt the blob. This value is only returned
     * when the blob was encrypted with a customer-provided key.
     *
     * @readonly
     */
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    /**
     * If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to
     * true, then the request returns a crc64 for the range, as long as the range size is less than
     * or equal to 4 MB. If both x-ms-range-get-content-crc64 & x-ms-range-get-content-md5 is
     * specified in the same request, it will fail with 400(Bad Request)
     */
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    /**
     * The response body as a browser Blob.
     * Always undefined in node.js.
     *
     * @readonly
     */
    get blobBody() {
      return void 0;
    }
    /**
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     *
     * It will parse avor data returned by blob query.
     *
     * @readonly
     */
    get readableStreamBody() {
      return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
    }
    /**
     * The HTTP response.
     */
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    /**
     * Creates an instance of BlobQueryResponse.
     *
     * @param originalResponse -
     * @param options -
     */
    constructor(originalResponse, options2 = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new BlobQuickQueryStream_js_1.BlobQuickQueryStream(this.originalResponse.readableStreamBody, options2);
    }
  };
  BlobQueryResponse.BlobQueryResponse = BlobQueryResponse$1;
  return BlobQueryResponse;
}
var models = {};
var hasRequiredModels;
function requireModels() {
  if (hasRequiredModels) return models;
  hasRequiredModels = 1;
  Object.defineProperty(models, "__esModule", { value: true });
  models.StorageBlobAudience = models.PremiumPageBlobTier = models.BlockBlobTier = void 0;
  models.toAccessTier = toAccessTier;
  models.ensureCpkIfSpecified = ensureCpkIfSpecified;
  models.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  var BlockBlobTier;
  (function(BlockBlobTier2) {
    BlockBlobTier2["Hot"] = "Hot";
    BlockBlobTier2["Cool"] = "Cool";
    BlockBlobTier2["Cold"] = "Cold";
    BlockBlobTier2["Archive"] = "Archive";
  })(BlockBlobTier || (models.BlockBlobTier = BlockBlobTier = {}));
  var PremiumPageBlobTier;
  (function(PremiumPageBlobTier2) {
    PremiumPageBlobTier2["P4"] = "P4";
    PremiumPageBlobTier2["P6"] = "P6";
    PremiumPageBlobTier2["P10"] = "P10";
    PremiumPageBlobTier2["P15"] = "P15";
    PremiumPageBlobTier2["P20"] = "P20";
    PremiumPageBlobTier2["P30"] = "P30";
    PremiumPageBlobTier2["P40"] = "P40";
    PremiumPageBlobTier2["P50"] = "P50";
    PremiumPageBlobTier2["P60"] = "P60";
    PremiumPageBlobTier2["P70"] = "P70";
    PremiumPageBlobTier2["P80"] = "P80";
  })(PremiumPageBlobTier || (models.PremiumPageBlobTier = PremiumPageBlobTier = {}));
  function toAccessTier(tier) {
    if (tier === void 0) {
      return void 0;
    }
    return tier;
  }
  function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps) {
      throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
    }
    if (cpk && !cpk.encryptionAlgorithm) {
      cpk.encryptionAlgorithm = constants_js_1.EncryptionAlgorithmAES25;
    }
  }
  var StorageBlobAudience;
  (function(StorageBlobAudience2) {
    StorageBlobAudience2["StorageOAuthScopes"] = "https://storage.azure.com/.default";
    StorageBlobAudience2["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
  })(StorageBlobAudience || (models.StorageBlobAudience = StorageBlobAudience = {}));
  function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
  }
  return models;
}
var PageBlobRangeResponse = {};
var hasRequiredPageBlobRangeResponse;
function requirePageBlobRangeResponse() {
  if (hasRequiredPageBlobRangeResponse) return PageBlobRangeResponse;
  hasRequiredPageBlobRangeResponse = 1;
  Object.defineProperty(PageBlobRangeResponse, "__esModule", { value: true });
  PageBlobRangeResponse.rangeResponseFromModel = rangeResponseFromModel;
  function rangeResponseFromModel(response2) {
    const pageRange = (response2._response.parsedBody.pageRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    const clearRange = (response2._response.parsedBody.clearRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    return {
      ...response2,
      pageRange,
      clearRange,
      _response: {
        ...response2._response,
        parsedBody: {
          pageRange,
          clearRange
        }
      }
    };
  }
  return PageBlobRangeResponse;
}
var BlobStartCopyFromUrlPoller = {};
var commonjs = {};
var poller$2 = {};
var operation$2 = {};
var operation$1 = {};
var logger = {};
var hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return logger;
  hasRequiredLogger = 1;
  Object.defineProperty(logger, "__esModule", { value: true });
  logger.logger = void 0;
  const logger_1 = /* @__PURE__ */ requireCommonjs$b();
  logger.logger = (0, logger_1.createClientLogger)("core-lro");
  return logger;
}
var constants = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", { value: true });
  constants.terminalStates = constants.POLL_INTERVAL_IN_MS = void 0;
  constants.POLL_INTERVAL_IN_MS = 2e3;
  constants.terminalStates = ["succeeded", "canceled", "failed"];
  return constants;
}
var hasRequiredOperation$2;
function requireOperation$2() {
  if (hasRequiredOperation$2) return operation$1;
  hasRequiredOperation$2 = 1;
  Object.defineProperty(operation$1, "__esModule", { value: true });
  operation$1.pollOperation = operation$1.initOperation = operation$1.deserializeState = void 0;
  const logger_js_1 = /* @__PURE__ */ requireLogger();
  const constants_js_1 = /* @__PURE__ */ requireConstants();
  function deserializeState(serializedState) {
    try {
      return JSON.parse(serializedState).state;
    } catch (e) {
      throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
  }
  operation$1.deserializeState = deserializeState;
  function setStateError(inputs) {
    const { state: state2, stateProxy, isOperationError } = inputs;
    return (error2) => {
      if (isOperationError(error2)) {
        stateProxy.setError(state2, error2);
        stateProxy.setFailed(state2);
      }
      throw error2;
    };
  }
  function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
      message = message + ".";
    }
    return message + " " + innerMessage;
  }
  function simplifyError(err) {
    let message = err.message;
    let code = err.code;
    let curErr = err;
    while (curErr.innererror) {
      curErr = curErr.innererror;
      code = curErr.code;
      message = appendReadableErrorMessage(message, curErr.message);
    }
    return {
      code,
      message
    };
  }
  function processOperationStatus(result) {
    const { state: state2, stateProxy, status, isDone, processResult, getError, response: response2, setErrorAsResult } = result;
    switch (status) {
      case "succeeded": {
        stateProxy.setSucceeded(state2);
        break;
      }
      case "failed": {
        const err = getError === null || getError === void 0 ? void 0 : getError(response2);
        let postfix = "";
        if (err) {
          const { code, message } = simplifyError(err);
          postfix = `. ${code}. ${message}`;
        }
        const errStr = `The long-running operation has failed${postfix}`;
        stateProxy.setError(state2, new Error(errStr));
        stateProxy.setFailed(state2);
        logger_js_1.logger.warning(errStr);
        break;
      }
      case "canceled": {
        stateProxy.setCanceled(state2);
        break;
      }
    }
    if ((isDone === null || isDone === void 0 ? void 0 : isDone(response2, state2)) || isDone === void 0 && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
      stateProxy.setResult(state2, buildResult({
        response: response2,
        state: state2,
        processResult
      }));
    }
  }
  function buildResult(inputs) {
    const { processResult, response: response2, state: state2 } = inputs;
    return processResult ? processResult(response2, state2) : response2;
  }
  async function initOperation(inputs) {
    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
    const { operationLocation, resourceLocation, metadata, response: response2 } = await init();
    if (operationLocation)
      withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
    const config2 = {
      metadata,
      operationLocation,
      resourceLocation
    };
    logger_js_1.logger.verbose(`LRO: Operation description:`, config2);
    const state2 = stateProxy.initState(config2);
    const status = getOperationStatus({ response: response2, state: state2, operationLocation });
    processOperationStatus({ state: state2, status, stateProxy, response: response2, setErrorAsResult, processResult });
    return state2;
  }
  operation$1.initOperation = initOperation;
  async function pollOperationHelper(inputs) {
    const { poll, state: state2, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options: options2 } = inputs;
    const response2 = await poll(operationLocation, options2).catch(setStateError({
      state: state2,
      stateProxy,
      isOperationError
    }));
    const status = getOperationStatus(response2, state2);
    logger_js_1.logger.verbose(`LRO: Status:
	Polling from: ${state2.config.operationLocation}
	Operation status: ${status}
	Polling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
    if (status === "succeeded") {
      const resourceLocation = getResourceLocation(response2, state2);
      if (resourceLocation !== void 0) {
        return {
          response: await poll(resourceLocation).catch(setStateError({ state: state2, stateProxy, isOperationError })),
          status
        };
      }
    }
    return { response: response2, status };
  }
  async function pollOperation2(inputs) {
    const { poll, state: state2, stateProxy, options: options2, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
    const { operationLocation } = state2.config;
    if (operationLocation !== void 0) {
      const { response: response2, status } = await pollOperationHelper({
        poll,
        getOperationStatus,
        state: state2,
        stateProxy,
        operationLocation,
        getResourceLocation,
        isOperationError,
        options: options2
      });
      processOperationStatus({
        status,
        response: response2,
        state: state2,
        stateProxy,
        isDone,
        processResult,
        getError,
        setErrorAsResult
      });
      if (!constants_js_1.terminalStates.includes(status)) {
        const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response2);
        if (intervalInMs)
          setDelay(intervalInMs);
        const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response2, state2);
        if (location !== void 0) {
          const isUpdated = operationLocation !== location;
          state2.config.operationLocation = location;
          withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);
        } else
          withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
      }
      updateState === null || updateState === void 0 ? void 0 : updateState(state2, response2);
    }
  }
  operation$1.pollOperation = pollOperation2;
  return operation$1;
}
var hasRequiredOperation$1;
function requireOperation$1() {
  if (hasRequiredOperation$1) return operation$2;
  hasRequiredOperation$1 = 1;
  Object.defineProperty(operation$2, "__esModule", { value: true });
  operation$2.pollHttpOperation = operation$2.isOperationError = operation$2.getResourceLocation = operation$2.getOperationStatus = operation$2.getOperationLocation = operation$2.initHttpOperation = operation$2.getStatusFromInitialResponse = operation$2.getErrorFromResponse = operation$2.parseRetryAfter = operation$2.inferLroMode = void 0;
  const operation_js_1 = /* @__PURE__ */ requireOperation$2();
  const logger_js_1 = /* @__PURE__ */ requireLogger();
  function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
  }
  function getLocationHeader(rawResponse) {
    return rawResponse.headers["location"];
  }
  function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
  }
  function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
  }
  function findResourceLocation(inputs) {
    var _a;
    const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
      case "PUT": {
        return requestPath;
      }
      case "DELETE": {
        return void 0;
      }
      case "PATCH": {
        return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;
      }
      default: {
        return getDefault();
      }
    }
    function getDefault() {
      switch (resourceLocationConfig) {
        case "azure-async-operation": {
          return void 0;
        }
        case "original-uri": {
          return requestPath;
        }
        case "location":
        default: {
          return location;
        }
      }
    }
  }
  function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
    const operationLocation = getOperationLocationHeader(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
    const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
    const location = getLocationHeader(rawResponse);
    const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== void 0) {
      return {
        mode: "OperationLocation",
        operationLocation: pollingUrl,
        resourceLocation: findResourceLocation({
          requestMethod: normalizedRequestMethod,
          location,
          requestPath,
          resourceLocationConfig
        })
      };
    } else if (location !== void 0) {
      return {
        mode: "ResourceLocation",
        operationLocation: location
      };
    } else if (normalizedRequestMethod === "PUT" && requestPath) {
      return {
        mode: "Body",
        operationLocation: requestPath
      };
    } else {
      return void 0;
    }
  }
  operation$2.inferLroMode = inferLroMode;
  function transformStatus(inputs) {
    const { status, statusCode } = inputs;
    if (typeof status !== "string" && status !== void 0) {
      throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
    }
    switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {
      case void 0:
        return toOperationStatus(statusCode);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default: {
        logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
        return status;
      }
    }
  }
  function getStatus(rawResponse) {
    var _a;
    const { status } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function getProvisioningState(rawResponse) {
    var _a, _b;
    const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    const status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function toOperationStatus(statusCode) {
    if (statusCode === 202) {
      return "running";
    } else if (statusCode < 300) {
      return "succeeded";
    } else {
      return "failed";
    }
  }
  function parseRetryAfter({ rawResponse }) {
    const retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== void 0) {
      const retryAfterInSeconds = parseInt(retryAfter);
      return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1e3;
    }
    return void 0;
  }
  operation$2.parseRetryAfter = parseRetryAfter;
  function getErrorFromResponse(response2) {
    const error2 = accessBodyProperty(response2, "error");
    if (!error2) {
      logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
      return;
    }
    if (!error2.code || !error2.message) {
      logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
      return;
    }
    return error2;
  }
  operation$2.getErrorFromResponse = getErrorFromResponse;
  function calculatePollingIntervalFromDate(retryAfterDate) {
    const timeNow = Math.floor((/* @__PURE__ */ new Date()).getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
      return retryAfterTime - timeNow;
    }
    return void 0;
  }
  function getStatusFromInitialResponse(inputs) {
    const { response: response2, state: state2, operationLocation } = inputs;
    function helper() {
      var _a;
      const mode = (_a = state2.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
      switch (mode) {
        case void 0:
          return toOperationStatus(response2.rawResponse.statusCode);
        case "Body":
          return getOperationStatus(response2, state2);
        default:
          return "running";
      }
    }
    const status = helper();
    return status === "running" && operationLocation === void 0 ? "succeeded" : status;
  }
  operation$2.getStatusFromInitialResponse = getStatusFromInitialResponse;
  async function initHttpOperation(inputs) {
    const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
    return (0, operation_js_1.initOperation)({
      init: async () => {
        const response2 = await lro.sendInitialRequest();
        const config2 = inferLroMode({
          rawResponse: response2.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response: response2, operationLocation: config2 === null || config2 === void 0 ? void 0 : config2.operationLocation, resourceLocation: config2 === null || config2 === void 0 ? void 0 : config2.resourceLocation }, (config2 === null || config2 === void 0 ? void 0 : config2.mode) ? { metadata: { mode: config2.mode } } : {});
      },
      stateProxy,
      processResult: processResult ? ({ flatResponse }, state2) => processResult(flatResponse, state2) : ({ flatResponse }) => flatResponse,
      getOperationStatus: getStatusFromInitialResponse,
      setErrorAsResult
    });
  }
  operation$2.initHttpOperation = initHttpOperation;
  function getOperationLocation({ rawResponse }, state2) {
    var _a;
    const mode = (_a = state2.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      }
      case "ResourceLocation": {
        return getLocationHeader(rawResponse);
      }
      case "Body":
      default: {
        return void 0;
      }
    }
  }
  operation$2.getOperationLocation = getOperationLocation;
  function getOperationStatus({ rawResponse }, state2) {
    var _a;
    const mode = (_a = state2.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getStatus(rawResponse);
      }
      case "ResourceLocation": {
        return toOperationStatus(rawResponse.statusCode);
      }
      case "Body": {
        return getProvisioningState(rawResponse);
      }
      default:
        throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
    }
  }
  operation$2.getOperationStatus = getOperationStatus;
  function accessBodyProperty({ flatResponse, rawResponse }, prop) {
    var _a, _b;
    return (_a = flatResponse === null || flatResponse === void 0 ? void 0 : flatResponse[prop]) !== null && _a !== void 0 ? _a : (_b = rawResponse.body) === null || _b === void 0 ? void 0 : _b[prop];
  }
  function getResourceLocation(res, state2) {
    const loc = accessBodyProperty(res, "resourceLocation");
    if (loc && typeof loc === "string") {
      state2.config.resourceLocation = loc;
    }
    return state2.config.resourceLocation;
  }
  operation$2.getResourceLocation = getResourceLocation;
  function isOperationError(e) {
    return e.name === "RestError";
  }
  operation$2.isOperationError = isOperationError;
  async function pollHttpOperation(inputs) {
    const { lro, stateProxy, options: options2, processResult, updateState, setDelay, state: state2, setErrorAsResult } = inputs;
    return (0, operation_js_1.pollOperation)({
      state: state2,
      stateProxy,
      setDelay,
      processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
      getError: getErrorFromResponse,
      updateState,
      getPollingInterval: parseRetryAfter,
      getOperationLocation,
      getOperationStatus,
      isOperationError,
      getResourceLocation,
      options: options2,
      /**
       * The expansion here is intentional because `lro` could be an object that
       * references an inner this, so we need to preserve a reference to it.
       */
      poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
      setErrorAsResult
    });
  }
  operation$2.pollHttpOperation = pollHttpOperation;
  return operation$2;
}
var poller$1 = {};
var hasRequiredPoller$2;
function requirePoller$2() {
  if (hasRequiredPoller$2) return poller$1;
  hasRequiredPoller$2 = 1;
  Object.defineProperty(poller$1, "__esModule", { value: true });
  poller$1.buildCreatePoller = void 0;
  const operation_js_1 = /* @__PURE__ */ requireOperation$2();
  const constants_js_1 = /* @__PURE__ */ requireConstants();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const createStateProxy = () => ({
    /**
     * The state at this point is created to be of type OperationState<TResult>.
     * It will be updated later to be of type TState when the
     * customer-provided callback, `updateState`, is called during polling.
     */
    initState: (config2) => ({ status: "running", config: config2 }),
    setCanceled: (state2) => state2.status = "canceled",
    setError: (state2, error2) => state2.error = error2,
    setResult: (state2, result) => state2.result = result,
    setRunning: (state2) => state2.status = "running",
    setSucceeded: (state2) => state2.status = "succeeded",
    setFailed: (state2) => state2.status = "failed",
    getError: (state2) => state2.error,
    getResult: (state2) => state2.result,
    isCanceled: (state2) => state2.status === "canceled",
    isFailed: (state2) => state2.status === "failed",
    isRunning: (state2) => state2.status === "running",
    isSucceeded: (state2) => state2.status === "succeeded"
  });
  function buildCreatePoller(inputs) {
    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
    return async ({ init, poll }, options2) => {
      const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options2 || {};
      const stateProxy = createStateProxy();
      const withOperationLocation = withOperationLocationCallback ? /* @__PURE__ */ (() => {
        let called = false;
        return (operationLocation, isUpdated) => {
          if (isUpdated)
            withOperationLocationCallback(operationLocation);
          else if (!called)
            withOperationLocationCallback(operationLocation);
          called = true;
        };
      })() : void 0;
      const state2 = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
        init,
        stateProxy,
        processResult,
        getOperationStatus: getStatusFromInitialResponse,
        withOperationLocation,
        setErrorAsResult: !resolveOnUnsuccessful
      });
      let resultPromise;
      const abortController = new AbortController();
      const handlers = /* @__PURE__ */ new Map();
      const handleProgressEvents = async () => handlers.forEach((h) => h(state2));
      const cancelErrMsg = "Operation was canceled";
      let currentPollIntervalInMs = intervalInMs;
      const poller2 = {
        getOperationState: () => state2,
        getResult: () => state2.result,
        isDone: () => ["succeeded", "failed", "canceled"].includes(state2.status),
        isStopped: () => resultPromise === void 0,
        stopPolling: () => {
          abortController.abort();
        },
        toString: () => JSON.stringify({
          state: state2
        }),
        onProgress: (callback) => {
          const s = Symbol();
          handlers.set(s, callback);
          return () => handlers.delete(s);
        },
        pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {
          const { abortSignal: inputAbortSignal } = pollOptions || {};
          function abortListener() {
            abortController.abort();
          }
          const abortSignal2 = abortController.signal;
          if (inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.aborted) {
            abortController.abort();
          } else if (!abortSignal2.aborted) {
            inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.addEventListener("abort", abortListener, { once: true });
          }
          try {
            if (!poller2.isDone()) {
              await poller2.poll({ abortSignal: abortSignal2 });
              while (!poller2.isDone()) {
                await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal: abortSignal2 });
                await poller2.poll({ abortSignal: abortSignal2 });
              }
            }
          } finally {
            inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.removeEventListener("abort", abortListener);
          }
          if (resolveOnUnsuccessful) {
            return poller2.getResult();
          } else {
            switch (state2.status) {
              case "succeeded":
                return poller2.getResult();
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state2.error;
              case "notStarted":
              case "running":
                throw new Error(`Polling completed without succeeding or failing`);
            }
          }
        })().finally(() => {
          resultPromise = void 0;
        }),
        async poll(pollOptions) {
          if (resolveOnUnsuccessful) {
            if (poller2.isDone())
              return;
          } else {
            switch (state2.status) {
              case "succeeded":
                return;
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state2.error;
            }
          }
          await (0, operation_js_1.pollOperation)({
            poll,
            state: state2,
            stateProxy,
            getOperationLocation,
            isOperationError,
            withOperationLocation,
            getPollingInterval,
            getOperationStatus: getStatusFromPollResponse,
            getResourceLocation,
            processResult,
            getError,
            updateState,
            options: pollOptions,
            setDelay: (pollIntervalInMs) => {
              currentPollIntervalInMs = pollIntervalInMs;
            },
            setErrorAsResult: !resolveOnUnsuccessful
          });
          await handleProgressEvents();
          if (!resolveOnUnsuccessful) {
            switch (state2.status) {
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state2.error;
            }
          }
        }
      };
      return poller2;
    };
  }
  poller$1.buildCreatePoller = buildCreatePoller;
  return poller$1;
}
var hasRequiredPoller$1;
function requirePoller$1() {
  if (hasRequiredPoller$1) return poller$2;
  hasRequiredPoller$1 = 1;
  Object.defineProperty(poller$2, "__esModule", { value: true });
  poller$2.createHttpPoller = void 0;
  const operation_js_1 = /* @__PURE__ */ requireOperation$1();
  const poller_js_1 = /* @__PURE__ */ requirePoller$2();
  async function createHttpPoller(lro, options2) {
    const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options2 || {};
    return (0, poller_js_1.buildCreatePoller)({
      getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
      getStatusFromPollResponse: operation_js_1.getOperationStatus,
      isOperationError: operation_js_1.isOperationError,
      getOperationLocation: operation_js_1.getOperationLocation,
      getResourceLocation: operation_js_1.getResourceLocation,
      getPollingInterval: operation_js_1.parseRetryAfter,
      getError: operation_js_1.getErrorFromResponse,
      resolveOnUnsuccessful
    })({
      init: async () => {
        const response2 = await lro.sendInitialRequest();
        const config2 = (0, operation_js_1.inferLroMode)({
          rawResponse: response2.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response: response2, operationLocation: config2 === null || config2 === void 0 ? void 0 : config2.operationLocation, resourceLocation: config2 === null || config2 === void 0 ? void 0 : config2.resourceLocation }, (config2 === null || config2 === void 0 ? void 0 : config2.mode) ? { metadata: { mode: config2.mode } } : {});
      },
      poll: lro.sendPollRequest
    }, {
      intervalInMs,
      withOperationLocation,
      restoreFrom,
      updateState,
      processResult: processResult ? ({ flatResponse }, state2) => processResult(flatResponse, state2) : ({ flatResponse }) => flatResponse
    });
  }
  poller$2.createHttpPoller = createHttpPoller;
  return poller$2;
}
var lroEngine$1 = {};
var lroEngine = {};
var operation = {};
var hasRequiredOperation;
function requireOperation() {
  if (hasRequiredOperation) return operation;
  hasRequiredOperation = 1;
  Object.defineProperty(operation, "__esModule", { value: true });
  operation.GenericPollOperation = void 0;
  const operation_js_1 = /* @__PURE__ */ requireOperation$1();
  const logger_js_1 = /* @__PURE__ */ requireLogger();
  const createStateProxy = () => ({
    initState: (config2) => ({ config: config2, isStarted: true }),
    setCanceled: (state2) => state2.isCancelled = true,
    setError: (state2, error2) => state2.error = error2,
    setResult: (state2, result) => state2.result = result,
    setRunning: (state2) => state2.isStarted = true,
    setSucceeded: (state2) => state2.isCompleted = true,
    setFailed: () => {
    },
    getError: (state2) => state2.error,
    getResult: (state2) => state2.result,
    isCanceled: (state2) => !!state2.isCancelled,
    isFailed: (state2) => !!state2.error,
    isRunning: (state2) => !!state2.isStarted,
    isSucceeded: (state2) => Boolean(state2.isCompleted && !state2.isCancelled && !state2.error)
  });
  class GenericPollOperation {
    constructor(state2, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
      this.state = state2;
      this.lro = lro;
      this.setErrorAsResult = setErrorAsResult;
      this.lroResourceLocationConfig = lroResourceLocationConfig;
      this.processResult = processResult;
      this.updateState = updateState;
      this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
    async update(options2) {
      var _a;
      const stateProxy = createStateProxy();
      if (!this.state.isStarted) {
        this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
          lro: this.lro,
          stateProxy,
          resourceLocationConfig: this.lroResourceLocationConfig,
          processResult: this.processResult,
          setErrorAsResult: this.setErrorAsResult
        }));
      }
      const updateState = this.updateState;
      const isDone = this.isDone;
      if (!this.state.isCompleted && this.state.error === void 0) {
        await (0, operation_js_1.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy,
          processResult: this.processResult,
          updateState: updateState ? (state2, { rawResponse }) => updateState(state2, rawResponse) : void 0,
          isDone: isDone ? ({ flatResponse }, state2) => isDone(flatResponse, state2) : void 0,
          options: options2,
          setDelay: (intervalInMs) => {
            this.pollerConfig.intervalInMs = intervalInMs;
          },
          setErrorAsResult: this.setErrorAsResult
        });
      }
      (_a = options2 === null || options2 === void 0 ? void 0 : options2.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options2, this.state);
      return this;
    }
    async cancel() {
      logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
      return this;
    }
    /**
     * Serializes the Poller operation.
     */
    toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }
  operation.GenericPollOperation = GenericPollOperation;
  return operation;
}
var poller = {};
var hasRequiredPoller;
function requirePoller() {
  if (hasRequiredPoller) return poller;
  hasRequiredPoller = 1;
  Object.defineProperty(poller, "__esModule", { value: true });
  poller.Poller = poller.PollerCancelledError = poller.PollerStoppedError = void 0;
  class PollerStoppedError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerStoppedError";
      Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
  }
  poller.PollerStoppedError = PollerStoppedError;
  class PollerCancelledError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerCancelledError";
      Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
  }
  poller.PollerCancelledError = PollerCancelledError;
  class Poller {
    /**
     * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
     *
     * When writing an implementation of a Poller, this implementation needs to deal with the initialization
     * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
     * operation has already been defined, at least its basic properties. The code below shows how to approach
     * the definition of the constructor of a new custom poller.
     *
     * ```ts
     * export class MyPoller extends Poller<MyOperationState, string> {
     *   constructor({
     *     // Anything you might need outside of the basics
     *   }) {
     *     let state: MyOperationState = {
     *       privateProperty: private,
     *       publicProperty: public,
     *     };
     *
     *     const operation = {
     *       state,
     *       update,
     *       cancel,
     *       toString
     *     }
     *
     *     // Sending the operation to the parent's constructor.
     *     super(operation);
     *
     *     // You can assign more local properties here.
     *   }
     * }
     * ```
     *
     * Inside of this constructor, a new promise is created. This will be used to
     * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
     * resolve and reject methods are also used internally to control when to resolve
     * or reject anyone waiting for the poller to finish.
     *
     * The constructor of a custom implementation of a poller is where any serialized version of
     * a previous poller's operation should be deserialized into the operation sent to the
     * base constructor. For example:
     *
     * ```ts
     * export class MyPoller extends Poller<MyOperationState, string> {
     *   constructor(
     *     baseOperation: string | undefined
     *   ) {
     *     let state: MyOperationState = {};
     *     if (baseOperation) {
     *       state = {
     *         ...JSON.parse(baseOperation).state,
     *         ...state
     *       };
     *     }
     *     const operation = {
     *       state,
     *       // ...
     *     }
     *     super(operation);
     *   }
     * }
     * ```
     *
     * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
     */
    constructor(operation2) {
      this.resolveOnUnsuccessful = false;
      this.stopped = true;
      this.pollProgressCallbacks = [];
      this.operation = operation2;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      this.promise.catch(() => {
      });
    }
    /**
     * Starts a loop that will break only if the poller is done
     * or if the poller is stopped.
     */
    async startPolling(pollOptions = {}) {
      if (this.stopped) {
        this.stopped = false;
      }
      while (!this.isStopped() && !this.isDone()) {
        await this.poll(pollOptions);
        await this.delay();
      }
    }
    /**
     * pollOnce does one polling, by calling to the update method of the underlying
     * poll operation to make any relevant change effective.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    async pollOnce(options2 = {}) {
      if (!this.isDone()) {
        this.operation = await this.operation.update({
          abortSignal: options2.abortSignal,
          fireProgress: this.fireProgress.bind(this)
        });
      }
      this.processUpdatedState();
    }
    /**
     * fireProgress calls the functions passed in via onProgress the method of the poller.
     *
     * It loops over all of the callbacks received from onProgress, and executes them, sending them
     * the current operation state.
     *
     * @param state - The current operation state.
     */
    fireProgress(state2) {
      for (const callback of this.pollProgressCallbacks) {
        callback(state2);
      }
    }
    /**
     * Invokes the underlying operation's cancel method.
     */
    async cancelOnce(options2 = {}) {
      this.operation = await this.operation.cancel(options2);
    }
    /**
     * Returns a promise that will resolve once a single polling request finishes.
     * It does this by calling the update method of the Poller's operation.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    poll(options2 = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options2);
        const clearPollOncePromise = () => {
          this.pollOncePromise = void 0;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          this.reject(this.operation.state.error);
          throw this.operation.state.error;
        }
      }
      if (this.operation.state.isCancelled) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          const error2 = new PollerCancelledError("Operation was canceled");
          this.reject(error2);
          throw error2;
        }
      }
      if (this.isDone() && this.resolve) {
        this.resolve(this.getResult());
      }
    }
    /**
     * Returns a promise that will resolve once the underlying operation is completed.
     */
    async pollUntilDone(pollOptions = {}) {
      if (this.stopped) {
        this.startPolling(pollOptions).catch(this.reject);
      }
      this.processUpdatedState();
      return this.promise;
    }
    /**
     * Invokes the provided callback after each polling is completed,
     * sending the current state of the poller's operation.
     *
     * It returns a method that can be used to stop receiving updates on the given callback function.
     */
    onProgress(callback) {
      this.pollProgressCallbacks.push(callback);
      return () => {
        this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
      };
    }
    /**
     * Returns true if the poller has finished polling.
     */
    isDone() {
      const state2 = this.operation.state;
      return Boolean(state2.isCompleted || state2.isCancelled || state2.error);
    }
    /**
     * Stops the poller from continuing to poll.
     */
    stopPolling() {
      if (!this.stopped) {
        this.stopped = true;
        if (this.reject) {
          this.reject(new PollerStoppedError("This poller is already stopped"));
        }
      }
    }
    /**
     * Returns true if the poller is stopped.
     */
    isStopped() {
      return this.stopped;
    }
    /**
     * Attempts to cancel the underlying operation.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * If it's called again before it finishes, it will throw an error.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    cancelOperation(options2 = {}) {
      if (!this.cancelPromise) {
        this.cancelPromise = this.cancelOnce(options2);
      } else if (options2.abortSignal) {
        throw new Error("A cancel request is currently pending");
      }
      return this.cancelPromise;
    }
    /**
     * Returns the state of the operation.
     *
     * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
     * implementations of the pollers can customize what's shared with the public by writing their own
     * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
     * and a public type representing a safe to share subset of the properties of the internal state.
     * Their definition of getOperationState can then return their public type.
     *
     * Example:
     *
     * ```ts
     * // Let's say we have our poller's operation state defined as:
     * interface MyOperationState extends PollOperationState<ResultType> {
     *   privateProperty?: string;
     *   publicProperty?: string;
     * }
     *
     * // To allow us to have a true separation of public and private state, we have to define another interface:
     * interface PublicState extends PollOperationState<ResultType> {
     *   publicProperty?: string;
     * }
     *
     * // Then, we define our Poller as follows:
     * export class MyPoller extends Poller<MyOperationState, ResultType> {
     *   // ... More content is needed here ...
     *
     *   public getOperationState(): PublicState {
     *     const state: PublicState = this.operation.state;
     *     return {
     *       // Properties from PollOperationState<TResult>
     *       isStarted: state.isStarted,
     *       isCompleted: state.isCompleted,
     *       isCancelled: state.isCancelled,
     *       error: state.error,
     *       result: state.result,
     *
     *       // The only other property needed by PublicState.
     *       publicProperty: state.publicProperty
     *     }
     *   }
     * }
     * ```
     *
     * You can see this in the tests of this repository, go to the file:
     * `../test/utils/testPoller.ts`
     * and look for the getOperationState implementation.
     */
    getOperationState() {
      return this.operation.state;
    }
    /**
     * Returns the result value of the operation,
     * regardless of the state of the poller.
     * It can return undefined or an incomplete form of the final TResult value
     * depending on the implementation.
     */
    getResult() {
      const state2 = this.operation.state;
      return state2.result;
    }
    /**
     * Returns a serialized version of the poller's operation
     * by invoking the operation's toString method.
     */
    toString() {
      return this.operation.toString();
    }
  }
  poller.Poller = Poller;
  return poller;
}
var hasRequiredLroEngine$1;
function requireLroEngine$1() {
  if (hasRequiredLroEngine$1) return lroEngine;
  hasRequiredLroEngine$1 = 1;
  Object.defineProperty(lroEngine, "__esModule", { value: true });
  lroEngine.LroEngine = void 0;
  const operation_js_1 = /* @__PURE__ */ requireOperation();
  const constants_js_1 = /* @__PURE__ */ requireConstants();
  const poller_js_1 = /* @__PURE__ */ requirePoller();
  const operation_js_2 = /* @__PURE__ */ requireOperation$2();
  class LroEngine extends poller_js_1.Poller {
    constructor(lro, options2) {
      const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options2 || {};
      const state2 = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
      const operation2 = new operation_js_1.GenericPollOperation(state2, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
      super(operation2);
      this.resolveOnUnsuccessful = resolveOnUnsuccessful;
      this.config = { intervalInMs };
      operation2.setPollerConfig(this.config);
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    delay() {
      return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
    }
  }
  lroEngine.LroEngine = LroEngine;
  return lroEngine;
}
var hasRequiredLroEngine;
function requireLroEngine() {
  if (hasRequiredLroEngine) return lroEngine$1;
  hasRequiredLroEngine = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LroEngine = void 0;
    var lroEngine_js_1 = /* @__PURE__ */ requireLroEngine$1();
    Object.defineProperty(exports, "LroEngine", { enumerable: true, get: function() {
      return lroEngine_js_1.LroEngine;
    } });
  })(lroEngine$1);
  return lroEngine$1;
}
var pollOperation = {};
var hasRequiredPollOperation;
function requirePollOperation() {
  if (hasRequiredPollOperation) return pollOperation;
  hasRequiredPollOperation = 1;
  Object.defineProperty(pollOperation, "__esModule", { value: true });
  return pollOperation;
}
var hasRequiredCommonjs$1;
function requireCommonjs$1() {
  if (hasRequiredCommonjs$1) return commonjs;
  hasRequiredCommonjs$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHttpPoller = void 0;
    const tslib_1 = require$$0$2;
    var poller_js_1 = /* @__PURE__ */ requirePoller$1();
    Object.defineProperty(exports, "createHttpPoller", { enumerable: true, get: function() {
      return poller_js_1.createHttpPoller;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireLroEngine(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requirePoller(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requirePollOperation(), exports);
  })(commonjs);
  return commonjs;
}
var hasRequiredBlobStartCopyFromUrlPoller;
function requireBlobStartCopyFromUrlPoller() {
  if (hasRequiredBlobStartCopyFromUrlPoller) return BlobStartCopyFromUrlPoller;
  hasRequiredBlobStartCopyFromUrlPoller = 1;
  Object.defineProperty(BlobStartCopyFromUrlPoller, "__esModule", { value: true });
  BlobStartCopyFromUrlPoller.BlobBeginCopyFromUrlPoller = void 0;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const core_lro_1 = /* @__PURE__ */ requireCommonjs$1();
  class BlobBeginCopyFromUrlPoller extends core_lro_1.Poller {
    intervalInMs;
    constructor(options2) {
      const { blobClient, copySource, intervalInMs = 15e3, onProgress, resumeFrom, startCopyFromURLOptions } = options2;
      let state2;
      if (resumeFrom) {
        state2 = JSON.parse(resumeFrom).state;
      }
      const operation2 = makeBlobBeginCopyFromURLPollOperation({
        ...state2,
        blobClient,
        copySource,
        startCopyFromURLOptions
      });
      super(operation2);
      if (typeof onProgress === "function") {
        this.onProgress(onProgress);
      }
      this.intervalInMs = intervalInMs;
    }
    delay() {
      return (0, core_util_1.delay)(this.intervalInMs);
    }
  }
  BlobStartCopyFromUrlPoller.BlobBeginCopyFromUrlPoller = BlobBeginCopyFromUrlPoller;
  const cancel = async function cancel2(options2 = {}) {
    const state2 = this.state;
    const { copyId } = state2;
    if (state2.isCompleted) {
      return makeBlobBeginCopyFromURLPollOperation(state2);
    }
    if (!copyId) {
      state2.isCancelled = true;
      return makeBlobBeginCopyFromURLPollOperation(state2);
    }
    await state2.blobClient.abortCopyFromURL(copyId, {
      abortSignal: options2.abortSignal
    });
    state2.isCancelled = true;
    return makeBlobBeginCopyFromURLPollOperation(state2);
  };
  const update = async function update2(options2 = {}) {
    const state2 = this.state;
    const { blobClient, copySource, startCopyFromURLOptions } = state2;
    if (!state2.isStarted) {
      state2.isStarted = true;
      const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
      state2.copyId = result.copyId;
      if (result.copyStatus === "success") {
        state2.result = result;
        state2.isCompleted = true;
      }
    } else if (!state2.isCompleted) {
      try {
        const result = await state2.blobClient.getProperties({ abortSignal: options2.abortSignal });
        const { copyStatus, copyProgress } = result;
        const prevCopyProgress = state2.copyProgress;
        if (copyProgress) {
          state2.copyProgress = copyProgress;
        }
        if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options2.fireProgress === "function") {
          options2.fireProgress(state2);
        } else if (copyStatus === "success") {
          state2.result = result;
          state2.isCompleted = true;
        } else if (copyStatus === "failed") {
          state2.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
          state2.isCompleted = true;
        }
      } catch (err) {
        state2.error = err;
        state2.isCompleted = true;
      }
    }
    return makeBlobBeginCopyFromURLPollOperation(state2);
  };
  const toString = function toString2() {
    return JSON.stringify({ state: this.state }, (key, value) => {
      if (key === "blobClient") {
        return void 0;
      }
      return value;
    });
  };
  function makeBlobBeginCopyFromURLPollOperation(state2) {
    return {
      state: { ...state2 },
      cancel,
      toString,
      update
    };
  }
  return BlobStartCopyFromUrlPoller;
}
var Range = {};
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return Range;
  hasRequiredRange = 1;
  Object.defineProperty(Range, "__esModule", { value: true });
  Range.rangeToString = rangeToString;
  function rangeToString(iRange) {
    if (iRange.offset < 0) {
      throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (iRange.count && iRange.count <= 0) {
      throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
  }
  return Range;
}
var Batch = {};
var hasRequiredBatch;
function requireBatch() {
  if (hasRequiredBatch) return Batch;
  hasRequiredBatch = 1;
  Object.defineProperty(Batch, "__esModule", { value: true });
  Batch.Batch = void 0;
  const events_1 = require$$0$6;
  var BatchStates;
  (function(BatchStates2) {
    BatchStates2[BatchStates2["Good"] = 0] = "Good";
    BatchStates2[BatchStates2["Error"] = 1] = "Error";
  })(BatchStates || (BatchStates = {}));
  let Batch$1 = class Batch {
    /**
     * Concurrency. Must be lager than 0.
     */
    concurrency;
    /**
     * Number of active operations under execution.
     */
    actives = 0;
    /**
     * Number of completed operations under execution.
     */
    completed = 0;
    /**
     * Offset of next operation to be executed.
     */
    offset = 0;
    /**
     * Operation array to be executed.
     */
    operations = [];
    /**
     * States of Batch. When an error happens, state will turn into error.
     * Batch will stop execute left operations.
     */
    state = BatchStates.Good;
    /**
     * A private emitter used to pass events inside this class.
     */
    emitter;
    /**
     * Creates an instance of Batch.
     * @param concurrency -
     */
    constructor(concurrency = 5) {
      if (concurrency < 1) {
        throw new RangeError("concurrency must be larger than 0");
      }
      this.concurrency = concurrency;
      this.emitter = new events_1.EventEmitter();
    }
    /**
     * Add a operation into queue.
     *
     * @param operation -
     */
    addOperation(operation2) {
      this.operations.push(async () => {
        try {
          this.actives++;
          await operation2();
          this.actives--;
          this.completed++;
          this.parallelExecute();
        } catch (error2) {
          this.emitter.emit("error", error2);
        }
      });
    }
    /**
     * Start execute operations in the queue.
     *
     */
    async do() {
      if (this.operations.length === 0) {
        return Promise.resolve();
      }
      this.parallelExecute();
      return new Promise((resolve, reject) => {
        this.emitter.on("finish", resolve);
        this.emitter.on("error", (error2) => {
          this.state = BatchStates.Error;
          reject(error2);
        });
      });
    }
    /**
     * Get next operation to be executed. Return null when reaching ends.
     *
     */
    nextOperation() {
      if (this.offset < this.operations.length) {
        return this.operations[this.offset++];
      }
      return null;
    }
    /**
     * Start execute operations. One one the most important difference between
     * this method with do() is that do() wraps as an sync method.
     *
     */
    parallelExecute() {
      if (this.state === BatchStates.Error) {
        return;
      }
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        const operation2 = this.nextOperation();
        if (operation2) {
          operation2();
        } else {
          return;
        }
      }
    }
  };
  Batch.Batch = Batch$1;
  return Batch;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.fsCreateReadStream = utils.fsStat = void 0;
  utils.streamToBuffer = streamToBuffer;
  utils.streamToBuffer2 = streamToBuffer2;
  utils.streamToBuffer3 = streamToBuffer3;
  utils.readStreamToLocalFile = readStreamToLocalFile;
  const tslib_1 = require$$0$2;
  const node_fs_1 = tslib_1.__importDefault(require$$1$a);
  const node_util_1 = tslib_1.__importDefault(require$$1$5);
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  async function streamToBuffer(stream, buffer, offset, end, encoding2) {
    let pos = 0;
    const count = end - offset;
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error(`The operation cannot be completed in timeout.`)), constants_js_1.REQUEST_TIMEOUT);
      stream.on("readable", () => {
        if (pos >= count) {
          clearTimeout(timeout);
          resolve();
          return;
        }
        let chunk = stream.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding2);
        }
        const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
        buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
        pos += chunkLength;
      });
      stream.on("end", () => {
        clearTimeout(timeout);
        if (pos < count) {
          reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
        }
        resolve();
      });
      stream.on("error", (msg) => {
        clearTimeout(timeout);
        reject(msg);
      });
    });
  }
  async function streamToBuffer2(stream, buffer, encoding2) {
    let pos = 0;
    const bufferSize = buffer.length;
    return new Promise((resolve, reject) => {
      stream.on("readable", () => {
        let chunk = stream.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (pos + chunk.length > bufferSize) {
          reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
          return;
        }
        buffer.fill(chunk, pos, pos + chunk.length);
        pos += chunk.length;
      });
      stream.on("end", () => {
        resolve(pos);
      });
      stream.on("error", reject);
    });
  }
  async function streamToBuffer3(readableStream, encoding2) {
    return new Promise((resolve, reject) => {
      const chunks = [];
      readableStream.on("data", (data) => {
        chunks.push(typeof data === "string" ? Buffer.from(data, encoding2) : data);
      });
      readableStream.on("end", () => {
        resolve(Buffer.concat(chunks));
      });
      readableStream.on("error", reject);
    });
  }
  async function readStreamToLocalFile(rs, file2) {
    return new Promise((resolve, reject) => {
      const ws = node_fs_1.default.createWriteStream(file2);
      rs.on("error", (err) => {
        reject(err);
      });
      ws.on("error", (err) => {
        reject(err);
      });
      ws.on("close", resolve);
      rs.pipe(ws);
    });
  }
  utils.fsStat = node_util_1.default.promisify(node_fs_1.default.stat);
  utils.fsCreateReadStream = node_fs_1.default.createReadStream;
  return utils;
}
var hasRequiredClients;
function requireClients() {
  if (hasRequiredClients) return Clients;
  hasRequiredClients = 1;
  Object.defineProperty(Clients, "__esModule", { value: true });
  Clients.PageBlobClient = Clients.BlockBlobClient = Clients.AppendBlobClient = Clients.BlobClient = void 0;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_auth_1 = /* @__PURE__ */ requireCommonjs$6();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const core_util_2 = /* @__PURE__ */ requireCommonjs$9();
  const BlobDownloadResponse_js_1 = /* @__PURE__ */ requireBlobDownloadResponse();
  const BlobQueryResponse_js_1 = /* @__PURE__ */ requireBlobQueryResponse();
  const AnonymousCredential_js_1 = /* @__PURE__ */ requireAnonymousCredential$1();
  const StorageSharedKeyCredential_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredential$1();
  const models_js_1 = /* @__PURE__ */ requireModels();
  const PageBlobRangeResponse_js_1 = /* @__PURE__ */ requirePageBlobRangeResponse();
  const Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
  const BlobStartCopyFromUrlPoller_js_1 = /* @__PURE__ */ requireBlobStartCopyFromUrlPoller();
  const Range_js_1 = /* @__PURE__ */ requireRange();
  const StorageClient_js_1 = /* @__PURE__ */ requireStorageClient();
  const Batch_js_1 = /* @__PURE__ */ requireBatch();
  const storage_common_1 = /* @__PURE__ */ requireCommonjs$2();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const tracing_js_1 = /* @__PURE__ */ requireTracing();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  const utils_js_1 = /* @__PURE__ */ requireUtils();
  const BlobSASSignatureValues_js_1 = /* @__PURE__ */ requireBlobSASSignatureValues();
  const BlobLeaseClient_js_1 = /* @__PURE__ */ requireBlobLeaseClient();
  class BlobClient extends StorageClient_js_1.StorageClient {
    /**
     * blobContext provided by protocol layer.
     */
    blobContext;
    _name;
    _containerName;
    _versionId;
    _snapshot;
    /**
     * The name of the blob.
     */
    get name() {
      return this._name;
    }
    /**
     * The name of the storage container the blob is associated with.
     */
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options2) {
      options2 = options2 || {};
      let pipeline2;
      let url;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline2 = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options2 = blobNameOrOptions;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options2);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options2 = blobNameOrOptions;
        }
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options2.proxyOptions) {
              options2.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline2 = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options2);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline2);
      ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
      this.blobContext = this.storageClientContext.blob;
      this._snapshot = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT);
      this._versionId = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID);
    }
    /**
     * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp
     */
    withSnapshot(snapshot) {
      return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    /**
     * Creates a new BlobClient object pointing to a version of this blob.
     * Provide "" will remove the versionId and return a Client to the base blob.
     *
     * @param versionId - The versionId.
     * @returns A new BlobClient object pointing to the version of this blob.
     */
    withVersion(versionId) {
      return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID, versionId.length === 0 ? void 0 : versionId), this.pipeline);
    }
    /**
     * Creates a AppendBlobClient object.
     *
     */
    getAppendBlobClient() {
      return new AppendBlobClient(this.url, this.pipeline);
    }
    /**
     * Creates a BlockBlobClient object.
     *
     */
    getBlockBlobClient() {
      return new BlockBlobClient(this.url, this.pipeline);
    }
    /**
     * Creates a PageBlobClient object.
     *
     */
    getPageBlobClient() {
      return new PageBlobClient(this.url, this.pipeline);
    }
    /**
     * Reads or downloads a blob from the system, including its metadata and properties.
     * You can also call Get Blob to read a snapshot.
     *
     * * In Node.js, data returns in a Readable stream readableStreamBody
     * * In browsers, data returns in a promise blobBody
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob
     *
     * @param offset - From which position of the blob to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Optional options to Blob Download operation.
     *
     *
     * Example usage (Node.js):
     *
     * ```ts snippet:ReadmeSampleDownloadBlob_Node
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobClient = containerClient.getBlobClient(blobName);
     *
     * // Get blob content from position 0 to the end
     * // In Node.js, get downloaded data by accessing downloadBlockBlobResponse.readableStreamBody
     * const downloadBlockBlobResponse = await blobClient.download();
     * if (downloadBlockBlobResponse.readableStreamBody) {
     *   const downloaded = await streamToString(downloadBlockBlobResponse.readableStreamBody);
     *   console.log(`Downloaded blob content: ${downloaded}`);
     * }
     *
     * async function streamToString(stream: NodeJS.ReadableStream): Promise<string> {
     *   const result = await new Promise<Buffer<ArrayBuffer>>((resolve, reject) => {
     *     const chunks: Buffer[] = [];
     *     stream.on("data", (data) => {
     *       chunks.push(Buffer.isBuffer(data) ? data : Buffer.from(data));
     *     });
     *     stream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     stream.on("error", reject);
     *   });
     *   return result.toString();
     * }
     * ```
     *
     * Example usage (browser):
     *
     * ```ts snippet:ReadmeSampleDownloadBlob_Browser
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobClient = containerClient.getBlobClient(blobName);
     *
     * // Get blob content from position 0 to the end
     * // In browsers, get downloaded data by accessing downloadBlockBlobResponse.blobBody
     * const downloadBlockBlobResponse = await blobClient.download();
     * const blobBody = await downloadBlockBlobResponse.blobBody;
     * if (blobBody) {
     *   const downloaded = await blobBody.text();
     *   console.log(`Downloaded blob content: ${downloaded}`);
     * }
     * ```
     */
    async download(offset = 0, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-download", options2, async (updatedOptions) => {
        const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.download({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          requestOptions: {
            onDownloadProgress: core_util_1.isNodeLike ? void 0 : options2.onProgress
            // for Node.js, progress is reported by RetriableReadableStream
          },
          range: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({ offset, count }),
          rangeGetContentMD5: options2.rangeGetContentMD5,
          rangeGetContentCRC64: options2.rangeGetContentCrc64,
          snapshot: options2.snapshot,
          cpkInfo: options2.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedRes = {
          ...res,
          _response: res._response,
          // _response is made non-enumerable
          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
          objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
        };
        if (!core_util_1.isNodeLike) {
          return wrappedRes;
        }
        if (options2.maxRetryRequests === void 0 || options2.maxRetryRequests < 0) {
          options2.maxRetryRequests = constants_js_1.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
        }
        if (res.contentLength === void 0) {
          throw new RangeError(`File download response doesn't contain valid content length header`);
        }
        if (!res.etag) {
          throw new RangeError(`File download response doesn't contain valid etag header`);
        }
        return new BlobDownloadResponse_js_1.BlobDownloadResponse(wrappedRes, async (start) => {
          const updatedDownloadOptions = {
            leaseAccessConditions: options2.conditions,
            modifiedAccessConditions: {
              ifMatch: options2.conditions.ifMatch || res.etag,
              ifModifiedSince: options2.conditions.ifModifiedSince,
              ifNoneMatch: options2.conditions.ifNoneMatch,
              ifUnmodifiedSince: options2.conditions.ifUnmodifiedSince,
              ifTags: options2.conditions?.tagConditions
            },
            range: (0, Range_js_1.rangeToString)({
              count: offset + res.contentLength - start,
              offset: start
            }),
            rangeGetContentMD5: options2.rangeGetContentMD5,
            rangeGetContentCRC64: options2.rangeGetContentCrc64,
            snapshot: options2.snapshot,
            cpkInfo: options2.customerProvidedKey
          };
          return (await this.blobContext.download({
            abortSignal: options2.abortSignal,
            ...updatedDownloadOptions
          })).readableStreamBody;
        }, offset, res.contentLength, {
          maxRetryRequests: options2.maxRetryRequests,
          onProgress: options2.onProgress
        });
      });
    }
    /**
     * Returns true if the Azure blob resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing blob might be deleted by other clients or
     * applications. Vice versa new blobs might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-exists", options2, async (updatedOptions) => {
        try {
          (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
          await this.getProperties({
            abortSignal: options2.abortSignal,
            customerProvidedKey: options2.customerProvidedKey,
            conditions: options2.conditions,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          } else if (e.statusCode === 409 && (e.details.errorCode === constants_js_1.BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === constants_js_1.BlobDoesNotUseCustomerSpecifiedEncryption)) {
            return true;
          }
          throw e;
        }
      });
    }
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the blob. It does not return the content of the blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @param options - Optional options to Get Properties operation.
     */
    async getProperties(options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-getProperties", options2, async (updatedOptions) => {
        const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.getProperties({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...res,
          _response: res._response,
          // _response is made non-enumerable
          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
          objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
        };
      });
    }
    /**
     * Marks the specified blob or snapshot for deletion. The blob is later deleted
     * during garbage collection. Note that in order to delete a blob, you must delete
     * all of its snapshots. You can delete both at the same time with the Delete
     * Blob operation.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
     *
     * @param options - Optional options to Blob Delete operation.
     */
    async delete(options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("BlobClient-delete", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.delete({
          abortSignal: options2.abortSignal,
          deleteSnapshots: options2.deleteSnapshots,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted
     * during garbage collection. Note that in order to delete a blob, you must delete
     * all of its snapshots. You can delete both at the same time with the Delete
     * Blob operation.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
     *
     * @param options - Optional options to Blob Delete operation.
     */
    async deleteIfExists(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-deleteIfExists", options2, async (updatedOptions) => {
        try {
          const res = (0, utils_common_js_1.assertResponse)(await this.delete(updatedOptions));
          return {
            succeeded: true,
            ...res,
            _response: res._response
            // _response is made non-enumerable
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobNotFound") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    /**
     * Restores the contents and metadata of soft deleted blob and any associated
     * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29
     * or later.
     * @see https://learn.microsoft.com/rest/api/storageservices/undelete-blob
     *
     * @param options - Optional options to Blob Undelete operation.
     */
    async undelete(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-undelete", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.undelete({
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Sets system properties on the blob.
     *
     * If no value provided, or no value provided for the specified blob HTTP headers,
     * these blob HTTP headers without a value will be cleared.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
     *
     * @param blobHTTPHeaders - If no value provided, or no value provided for
     *                                                   the specified blob HTTP headers, these blob HTTP
     *                                                   headers without a value will be cleared.
     *                                                   A common header to set is `blobContentType`
     *                                                   enabling the browser to provide functionality
     *                                                   based on file type.
     * @param options - Optional options to Blob Set HTTP Headers operation.
     */
    async setHTTPHeaders(blobHTTPHeaders, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-setHTTPHeaders", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setHttpHeaders({
          abortSignal: options2.abortSignal,
          blobHttpHeaders: blobHTTPHeaders,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          // cpkInfo: options.customerProvidedKey, // CPK is not included in Swagger, should change this back when this issue is fixed in Swagger.
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Sets user-defined metadata for the specified blob as one or more name-value pairs.
     *
     * If no option provided, or no metadata defined in the parameter, the blob
     * metadata will be removed.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-metadata
     *
     * @param metadata - Replace existing metadata with this value.
     *                               If no value provided the existing metadata will be removed.
     * @param options - Optional options to Set Metadata operation.
     */
    async setMetadata(metadata, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-setMetadata", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setMetadata({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Sets tags on the underlying blob.
     * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.
     * Valid tag key and value characters include lower and upper case letters, digits (0-9),
     * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').
     *
     * @param tags -
     * @param options -
     */
    async setTags(tags, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setTags", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTags({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions,
          tags: (0, utils_common_js_1.toBlobTags)(tags)
        }));
      });
    }
    /**
     * Gets the tags associated with the underlying blob.
     *
     * @param options -
     */
    async getTags(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-getTags", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.blobContext.getTags({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response2,
          _response: response2._response,
          // _response is made non-enumerable
          tags: (0, utils_common_js_1.toTags)({ blobTagSet: response2.blobTagSet }) || {}
        };
        return wrappedResponse;
      });
    }
    /**
     * Get a {@link BlobLeaseClient} that manages leases on the blob.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new BlobLeaseClient object for managing leases on the blob.
     */
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
    }
    /**
     * Creates a read-only snapshot of a blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/snapshot-blob
     *
     * @param options - Optional options to the Blob Create Snapshot operation.
     */
    async createSnapshot(options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlobClient-createSnapshot", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.createSnapshot({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          metadata: options2.metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Asynchronously copies a blob to a destination within the storage account.
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the copy is completed.
     * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * In version 2012-02-12 and later, the source for a Copy Blob operation can be
     * a committed blob in any Azure storage account.
     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
     * an Azure file in any Azure storage account.
     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
     * operation to copy from another storage account.
     * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob
     *
     * ```ts snippet:ClientsBeginCopyFromURL
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobClient = containerClient.getBlobClient(blobName);
     *
     * // Example using automatic polling
     * const automaticCopyPoller = await blobClient.beginCopyFromURL("url");
     * const automaticResult = await automaticCopyPoller.pollUntilDone();
     *
     * // Example using manual polling
     * const manualCopyPoller = await blobClient.beginCopyFromURL("url");
     * while (!manualCopyPoller.isDone()) {
     *   await manualCopyPoller.poll();
     * }
     * const manualResult = manualCopyPoller.getResult();
     *
     * // Example using progress updates
     * const progressUpdatesCopyPoller = await blobClient.beginCopyFromURL("url", {
     *   onProgress(state) {
     *     console.log(`Progress: ${state.copyProgress}`);
     *   },
     * });
     * const progressUpdatesResult = await progressUpdatesCopyPoller.pollUntilDone();
     *
     * // Example using a changing polling interval (default 15 seconds)
     * const pollingIntervalCopyPoller = await blobClient.beginCopyFromURL("url", {
     *   intervalInMs: 1000, // poll blob every 1 second for copy progress
     * });
     * const pollingIntervalResult = await pollingIntervalCopyPoller.pollUntilDone();
     *
     * // Example using copy cancellation:
     * const cancelCopyPoller = await blobClient.beginCopyFromURL("url");
     * // cancel operation after starting it.
     * try {
     *   await cancelCopyPoller.cancelOperation();
     *   // calls to get the result now throw PollerCancelledError
     *   cancelCopyPoller.getResult();
     * } catch (err: any) {
     *   if (err.name === "PollerCancelledError") {
     *     console.log("The copy was cancelled.");
     *   }
     * }
     * ```
     *
     * @param copySource - url to the source Azure Blob/File.
     * @param options - Optional options to the Blob Start Copy From URL operation.
     */
    async beginCopyFromURL(copySource, options2 = {}) {
      const client2 = {
        abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
        getProperties: (...args) => this.getProperties(...args),
        startCopyFromURL: (...args) => this.startCopyFromURL(...args)
      };
      const poller2 = new BlobStartCopyFromUrlPoller_js_1.BlobBeginCopyFromUrlPoller({
        blobClient: client2,
        copySource,
        intervalInMs: options2.intervalInMs,
        onProgress: options2.onProgress,
        resumeFrom: options2.resumeFrom,
        startCopyFromURLOptions: options2
      });
      await poller2.poll();
      return poller2;
    }
    /**
     * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero
     * length and full metadata. Version 2012-02-12 and newer.
     * @see https://learn.microsoft.com/rest/api/storageservices/abort-copy-blob
     *
     * @param copyId - Id of the Copy From URL operation.
     * @param options - Optional options to the Blob Abort Copy From URL operation.
     */
    async abortCopyFromURL(copyId, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-abortCopyFromURL", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.abortCopyFromURL(copyId, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not
     * return a response until the copy is complete.
     * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob-from-url
     *
     * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication
     * @param options -
     */
    async syncCopyFromURL(copySource, options2 = {}) {
      options2.conditions = options2.conditions || {};
      options2.sourceConditions = options2.sourceConditions || {};
      return tracing_js_1.tracingClient.withSpan("BlobClient-syncCopyFromURL", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.copyFromURL(copySource, {
          abortSignal: options2.abortSignal,
          metadata: options2.metadata,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options2.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options2.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options2.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options2.sourceConditions?.ifUnmodifiedSince
          },
          sourceContentMD5: options2.sourceContentMD5,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options2.sourceAuthorization),
          tier: (0, models_js_1.toAccessTier)(options2.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          immutabilityPolicyExpiry: options2.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options2.immutabilityPolicy?.policyMode,
          legalHold: options2.legalHold,
          encryptionScope: options2.encryptionScope,
          copySourceTags: options2.copySourceTags,
          fileRequestIntent: options2.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Sets the tier on a blob. The operation is allowed on a page blob in a premium
     * storage account and on a block blob in a blob storage account (locally redundant
     * storage only). A premium page blob's tier determines the allowed size, IOPS,
     * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive
     * storage type. This operation does not update the blob's ETag.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-tier
     *
     * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.
     * @param options - Optional options to the Blob Set Tier operation.
     */
    async setAccessTier(tier, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setAccessTier", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTier((0, models_js_1.toAccessTier)(tier), {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          rehydratePriority: options2.rehydratePriority,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async downloadToBuffer(param1, param2, param3, param4 = {}) {
      let buffer;
      let offset = 0;
      let count = 0;
      let options2 = param4;
      if (param1 instanceof Buffer) {
        buffer = param1;
        offset = param2 || 0;
        count = typeof param3 === "number" ? param3 : 0;
      } else {
        offset = typeof param1 === "number" ? param1 : 0;
        count = typeof param2 === "number" ? param2 : 0;
        options2 = param3 || {};
      }
      let blockSize = options2.blockSize ?? 0;
      if (blockSize < 0) {
        throw new RangeError("blockSize option must be >= 0");
      }
      if (blockSize === 0) {
        blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      }
      if (offset < 0) {
        throw new RangeError("offset option must be >= 0");
      }
      if (count && count <= 0) {
        throw new RangeError("count option must be greater than 0");
      }
      if (!options2.conditions) {
        options2.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToBuffer", options2, async (updatedOptions) => {
        if (!count) {
          const response2 = await this.getProperties({
            ...options2,
            tracingOptions: updatedOptions.tracingOptions
          });
          count = response2.contentLength - offset;
          if (count < 0) {
            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response2.contentLength}`);
          }
        }
        if (!buffer) {
          try {
            buffer = Buffer.alloc(count);
          } catch (error2) {
            throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${error2.message}`);
          }
        }
        if (buffer.length < count) {
          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
        }
        let transferProgress = 0;
        const batch = new Batch_js_1.Batch(options2.concurrency);
        for (let off = offset; off < offset + count; off = off + blockSize) {
          batch.addOperation(async () => {
            let chunkEnd = offset + count;
            if (off + blockSize < chunkEnd) {
              chunkEnd = off + blockSize;
            }
            const response2 = await this.download(off, chunkEnd - off, {
              abortSignal: options2.abortSignal,
              conditions: options2.conditions,
              maxRetryRequests: options2.maxRetryRequestsPerBlock,
              customerProvidedKey: options2.customerProvidedKey,
              tracingOptions: updatedOptions.tracingOptions
            });
            const stream = response2.readableStreamBody;
            await (0, utils_js_1.streamToBuffer)(stream, buffer, off - offset, chunkEnd - offset);
            transferProgress += chunkEnd - off;
            if (options2.onProgress) {
              options2.onProgress({ loadedBytes: transferProgress });
            }
          });
        }
        await batch.do();
        return buffer;
      });
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param filePath -
     * @param offset - From which position of the block blob to download.
     * @param count - How much data to be downloaded. Will download to the end when passing undefined.
     * @param options - Options to Blob download options.
     * @returns The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     */
    async downloadToFile(filePath, offset = 0, count, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToFile", options2, async (updatedOptions) => {
        const response2 = await this.download(offset, count, {
          ...options2,
          tracingOptions: updatedOptions.tracingOptions
        });
        if (response2.readableStreamBody) {
          await (0, utils_js_1.readStreamToLocalFile)(response2.readableStreamBody, filePath);
        }
        response2.blobDownloadStream = void 0;
        return response2;
      });
    }
    getBlobAndContainerNamesFromUrl() {
      let containerName;
      let blobName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.host.split(".")[1] === "blob") {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          containerName = pathComponents[2];
          blobName = pathComponents[4];
        } else {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        }
        containerName = decodeURIComponent(containerName);
        blobName = decodeURIComponent(blobName);
        blobName = blobName.replace(/\\/g, "/");
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return { blobName, containerName };
      } catch (error2) {
        throw new Error("Unable to extract blobName and containerName with provided information.");
      }
    }
    /**
     * Asynchronously copies a blob to a destination within the storage account.
     * In version 2012-02-12 and later, the source for a Copy Blob operation can be
     * a committed blob in any Azure storage account.
     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
     * an Azure file in any Azure storage account.
     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
     * operation to copy from another storage account.
     * @see https://learn.microsoft.com/rest/api/storageservices/copy-blob
     *
     * @param copySource - url to the source Azure Blob/File.
     * @param options - Optional options to the Blob Start Copy From URL operation.
     */
    async startCopyFromURL(copySource, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-startCopyFromURL", options2, async (updatedOptions) => {
        options2.conditions = options2.conditions || {};
        options2.sourceConditions = options2.sourceConditions || {};
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.startCopyFromURL(copySource, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          metadata: options2.metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options2.sourceConditions.ifMatch,
            sourceIfModifiedSince: options2.sourceConditions.ifModifiedSince,
            sourceIfNoneMatch: options2.sourceConditions.ifNoneMatch,
            sourceIfUnmodifiedSince: options2.sourceConditions.ifUnmodifiedSince,
            sourceIfTags: options2.sourceConditions.tagConditions
          },
          immutabilityPolicyExpiry: options2.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options2.immutabilityPolicy?.policyMode,
          legalHold: options2.legalHold,
          rehydratePriority: options2.rehydratePriority,
          tier: (0, models_js_1.toAccessTier)(options2.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          sealBlob: options2.sealBlob,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Only available for BlobClient constructed with a shared key credential.
     *
     * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options2) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options2
        }, this.credential).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    /**
     * Only available for BlobClient constructed with a shared key credential.
     *
     * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
     * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
    generateSasStringToSign(options2) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...options2
      }, this.credential).stringToSign;
    }
    /**
     *
     * Generates a Blob Service Shared Access Signature (SAS) URI based on
     * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateUserDelegationSasUrl(options2, userDelegationKey) {
      return new Promise((resolve) => {
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options2
        }, userDelegationKey, this.accountName).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    /**
     * Only available for BlobClient constructed with a shared key credential.
     *
     * Generates string to sign for a Blob Service Shared Access Signature (SAS) URI based on
     * the client properties and parameters passed in. The SAS is signed by the input user delegation key.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateUserDelegationSasStringToSign(options2, userDelegationKey) {
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...options2
      }, userDelegationKey, this.accountName).stringToSign;
    }
    /**
     * Delete the immutablility policy on the blob.
     *
     * @param options - Optional options to delete immutability policy on the blob.
     */
    async deleteImmutabilityPolicy(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.deleteImmutabilityPolicy({
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Set immutability policy on the blob.
     *
     * @param options - Optional options to set immutability policy on the blob.
     */
    async setImmutabilityPolicy(immutabilityPolicy, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setImmutabilityPolicy({
          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
          immutabilityPolicyMode: immutabilityPolicy.policyMode,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Set legal hold on the blob.
     *
     * @param options - Optional options to set legal hold on the blob.
     */
    async setLegalHold(legalHoldEnabled, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setLegalHold", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setLegalHold(legalHoldEnabled, {
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The Get Account Information operation returns the sku name and account kind
     * for the specified account.
     * The Get Account Information operation is available on service versions beginning
     * with version 2018-03-28.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
     *
     * @param options - Options to the Service Get Account Info operation.
     * @returns Response data for the Service Get Account Info operation.
     */
    async getAccountInfo(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-getAccountInfo", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.getAccountInfo({
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  Clients.BlobClient = BlobClient;
  class AppendBlobClient extends BlobClient {
    /**
     * appendBlobsContext provided by protocol layer.
     */
    appendBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options2) {
      let pipeline2;
      let url;
      options2 = options2 || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline2 = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options2 = blobNameOrOptions;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options2);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options2.proxyOptions) {
              options2.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline2 = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options2);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline2);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    /**
     * Creates a new AppendBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.
     */
    withSnapshot(snapshot) {
      return new AppendBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    /**
     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param options - Options to the Append Block Create operation.
     *
     *
     * Example usage:
     *
     * ```ts snippet:ClientsCreateAppendBlob
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * const appendBlobClient = containerClient.getAppendBlobClient(blobName);
     * await appendBlobClient.create();
     * ```
     */
    async create(options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-create", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.create(0, {
          abortSignal: options2.abortSignal,
          blobHttpHeaders: options2.blobHTTPHeaders,
          leaseAccessConditions: options2.conditions,
          metadata: options2.metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          immutabilityPolicyExpiry: options2.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options2.immutabilityPolicy?.policyMode,
          legalHold: options2.legalHold,
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
     * If the blob with the same name already exists, the content of the existing blob will remain unchanged.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param options -
     */
    async createIfNotExists(options2 = {}) {
      const conditions = { ifNoneMatch: constants_js_1.ETagAny };
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-createIfNotExists", options2, async (updatedOptions) => {
        try {
          const res = (0, utils_common_js_1.assertResponse)(await this.create({
            ...updatedOptions,
            conditions
          }));
          return {
            succeeded: true,
            ...res,
            _response: res._response
            // _response is made non-enumerable
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobAlreadyExists") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    /**
     * Seals the append blob, making it read only.
     *
     * @param options -
     */
    async seal(options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-seal", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.seal({
          abortSignal: options2.abortSignal,
          appendPositionAccessConditions: options2.conditions,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Commits a new block of data to the end of the existing append blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/append-block
     *
     * @param body - Data to be appended.
     * @param contentLength - Length of the body in bytes.
     * @param options - Options to the Append Block operation.
     *
     *
     * Example usage:
     *
     * ```ts snippet:ClientsAppendBlock
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * const content = "Hello World!";
     *
     * // Create a new append blob and append data to the blob.
     * const newAppendBlobClient = containerClient.getAppendBlobClient(blobName);
     * await newAppendBlobClient.create();
     * await newAppendBlobClient.appendBlock(content, content.length);
     *
     * // Append data to an existing append blob.
     * const existingAppendBlobClient = containerClient.getAppendBlobClient(blobName);
     * await existingAppendBlobClient.appendBlock(content, content.length);
     * ```
     */
    async appendBlock(body2, contentLength, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlock", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlock(contentLength, body2, {
          abortSignal: options2.abortSignal,
          appendPositionAccessConditions: options2.conditions,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options2.onProgress
          },
          transactionalContentMD5: options2.transactionalContentMD5,
          transactionalContentCrc64: options2.transactionalContentCrc64,
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The Append Block operation commits a new block of data to the end of an existing append blob
     * where the contents are read from a source url.
     * @see https://learn.microsoft.com/rest/api/storageservices/append-block-from-url
     *
     * @param sourceURL -
     *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can
     *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob
     *                 must either be public or must be authenticated via a shared access signature. If the source blob is
     *                 public, no authentication is required to perform the operation.
     * @param sourceOffset - Offset in source to be appended
     * @param count - Number of bytes to be appended as a block
     * @param options -
     */
    async appendBlockFromURL(sourceURL, sourceOffset, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      options2.sourceConditions = options2.sourceConditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
          abortSignal: options2.abortSignal,
          sourceRange: (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }),
          sourceContentMD5: options2.sourceContentMD5,
          sourceContentCrc64: options2.sourceContentCrc64,
          leaseAccessConditions: options2.conditions,
          appendPositionAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options2.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options2.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options2.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options2.sourceConditions?.ifUnmodifiedSince
          },
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options2.sourceAuthorization),
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          fileRequestIntent: options2.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  Clients.AppendBlobClient = AppendBlobClient;
  class BlockBlobClient extends BlobClient {
    /**
     * blobContext provided by protocol layer.
     *
     * Note. Ideally BlobClient should set BlobClient.blobContext to protected. However, API
     * extractor has issue blocking that. Here we redecelare _blobContext in BlockBlobClient.
     */
    _blobContext;
    /**
     * blockBlobContext provided by protocol layer.
     */
    blockBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options2) {
      let pipeline2;
      let url;
      options2 = options2 || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline2 = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options2 = blobNameOrOptions;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options2);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options2 = blobNameOrOptions;
        }
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options2.proxyOptions) {
              options2.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline2 = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options2);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline2);
      this.blockBlobContext = this.storageClientContext.blockBlob;
      this._blobContext = this.storageClientContext.blob;
    }
    /**
     * Creates a new BlockBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base blob.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.
     */
    withSnapshot(snapshot) {
      return new BlockBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Quick query for a JSON or CSV formatted blob.
     *
     * Example usage (Node.js):
     *
     * ```ts snippet:ClientsQuery
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
     *
     * // Query and convert a blob to a string
     * const queryBlockBlobResponse = await blockBlobClient.query("select from BlobStorage");
     * if (queryBlockBlobResponse.readableStreamBody) {
     *   const downloadedBuffer = await streamToBuffer(queryBlockBlobResponse.readableStreamBody);
     *   const downloaded = downloadedBuffer.toString();
     *   console.log(`Query blob content: ${downloaded}`);
     * }
     *
     * async function streamToBuffer(readableStream: NodeJS.ReadableStream): Promise<Buffer> {
     *   return new Promise((resolve, reject) => {
     *     const chunks: Buffer[] = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * @param query -
     * @param options -
     */
    async query(query, options2 = {}) {
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      if (!core_util_1.isNodeLike) {
        throw new Error("This operation currently is only supported in Node.js.");
      }
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-query", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this._blobContext.query({
          abortSignal: options2.abortSignal,
          queryRequest: {
            queryType: "SQL",
            expression: query,
            inputSerialization: (0, utils_common_js_1.toQuerySerialization)(options2.inputTextConfiguration),
            outputSerialization: (0, utils_common_js_1.toQuerySerialization)(options2.outputTextConfiguration)
          },
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return new BlobQueryResponse_js_1.BlobQueryResponse(response2, {
          abortSignal: options2.abortSignal,
          onProgress: options2.onProgress,
          onError: options2.onError
        });
      });
    }
    /**
     * Creates a new block blob, or updates the content of an existing block blob.
     * Updating an existing block blob overwrites any existing metadata on the blob.
     * Partial updates are not supported; the content of the existing blob is
     * overwritten with the new content. To perform a partial update of a block blob's,
     * use {@link stageBlock} and {@link commitBlockList}.
     *
     * This is a non-parallel uploading method, please use {@link uploadFile},
     * {@link uploadStream} or {@link uploadBrowserData} for better performance
     * with concurrency uploading.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to the Block Blob Upload operation.
     * @returns Response data for the Block Blob Upload operation.
     *
     * Example usage:
     *
     * ```ts snippet:ClientsUpload
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
     *
     * const content = "Hello world!";
     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
     * ```
     */
    async upload(body2, contentLength, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-upload", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.upload(contentLength, body2, {
          abortSignal: options2.abortSignal,
          blobHttpHeaders: options2.blobHTTPHeaders,
          leaseAccessConditions: options2.conditions,
          metadata: options2.metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options2.onProgress
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          immutabilityPolicyExpiry: options2.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options2.immutabilityPolicy?.policyMode,
          legalHold: options2.legalHold,
          tier: (0, models_js_1.toAccessTier)(options2.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Creates a new Block Blob where the contents of the blob are read from a given URL.
     * This API is supported beginning with the 2020-04-08 version. Partial updates
     * are not supported with Put Blob from URL; the content of an existing blob is overwritten with
     * the content of the new blob.  To perform partial updates to a block blob’s contents using a
     * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.
     *
     * @param sourceURL - Specifies the URL of the blob. The value
     *                           may be a URL of up to 2 KB in length that specifies a blob.
     *                           The value should be URL-encoded as it would appear
     *                           in a request URI. The source blob must either be public
     *                           or must be authenticated via a shared access signature.
     *                           If the source blob is public, no authentication is required
     *                           to perform the operation. Here are some examples of source object URLs:
     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
     * @param options - Optional parameters.
     */
    async syncUploadFromURL(sourceURL, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, {
          ...options2,
          blobHttpHeaders: options2.blobHTTPHeaders,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options2.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options2.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options2.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options2.sourceConditions?.ifUnmodifiedSince,
            sourceIfTags: options2.sourceConditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options2.sourceAuthorization),
          tier: (0, models_js_1.toAccessTier)(options2.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          copySourceTags: options2.copySourceTags,
          fileRequestIntent: options2.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Uploads the specified block to the block blob's "staging area" to be later
     * committed by a call to commitBlockList.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-block
     *
     * @param blockId - A 64-byte value that is base64-encoded
     * @param body - Data to upload to the staging area.
     * @param contentLength - Number of bytes to upload.
     * @param options - Options to the Block Blob Stage Block operation.
     * @returns Response data for the Block Blob Stage Block operation.
     */
    async stageBlock(blockId, body2, contentLength, options2 = {}) {
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlock", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlock(blockId, contentLength, body2, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          requestOptions: {
            onUploadProgress: options2.onProgress
          },
          transactionalContentMD5: options2.transactionalContentMD5,
          transactionalContentCrc64: options2.transactionalContentCrc64,
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The Stage Block From URL operation creates a new block to be committed as part
     * of a blob where the contents are read from a URL.
     * This API is available starting in version 2018-03-28.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-block-from-url
     *
     * @param blockId - A 64-byte value that is base64-encoded
     * @param sourceURL - Specifies the URL of the blob. The value
     *                           may be a URL of up to 2 KB in length that specifies a blob.
     *                           The value should be URL-encoded as it would appear
     *                           in a request URI. The source blob must either be public
     *                           or must be authenticated via a shared access signature.
     *                           If the source blob is public, no authentication is required
     *                           to perform the operation. Here are some examples of source object URLs:
     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
     * @param offset - From which position of the blob to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Options to the Block Blob Stage Block From URL operation.
     * @returns Response data for the Block Blob Stage Block From URL operation.
     */
    async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options2 = {}) {
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          sourceContentMD5: options2.sourceContentMD5,
          sourceContentCrc64: options2.sourceContentCrc64,
          sourceRange: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({ offset, count }),
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options2.sourceAuthorization),
          fileRequestIntent: options2.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Writes a blob by specifying the list of block IDs that make up the blob.
     * In order to be written as part of a blob, a block must have been successfully written
     * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to
     * update a blob by uploading only those blocks that have changed, then committing the new and existing
     * blocks together. Any blocks not specified in the block list and permanently deleted.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-block-list
     *
     * @param blocks -  Array of 64-byte value that is base64-encoded
     * @param options - Options to the Block Blob Commit Block List operation.
     * @returns Response data for the Block Blob Commit Block List operation.
     */
    async commitBlockList(blocks, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-commitBlockList", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.commitBlockList({ latest: blocks }, {
          abortSignal: options2.abortSignal,
          blobHttpHeaders: options2.blobHTTPHeaders,
          leaseAccessConditions: options2.conditions,
          metadata: options2.metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          immutabilityPolicyExpiry: options2.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options2.immutabilityPolicy?.policyMode,
          legalHold: options2.legalHold,
          tier: (0, models_js_1.toAccessTier)(options2.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Returns the list of blocks that have been uploaded as part of a block blob
     * using the specified block list filter.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-block-list
     *
     * @param listType - Specifies whether to return the list of committed blocks,
     *                                        the list of uncommitted blocks, or both lists together.
     * @param options - Options to the Block Blob Get Block List operation.
     * @returns Response data for the Block Blob Get Block List operation.
     */
    async getBlockList(listType, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-getBlockList", options2, async (updatedOptions) => {
        const res = (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.getBlockList(listType, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        if (!res.committedBlocks) {
          res.committedBlocks = [];
        }
        if (!res.uncommittedBlocks) {
          res.uncommittedBlocks = [];
        }
        return res;
      });
    }
    // High level functions
    /**
     * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.
     *
     * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
     * to commit the block list.
     *
     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
     * `blobContentType`, enabling the browser to provide
     * functionality based on file type.
     *
     * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView
     * @param options -
     */
    async uploadData(data, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadData", options2, async (updatedOptions) => {
        if (core_util_1.isNodeLike) {
          let buffer;
          if (data instanceof Buffer) {
            buffer = data;
          } else if (data instanceof ArrayBuffer) {
            buffer = Buffer.from(data);
          } else {
            data = data;
            buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          }
          return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
        } else {
          const browserBlob = new Blob([data]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        }
      });
    }
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.
     *
     * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call
     * {@link commitBlockList} to commit the block list.
     *
     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is
     * `blobContentType`, enabling the browser to provide
     * functionality based on file type.
     *
     * @deprecated Use {@link uploadData} instead.
     *
     * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView
     * @param options - Options to upload browser data.
     * @returns Response data for the Blob Upload operation.
     */
    async uploadBrowserData(browserData, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options2, async (updatedOptions) => {
        const browserBlob = new Blob([browserData]);
        return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
      });
    }
    /**
     *
     * Uploads data to block blob. Requires a bodyFactory as the data source,
     * which need to return a {@link HttpRequestBody} object with the offset and size provided.
     *
     * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is
     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.
     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
     * to commit the block list.
     *
     * @param bodyFactory -
     * @param size - size of the data to upload.
     * @param options - Options to Upload to Block Blob operation.
     * @returns Response data for the Blob Upload operation.
     */
    async uploadSeekableInternal(bodyFactory, size, options2 = {}) {
      let blockSize = options2.blockSize ?? 0;
      if (blockSize < 0 || blockSize > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
        throw new RangeError(`blockSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
      }
      const maxSingleShotSize = options2.maxSingleShotSize ?? constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (maxSingleShotSize < 0 || maxSingleShotSize > constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
      }
      if (blockSize === 0) {
        if (size > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * constants_js_1.BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`${size} is too larger to upload to a block blob.`);
        }
        if (size > maxSingleShotSize) {
          blockSize = Math.ceil(size / constants_js_1.BLOCK_BLOB_MAX_BLOCKS);
          if (blockSize < constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
            blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
          }
        }
      }
      if (!options2.blobHTTPHeaders) {
        options2.blobHTTPHeaders = {};
      }
      if (!options2.conditions) {
        options2.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options2, async (updatedOptions) => {
        if (size <= maxSingleShotSize) {
          return (0, utils_common_js_1.assertResponse)(await this.upload(bodyFactory(0, size), size, updatedOptions));
        }
        const numBlocks = Math.floor((size - 1) / blockSize) + 1;
        if (numBlocks > constants_js_1.BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${constants_js_1.BLOCK_BLOB_MAX_BLOCKS}`);
        }
        const blockList = [];
        const blockIDPrefix = (0, core_util_2.randomUUID)();
        let transferProgress = 0;
        const batch = new Batch_js_1.Batch(options2.concurrency);
        for (let i = 0; i < numBlocks; i++) {
          batch.addOperation(async () => {
            const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, i);
            const start = blockSize * i;
            const end = i === numBlocks - 1 ? size : start + blockSize;
            const contentLength = end - start;
            blockList.push(blockID);
            await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {
              abortSignal: options2.abortSignal,
              conditions: options2.conditions,
              encryptionScope: options2.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            });
            transferProgress += contentLength;
            if (options2.onProgress) {
              options2.onProgress({
                loadedBytes: transferProgress
              });
            }
          });
        }
        await batch.do();
        return this.commitBlockList(blockList, updatedOptions);
      });
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a local file in blocks to a block blob.
     *
     * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.
     * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList
     * to commit the block list.
     *
     * @param filePath - Full path of local file
     * @param options - Options to Upload to Block Blob operation.
     * @returns Response data for the Blob Upload operation.
     */
    async uploadFile(filePath, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadFile", options2, async (updatedOptions) => {
        const size = (await (0, utils_js_1.fsStat)(filePath)).size;
        return this.uploadSeekableInternal((offset, count) => {
          return () => (0, utils_js_1.fsCreateReadStream)(filePath, {
            autoClose: true,
            end: count ? offset + count - 1 : Infinity,
            start: offset
          });
        }, size, {
          ...options2,
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a Node.js Readable stream into block blob.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *    parameter, which will avoid Buffer.concat() operations.
     *
     * @param stream - Node.js Readable stream
     * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB
     * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,
     *                                 positive correlation with max uploading concurrency. Default value is 5
     * @param options - Options to Upload Stream to Block Blob operation.
     * @returns Response data for the Blob Upload operation.
     */
    async uploadStream(stream, bufferSize = constants_js_1.DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options2 = {}) {
      if (!options2.blobHTTPHeaders) {
        options2.blobHTTPHeaders = {};
      }
      if (!options2.conditions) {
        options2.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadStream", options2, async (updatedOptions) => {
        let blockNum = 0;
        const blockIDPrefix = (0, core_util_2.randomUUID)();
        let transferProgress = 0;
        const blockList = [];
        const scheduler = new storage_common_1.BufferScheduler(
          stream,
          bufferSize,
          maxConcurrency,
          async (body2, length) => {
            const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, blockNum);
            blockList.push(blockID);
            blockNum++;
            await this.stageBlock(blockID, body2, length, {
              customerProvidedKey: options2.customerProvidedKey,
              conditions: options2.conditions,
              encryptionScope: options2.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            });
            transferProgress += length;
            if (options2.onProgress) {
              options2.onProgress({ loadedBytes: transferProgress });
            }
          },
          // concurrency should set a smaller value than maxConcurrency, which is helpful to
          // reduce the possibility when a outgoing handler waits for stream data, in
          // this situation, outgoing handlers are blocked.
          // Outgoing queue shouldn't be empty.
          Math.ceil(maxConcurrency / 4 * 3)
        );
        await scheduler.do();
        return (0, utils_common_js_1.assertResponse)(await this.commitBlockList(blockList, {
          ...options2,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  Clients.BlockBlobClient = BlockBlobClient;
  class PageBlobClient extends BlobClient {
    /**
     * pageBlobsContext provided by protocol layer.
     */
    pageBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options2) {
      let pipeline2;
      let url;
      options2 = options2 || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline2 = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        options2 = blobNameOrOptions;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options2);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options2.proxyOptions) {
              options2.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline2 = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options2);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url, pipeline2);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    /**
     * Creates a new PageBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.
     */
    withSnapshot(snapshot) {
      return new PageBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    /**
     * Creates a page blob of the specified length. Call uploadPages to upload data
     * data to a page blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param size - size of the page blob.
     * @param options - Options to the Page Blob Create operation.
     * @returns Response data for the Page Blob Create operation.
     */
    async create(size, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-create", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.create(0, size, {
          abortSignal: options2.abortSignal,
          blobHttpHeaders: options2.blobHTTPHeaders,
          blobSequenceNumber: options2.blobSequenceNumber,
          leaseAccessConditions: options2.conditions,
          metadata: options2.metadata,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          immutabilityPolicyExpiry: options2.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options2.immutabilityPolicy?.policyMode,
          legalHold: options2.legalHold,
          tier: (0, models_js_1.toAccessTier)(options2.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options2.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Creates a page blob of the specified length. Call uploadPages to upload data
     * data to a page blob. If the blob with the same name already exists, the content
     * of the existing blob will remain unchanged.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param size - size of the page blob.
     * @param options -
     */
    async createIfNotExists(size, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-createIfNotExists", options2, async (updatedOptions) => {
        try {
          const conditions = { ifNoneMatch: constants_js_1.ETagAny };
          const res = (0, utils_common_js_1.assertResponse)(await this.create(size, {
            ...options2,
            conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
          return {
            succeeded: true,
            ...res,
            _response: res._response
            // _response is made non-enumerable
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobAlreadyExists") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    /**
     * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-page
     *
     * @param body - Data to upload
     * @param offset - Offset of destination page blob
     * @param count - Content length of the body, also number of bytes to be uploaded
     * @param options - Options to the Page Blob Upload Pages operation.
     * @returns Response data for the Page Blob Upload Pages operation.
     */
    async uploadPages(body2, offset, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPages", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPages(count, body2, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options2.onProgress
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          sequenceNumberAccessConditions: options2.conditions,
          transactionalContentMD5: options2.transactionalContentMD5,
          transactionalContentCrc64: options2.transactionalContentCrc64,
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The Upload Pages operation writes a range of pages to a page blob where the
     * contents are read from a URL.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-page-from-url
     *
     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication
     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob
     * @param destOffset - Offset of destination page blob
     * @param count - Number of bytes to be uploaded from source page blob
     * @param options -
     */
    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      options2.sourceConditions = options2.sourceConditions || {};
      (0, models_js_1.ensureCpkIfSpecified)(options2.customerProvidedKey, this.isHttps);
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPagesFromURL(sourceURL, (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }), 0, (0, Range_js_1.rangeToString)({ offset: destOffset, count }), {
          abortSignal: options2.abortSignal,
          sourceContentMD5: options2.sourceContentMD5,
          sourceContentCrc64: options2.sourceContentCrc64,
          leaseAccessConditions: options2.conditions,
          sequenceNumberAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options2.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options2.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options2.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options2.sourceConditions?.ifUnmodifiedSince
          },
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options2.sourceAuthorization),
          fileRequestIntent: options2.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Frees the specified pages from the page blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/put-page
     *
     * @param offset - Starting byte position of the pages to clear.
     * @param count - Number of bytes to clear.
     * @param options - Options to the Page Blob Clear Pages operation.
     * @returns Response data for the Page Blob Clear Pages operation.
     */
    async clearPages(offset = 0, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-clearPages", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.clearPages(0, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          sequenceNumberAccessConditions: options2.conditions,
          cpkInfo: options2.customerProvidedKey,
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Returns the list of valid page ranges for a page blob or snapshot of a page blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param options - Options to the Page Blob Get Ranges operation.
     * @returns Response data for the Page Blob Get Ranges operation.
     */
    async getPageRanges(offset = 0, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRanges", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response2);
      });
    }
    /**
     * getPageRangesSegment returns a single segment of page ranges starting from the
     * specified Marker. Use an empty Marker to start enumeration from the beginning.
     * After getting a segment, process it, and then call getPageRangesSegment again
     * (passing the the previously-returned Marker) to get the next segment.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to PageBlob Get Page Ranges Segment operation.
     */
    async listPageRangesSegment(offset = 0, count, marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          marker,
          maxPageSize: options2.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param marker - A string value that identifies the portion of
     *                          the get of page ranges to be returned with the next getting operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          getting operation did not return all page ranges remaining within the current page.
     *                          The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of get
     *                          items. The marker value is opaque to the client.
     * @param options - Options to List Page Ranges operation.
     */
    async *listPageRangeItemSegments(offset = 0, count, marker, options2 = {}) {
      let getPageRangeItemSegmentsResponse;
      if (!!marker || marker === void 0) {
        do {
          getPageRangeItemSegmentsResponse = await this.listPageRangesSegment(offset, count, marker, options2);
          marker = getPageRangeItemSegmentsResponse.continuationToken;
          yield await getPageRangeItemSegmentsResponse;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param options - Options to List Page Ranges operation.
     */
    async *listPageRangeItems(offset = 0, count, options2 = {}) {
      let marker;
      for await (const getPageRangesSegment of this.listPageRangeItemSegments(offset, count, marker, options2)) {
        yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
      }
    }
    /**
     * Returns an async iterable iterator to list of page ranges for a page blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.
     *
     * ```ts snippet:ClientsListPageBlobs
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const pageBlobClient = containerClient.getPageBlobClient(blobName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * for await (const pageRange of pageBlobClient.listPageRanges()) {
     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = pageBlobClient.listPageRanges();
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Page range ${i++}: ${value.start} - ${value.end}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {
     *   for (const pageRange of page.pageRange || []) {
     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 page ranges
     * if (response.pageRange) {
     *   for (const pageRange of response.pageRange) {
     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 page ranges
     * if (response.pageRange) {
     *   for (const pageRange of response.pageRange) {
     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     *   }
     * }
     * ```
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param options - Options to the Page Blob Get Ranges operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    listPageRanges(offset = 0, count, options2 = {}) {
      options2.conditions = options2.conditions || {};
      const iter = this.listPageRangeItems(offset, count, options2);
      return {
        /**
         * The next method, part of the iteration protocol
         */
        next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.listPageRangeItemSegments(offset, count, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...options2
          });
        }
      };
    }
    /**
     * Gets the collection of page ranges that differ between a specified snapshot and this page blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param offset - Starting byte position of the page blob
     * @param count - Number of bytes to get ranges diff.
     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
     * @param options - Options to the Page Blob Get Page Ranges Diff operation.
     * @returns Response data for the Page Blob Get Page Range Diff operation.
     */
    async getPageRangesDiff(offset, count, prevSnapshot, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options2, async (updatedOptions) => {
        const result = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          prevsnapshot: prevSnapshot,
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(result);
      });
    }
    /**
     * getPageRangesDiffSegment returns a single segment of page ranges starting from the
     * specified Marker for difference between previous snapshot and the target page blob.
     * Use an empty Marker to start enumeration from the beginning.
     * After getting a segment, process it, and then call getPageRangesDiffSegment again
     * (passing the the previously-returned Marker) to get the next segment.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
     * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.
     * @param options - Options to the Page Blob Get Page Ranges Diff operation.
     */
    async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options2?.abortSignal,
          leaseAccessConditions: options2?.conditions,
          modifiedAccessConditions: {
            ...options2?.conditions,
            ifTags: options2?.conditions?.tagConditions
          },
          prevsnapshot: prevSnapshotOrUrl,
          range: (0, Range_js_1.rangeToString)({
            offset,
            count
          }),
          marker,
          maxPageSize: options2?.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}
     *
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
     * @param marker - A string value that identifies the portion of
     *                          the get of page ranges to be returned with the next getting operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          getting operation did not return all page ranges remaining within the current page.
     *                          The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of get
     *                          items. The marker value is opaque to the client.
     * @param options - Options to the Page Blob Get Page Ranges Diff operation.
     */
    async *listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options2) {
      let getPageRangeItemSegmentsResponse;
      if (!!marker || marker === void 0) {
        do {
          getPageRangeItemSegmentsResponse = await this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options2);
          marker = getPageRangeItemSegmentsResponse.continuationToken;
          yield await getPageRangeItemSegmentsResponse;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.
     * @param options - Options to the Page Blob Get Page Ranges Diff operation.
     */
    async *listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options2) {
      let marker;
      for await (const getPageRangesSegment of this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options2)) {
        yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
      }
    }
    /**
     * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.
     *
     * ```ts snippet:ClientsListPageBlobsDiff
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const pageBlobClient = containerClient.getPageBlobClient(blobName);
     *
     * const offset = 0;
     * const count = 1024;
     * const previousSnapshot = "<previous snapshot>";
     * // Example using `for await` syntax
     * let i = 1;
     * for await (const pageRange of pageBlobClient.listPageRangesDiff(offset, count, previousSnapshot)) {
     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = pageBlobClient.listPageRangesDiff(offset, count, previousSnapshot);
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Page range ${i++}: ${value.start} - ${value.end}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of pageBlobClient
     *   .listPageRangesDiff(offset, count, previousSnapshot)
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const pageRange of page.pageRange || []) {
     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = pageBlobClient
     *   .listPageRangesDiff(offset, count, previousSnapshot)
     *   .byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 page ranges
     * if (response.pageRange) {
     *   for (const pageRange of response.pageRange) {
     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = pageBlobClient
     *   .listPageRangesDiff(offset, count, previousSnapshot)
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 page ranges
     * if (response.pageRange) {
     *   for (const pageRange of response.pageRange) {
     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);
     *   }
     * }
     * ```
     *
     * @param offset - Starting byte position of the page ranges.
     * @param count - Number of bytes to get.
     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.
     * @param options - Options to the Page Blob Get Ranges operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    listPageRangesDiff(offset, count, prevSnapshot, options2 = {}) {
      options2.conditions = options2.conditions || {};
      const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, {
        ...options2
      });
      return {
        /**
         * The next method, part of the iteration protocol
         */
        next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...options2
          });
        }
      };
    }
    /**
     * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param offset - Starting byte position of the page blob
     * @param count - Number of bytes to get ranges diff.
     * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.
     * @param options - Options to the Page Blob Get Page Ranges Diff operation.
     * @returns Response data for the Page Blob Get Page Range Diff operation.
     */
    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          prevSnapshotUrl,
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response2);
      });
    }
    /**
     * Resizes the page blob to the specified size (which must be a multiple of 512).
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
     *
     * @param size - Target size
     * @param options - Options to the Page Blob Resize operation.
     * @returns Response data for the Page Blob Resize operation.
     */
    async resize(size, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-resize", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.resize(size, {
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          encryptionScope: options2.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Sets a page blob's sequence number.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties
     *
     * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.
     * @param sequenceNumber - Required if sequenceNumberAction is max or update
     * @param options - Options to the Page Blob Update Sequence Number operation.
     * @returns Response data for the Page Blob Update Sequence Number operation.
     */
    async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {
          abortSignal: options2.abortSignal,
          blobSequenceNumber: sequenceNumber,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.
     * The snapshot is copied such that only the differential changes between the previously
     * copied snapshot are transferred to the destination.
     * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.
     * @see https://learn.microsoft.com/rest/api/storageservices/incremental-copy-blob
     * @see https://learn.microsoft.com/azure/virtual-machines/windows/incremental-snapshots
     *
     * @param copySource - Specifies the name of the source page blob snapshot. For example,
     *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
     * @param options - Options to the Page Blob Copy Incremental operation.
     * @returns Response data for the Page Blob Copy Incremental operation.
     */
    async startCopyIncremental(copySource, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-startCopyIncremental", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.copyIncremental(copySource, {
          abortSignal: options2.abortSignal,
          modifiedAccessConditions: {
            ...options2.conditions,
            ifTags: options2.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  Clients.PageBlobClient = PageBlobClient;
  return Clients;
}
var BlobBatchClient = {};
var BatchResponseParser = {};
var BatchUtils = {};
var hasRequiredBatchUtils;
function requireBatchUtils() {
  if (hasRequiredBatchUtils) return BatchUtils;
  hasRequiredBatchUtils = 1;
  Object.defineProperty(BatchUtils, "__esModule", { value: true });
  BatchUtils.getBodyAsText = getBodyAsText;
  BatchUtils.utf8ByteLength = utf8ByteLength;
  const utils_js_1 = /* @__PURE__ */ requireUtils();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  async function getBodyAsText(batchResponse) {
    let buffer = Buffer.alloc(constants_js_1.BATCH_MAX_PAYLOAD_IN_BYTES);
    const responseLength = await (0, utils_js_1.streamToBuffer2)(batchResponse.readableStreamBody, buffer);
    buffer = buffer.slice(0, responseLength);
    return buffer.toString();
  }
  function utf8ByteLength(str) {
    return Buffer.byteLength(str);
  }
  return BatchUtils;
}
var hasRequiredBatchResponseParser;
function requireBatchResponseParser() {
  if (hasRequiredBatchResponseParser) return BatchResponseParser;
  hasRequiredBatchResponseParser = 1;
  Object.defineProperty(BatchResponseParser, "__esModule", { value: true });
  BatchResponseParser.BatchResponseParser = void 0;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_http_compat_1 = /* @__PURE__ */ requireCommonjs$4();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const BatchUtils_js_1 = /* @__PURE__ */ requireBatchUtils();
  const log_js_1 = /* @__PURE__ */ requireLog$1();
  const HTTP_HEADER_DELIMITER = ": ";
  const SPACE_DELIMITER = " ";
  const NOT_FOUND = -1;
  let BatchResponseParser$1 = class BatchResponseParser {
    batchResponse;
    responseBatchBoundary;
    perResponsePrefix;
    batchResponseEnding;
    subRequests;
    constructor(batchResponse, subRequests) {
      if (!batchResponse || !batchResponse.contentType) {
        throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
      }
      if (!subRequests || subRequests.size === 0) {
        throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
      }
      this.batchResponse = batchResponse;
      this.subRequests = subRequests;
      this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
      this.perResponsePrefix = `--${this.responseBatchBoundary}${constants_js_1.HTTP_LINE_ENDING}`;
      this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    // For example of response, please refer to https://learn.microsoft.com/rest/api/storageservices/blob-batch#response
    async parseBatchResponse() {
      if (this.batchResponse._response.status !== constants_js_1.HTTPURLConnection.HTTP_ACCEPTED) {
        throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
      }
      const responseBodyAsText = await (0, BatchUtils_js_1.getBodyAsText)(this.batchResponse);
      const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
      const subResponseCount = subResponses.length;
      if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
        throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
      }
      const deserializedSubResponses = new Array(subResponseCount);
      let subResponsesSucceededCount = 0;
      let subResponsesFailedCount = 0;
      for (let index = 0; index < subResponseCount; index++) {
        const subResponse = subResponses[index];
        const deserializedSubResponse = {};
        deserializedSubResponse.headers = (0, core_http_compat_1.toHttpHeadersLike)((0, core_rest_pipeline_1.createHttpHeaders)());
        const responseLines = subResponse.split(`${constants_js_1.HTTP_LINE_ENDING}`);
        let subRespHeaderStartFound = false;
        let subRespHeaderEndFound = false;
        let subRespFailed = false;
        let contentId = NOT_FOUND;
        for (const responseLine of responseLines) {
          if (!subRespHeaderStartFound) {
            if (responseLine.startsWith(constants_js_1.HeaderConstants.CONTENT_ID)) {
              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
            }
            if (responseLine.startsWith(constants_js_1.HTTP_VERSION_1_1)) {
              subRespHeaderStartFound = true;
              const tokens = responseLine.split(SPACE_DELIMITER);
              deserializedSubResponse.status = parseInt(tokens[1]);
              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
            }
            continue;
          }
          if (responseLine.trim() === "") {
            if (!subRespHeaderEndFound) {
              subRespHeaderEndFound = true;
            }
            continue;
          }
          if (!subRespHeaderEndFound) {
            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
            }
            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
            deserializedSubResponse.headers.set(tokens[0], tokens[1]);
            if (tokens[0] === constants_js_1.HeaderConstants.X_MS_ERROR_CODE) {
              deserializedSubResponse.errorCode = tokens[1];
              subRespFailed = true;
            }
          } else {
            if (!deserializedSubResponse.bodyAsText) {
              deserializedSubResponse.bodyAsText = "";
            }
            deserializedSubResponse.bodyAsText += responseLine;
          }
        }
        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === void 0) {
          deserializedSubResponse._request = this.subRequests.get(contentId);
          deserializedSubResponses[contentId] = deserializedSubResponse;
        } else {
          log_js_1.logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
        }
        if (subRespFailed) {
          subResponsesFailedCount++;
        } else {
          subResponsesSucceededCount++;
        }
      }
      return {
        subResponses: deserializedSubResponses,
        subResponsesSucceededCount,
        subResponsesFailedCount
      };
    }
  };
  BatchResponseParser.BatchResponseParser = BatchResponseParser$1;
  return BatchResponseParser;
}
var BlobBatch = {};
var Mutex = {};
var hasRequiredMutex;
function requireMutex() {
  if (hasRequiredMutex) return Mutex;
  hasRequiredMutex = 1;
  Object.defineProperty(Mutex, "__esModule", { value: true });
  Mutex.Mutex = void 0;
  var MutexLockStatus;
  (function(MutexLockStatus2) {
    MutexLockStatus2[MutexLockStatus2["LOCKED"] = 0] = "LOCKED";
    MutexLockStatus2[MutexLockStatus2["UNLOCKED"] = 1] = "UNLOCKED";
  })(MutexLockStatus || (MutexLockStatus = {}));
  let Mutex$1 = class Mutex {
    /**
     * Lock for a specific key. If the lock has been acquired by another customer, then
     * will wait until getting the lock.
     *
     * @param key - lock key
     */
    static async lock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === void 0 || this.keys[key] === MutexLockStatus.UNLOCKED) {
          this.keys[key] = MutexLockStatus.LOCKED;
          resolve();
        } else {
          this.onUnlockEvent(key, () => {
            this.keys[key] = MutexLockStatus.LOCKED;
            resolve();
          });
        }
      });
    }
    /**
     * Unlock a key.
     *
     * @param key -
     */
    static async unlock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === MutexLockStatus.LOCKED) {
          this.emitUnlockEvent(key);
        }
        delete this.keys[key];
        resolve();
      });
    }
    static keys = {};
    static listeners = {};
    static onUnlockEvent(key, handler) {
      if (this.listeners[key] === void 0) {
        this.listeners[key] = [handler];
      } else {
        this.listeners[key].push(handler);
      }
    }
    static emitUnlockEvent(key) {
      if (this.listeners[key] !== void 0 && this.listeners[key].length > 0) {
        const handler = this.listeners[key].shift();
        setImmediate(() => {
          handler.call(this);
        });
      }
    }
  };
  Mutex.Mutex = Mutex$1;
  return Mutex;
}
var hasRequiredBlobBatch;
function requireBlobBatch() {
  if (hasRequiredBlobBatch) return BlobBatch;
  hasRequiredBlobBatch = 1;
  Object.defineProperty(BlobBatch, "__esModule", { value: true });
  BlobBatch.BlobBatch = void 0;
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const core_auth_1 = /* @__PURE__ */ requireCommonjs$6();
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_util_2 = /* @__PURE__ */ requireCommonjs$9();
  const AnonymousCredential_js_1 = /* @__PURE__ */ requireAnonymousCredential$1();
  const Clients_js_1 = /* @__PURE__ */ requireClients();
  const Mutex_js_1 = /* @__PURE__ */ requireMutex();
  const Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  const core_xml_1 = /* @__PURE__ */ requireCommonjs$3();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const StorageSharedKeyCredential_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredential$1();
  const tracing_js_1 = /* @__PURE__ */ requireTracing();
  const core_client_1 = /* @__PURE__ */ requireCommonjs$5();
  const StorageSharedKeyCredentialPolicyV2_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredentialPolicyV2();
  let BlobBatch$1 = class BlobBatch {
    batchRequest;
    batch = "batch";
    batchType;
    constructor() {
      this.batchRequest = new InnerBatchRequest();
    }
    /**
     * Get the value of Content-Type for a batch request.
     * The value must be multipart/mixed with a batch boundary.
     * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252
     */
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    /**
     * Get assembled HTTP request body for sub requests.
     */
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    /**
     * Get sub requests that are added into the batch request.
     */
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
      await Mutex_js_1.Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(subRequest);
        await assembleSubRequestFunc();
        this.batchRequest.postAddSubRequest(subRequest);
      } finally {
        await Mutex_js_1.Mutex.unlock(this.batch);
      }
    }
    setBatchType(batchType) {
      if (!this.batchType) {
        this.batchType = batchType;
      }
      if (this.batchType !== batchType) {
        throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
      }
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options2) {
      let url;
      let credential;
      if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrOptions instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrOptions))) {
        url = urlOrBlobClient;
        credential = credentialOrOptions;
      } else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
        url = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        options2 = credentialOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options2) {
        options2 = {};
      }
      return tracing_js_1.tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options2, async (updatedOptions) => {
        this.setBatchType("delete");
        await this.addSubRequestInternal({
          url,
          credential
        }, async () => {
          await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
        });
      });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options2) {
      let url;
      let credential;
      let tier;
      if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrTier instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrTier))) {
        url = urlOrBlobClient;
        credential = credentialOrTier;
        tier = tierOrOptions;
      } else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
        url = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        tier = credentialOrTier;
        options2 = tierOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options2) {
        options2 = {};
      }
      return tracing_js_1.tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options2, async (updatedOptions) => {
        this.setBatchType("setAccessTier");
        await this.addSubRequestInternal({
          url,
          credential
        }, async () => {
          await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
        });
      });
    }
  };
  BlobBatch.BlobBatch = BlobBatch$1;
  class InnerBatchRequest {
    operationCount;
    body;
    subRequests;
    boundary;
    subRequestPrefix;
    multipartContentType;
    batchRequestEnding;
    constructor() {
      this.operationCount = 0;
      this.body = "";
      const tempGuid = (0, core_util_1.randomUUID)();
      this.boundary = `batch_${tempGuid}`;
      this.subRequestPrefix = `--${this.boundary}${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TYPE}: application/http${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
      this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
      this.batchRequestEnding = `--${this.boundary}--`;
      this.subRequests = /* @__PURE__ */ new Map();
    }
    /**
     * Create pipeline to assemble sub requests. The idea here is to use existing
     * credential and serialization/deserialization components, with additional policies to
     * filter unnecessary headers, assemble sub requests into request's body
     * and intercept request from going to wire.
     * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.
     */
    createPipeline(credential) {
      const corePipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
      corePipeline.addPolicy((0, core_client_1.serializationPolicy)({
        stringifyXML: core_xml_1.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }), { phase: "Serialize" });
      corePipeline.addPolicy(batchHeaderFilterPolicy());
      corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
      if ((0, core_auth_1.isTokenCredential)(credential)) {
        corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential,
          scopes: constants_js_1.StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) {
        corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      const pipeline2 = new Pipeline_js_1.Pipeline([]);
      pipeline2._credential = credential;
      pipeline2._corePipeline = corePipeline;
      return pipeline2;
    }
    appendSubRequestToBody(request2) {
      this.body += [
        this.subRequestPrefix,
        // sub request constant prefix
        `${constants_js_1.HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        // sub request's content ID
        "",
        // empty line after sub request's content ID
        `${request2.method.toString()} ${(0, utils_common_js_1.getURLPathAndQuery)(request2.url)} ${constants_js_1.HTTP_VERSION_1_1}${constants_js_1.HTTP_LINE_ENDING}`
        // sub request start line with method
      ].join(constants_js_1.HTTP_LINE_ENDING);
      for (const [name, value] of request2.headers) {
        this.body += `${name}: ${value}${constants_js_1.HTTP_LINE_ENDING}`;
      }
      this.body += constants_js_1.HTTP_LINE_ENDING;
    }
    preAddSubRequest(subRequest) {
      if (this.operationCount >= constants_js_1.BATCH_MAX_REQUEST) {
        throw new RangeError(`Cannot exceed ${constants_js_1.BATCH_MAX_REQUEST} sub requests in a single batch`);
      }
      const path2 = (0, utils_common_js_1.getURLPath)(subRequest.url);
      if (!path2 || path2 === "") {
        throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
      }
    }
    postAddSubRequest(subRequest) {
      this.subRequests.set(this.operationCount, subRequest);
      this.operationCount++;
    }
    // Return the http request body with assembling the ending line to the sub request body.
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${constants_js_1.HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }
  function batchRequestAssemblePolicy(batchRequest) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(request2) {
        batchRequest.appendSubRequestToBody(request2);
        return {
          request: request2,
          status: 200,
          headers: (0, core_rest_pipeline_1.createHttpHeaders)()
        };
      }
    };
  }
  function batchHeaderFilterPolicy() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(request2, next) {
        let xMsHeaderName = "";
        for (const [name] of request2.headers) {
          if ((0, utils_common_js_1.iEqual)(name, constants_js_1.HeaderConstants.X_MS_VERSION)) {
            xMsHeaderName = name;
          }
        }
        if (xMsHeaderName !== "") {
          request2.headers.delete(xMsHeaderName);
        }
        return next(request2);
      }
    };
  }
  return BlobBatch;
}
var hasRequiredBlobBatchClient;
function requireBlobBatchClient() {
  if (hasRequiredBlobBatchClient) return BlobBatchClient;
  hasRequiredBlobBatchClient = 1;
  Object.defineProperty(BlobBatchClient, "__esModule", { value: true });
  BlobBatchClient.BlobBatchClient = void 0;
  const BatchResponseParser_js_1 = /* @__PURE__ */ requireBatchResponseParser();
  const BatchUtils_js_1 = /* @__PURE__ */ requireBatchUtils();
  const BlobBatch_js_1 = /* @__PURE__ */ requireBlobBatch();
  const tracing_js_1 = /* @__PURE__ */ requireTracing();
  const AnonymousCredential_js_1 = /* @__PURE__ */ requireAnonymousCredential$1();
  const StorageContextClient_js_1 = /* @__PURE__ */ requireStorageContextClient();
  const Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  let BlobBatchClient$1 = class BlobBatchClient {
    serviceOrContainerContext;
    constructor(url, credentialOrPipeline, options2) {
      let pipeline2;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) {
        pipeline2 = credentialOrPipeline;
      } else if (!credentialOrPipeline) {
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      } else {
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options2);
      }
      const storageClientContext = new StorageContextClient_js_1.StorageContextClient(url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline2));
      const path2 = (0, utils_common_js_1.getURLPath)(url);
      if (path2 && path2 !== "/") {
        this.serviceOrContainerContext = storageClientContext.container;
      } else {
        this.serviceOrContainerContext = storageClientContext.service;
      }
    }
    /**
     * Creates a {@link BlobBatch}.
     * A BlobBatch represents an aggregated set of operations on blobs.
     */
    createBatch() {
      return new BlobBatch_js_1.BlobBatch();
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options2) {
      const batch = new BlobBatch_js_1.BlobBatch();
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options2);
        } else {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options2) {
      const batch = new BlobBatch_js_1.BlobBatch();
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options2);
        } else {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    /**
     * Submit batch request which consists of multiple subrequests.
     *
     * Get `blobBatchClient` and other details before running the snippets.
     * `blobServiceClient.getBlobBatchClient()` gives the `blobBatchClient`
     *
     * Example usage:
     *
     * ```ts snippet:BlobBatchClientSubmitBatch
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { BlobServiceClient, BlobBatch } from "@azure/storage-blob";
     *
     * const account = "<account>";
     * const credential = new DefaultAzureCredential();
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   credential,
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobBatchClient = containerClient.getBlobBatchClient();
     *
     * const batchRequest = new BlobBatch();
     * await batchRequest.deleteBlob("<blob-url-1>", credential);
     * await batchRequest.deleteBlob("<blob-url-2>", credential, {
     *   deleteSnapshots: "include",
     * });
     * const batchResp = await blobBatchClient.submitBatch(batchRequest);
     * console.log(batchResp.subResponsesSucceededCount);
     * ```
     *
     * Example using a lease:
     *
     * ```ts snippet:BlobBatchClientSubmitBatchWithLease
     * import { DefaultAzureCredential } from "@azure/identity";
     * import { BlobServiceClient, BlobBatch } from "@azure/storage-blob";
     *
     * const account = "<account>";
     * const credential = new DefaultAzureCredential();
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   credential,
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blobBatchClient = containerClient.getBlobBatchClient();
     * const blobClient = containerClient.getBlobClient("<blob name>");
     *
     * const batchRequest = new BlobBatch();
     * await batchRequest.setBlobAccessTier(blobClient, "Cool");
     * await batchRequest.setBlobAccessTier(blobClient, "Cool", {
     *   conditions: { leaseId: "<lease-id>" },
     * });
     * const batchResp = await blobBatchClient.submitBatch(batchRequest);
     * console.log(batchResp.subResponsesSucceededCount);
     * ```
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
     *
     * @param batchRequest - A set of Delete or SetTier operations.
     * @param options -
     */
    async submitBatch(batchRequest, options2 = {}) {
      if (!batchRequest || batchRequest.getSubRequests().size === 0) {
        throw new RangeError("Batch request should contain one or more sub requests.");
      }
      return tracing_js_1.tracingClient.withSpan("BlobBatchClient-submitBatch", options2, async (updatedOptions) => {
        const batchRequestBody = batchRequest.getHttpRequestBody();
        const rawBatchResponse = (0, utils_common_js_1.assertResponse)(await this.serviceOrContainerContext.submitBatch((0, BatchUtils_js_1.utf8ByteLength)(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, {
          ...updatedOptions
        }));
        const batchResponseParser = new BatchResponseParser_js_1.BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
        const responseSummary = await batchResponseParser.parseBatchResponse();
        const res = {
          _response: rawBatchResponse._response,
          contentType: rawBatchResponse.contentType,
          errorCode: rawBatchResponse.errorCode,
          requestId: rawBatchResponse.requestId,
          clientRequestId: rawBatchResponse.clientRequestId,
          version: rawBatchResponse.version,
          subResponses: responseSummary.subResponses,
          subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
          subResponsesFailedCount: responseSummary.subResponsesFailedCount
        };
        return res;
      });
    }
  };
  BlobBatchClient.BlobBatchClient = BlobBatchClient$1;
  return BlobBatchClient;
}
var hasRequiredContainerClient;
function requireContainerClient() {
  if (hasRequiredContainerClient) return ContainerClient;
  hasRequiredContainerClient = 1;
  Object.defineProperty(ContainerClient, "__esModule", { value: true });
  ContainerClient.ContainerClient = void 0;
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const core_auth_1 = /* @__PURE__ */ requireCommonjs$6();
  const AnonymousCredential_js_1 = /* @__PURE__ */ requireAnonymousCredential$1();
  const StorageSharedKeyCredential_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredential$1();
  const Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
  const StorageClient_js_1 = /* @__PURE__ */ requireStorageClient();
  const tracing_js_1 = /* @__PURE__ */ requireTracing();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  const BlobSASSignatureValues_js_1 = /* @__PURE__ */ requireBlobSASSignatureValues();
  const BlobLeaseClient_js_1 = /* @__PURE__ */ requireBlobLeaseClient();
  const Clients_js_1 = /* @__PURE__ */ requireClients();
  const BlobBatchClient_js_1 = /* @__PURE__ */ requireBlobBatchClient();
  let ContainerClient$1 = class ContainerClient extends StorageClient_js_1.StorageClient {
    /**
     * containerContext provided by protocol layer.
     */
    containerContext;
    _containerName;
    /**
     * The name of the container.
     */
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options2) {
      let pipeline2;
      let url;
      options2 = options2 || {};
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline2 = credentialOrPipelineOrContainerName;
      } else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
        url = urlOrConnectionString;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options2);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url = urlOrConnectionString;
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (core_util_1.isNodeLike) {
            const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName));
            if (!options2.proxyOptions) {
              options2.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            }
            pipeline2 = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options2);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
          pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName parameter");
      }
      super(url, pipeline2);
      this._containerName = this.getContainerNameFromUrl();
      this.containerContext = this.storageClientContext.container;
    }
    /**
     * Creates a new container under the specified account. If the container with
     * the same name already exists, the operation fails.
     * @see https://learn.microsoft.com/rest/api/storageservices/create-container
     * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
     *
     * @param options - Options to Container Create operation.
     *
     *
     * Example usage:
     *
     * ```ts snippet:ContainerClientCreate
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const createContainerResponse = await containerClient.create();
     * console.log("Container was created successfully", createContainerResponse.requestId);
     * ```
     */
    async create(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-create", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.create(updatedOptions));
      });
    }
    /**
     * Creates a new container under the specified account. If the container with
     * the same name already exists, it is not changed.
     * @see https://learn.microsoft.com/rest/api/storageservices/create-container
     * Naming rules: @see https://learn.microsoft.com/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
     *
     * @param options -
     */
    async createIfNotExists(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-createIfNotExists", options2, async (updatedOptions) => {
        try {
          const res = await this.create(updatedOptions);
          return {
            succeeded: true,
            ...res,
            _response: res._response
            // _response is made non-enumerable
          };
        } catch (e) {
          if (e.details?.errorCode === "ContainerAlreadyExists") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          } else {
            throw e;
          }
        }
      });
    }
    /**
     * Returns true if the Azure container resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing container might be deleted by other clients or
     * applications. Vice versa new containers with the same name might be added by other clients or
     * applications after this function completes.
     *
     * @param options -
     */
    async exists(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-exists", options2, async (updatedOptions) => {
        try {
          await this.getProperties({
            abortSignal: options2.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          }
          throw e;
        }
      });
    }
    /**
     * Creates a {@link BlobClient}
     *
     * @param blobName - A blob name
     * @returns A new BlobClient object for the given blob name.
     */
    getBlobClient(blobName) {
      return new Clients_js_1.BlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    /**
     * Creates an {@link AppendBlobClient}
     *
     * @param blobName - An append blob name
     */
    getAppendBlobClient(blobName) {
      return new Clients_js_1.AppendBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    /**
     * Creates a {@link BlockBlobClient}
     *
     * @param blobName - A block blob name
     *
     *
     * Example usage:
     *
     * ```ts snippet:ClientsUpload
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const blobName = "<blob name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     * const blockBlobClient = containerClient.getBlockBlobClient(blobName);
     *
     * const content = "Hello world!";
     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
     * ```
     */
    getBlockBlobClient(blobName) {
      return new Clients_js_1.BlockBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    /**
     * Creates a {@link PageBlobClient}
     *
     * @param blobName - A page blob name
     */
    getPageBlobClient(blobName) {
      return new Clients_js_1.PageBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    /**
     * Returns all user-defined metadata and system properties for the specified
     * container. The data returned does not include the container's list of blobs.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-container-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @param options - Options to Container Get Properties operation.
     */
    async getProperties(options2 = {}) {
      if (!options2.conditions) {
        options2.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getProperties", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.getProperties({
          abortSignal: options2.abortSignal,
          ...options2.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Marks the specified container for deletion. The container and any blobs
     * contained within it are later deleted during garbage collection.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-container
     *
     * @param options - Options to Container Delete operation.
     */
    async delete(options2 = {}) {
      if (!options2.conditions) {
        options2.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-delete", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.delete({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: options2.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Marks the specified container for deletion if it exists. The container and any blobs
     * contained within it are later deleted during garbage collection.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-container
     *
     * @param options - Options to Container Delete operation.
     */
    async deleteIfExists(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteIfExists", options2, async (updatedOptions) => {
        try {
          const res = await this.delete(updatedOptions);
          return {
            succeeded: true,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "ContainerNotFound") {
            return {
              succeeded: false,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          }
          throw e;
        }
      });
    }
    /**
     * Sets one or more user-defined name-value pairs for the specified container.
     *
     * If no option provided, or no metadata defined in the parameter, the container
     * metadata will be removed.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/set-container-metadata
     *
     * @param metadata - Replace existing metadata with this value.
     *                            If no value provided the existing metadata will be removed.
     * @param options - Options to Container Set Metadata operation.
     */
    async setMetadata(metadata, options2 = {}) {
      if (!options2.conditions) {
        options2.conditions = {};
      }
      if (options2.conditions.ifUnmodifiedSince) {
        throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-setMetadata", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.setMetadata({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          metadata,
          modifiedAccessConditions: options2.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Gets the permissions for the specified container. The permissions indicate
     * whether container data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-container-acl
     *
     * @param options - Options to Container Get Access Policy operation.
     */
    async getAccessPolicy(options2 = {}) {
      if (!options2.conditions) {
        options2.conditions = {};
      }
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccessPolicy", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccessPolicy({
          abortSignal: options2.abortSignal,
          leaseAccessConditions: options2.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const res = {
          _response: response2._response,
          blobPublicAccess: response2.blobPublicAccess,
          date: response2.date,
          etag: response2.etag,
          errorCode: response2.errorCode,
          lastModified: response2.lastModified,
          requestId: response2.requestId,
          clientRequestId: response2.clientRequestId,
          signedIdentifiers: [],
          version: response2.version
        };
        for (const identifier of response2) {
          let accessPolicy = void 0;
          if (identifier.accessPolicy) {
            accessPolicy = {
              permissions: identifier.accessPolicy.permissions
            };
            if (identifier.accessPolicy.expiresOn) {
              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
            }
            if (identifier.accessPolicy.startsOn) {
              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
            }
          }
          res.signedIdentifiers.push({
            accessPolicy,
            id: identifier.id
          });
        }
        return res;
      });
    }
    /**
     * Sets the permissions for the specified container. The permissions indicate
     * whether blobs in a container may be accessed publicly.
     *
     * When you set permissions for a container, the existing permissions are replaced.
     * If no access or containerAcl provided, the existing container ACL will be
     * removed.
     *
     * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-container-acl
     *
     * @param access - The level of public access to data in the container.
     * @param containerAcl - Array of elements each having a unique Id and details of the access policy.
     * @param options - Options to Container Set Access Policy operation.
     */
    async setAccessPolicy(access, containerAcl, options2 = {}) {
      options2.conditions = options2.conditions || {};
      return tracing_js_1.tracingClient.withSpan("ContainerClient-setAccessPolicy", options2, async (updatedOptions) => {
        const acl = [];
        for (const identifier of containerAcl || []) {
          acl.push({
            accessPolicy: {
              expiresOn: identifier.accessPolicy.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.expiresOn) : "",
              permissions: identifier.accessPolicy.permissions,
              startsOn: identifier.accessPolicy.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.startsOn) : ""
            },
            id: identifier.id
          });
        }
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.setAccessPolicy({
          abortSignal: options2.abortSignal,
          access,
          containerAcl: acl,
          leaseAccessConditions: options2.conditions,
          modifiedAccessConditions: options2.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Get a {@link BlobLeaseClient} that manages leases on the container.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new BlobLeaseClient object for managing leases on the container.
     */
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
    }
    /**
     * Creates a new block blob, or updates the content of an existing block blob.
     *
     * Updating an existing block blob overwrites any existing metadata on the blob.
     * Partial updates are not supported; the content of the existing blob is
     * overwritten with the new content. To perform a partial update of a block blob's,
     * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.
     *
     * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},
     * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better
     * performance with concurrency uploading.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param blobName - Name of the block blob to create or update.
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to configure the Block Blob Upload operation.
     * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.
     */
    async uploadBlockBlob(blobName, body2, contentLength, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-uploadBlockBlob", options2, async (updatedOptions) => {
        const blockBlobClient = this.getBlockBlobClient(blobName);
        const response2 = await blockBlobClient.upload(body2, contentLength, updatedOptions);
        return {
          blockBlobClient,
          response: response2
        };
      });
    }
    /**
     * Marks the specified blob or snapshot for deletion. The blob is later deleted
     * during garbage collection. Note that in order to delete a blob, you must delete
     * all of its snapshots. You can delete both at the same time with the Delete
     * Blob operation.
     * @see https://learn.microsoft.com/rest/api/storageservices/delete-blob
     *
     * @param blobName -
     * @param options - Options to Blob Delete operation.
     * @returns Block blob deletion response data.
     */
    async deleteBlob(blobName, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteBlob", options2, async (updatedOptions) => {
        let blobClient = this.getBlobClient(blobName);
        if (options2.versionId) {
          blobClient = blobClient.withVersion(options2.versionId);
        }
        return blobClient.delete(updatedOptions);
      });
    }
    /**
     * listBlobFlatSegment returns a single segment of blobs starting from the
     * specified Marker. Use an empty Marker to start enumeration from the beginning.
     * After getting a segment, process it, and then call listBlobsFlatSegment again
     * (passing the the previously-returned Marker) to get the next segment.
     * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Container List Blob Flat Segment operation.
     */
    async listBlobFlatSegment(marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobFlatSegment({
          marker,
          ...options2,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response2,
          _response: {
            ...response2._response,
            parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobFlat)(response2._response.parsedBody)
          },
          // _response is made non-enumerable
          segment: {
            ...response2.segment,
            blobItems: response2.segment.blobItems.map((blobItemInternal) => {
              const blobItem = {
                ...blobItemInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
              };
              return blobItem;
            })
          }
        };
        return wrappedResponse;
      });
    }
    /**
     * listBlobHierarchySegment returns a single segment of blobs starting from
     * the specified Marker. Use an empty Marker to start enumeration from the
     * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment
     * again (passing the the previously-returned Marker) to get the next segment.
     * @see https://learn.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Container List Blob Hierarchy Segment operation.
     */
    async listBlobHierarchySegment(delimiter, marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobHierarchySegment(delimiter, {
          marker,
          ...options2,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response2,
          _response: {
            ...response2._response,
            parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobHierarchy)(response2._response.parsedBody)
          },
          // _response is made non-enumerable
          segment: {
            ...response2.segment,
            blobItems: response2.segment.blobItems.map((blobItemInternal) => {
              const blobItem = {
                ...blobItemInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
              };
              return blobItem;
            }),
            blobPrefixes: response2.segment.blobPrefixes?.map((blobPrefixInternal) => {
              const blobPrefix = {
                ...blobPrefixInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobPrefixInternal.name)
              };
              return blobPrefix;
            })
          }
        };
        return wrappedResponse;
      });
    }
    /**
     * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list blobs operation.
     */
    async *listSegments(marker, options2 = {}) {
      let listBlobsFlatSegmentResponse;
      if (!!marker || marker === void 0) {
        do {
          listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options2);
          marker = listBlobsFlatSegmentResponse.continuationToken;
          yield await listBlobsFlatSegmentResponse;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator of {@link BlobItem} objects
     *
     * @param options - Options to list blobs operation.
     */
    async *listItems(options2 = {}) {
      let marker;
      for await (const listBlobsFlatSegmentResponse of this.listSegments(marker, options2)) {
        yield* listBlobsFlatSegmentResponse.segment.blobItems;
      }
    }
    /**
     * Returns an async iterable iterator to list all the blobs
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * ```ts snippet:ReadmeSampleListBlobs_Multiple
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * const blobs = containerClient.listBlobsFlat();
     * for await (const blob of blobs) {
     *   console.log(`Blob ${i++}: ${blob.name}`);
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = containerClient.listBlobsFlat();
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Blob ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {
     *   for (const blob of page.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 blob names
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list blobs.
     * @returns An asyncIterableIterator that supports paging.
     */
    listBlobsFlat(options2 = {}) {
      const include = [];
      if (options2.includeCopy) {
        include.push("copy");
      }
      if (options2.includeDeleted) {
        include.push("deleted");
      }
      if (options2.includeMetadata) {
        include.push("metadata");
      }
      if (options2.includeSnapshots) {
        include.push("snapshots");
      }
      if (options2.includeVersions) {
        include.push("versions");
      }
      if (options2.includeUncommitedBlobs) {
        include.push("uncommittedblobs");
      }
      if (options2.includeTags) {
        include.push("tags");
      }
      if (options2.includeDeletedWithVersions) {
        include.push("deletedwithversions");
      }
      if (options2.includeImmutabilityPolicy) {
        include.push("immutabilitypolicy");
      }
      if (options2.includeLegalHold) {
        include.push("legalhold");
      }
      if (options2.prefix === "") {
        options2.prefix = void 0;
      }
      const updatedOptions = {
        ...options2,
        ...include.length > 0 ? { include } : {}
      };
      const iter = this.listItems(updatedOptions);
      return {
        /**
         * The next method, part of the iteration protocol
         */
        next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...updatedOptions
          });
        }
      };
    }
    /**
     * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list blobs operation.
     */
    async *listHierarchySegments(delimiter, marker, options2 = {}) {
      let listBlobsHierarchySegmentResponse;
      if (!!marker || marker === void 0) {
        do {
          listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(delimiter, marker, options2);
          marker = listBlobsHierarchySegmentResponse.continuationToken;
          yield await listBlobsHierarchySegmentResponse;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param options - Options to list blobs operation.
     */
    async *listItemsByHierarchy(delimiter, options2 = {}) {
      let marker;
      for await (const listBlobsHierarchySegmentResponse of this.listHierarchySegments(delimiter, marker, options2)) {
        const segment = listBlobsHierarchySegmentResponse.segment;
        if (segment.blobPrefixes) {
          for (const prefix of segment.blobPrefixes) {
            yield {
              kind: "prefix",
              ...prefix
            };
          }
        }
        for (const blob2 of segment.blobItems) {
          yield { kind: "blob", ...blob2 };
        }
      }
    }
    /**
     * Returns an async iterable iterator to list all the blobs by hierarchy.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.
     *
     * ```ts snippet:ReadmeSampleListBlobsByHierarchy
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * const blobs = containerClient.listBlobsByHierarchy("/");
     * for await (const blob of blobs) {
     *   if (blob.kind === "prefix") {
     *     console.log(`\tBlobPrefix: ${blob.name}`);
     *   } else {
     *     console.log(`\tBlobItem: name - ${blob.name}`);
     *   }
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = containerClient.listBlobsByHierarchy("/");
     * let { value, done } = await iter.next();
     * while (!done) {
     *   if (value.kind === "prefix") {
     *     console.log(`\tBlobPrefix: ${value.name}`);
     *   } else {
     *     console.log(`\tBlobItem: name - ${value.name}`);
     *   }
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of containerClient.listBlobsByHierarchy("/").byPage({ maxPageSize: 20 })) {
     *   const segment = page.segment;
     *   if (segment.blobPrefixes) {
     *     for (const prefix of segment.blobPrefixes) {
     *       console.log(`\tBlobPrefix: ${prefix.name}`);
     *     }
     *   }
     *   for (const blob of page.segment.blobItems) {
     *     console.log(`\tBlobItem: name - ${blob.name}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = containerClient.listBlobsByHierarchy("/").byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.blobPrefixes) {
     *   for (const prefix of response.blobPrefixes) {
     *     console.log(`\tBlobPrefix: ${prefix.name}`);
     *   }
     * }
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`\tBlobItem: name - ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = containerClient
     *   .listBlobsByHierarchy("/")
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 blob names
     * if (response.blobPrefixes) {
     *   for (const prefix of response.blobPrefixes) {
     *     console.log(`\tBlobPrefix: ${prefix.name}`);
     *   }
     * }
     * if (response.segment.blobItems) {
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param delimiter - The character or string used to define the virtual hierarchy
     * @param options - Options to list blobs operation.
     */
    listBlobsByHierarchy(delimiter, options2 = {}) {
      if (delimiter === "") {
        throw new RangeError("delimiter should contain one or more characters");
      }
      const include = [];
      if (options2.includeCopy) {
        include.push("copy");
      }
      if (options2.includeDeleted) {
        include.push("deleted");
      }
      if (options2.includeMetadata) {
        include.push("metadata");
      }
      if (options2.includeSnapshots) {
        include.push("snapshots");
      }
      if (options2.includeVersions) {
        include.push("versions");
      }
      if (options2.includeUncommitedBlobs) {
        include.push("uncommittedblobs");
      }
      if (options2.includeTags) {
        include.push("tags");
      }
      if (options2.includeDeletedWithVersions) {
        include.push("deletedwithversions");
      }
      if (options2.includeImmutabilityPolicy) {
        include.push("immutabilitypolicy");
      }
      if (options2.includeLegalHold) {
        include.push("legalhold");
      }
      if (options2.prefix === "") {
        options2.prefix = void 0;
      }
      const updatedOptions = {
        ...options2,
        ...include.length > 0 ? { include } : {}
      };
      const iter = this.listItemsByHierarchy(delimiter, updatedOptions);
      return {
        /**
         * The next method, part of the iteration protocol
         */
        async next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.listHierarchySegments(delimiter, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...updatedOptions
          });
        }
      };
    }
    /**
     * The Filter Blobs operation enables callers to list blobs in the container whose tags
     * match a given search expression.
     *
     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                        The given expression must evaluate to true for a blob to be returned in the results.
     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_1.assertResponse)(await this.containerContext.filterBlobs({
          abortSignal: options2.abortSignal,
          where: tagFilterSqlExpression,
          marker,
          maxPageSize: options2.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response2,
          _response: response2._response,
          // _response is made non-enumerable
          blobs: response2.blobs.map((blob2) => {
            let tagValue = "";
            if (blob2.tags?.blobTagSet.length === 1) {
              tagValue = blob2.tags.blobTagSet[0].value;
            }
            return { ...blob2, tags: (0, utils_common_js_1.toTags)(blob2.tags), tagValue };
          })
        };
        return wrappedResponse;
      });
    }
    /**
     * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */
    async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options2 = {}) {
      let response2;
      if (!!marker || marker === void 0) {
        do {
          response2 = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options2);
          response2.blobs = response2.blobs || [];
          marker = response2.continuationToken;
          yield response2;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator for blobs.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to findBlobsByTagsItems.
     */
    async *findBlobsByTagsItems(tagFilterSqlExpression, options2 = {}) {
      let marker;
      for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options2)) {
        yield* segment.blobs;
      }
    }
    /**
     * Returns an async iterable iterator to find all blobs with specified tag
     * under the specified container.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * Example using `for await` syntax:
     *
     * ```ts snippet:ReadmeSampleFindBlobsByTags
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerName = "<container name>";
     * const containerClient = blobServiceClient.getContainerClient(containerName);
     *
     * // Example using `for await` syntax
     * let i = 1;
     * for await (const blob of containerClient.findBlobsByTags("tagkey='tagvalue'")) {
     *   console.log(`Blob ${i++}: ${blob.name}`);
     * }
     *
     * // Example using `iter.next()` syntax
     * i = 1;
     * const iter = containerClient.findBlobsByTags("tagkey='tagvalue'");
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Blob ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Example using `byPage()` syntax
     * i = 1;
     * for await (const page of containerClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const blob of page.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     *
     * // Example using paging with a marker
     * i = 1;
     * let iterator = containerClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = containerClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     * // Prints 10 blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to find blobs by tags.
     */
    findBlobsByTags(tagFilterSqlExpression, options2 = {}) {
      const listSegmentOptions = {
        ...options2
      };
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        /**
         * The next method, part of the iteration protocol
         */
        next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    /**
     * The Get Account Information operation returns the sku name and account kind
     * for the specified account.
     * The Get Account Information operation is available on service versions beginning
     * with version 2018-03-28.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
     *
     * @param options - Options to the Service Get Account Info operation.
     * @returns Response data for the Service Get Account Info operation.
     */
    async getAccountInfo(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccountInfo", options2, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccountInfo({
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getContainerNameFromUrl() {
      let containerName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          containerName = parsedUrl.pathname.split("/")[1];
        } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
          containerName = parsedUrl.pathname.split("/")[2];
        } else {
          containerName = parsedUrl.pathname.split("/")[1];
        }
        containerName = decodeURIComponent(containerName);
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return containerName;
      } catch (error2) {
        throw new Error("Unable to extract containerName with provided information.");
      }
    }
    /**
     * Only available for ContainerClient constructed with a shared key credential.
     *
     * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options2) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          ...options2
        }, this.credential).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    /**
     * Only available for ContainerClient constructed with a shared key credential.
     *
     * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
     * based on the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/
    generateSasStringToSign(options2) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        ...options2
      }, this.credential).stringToSign;
    }
    /**
     * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the input user delegation key.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateUserDelegationSasUrl(options2, userDelegationKey) {
      return new Promise((resolve) => {
        const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          ...options2
        }, userDelegationKey, this.accountName).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    /**
     * Generates string to sign for a Blob Container Service Shared Access Signature (SAS) URI
     * based on the client properties and parameters passed in. The SAS is signed by the input user delegation key.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @param userDelegationKey -  Return value of `blobServiceClient.getUserDelegationKey()`
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateUserDelegationSasStringToSign(options2, userDelegationKey) {
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        ...options2
      }, userDelegationKey, this.accountName).stringToSign;
    }
    /**
     * Creates a BlobBatchClient object to conduct batch operations.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
     *
     * @returns A new BlobBatchClient object for this container.
     */
    getBlobBatchClient() {
      return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
    }
  };
  ContainerClient.ContainerClient = ContainerClient$1;
  return ContainerClient;
}
var AccountSASPermissions = {};
var hasRequiredAccountSASPermissions;
function requireAccountSASPermissions() {
  if (hasRequiredAccountSASPermissions) return AccountSASPermissions;
  hasRequiredAccountSASPermissions = 1;
  Object.defineProperty(AccountSASPermissions, "__esModule", { value: true });
  AccountSASPermissions.AccountSASPermissions = void 0;
  let AccountSASPermissions$1 = class AccountSASPermissions2 {
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @param permissions -
     */
    static parse(permissions) {
      const accountSASPermissions = new AccountSASPermissions2();
      for (const c of permissions) {
        switch (c) {
          case "r":
            accountSASPermissions.read = true;
            break;
          case "w":
            accountSASPermissions.write = true;
            break;
          case "d":
            accountSASPermissions.delete = true;
            break;
          case "x":
            accountSASPermissions.deleteVersion = true;
            break;
          case "l":
            accountSASPermissions.list = true;
            break;
          case "a":
            accountSASPermissions.add = true;
            break;
          case "c":
            accountSASPermissions.create = true;
            break;
          case "u":
            accountSASPermissions.update = true;
            break;
          case "p":
            accountSASPermissions.process = true;
            break;
          case "t":
            accountSASPermissions.tag = true;
            break;
          case "f":
            accountSASPermissions.filter = true;
            break;
          case "i":
            accountSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            accountSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission character: ${c}`);
        }
      }
      return accountSASPermissions;
    }
    /**
     * Creates a {@link AccountSASPermissions} from a raw object which contains same keys as it
     * and boolean values for them.
     *
     * @param permissionLike -
     */
    static from(permissionLike) {
      const accountSASPermissions = new AccountSASPermissions2();
      if (permissionLike.read) {
        accountSASPermissions.read = true;
      }
      if (permissionLike.write) {
        accountSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        accountSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        accountSASPermissions.deleteVersion = true;
      }
      if (permissionLike.filter) {
        accountSASPermissions.filter = true;
      }
      if (permissionLike.tag) {
        accountSASPermissions.tag = true;
      }
      if (permissionLike.list) {
        accountSASPermissions.list = true;
      }
      if (permissionLike.add) {
        accountSASPermissions.add = true;
      }
      if (permissionLike.create) {
        accountSASPermissions.create = true;
      }
      if (permissionLike.update) {
        accountSASPermissions.update = true;
      }
      if (permissionLike.process) {
        accountSASPermissions.process = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        accountSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        accountSASPermissions.permanentDelete = true;
      }
      return accountSASPermissions;
    }
    /**
     * Permission to read resources and list queues and tables granted.
     */
    read = false;
    /**
     * Permission to write resources granted.
     */
    write = false;
    /**
     * Permission to delete blobs and files granted.
     */
    delete = false;
    /**
     * Permission to delete versions granted.
     */
    deleteVersion = false;
    /**
     * Permission to list blob containers, blobs, shares, directories, and files granted.
     */
    list = false;
    /**
     * Permission to add messages, table entities, and append to blobs granted.
     */
    add = false;
    /**
     * Permission to create blobs and files granted.
     */
    create = false;
    /**
     * Permissions to update messages and table entities granted.
     */
    update = false;
    /**
     * Permission to get and delete messages granted.
     */
    process = false;
    /**
     * Specfies Tag access granted.
     */
    tag = false;
    /**
     * Permission to filter blobs.
     */
    filter = false;
    /**
     * Permission to set immutability policy.
     */
    setImmutabilityPolicy = false;
    /**
     * Specifies that Permanent Delete is permitted.
     */
    permanentDelete = false;
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
     *
     */
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.filter) {
        permissions.push("f");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.update) {
        permissions.push("u");
      }
      if (this.process) {
        permissions.push("p");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  };
  AccountSASPermissions.AccountSASPermissions = AccountSASPermissions$1;
  return AccountSASPermissions;
}
var AccountSASSignatureValues = {};
var AccountSASResourceTypes = {};
var hasRequiredAccountSASResourceTypes;
function requireAccountSASResourceTypes() {
  if (hasRequiredAccountSASResourceTypes) return AccountSASResourceTypes;
  hasRequiredAccountSASResourceTypes = 1;
  Object.defineProperty(AccountSASResourceTypes, "__esModule", { value: true });
  AccountSASResourceTypes.AccountSASResourceTypes = void 0;
  let AccountSASResourceTypes$1 = class AccountSASResourceTypes2 {
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @param resourceTypes -
     */
    static parse(resourceTypes) {
      const accountSASResourceTypes = new AccountSASResourceTypes2();
      for (const c of resourceTypes) {
        switch (c) {
          case "s":
            accountSASResourceTypes.service = true;
            break;
          case "c":
            accountSASResourceTypes.container = true;
            break;
          case "o":
            accountSASResourceTypes.object = true;
            break;
          default:
            throw new RangeError(`Invalid resource type: ${c}`);
        }
      }
      return accountSASResourceTypes;
    }
    /**
     * Permission to access service level APIs granted.
     */
    service = false;
    /**
     * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
     */
    container = false;
    /**
     * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
     */
    object = false;
    /**
     * Converts the given resource types to a string.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/constructing-an-account-sas
     *
     */
    toString() {
      const resourceTypes = [];
      if (this.service) {
        resourceTypes.push("s");
      }
      if (this.container) {
        resourceTypes.push("c");
      }
      if (this.object) {
        resourceTypes.push("o");
      }
      return resourceTypes.join("");
    }
  };
  AccountSASResourceTypes.AccountSASResourceTypes = AccountSASResourceTypes$1;
  return AccountSASResourceTypes;
}
var AccountSASServices = {};
var hasRequiredAccountSASServices;
function requireAccountSASServices() {
  if (hasRequiredAccountSASServices) return AccountSASServices;
  hasRequiredAccountSASServices = 1;
  Object.defineProperty(AccountSASServices, "__esModule", { value: true });
  AccountSASServices.AccountSASServices = void 0;
  let AccountSASServices$1 = class AccountSASServices2 {
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @param services -
     */
    static parse(services) {
      const accountSASServices = new AccountSASServices2();
      for (const c of services) {
        switch (c) {
          case "b":
            accountSASServices.blob = true;
            break;
          case "f":
            accountSASServices.file = true;
            break;
          case "q":
            accountSASServices.queue = true;
            break;
          case "t":
            accountSASServices.table = true;
            break;
          default:
            throw new RangeError(`Invalid service character: ${c}`);
        }
      }
      return accountSASServices;
    }
    /**
     * Permission to access blob resources granted.
     */
    blob = false;
    /**
     * Permission to access file resources granted.
     */
    file = false;
    /**
     * Permission to access queue resources granted.
     */
    queue = false;
    /**
     * Permission to access table resources granted.
     */
    table = false;
    /**
     * Converts the given services to a string.
     *
     */
    toString() {
      const services = [];
      if (this.blob) {
        services.push("b");
      }
      if (this.table) {
        services.push("t");
      }
      if (this.queue) {
        services.push("q");
      }
      if (this.file) {
        services.push("f");
      }
      return services.join("");
    }
  };
  AccountSASServices.AccountSASServices = AccountSASServices$1;
  return AccountSASServices;
}
var hasRequiredAccountSASSignatureValues;
function requireAccountSASSignatureValues() {
  if (hasRequiredAccountSASSignatureValues) return AccountSASSignatureValues;
  hasRequiredAccountSASSignatureValues = 1;
  Object.defineProperty(AccountSASSignatureValues, "__esModule", { value: true });
  AccountSASSignatureValues.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
  AccountSASSignatureValues.generateAccountSASQueryParametersInternal = generateAccountSASQueryParametersInternal;
  const AccountSASPermissions_js_1 = /* @__PURE__ */ requireAccountSASPermissions();
  const AccountSASResourceTypes_js_1 = /* @__PURE__ */ requireAccountSASResourceTypes();
  const AccountSASServices_js_1 = /* @__PURE__ */ requireAccountSASServices();
  const SasIPRange_js_1 = /* @__PURE__ */ requireSasIPRange();
  const SASQueryParameters_js_1 = /* @__PURE__ */ requireSASQueryParameters();
  const constants_js_1 = /* @__PURE__ */ requireConstants$2();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
  }
  function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
    const version2 = accountSASSignatureValues.version ? accountSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    }
    if (accountSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    const parsedPermissions = AccountSASPermissions_js_1.AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
    const parsedServices = AccountSASServices_js_1.AccountSASServices.parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = AccountSASResourceTypes_js_1.AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    let stringToSign;
    if (version2 >= "2020-12-06") {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
        (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
        ""
        // Account SAS requires an additional newline character
      ].join("\n");
    } else {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
        (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        ""
        // Account SAS requires an additional newline character
      ].join("\n");
    }
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(version2, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, accountSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  return AccountSASSignatureValues;
}
var hasRequiredBlobServiceClient;
function requireBlobServiceClient() {
  if (hasRequiredBlobServiceClient) return BlobServiceClient;
  hasRequiredBlobServiceClient = 1;
  Object.defineProperty(BlobServiceClient, "__esModule", { value: true });
  BlobServiceClient.BlobServiceClient = void 0;
  const core_auth_1 = /* @__PURE__ */ requireCommonjs$6();
  const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
  const core_util_1 = /* @__PURE__ */ requireCommonjs$9();
  const Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
  const ContainerClient_js_1 = /* @__PURE__ */ requireContainerClient();
  const utils_common_js_1 = /* @__PURE__ */ requireUtils_common$2();
  const StorageSharedKeyCredential_js_1 = /* @__PURE__ */ requireStorageSharedKeyCredential$1();
  const AnonymousCredential_js_1 = /* @__PURE__ */ requireAnonymousCredential$1();
  const utils_common_js_2 = /* @__PURE__ */ requireUtils_common$2();
  const tracing_js_1 = /* @__PURE__ */ requireTracing();
  const BlobBatchClient_js_1 = /* @__PURE__ */ requireBlobBatchClient();
  const StorageClient_js_1 = /* @__PURE__ */ requireStorageClient();
  const AccountSASPermissions_js_1 = /* @__PURE__ */ requireAccountSASPermissions();
  const AccountSASSignatureValues_js_1 = /* @__PURE__ */ requireAccountSASSignatureValues();
  const AccountSASServices_js_1 = /* @__PURE__ */ requireAccountSASServices();
  let BlobServiceClient$1 = class BlobServiceClient2 extends StorageClient_js_1.StorageClient {
    /**
     * serviceContext provided by protocol layer.
     */
    serviceContext;
    /**
     *
     * Creates an instance of BlobServiceClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Optional. Options to configure the HTTP pipeline.
     */
    static fromConnectionString(connectionString, options2) {
      options2 = options2 || {};
      const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(connectionString);
      if (extractedCreds.kind === "AccountConnString") {
        if (core_util_1.isNodeLike) {
          const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          if (!options2.proxyOptions) {
            options2.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
          }
          const pipeline2 = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options2);
          return new BlobServiceClient2(extractedCreds.url, pipeline2);
        } else {
          throw new Error("Account connection string is only supported in Node.js environment");
        }
      } else if (extractedCreds.kind === "SASConnString") {
        const pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
        return new BlobServiceClient2(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline2);
      } else {
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
      }
    }
    constructor(url, credentialOrPipeline, options2) {
      let pipeline2;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) {
        pipeline2 = credentialOrPipeline;
      } else if (core_util_1.isNodeLike && credentialOrPipeline instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipeline)) {
        pipeline2 = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options2);
      } else {
        pipeline2 = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options2);
      }
      super(url, pipeline2);
      this.serviceContext = this.storageClientContext.service;
    }
    /**
     * Creates a {@link ContainerClient} object
     *
     * @param containerName - A container name
     * @returns A new ContainerClient object for the given container name.
     *
     * Example usage:
     *
     * ```ts snippet:BlobServiceClientGetContainerClient
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * const containerClient = blobServiceClient.getContainerClient("<container name>");
     * ```
     */
    getContainerClient(containerName) {
      return new ContainerClient_js_1.ContainerClient((0, utils_common_js_1.appendToURLPath)(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    /**
     * Create a Blob container. @see https://learn.microsoft.com/rest/api/storageservices/create-container
     *
     * @param containerName - Name of the container to create.
     * @param options - Options to configure Container Create operation.
     * @returns Container creation response and the corresponding container client.
     */
    async createContainer(containerName, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-createContainer", options2, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        const containerCreateResponse = await containerClient.create(updatedOptions);
        return {
          containerClient,
          containerCreateResponse
        };
      });
    }
    /**
     * Deletes a Blob container.
     *
     * @param containerName - Name of the container to delete.
     * @param options - Options to configure Container Delete operation.
     * @returns Container deletion response.
     */
    async deleteContainer(containerName, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-deleteContainer", options2, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        return containerClient.delete(updatedOptions);
      });
    }
    /**
     * Restore a previously deleted Blob container.
     * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.
     *
     * @param deletedContainerName - Name of the previously deleted container.
     * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.
     * @param options - Options to configure Container Restore operation.
     * @returns Container deletion response.
     */
    async undeleteContainer(deletedContainerName, deletedContainerVersion, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-undeleteContainer", options2, async (updatedOptions) => {
        const containerClient = this.getContainerClient(options2.destinationContainerName || deletedContainerName);
        const containerContext = containerClient["storageClientContext"].container;
        const containerUndeleteResponse = (0, utils_common_js_2.assertResponse)(await containerContext.restore({
          deletedContainerName,
          deletedContainerVersion,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return { containerClient, containerUndeleteResponse };
      });
    }
    /**
     * Gets the properties of a storage account’s Blob service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-properties
     *
     * @param options - Options to the Service Get Properties operation.
     * @returns Response data for the Service Get Properties operation.
     */
    async getProperties(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getProperties", options2, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getProperties({
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Sets properties for a storage account’s Blob service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-service-properties
     *
     * @param properties -
     * @param options - Options to the Service Set Properties operation.
     * @returns Response data for the Service Set Properties operation.
     */
    async setProperties(properties, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-setProperties", options2, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.setProperties(properties, {
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Retrieves statistics related to replication for the Blob service. It is only
     * available on the secondary location endpoint when read-access geo-redundant
     * replication is enabled for the storage account.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-stats
     *
     * @param options - Options to the Service Get Statistics operation.
     * @returns Response data for the Service Get Statistics operation.
     */
    async getStatistics(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getStatistics", options2, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getStatistics({
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The Get Account Information operation returns the sku name and account kind
     * for the specified account.
     * The Get Account Information operation is available on service versions beginning
     * with version 2018-03-28.
     * @see https://learn.microsoft.com/rest/api/storageservices/get-account-information
     *
     * @param options - Options to the Service Get Account Info operation.
     * @returns Response data for the Service Get Account Info operation.
     */
    async getAccountInfo(options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getAccountInfo", options2, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getAccountInfo({
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * Returns a list of the containers under the specified account.
     * @see https://learn.microsoft.com/rest/api/storageservices/list-containers2
     *
     * @param marker - A string value that identifies the portion of
     *                        the list of containers to be returned with the next listing operation. The
     *                        operation returns the continuationToken value within the response body if the
     *                        listing operation did not return all containers remaining to be listed
     *                        with the current page. The continuationToken value can be used as the value for
     *                        the marker parameter in a subsequent call to request the next page of list
     *                        items. The marker value is opaque to the client.
     * @param options - Options to the Service List Container Segment operation.
     * @returns Response data for the Service List Container Segment operation.
     */
    async listContainersSegment(marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-listContainersSegment", options2, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.listContainersSegment({
          abortSignal: options2.abortSignal,
          marker,
          ...options2,
          include: typeof options2.include === "string" ? [options2.include] : options2.include,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    /**
     * The Filter Blobs operation enables callers to list blobs across all containers whose tags
     * match a given search expression. Filter blobs searches across all containers within a
     * storage account but can be scoped within the expression to a single container.
     *
     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                        The given expression must evaluate to true for a blob to be returned in the results.
     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_2.assertResponse)(await this.serviceContext.filterBlobs({
          abortSignal: options2.abortSignal,
          where: tagFilterSqlExpression,
          marker,
          maxPageSize: options2.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = {
          ...response2,
          _response: response2._response,
          // _response is made non-enumerable
          blobs: response2.blobs.map((blob2) => {
            let tagValue = "";
            if (blob2.tags?.blobTagSet.length === 1) {
              tagValue = blob2.tags.blobTagSet[0].value;
            }
            return { ...blob2, tags: (0, utils_common_js_1.toTags)(blob2.tags), tagValue };
          })
        };
        return wrappedResponse;
      });
    }
    /**
     * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param marker - A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the continuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The continuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to find blobs by tags.
     */
    async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options2 = {}) {
      let response2;
      if (!!marker || marker === void 0) {
        do {
          response2 = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options2);
          response2.blobs = response2.blobs || [];
          marker = response2.continuationToken;
          yield response2;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator for blobs.
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to findBlobsByTagsItems.
     */
    async *findBlobsByTagsItems(tagFilterSqlExpression, options2 = {}) {
      let marker;
      for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options2)) {
        yield* segment.blobs;
      }
    }
    /**
     * Returns an async iterable iterator to find all blobs with specified tag
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-service-properties
     *
     * ```ts snippet:BlobServiceClientFindBlobsByTags
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * // Use for await to iterate the blobs
     * let i = 1;
     * for await (const blob of blobServiceClient.findBlobsByTags("tagkey='tagvalue'")) {
     *   console.log(`Blob ${i++}: ${blob.name}`);
     * }
     *
     * // Use iter.next() to iterate the blobs
     * i = 1;
     * const iter = blobServiceClient.findBlobsByTags("tagkey='tagvalue'");
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Blob ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Use byPage() to iterate the blobs
     * i = 1;
     * for await (const page of blobServiceClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const blob of page.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     *
     * // Use paging with a marker
     * i = 1;
     * let iterator = blobServiceClient.findBlobsByTags("tagkey='tagvalue'").byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     * // Prints 2 blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = blobServiceClient
     *   .findBlobsByTags("tagkey='tagvalue'")
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints blob names
     * if (response.blobs) {
     *   for (const blob of response.blobs) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * }
     * ```
     *
     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.
     *                                         The given expression must evaluate to true for a blob to be returned in the results.
     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;
     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.
     * @param options - Options to find blobs by tags.
     */
    findBlobsByTags(tagFilterSqlExpression, options2 = {}) {
      const listSegmentOptions = {
        ...options2
      };
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        /**
         * The next method, part of the iteration protocol
         */
        next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    /**
     * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses
     *
     * @param marker - A string value that identifies the portion of
     *                        the list of containers to be returned with the next listing operation. The
     *                        operation returns the continuationToken value within the response body if the
     *                        listing operation did not return all containers remaining to be listed
     *                        with the current page. The continuationToken value can be used as the value for
     *                        the marker parameter in a subsequent call to request the next page of list
     *                        items. The marker value is opaque to the client.
     * @param options - Options to list containers operation.
     */
    async *listSegments(marker, options2 = {}) {
      let listContainersSegmentResponse;
      if (!!marker || marker === void 0) {
        do {
          listContainersSegmentResponse = await this.listContainersSegment(marker, options2);
          listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
          marker = listContainersSegmentResponse.continuationToken;
          yield await listContainersSegmentResponse;
        } while (marker);
      }
    }
    /**
     * Returns an AsyncIterableIterator for Container Items
     *
     * @param options - Options to list containers operation.
     */
    async *listItems(options2 = {}) {
      let marker;
      for await (const segment of this.listSegments(marker, options2)) {
        yield* segment.containerItems;
      }
    }
    /**
     * Returns an async iterable iterator to list all the containers
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the containers in pages.
     *
     * ```ts snippet:BlobServiceClientListContainers
     * import { BlobServiceClient } from "@azure/storage-blob";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * const account = "<account>";
     * const blobServiceClient = new BlobServiceClient(
     *   `https://${account}.blob.core.windows.net`,
     *   new DefaultAzureCredential(),
     * );
     *
     * // Use for await to iterate the containers
     * let i = 1;
     * for await (const container of blobServiceClient.listContainers()) {
     *   console.log(`Container ${i++}: ${container.name}`);
     * }
     *
     * // Use iter.next() to iterate the containers
     * i = 1;
     * const iter = blobServiceClient.listContainers();
     * let { value, done } = await iter.next();
     * while (!done) {
     *   console.log(`Container ${i++}: ${value.name}`);
     *   ({ value, done } = await iter.next());
     * }
     *
     * // Use byPage() to iterate the containers
     * i = 1;
     * for await (const page of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {
     *   for (const container of page.containerItems) {
     *     console.log(`Container ${i++}: ${container.name}`);
     *   }
     * }
     *
     * // Use paging with a marker
     * i = 1;
     * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 container names
     * if (response.containerItems) {
     *   for (const container of response.containerItems) {
     *     console.log(`Container ${i++}: ${container.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     * // Passing next marker as continuationToken
     * iterator = blobServiceClient
     *   .listContainers()
     *   .byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 container names
     * if (response.containerItems) {
     *   for (const container of response.containerItems) {
     *     console.log(`Container ${i++}: ${container.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list containers.
     * @returns An asyncIterableIterator that supports paging.
     */
    listContainers(options2 = {}) {
      if (options2.prefix === "") {
        options2.prefix = void 0;
      }
      const include = [];
      if (options2.includeDeleted) {
        include.push("deleted");
      }
      if (options2.includeMetadata) {
        include.push("metadata");
      }
      if (options2.includeSystem) {
        include.push("system");
      }
      const listSegmentOptions = {
        ...options2,
        ...include.length > 0 ? { include } : {}
      };
      const iter = this.listItems(listSegmentOptions);
      return {
        /**
         * The next method, part of the iteration protocol
         */
        next() {
          return iter.next();
        },
        /**
         * The connection to the async iterator, part of the iteration protocol
         */
        [Symbol.asyncIterator]() {
          return this;
        },
        /**
         * Return an AsyncIterableIterator that works a page at a time
         */
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    /**
     * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).
     *
     * Retrieves a user delegation key for the Blob service. This is only a valid operation when using
     * bearer token authentication.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/get-user-delegation-key
     *
     * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time
     * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time
     */
    async getUserDelegationKey(startsOn, expiresOn, options2 = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options2, async (updatedOptions) => {
        const response2 = (0, utils_common_js_2.assertResponse)(await this.serviceContext.getUserDelegationKey({
          startsOn: (0, utils_common_js_2.truncatedISO8061Date)(startsOn, false),
          expiresOn: (0, utils_common_js_2.truncatedISO8061Date)(expiresOn, false)
        }, {
          abortSignal: options2.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const userDelegationKey = {
          signedObjectId: response2.signedObjectId,
          signedTenantId: response2.signedTenantId,
          signedStartsOn: new Date(response2.signedStartsOn),
          signedExpiresOn: new Date(response2.signedExpiresOn),
          signedService: response2.signedService,
          signedVersion: response2.signedVersion,
          value: response2.value
        };
        const res = {
          _response: response2._response,
          requestId: response2.requestId,
          clientRequestId: response2.clientRequestId,
          version: response2.version,
          date: response2.date,
          errorCode: response2.errorCode,
          ...userDelegationKey
        };
        return res;
      });
    }
    /**
     * Creates a BlobBatchClient object to conduct batch operations.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/blob-batch
     *
     * @returns A new BlobBatchClient object for this service.
     */
    getBlobBatchClient() {
      return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
    }
    /**
     * Only available for BlobServiceClient constructed with a shared key credential.
     *
     * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options2 = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn === void 0) {
        const now = /* @__PURE__ */ new Date();
        expiresOn = new Date(now.getTime() + 3600 * 1e3);
      }
      const sas = (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParameters)({
        permissions,
        expiresOn,
        resourceTypes,
        services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
        ...options2
      }, this.credential).toString();
      return (0, utils_common_js_1.appendToURLQuery)(this.url, sas);
    }
    /**
     * Only available for BlobServiceClient constructed with a shared key credential.
     *
     * Generates string to sign for a Blob account Shared Access Signature (SAS) URI based on
     * the client properties and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://learn.microsoft.com/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasStringToSign(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options2 = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn === void 0) {
        const now = /* @__PURE__ */ new Date();
        expiresOn = new Date(now.getTime() + 3600 * 1e3);
      }
      return (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParametersInternal)({
        permissions,
        expiresOn,
        resourceTypes,
        services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
        ...options2
      }, this.credential).stringToSign;
    }
  };
  BlobServiceClient.BlobServiceClient = BlobServiceClient$1;
  return BlobServiceClient;
}
var BatchResponse = {};
var hasRequiredBatchResponse;
function requireBatchResponse() {
  if (hasRequiredBatchResponse) return BatchResponse;
  hasRequiredBatchResponse = 1;
  Object.defineProperty(BatchResponse, "__esModule", { value: true });
  return BatchResponse;
}
var generatedModels = {};
var hasRequiredGeneratedModels;
function requireGeneratedModels() {
  if (hasRequiredGeneratedModels) return generatedModels;
  hasRequiredGeneratedModels = 1;
  Object.defineProperty(generatedModels, "__esModule", { value: true });
  generatedModels.KnownEncryptionAlgorithmType = void 0;
  var KnownEncryptionAlgorithmType;
  (function(KnownEncryptionAlgorithmType2) {
    KnownEncryptionAlgorithmType2["AES256"] = "AES256";
  })(KnownEncryptionAlgorithmType || (generatedModels.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
  return generatedModels;
}
var hasRequiredCommonjs;
function requireCommonjs() {
  if (hasRequiredCommonjs) return commonjs$c;
  hasRequiredCommonjs = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = exports.RestError = exports.BaseRequestPolicy = exports.StorageOAuthScopes = exports.newPipeline = exports.isPipelineLike = exports.Pipeline = exports.getBlobServiceAccountAudience = exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = exports.generateBlobSASQueryParameters = exports.generateAccountSASQueryParameters = void 0;
    const tslib_1 = require$$0$2;
    const core_rest_pipeline_1 = /* @__PURE__ */ requireCommonjs$7();
    Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
      return core_rest_pipeline_1.RestError;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireBlobServiceClient(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireClients(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireContainerClient(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlobLeaseClient(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAccountSASPermissions(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAccountSASResourceTypes(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAccountSASServices(), exports);
    var AccountSASSignatureValues_js_1 = /* @__PURE__ */ requireAccountSASSignatureValues();
    Object.defineProperty(exports, "generateAccountSASQueryParameters", { enumerable: true, get: function() {
      return AccountSASSignatureValues_js_1.generateAccountSASQueryParameters;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireBlobBatch(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlobBatchClient(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBatchResponse(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireBlobSASPermissions(), exports);
    var BlobSASSignatureValues_js_1 = /* @__PURE__ */ requireBlobSASSignatureValues();
    Object.defineProperty(exports, "generateBlobSASQueryParameters", { enumerable: true, get: function() {
      return BlobSASSignatureValues_js_1.generateBlobSASQueryParameters;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageBrowserPolicyFactory(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireContainerSASPermissions(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireAnonymousCredential$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireCredential$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageSharedKeyCredential$1(), exports);
    var models_js_1 = /* @__PURE__ */ requireModels();
    Object.defineProperty(exports, "BlockBlobTier", { enumerable: true, get: function() {
      return models_js_1.BlockBlobTier;
    } });
    Object.defineProperty(exports, "PremiumPageBlobTier", { enumerable: true, get: function() {
      return models_js_1.PremiumPageBlobTier;
    } });
    Object.defineProperty(exports, "StorageBlobAudience", { enumerable: true, get: function() {
      return models_js_1.StorageBlobAudience;
    } });
    Object.defineProperty(exports, "getBlobServiceAccountAudience", { enumerable: true, get: function() {
      return models_js_1.getBlobServiceAccountAudience;
    } });
    var Pipeline_js_1 = /* @__PURE__ */ requirePipeline();
    Object.defineProperty(exports, "Pipeline", { enumerable: true, get: function() {
      return Pipeline_js_1.Pipeline;
    } });
    Object.defineProperty(exports, "isPipelineLike", { enumerable: true, get: function() {
      return Pipeline_js_1.isPipelineLike;
    } });
    Object.defineProperty(exports, "newPipeline", { enumerable: true, get: function() {
      return Pipeline_js_1.newPipeline;
    } });
    Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: true, get: function() {
      return Pipeline_js_1.StorageOAuthScopes;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicyFactory$1(), exports);
    var RequestPolicy_js_1 = /* @__PURE__ */ requireRequestPolicy$1();
    Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: true, get: function() {
      return RequestPolicy_js_1.BaseRequestPolicy;
    } });
    tslib_1.__exportStar(/* @__PURE__ */ requireAnonymousCredentialPolicy$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireCredentialPolicy$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageRetryPolicyFactory$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireStorageSharedKeyCredentialPolicy$1(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireSASQueryParameters(), exports);
    tslib_1.__exportStar(/* @__PURE__ */ requireGeneratedModels(), exports);
    var log_js_1 = /* @__PURE__ */ requireLog$1();
    Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
      return log_js_1.logger;
    } });
  })(commonjs$c);
  return commonjs$c;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.UsageError = errors.NetworkError = errors.GHESNotSupportedError = errors.CacheNotFoundError = errors.InvalidResponseError = errors.FilesNotFoundError = void 0;
  class FilesNotFoundError extends Error {
    constructor(files = []) {
      let message = "No files were found to upload";
      if (files.length > 0) {
        message += `: ${files.join(", ")}`;
      }
      super(message);
      this.files = files;
      this.name = "FilesNotFoundError";
    }
  }
  errors.FilesNotFoundError = FilesNotFoundError;
  class InvalidResponseError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidResponseError";
    }
  }
  errors.InvalidResponseError = InvalidResponseError;
  class CacheNotFoundError extends Error {
    constructor(message = "Cache not found") {
      super(message);
      this.name = "CacheNotFoundError";
    }
  }
  errors.CacheNotFoundError = CacheNotFoundError;
  class GHESNotSupportedError extends Error {
    constructor(message = "@actions/cache v4.1.4+, actions/cache/save@v4+ and actions/cache/restore@v4+ are not currently supported on GHES.") {
      super(message);
      this.name = "GHESNotSupportedError";
    }
  }
  errors.GHESNotSupportedError = GHESNotSupportedError;
  class NetworkError extends Error {
    constructor(code) {
      const message = `Unable to make request: ${code}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
      super(message);
      this.code = code;
      this.name = "NetworkError";
    }
  }
  errors.NetworkError = NetworkError;
  NetworkError.isNetworkErrorCode = (code) => {
    if (!code)
      return false;
    return [
      "ECONNRESET",
      "ENOTFOUND",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH"
    ].includes(code);
  };
  class UsageError extends Error {
    constructor() {
      const message = `Cache storage quota has been hit. Unable to upload any new cache entries. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`;
      super(message);
      this.name = "UsageError";
    }
  }
  errors.UsageError = UsageError;
  UsageError.isUsageErrorMessage = (msg) => {
    if (!msg)
      return false;
    return msg.includes("insufficient usage");
  };
  return errors;
}
var hasRequiredUploadUtils;
function requireUploadUtils() {
  if (hasRequiredUploadUtils) return uploadUtils;
  hasRequiredUploadUtils = 1;
  var __createBinding2 = uploadUtils && uploadUtils.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = uploadUtils && uploadUtils.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = uploadUtils && uploadUtils.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = uploadUtils && uploadUtils.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(uploadUtils, "__esModule", { value: true });
  uploadUtils.uploadCacheArchiveSDK = uploadUtils.UploadProgress = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const storage_blob_1 = /* @__PURE__ */ requireCommonjs();
  const errors_1 = /* @__PURE__ */ requireErrors();
  class UploadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.sentBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    /**
     * Sets the number of bytes sent
     *
     * @param sentBytes the number of bytes sent
     */
    setSentBytes(sentBytes) {
      this.sentBytes = sentBytes;
    }
    /**
     * Returns the total number of bytes transferred.
     */
    getTransferredBytes() {
      return this.sentBytes;
    }
    /**
     * Returns true if the upload is complete.
     */
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    /**
     * Prints the current upload stats. Once the upload completes, this will print one
     * last line and then stop.
     */
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.sentBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const uploadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1e3)).toFixed(1);
      core2.info(`Sent ${transferredBytes} of ${this.contentLength} (${percentage}%), ${uploadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    /**
     * Returns a function used to handle TransferProgressEvents.
     */
    onProgress() {
      return (progress) => {
        this.setSentBytes(progress.loadedBytes);
      };
    }
    /**
     * Starts the timer that displays the stats.
     *
     * @param delayInMs the delay between each write
     */
    startDisplayTimer(delayInMs = 1e3) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    /**
     * Stops the timer that displays the stats. As this typically indicates the upload
     * is complete, this will display one last line, unless the last line has already
     * been written.
     */
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = void 0;
      }
      this.display();
    }
  }
  uploadUtils.UploadProgress = UploadProgress;
  function uploadCacheArchiveSDK(signedUploadURL, archivePath, options2) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      const blobClient = new storage_blob_1.BlobClient(signedUploadURL);
      const blockBlobClient = blobClient.getBlockBlobClient();
      const uploadProgress = new UploadProgress((_a = options2 === null || options2 === void 0 ? void 0 : options2.archiveSizeBytes) !== null && _a !== void 0 ? _a : 0);
      const uploadOptions = {
        blockSize: options2 === null || options2 === void 0 ? void 0 : options2.uploadChunkSize,
        concurrency: options2 === null || options2 === void 0 ? void 0 : options2.uploadConcurrency,
        maxSingleShotSize: 128 * 1024 * 1024,
        onProgress: uploadProgress.onProgress()
      };
      try {
        uploadProgress.startDisplayTimer();
        core2.debug(`BlobClient: ${blobClient.name}:${blobClient.accountName}:${blobClient.containerName}`);
        const response2 = yield blockBlobClient.uploadFile(archivePath, uploadOptions);
        if (response2._response.status >= 400) {
          throw new errors_1.InvalidResponseError(`uploadCacheArchiveSDK: upload failed with status code ${response2._response.status}`);
        }
        return response2;
      } catch (error2) {
        core2.warning(`uploadCacheArchiveSDK: internal error uploading cache archive: ${error2.message}`);
        throw error2;
      } finally {
        uploadProgress.stopDisplayTimer();
      }
    });
  }
  uploadUtils.uploadCacheArchiveSDK = uploadCacheArchiveSDK;
  return uploadUtils;
}
var downloadUtils = {};
var requestUtils = {};
var hasRequiredRequestUtils;
function requireRequestUtils() {
  if (hasRequiredRequestUtils) return requestUtils;
  hasRequiredRequestUtils = 1;
  var __createBinding2 = requestUtils && requestUtils.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = requestUtils && requestUtils.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = requestUtils && requestUtils.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = requestUtils && requestUtils.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(requestUtils, "__esModule", { value: true });
  requestUtils.retryHttpClientResponse = requestUtils.retryTypedResponse = requestUtils.retry = requestUtils.isRetryableStatusCode = requestUtils.isServerErrorStatusCode = requestUtils.isSuccessStatusCode = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const http_client_1 = /* @__PURE__ */ requireLib$1();
  const constants_1 = /* @__PURE__ */ requireConstants$5();
  function isSuccessStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    return statusCode >= 200 && statusCode < 300;
  }
  requestUtils.isSuccessStatusCode = isSuccessStatusCode;
  function isServerErrorStatusCode(statusCode) {
    if (!statusCode) {
      return true;
    }
    return statusCode >= 500;
  }
  requestUtils.isServerErrorStatusCode = isServerErrorStatusCode;
  function isRetryableStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    const retryableStatusCodes = [
      http_client_1.HttpCodes.BadGateway,
      http_client_1.HttpCodes.ServiceUnavailable,
      http_client_1.HttpCodes.GatewayTimeout
    ];
    return retryableStatusCodes.includes(statusCode);
  }
  requestUtils.isRetryableStatusCode = isRetryableStatusCode;
  function sleep(milliseconds) {
    return __awaiter2(this, void 0, void 0, function* () {
      return new Promise((resolve) => setTimeout(resolve, milliseconds));
    });
  }
  function retry(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay2 = constants_1.DefaultRetryDelay, onError = void 0) {
    return __awaiter2(this, void 0, void 0, function* () {
      let errorMessage = "";
      let attempt = 1;
      while (attempt <= maxAttempts) {
        let response2 = void 0;
        let statusCode = void 0;
        let isRetryable = false;
        try {
          response2 = yield method();
        } catch (error2) {
          if (onError) {
            response2 = onError(error2);
          }
          isRetryable = true;
          errorMessage = error2.message;
        }
        if (response2) {
          statusCode = getStatusCode(response2);
          if (!isServerErrorStatusCode(statusCode)) {
            return response2;
          }
        }
        if (statusCode) {
          isRetryable = isRetryableStatusCode(statusCode);
          errorMessage = `Cache service responded with ${statusCode}`;
        }
        core2.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
        if (!isRetryable) {
          core2.debug(`${name} - Error is not retryable`);
          break;
        }
        yield sleep(delay2);
        attempt++;
      }
      throw Error(`${name} failed: ${errorMessage}`);
    });
  }
  requestUtils.retry = retry;
  function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay2 = constants_1.DefaultRetryDelay) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield retry(
        name,
        method,
        (response2) => response2.statusCode,
        maxAttempts,
        delay2,
        // If the error object contains the statusCode property, extract it and return
        // an TypedResponse<T> so it can be processed by the retry logic.
        (error2) => {
          if (error2 instanceof http_client_1.HttpClientError) {
            return {
              statusCode: error2.statusCode,
              result: null,
              headers: {},
              error: error2
            };
          } else {
            return void 0;
          }
        }
      );
    });
  }
  requestUtils.retryTypedResponse = retryTypedResponse;
  function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay2 = constants_1.DefaultRetryDelay) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield retry(name, method, (response2) => response2.message.statusCode, maxAttempts, delay2);
    });
  }
  requestUtils.retryHttpClientResponse = retryHttpClientResponse;
  return requestUtils;
}
const listenersMap = /* @__PURE__ */ new WeakMap();
const abortedMap = /* @__PURE__ */ new WeakMap();
let AbortSignal$1 = class AbortSignal2 {
  constructor() {
    this.onabort = null;
    listenersMap.set(this, []);
    abortedMap.set(this, false);
  }
  /**
   * Status of whether aborted or not.
   *
   * @readonly
   */
  get aborted() {
    if (!abortedMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    return abortedMap.get(this);
  }
  /**
   * Creates a new AbortSignal instance that will never be aborted.
   *
   * @readonly
   */
  static get none() {
    return new AbortSignal2();
  }
  /**
   * Added new "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be added
   */
  addEventListener(_type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    const listeners = listenersMap.get(this);
    listeners.push(listener);
  }
  /**
   * Remove "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be removed
   */
  removeEventListener(_type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    const listeners = listenersMap.get(this);
    const index = listeners.indexOf(listener);
    if (index > -1) {
      listeners.splice(index, 1);
    }
  }
  /**
   * Dispatches a synthetic event to the AbortSignal.
   */
  dispatchEvent(_event) {
    throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
  }
};
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}
class AbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
}
let AbortController$1 = class AbortController2 {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(parentSignals) {
    this._signal = new AbortSignal$1();
    if (!parentSignals) {
      return;
    }
    if (!Array.isArray(parentSignals)) {
      parentSignals = arguments;
    }
    for (const parentSignal of parentSignals) {
      if (parentSignal.aborted) {
        this.abort();
      } else {
        parentSignal.addEventListener("abort", () => {
          this.abort();
        });
      }
    }
  }
  /**
   * The AbortSignal associated with this controller that will signal aborted
   * when the abort method is called on this controller.
   *
   * @readonly
   */
  get signal() {
    return this._signal;
  }
  /**
   * Signal that any operations passed this controller's associated abort signal
   * to cancel any remaining work and throw an `AbortError`.
   */
  abort() {
    abortSignal(this._signal);
  }
  /**
   * Creates a new AbortSignal instance that will abort after the provided ms.
   * @param ms - Elapsed time in milliseconds to trigger an abort.
   */
  static timeout(ms2) {
    const signal = new AbortSignal$1();
    const timer = setTimeout(abortSignal, ms2, signal);
    if (typeof timer.unref === "function") {
      timer.unref();
    }
    return signal;
  }
};
const src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortController: AbortController$1,
  AbortError,
  AbortSignal: AbortSignal$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(src);
var hasRequiredDownloadUtils;
function requireDownloadUtils() {
  if (hasRequiredDownloadUtils) return downloadUtils;
  hasRequiredDownloadUtils = 1;
  var __createBinding2 = downloadUtils && downloadUtils.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = downloadUtils && downloadUtils.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = downloadUtils && downloadUtils.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = downloadUtils && downloadUtils.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(downloadUtils, "__esModule", { value: true });
  downloadUtils.downloadCacheStorageSDK = downloadUtils.downloadCacheHttpClientConcurrent = downloadUtils.downloadCacheHttpClient = downloadUtils.DownloadProgress = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const http_client_1 = /* @__PURE__ */ requireLib$1();
  const storage_blob_1 = /* @__PURE__ */ requireCommonjs();
  const buffer = __importStar2(require$$7);
  const fs = __importStar2(require$$1$2);
  const stream = __importStar2(require$$0$9);
  const util2 = __importStar2(require$$0$5);
  const utils2 = __importStar2(/* @__PURE__ */ requireCacheUtils());
  const constants_1 = /* @__PURE__ */ requireConstants$5();
  const requestUtils_1 = /* @__PURE__ */ requireRequestUtils();
  const abort_controller_1 = require$$10;
  function pipeResponseToStream(response2, output) {
    return __awaiter2(this, void 0, void 0, function* () {
      const pipeline2 = util2.promisify(stream.pipeline);
      yield pipeline2(response2.message, output);
    });
  }
  class DownloadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.segmentIndex = 0;
      this.segmentSize = 0;
      this.segmentOffset = 0;
      this.receivedBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    /**
     * Progress to the next segment. Only call this method when the previous segment
     * is complete.
     *
     * @param segmentSize the length of the next segment
     */
    nextSegment(segmentSize) {
      this.segmentOffset = this.segmentOffset + this.segmentSize;
      this.segmentIndex = this.segmentIndex + 1;
      this.segmentSize = segmentSize;
      this.receivedBytes = 0;
      core2.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
    }
    /**
     * Sets the number of bytes received for the current segment.
     *
     * @param receivedBytes the number of bytes received
     */
    setReceivedBytes(receivedBytes) {
      this.receivedBytes = receivedBytes;
    }
    /**
     * Returns the total number of bytes transferred.
     */
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    /**
     * Returns true if the download is complete.
     */
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    /**
     * Prints the current download stats. Once the download completes, this will print one
     * last line and then stop.
     */
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.segmentOffset + this.receivedBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const downloadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1e3)).toFixed(1);
      core2.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    /**
     * Returns a function used to handle TransferProgressEvents.
     */
    onProgress() {
      return (progress) => {
        this.setReceivedBytes(progress.loadedBytes);
      };
    }
    /**
     * Starts the timer that displays the stats.
     *
     * @param delayInMs the delay between each write
     */
    startDisplayTimer(delayInMs = 1e3) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    /**
     * Stops the timer that displays the stats. As this typically indicates the download
     * is complete, this will display one last line, unless the last line has already
     * been written.
     */
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = void 0;
      }
      this.display();
    }
  }
  downloadUtils.DownloadProgress = DownloadProgress;
  function downloadCacheHttpClient(archiveLocation, archivePath) {
    return __awaiter2(this, void 0, void 0, function* () {
      const writeStream = fs.createWriteStream(archivePath);
      const httpClient = new http_client_1.HttpClient("actions/cache");
      const downloadResponse = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.get(archiveLocation);
      }));
      downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, () => {
        downloadResponse.message.destroy();
        core2.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
      });
      yield pipeResponseToStream(downloadResponse, writeStream);
      const contentLengthHeader = downloadResponse.message.headers["content-length"];
      if (contentLengthHeader) {
        const expectedLength = parseInt(contentLengthHeader);
        const actualLength = utils2.getArchiveFileSizeInBytes(archivePath);
        if (actualLength !== expectedLength) {
          throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
        }
      } else {
        core2.debug("Unable to validate download, no Content-Length header");
      }
    });
  }
  downloadUtils.downloadCacheHttpClient = downloadCacheHttpClient;
  function downloadCacheHttpClientConcurrent(archiveLocation, archivePath, options2) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      const archiveDescriptor = yield fs.promises.open(archivePath, "w");
      const httpClient = new http_client_1.HttpClient("actions/cache", void 0, {
        socketTimeout: options2.timeoutInMs,
        keepAlive: true
      });
      try {
        const res = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCacheMetadata", () => __awaiter2(this, void 0, void 0, function* () {
          return yield httpClient.request("HEAD", archiveLocation, null, {});
        }));
        const lengthHeader = res.message.headers["content-length"];
        if (lengthHeader === void 0 || lengthHeader === null) {
          throw new Error("Content-Length not found on blob response");
        }
        const length = parseInt(lengthHeader);
        if (Number.isNaN(length)) {
          throw new Error(`Could not interpret Content-Length: ${length}`);
        }
        const downloads = [];
        const blockSize = 4 * 1024 * 1024;
        for (let offset = 0; offset < length; offset += blockSize) {
          const count = Math.min(blockSize, length - offset);
          downloads.push({
            offset,
            promiseGetter: () => __awaiter2(this, void 0, void 0, function* () {
              return yield downloadSegmentRetry(httpClient, archiveLocation, offset, count);
            })
          });
        }
        downloads.reverse();
        let actives = 0;
        let bytesDownloaded = 0;
        const progress = new DownloadProgress(length);
        progress.startDisplayTimer();
        const progressFn = progress.onProgress();
        const activeDownloads = [];
        let nextDownload;
        const waitAndWrite = () => __awaiter2(this, void 0, void 0, function* () {
          const segment = yield Promise.race(Object.values(activeDownloads));
          yield archiveDescriptor.write(segment.buffer, 0, segment.count, segment.offset);
          actives--;
          delete activeDownloads[segment.offset];
          bytesDownloaded += segment.count;
          progressFn({ loadedBytes: bytesDownloaded });
        });
        while (nextDownload = downloads.pop()) {
          activeDownloads[nextDownload.offset] = nextDownload.promiseGetter();
          actives++;
          if (actives >= ((_a = options2.downloadConcurrency) !== null && _a !== void 0 ? _a : 10)) {
            yield waitAndWrite();
          }
        }
        while (actives > 0) {
          yield waitAndWrite();
        }
      } finally {
        httpClient.dispose();
        yield archiveDescriptor.close();
      }
    });
  }
  downloadUtils.downloadCacheHttpClientConcurrent = downloadCacheHttpClientConcurrent;
  function downloadSegmentRetry(httpClient, archiveLocation, offset, count) {
    return __awaiter2(this, void 0, void 0, function* () {
      const retries = 5;
      let failures = 0;
      while (true) {
        try {
          const timeout = 3e4;
          const result = yield promiseWithTimeout(timeout, downloadSegment(httpClient, archiveLocation, offset, count));
          if (typeof result === "string") {
            throw new Error("downloadSegmentRetry failed due to timeout");
          }
          return result;
        } catch (err) {
          if (failures >= retries) {
            throw err;
          }
          failures++;
        }
      }
    });
  }
  function downloadSegment(httpClient, archiveLocation, offset, count) {
    return __awaiter2(this, void 0, void 0, function* () {
      const partRes = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCachePart", () => __awaiter2(this, void 0, void 0, function* () {
        return yield httpClient.get(archiveLocation, {
          Range: `bytes=${offset}-${offset + count - 1}`
        });
      }));
      if (!partRes.readBodyBuffer) {
        throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
      }
      return {
        offset,
        count,
        buffer: yield partRes.readBodyBuffer()
      };
    });
  }
  function downloadCacheStorageSDK(archiveLocation, archivePath, options2) {
    var _a;
    return __awaiter2(this, void 0, void 0, function* () {
      const client2 = new storage_blob_1.BlockBlobClient(archiveLocation, void 0, {
        retryOptions: {
          // Override the timeout used when downloading each 4 MB chunk
          // The default is 2 min / MB, which is way too slow
          tryTimeoutInMs: options2.timeoutInMs
        }
      });
      const properties = yield client2.getProperties();
      const contentLength = (_a = properties.contentLength) !== null && _a !== void 0 ? _a : -1;
      if (contentLength < 0) {
        core2.debug("Unable to determine content length, downloading file with http-client...");
        yield downloadCacheHttpClient(archiveLocation, archivePath);
      } else {
        const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH);
        const downloadProgress = new DownloadProgress(contentLength);
        const fd = fs.openSync(archivePath, "w");
        try {
          downloadProgress.startDisplayTimer();
          const controller = new abort_controller_1.AbortController();
          const abortSignal2 = controller.signal;
          while (!downloadProgress.isDone()) {
            const segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize;
            const segmentSize = Math.min(maxSegmentSize, contentLength - segmentStart);
            downloadProgress.nextSegment(segmentSize);
            const result = yield promiseWithTimeout(options2.segmentTimeoutInMs || 36e5, client2.downloadToBuffer(segmentStart, segmentSize, {
              abortSignal: abortSignal2,
              concurrency: options2.downloadConcurrency,
              onProgress: downloadProgress.onProgress()
            }));
            if (result === "timeout") {
              controller.abort();
              throw new Error("Aborting cache download as the download time exceeded the timeout.");
            } else if (Buffer.isBuffer(result)) {
              fs.writeFileSync(fd, result);
            }
          }
        } finally {
          downloadProgress.stopDisplayTimer();
          fs.closeSync(fd);
        }
      }
    });
  }
  downloadUtils.downloadCacheStorageSDK = downloadCacheStorageSDK;
  const promiseWithTimeout = (timeoutMs, promise) => __awaiter2(void 0, void 0, void 0, function* () {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve) => {
      timeoutHandle = setTimeout(() => resolve("timeout"), timeoutMs);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    });
  });
  return downloadUtils;
}
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  var __createBinding2 = options && options.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = options && options.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = options && options.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(options, "__esModule", { value: true });
  options.getDownloadOptions = options.getUploadOptions = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  function getUploadOptions(copy2) {
    const result = {
      useAzureSdk: false,
      uploadConcurrency: 4,
      uploadChunkSize: 32 * 1024 * 1024
    };
    if (copy2) {
      if (typeof copy2.useAzureSdk === "boolean") {
        result.useAzureSdk = copy2.useAzureSdk;
      }
      if (typeof copy2.uploadConcurrency === "number") {
        result.uploadConcurrency = copy2.uploadConcurrency;
      }
      if (typeof copy2.uploadChunkSize === "number") {
        result.uploadChunkSize = copy2.uploadChunkSize;
      }
    }
    result.uploadConcurrency = !isNaN(Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) ? Math.min(32, Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) : result.uploadConcurrency;
    result.uploadChunkSize = !isNaN(Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"])) ? Math.min(128 * 1024 * 1024, Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"]) * 1024 * 1024) : result.uploadChunkSize;
    core2.debug(`Use Azure SDK: ${result.useAzureSdk}`);
    core2.debug(`Upload concurrency: ${result.uploadConcurrency}`);
    core2.debug(`Upload chunk size: ${result.uploadChunkSize}`);
    return result;
  }
  options.getUploadOptions = getUploadOptions;
  function getDownloadOptions(copy2) {
    const result = {
      useAzureSdk: false,
      concurrentBlobDownloads: true,
      downloadConcurrency: 8,
      timeoutInMs: 3e4,
      segmentTimeoutInMs: 6e5,
      lookupOnly: false
    };
    if (copy2) {
      if (typeof copy2.useAzureSdk === "boolean") {
        result.useAzureSdk = copy2.useAzureSdk;
      }
      if (typeof copy2.concurrentBlobDownloads === "boolean") {
        result.concurrentBlobDownloads = copy2.concurrentBlobDownloads;
      }
      if (typeof copy2.downloadConcurrency === "number") {
        result.downloadConcurrency = copy2.downloadConcurrency;
      }
      if (typeof copy2.timeoutInMs === "number") {
        result.timeoutInMs = copy2.timeoutInMs;
      }
      if (typeof copy2.segmentTimeoutInMs === "number") {
        result.segmentTimeoutInMs = copy2.segmentTimeoutInMs;
      }
      if (typeof copy2.lookupOnly === "boolean") {
        result.lookupOnly = copy2.lookupOnly;
      }
    }
    const segmentDownloadTimeoutMins = process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"];
    if (segmentDownloadTimeoutMins && !isNaN(Number(segmentDownloadTimeoutMins)) && isFinite(Number(segmentDownloadTimeoutMins))) {
      result.segmentTimeoutInMs = Number(segmentDownloadTimeoutMins) * 60 * 1e3;
    }
    core2.debug(`Use Azure SDK: ${result.useAzureSdk}`);
    core2.debug(`Download concurrency: ${result.downloadConcurrency}`);
    core2.debug(`Request timeout (ms): ${result.timeoutInMs}`);
    core2.debug(`Cache segment download timeout mins env var: ${process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"]}`);
    core2.debug(`Segment download timeout (ms): ${result.segmentTimeoutInMs}`);
    core2.debug(`Lookup only: ${result.lookupOnly}`);
    return result;
  }
  options.getDownloadOptions = getDownloadOptions;
  return options;
}
var config = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", { value: true });
  config.getCacheServiceURL = config.getCacheServiceVersion = config.isGhes = void 0;
  function isGhes() {
    const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
    const hostname = ghUrl.hostname.trimEnd().toUpperCase();
    const isGitHubHost = hostname === "GITHUB.COM";
    const isGheHost = hostname.endsWith(".GHE.COM");
    const isLocalHost = hostname.endsWith(".LOCALHOST");
    return !isGitHubHost && !isGheHost && !isLocalHost;
  }
  config.isGhes = isGhes;
  function getCacheServiceVersion() {
    if (isGhes())
      return "v1";
    return process.env["ACTIONS_CACHE_SERVICE_V2"] ? "v2" : "v1";
  }
  config.getCacheServiceVersion = getCacheServiceVersion;
  function getCacheServiceURL() {
    const version2 = getCacheServiceVersion();
    switch (version2) {
      case "v1":
        return process.env["ACTIONS_CACHE_URL"] || process.env["ACTIONS_RESULTS_URL"] || "";
      case "v2":
        return process.env["ACTIONS_RESULTS_URL"] || "";
      default:
        throw new Error(`Unsupported cache service version: ${version2}`);
    }
  }
  config.getCacheServiceURL = getCacheServiceURL;
  return config;
}
var userAgent = {};
const version = "4.1.0";
const require$$0$1 = {
  version
};
var hasRequiredUserAgent;
function requireUserAgent() {
  if (hasRequiredUserAgent) return userAgent;
  hasRequiredUserAgent = 1;
  Object.defineProperty(userAgent, "__esModule", { value: true });
  userAgent.getUserAgentString = void 0;
  const packageJson = require$$0$1;
  function getUserAgentString() {
    return `@actions/cache-${packageJson.version}`;
  }
  userAgent.getUserAgentString = getUserAgentString;
  return userAgent;
}
var hasRequiredCacheHttpClient;
function requireCacheHttpClient() {
  if (hasRequiredCacheHttpClient) return cacheHttpClient;
  hasRequiredCacheHttpClient = 1;
  var __createBinding2 = cacheHttpClient && cacheHttpClient.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = cacheHttpClient && cacheHttpClient.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = cacheHttpClient && cacheHttpClient.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = cacheHttpClient && cacheHttpClient.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(cacheHttpClient, "__esModule", { value: true });
  cacheHttpClient.saveCache = cacheHttpClient.reserveCache = cacheHttpClient.downloadCache = cacheHttpClient.getCacheEntry = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const http_client_1 = /* @__PURE__ */ requireLib$1();
  const auth_1 = /* @__PURE__ */ requireAuth();
  const fs = __importStar2(require$$1$2);
  const url_1 = require$$5$1;
  const utils2 = __importStar2(/* @__PURE__ */ requireCacheUtils());
  const uploadUtils_1 = /* @__PURE__ */ requireUploadUtils();
  const downloadUtils_1 = /* @__PURE__ */ requireDownloadUtils();
  const options_1 = /* @__PURE__ */ requireOptions();
  const requestUtils_1 = /* @__PURE__ */ requireRequestUtils();
  const config_1 = /* @__PURE__ */ requireConfig();
  const user_agent_1 = /* @__PURE__ */ requireUserAgent();
  function getCacheApiUrl(resource) {
    const baseUrl = (0, config_1.getCacheServiceURL)();
    if (!baseUrl) {
      throw new Error("Cache Service Url not found, unable to restore cache.");
    }
    const url = `${baseUrl}_apis/artifactcache/${resource}`;
    core2.debug(`Resource Url: ${url}`);
    return url;
  }
  function createAcceptHeader(type, apiVersion) {
    return `${type};api-version=${apiVersion}`;
  }
  function getRequestOptions() {
    const requestOptions = {
      headers: {
        Accept: createAcceptHeader("application/json", "6.0-preview.1")
      }
    };
    return requestOptions;
  }
  function createHttpClient() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"] || "";
    const bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
    return new http_client_1.HttpClient((0, user_agent_1.getUserAgentString)(), [bearerCredentialHandler], getRequestOptions());
  }
  function getCacheEntry(keys, paths, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const httpClient = createHttpClient();
      const version2 = utils2.getCacheVersion(paths, options2 === null || options2 === void 0 ? void 0 : options2.compressionMethod, options2 === null || options2 === void 0 ? void 0 : options2.enableCrossOsArchive);
      const resource = `cache?keys=${encodeURIComponent(keys.join(","))}&version=${version2}`;
      const response2 = yield (0, requestUtils_1.retryTypedResponse)("getCacheEntry", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response2.statusCode === 204) {
        if (core2.isDebug()) {
          yield printCachesListForDiagnostics(keys[0], httpClient, version2);
        }
        return null;
      }
      if (!(0, requestUtils_1.isSuccessStatusCode)(response2.statusCode)) {
        throw new Error(`Cache service responded with ${response2.statusCode}`);
      }
      const cacheResult = response2.result;
      const cacheDownloadUrl = cacheResult === null || cacheResult === void 0 ? void 0 : cacheResult.archiveLocation;
      if (!cacheDownloadUrl) {
        throw new Error("Cache not found.");
      }
      core2.setSecret(cacheDownloadUrl);
      core2.debug(`Cache Result:`);
      core2.debug(JSON.stringify(cacheResult));
      return cacheResult;
    });
  }
  cacheHttpClient.getCacheEntry = getCacheEntry;
  function printCachesListForDiagnostics(key, httpClient, version2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const resource = `caches?key=${encodeURIComponent(key)}`;
      const response2 = yield (0, requestUtils_1.retryTypedResponse)("listCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response2.statusCode === 200) {
        const cacheListResult = response2.result;
        const totalCount = cacheListResult === null || cacheListResult === void 0 ? void 0 : cacheListResult.totalCount;
        if (totalCount && totalCount > 0) {
          core2.debug(`No matching cache found for cache key '${key}', version '${version2} and scope ${process.env["GITHUB_REF"]}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
          for (const cacheEntry of (cacheListResult === null || cacheListResult === void 0 ? void 0 : cacheListResult.artifactCaches) || []) {
            core2.debug(`Cache Key: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.cacheKey}, Cache Version: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.cacheVersion}, Cache Scope: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.scope}, Cache Created: ${cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.creationTime}`);
          }
        }
      }
    });
  }
  function downloadCache(archiveLocation, archivePath, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const archiveUrl = new url_1.URL(archiveLocation);
      const downloadOptions = (0, options_1.getDownloadOptions)(options2);
      if (archiveUrl.hostname.endsWith(".blob.core.windows.net")) {
        if (downloadOptions.useAzureSdk) {
          yield (0, downloadUtils_1.downloadCacheStorageSDK)(archiveLocation, archivePath, downloadOptions);
        } else if (downloadOptions.concurrentBlobDownloads) {
          yield (0, downloadUtils_1.downloadCacheHttpClientConcurrent)(archiveLocation, archivePath, downloadOptions);
        } else {
          yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
        }
      } else {
        yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
      }
    });
  }
  cacheHttpClient.downloadCache = downloadCache;
  function reserveCache(key, paths, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const httpClient = createHttpClient();
      const version2 = utils2.getCacheVersion(paths, options2 === null || options2 === void 0 ? void 0 : options2.compressionMethod, options2 === null || options2 === void 0 ? void 0 : options2.enableCrossOsArchive);
      const reserveCacheRequest = {
        key,
        version: version2,
        cacheSize: options2 === null || options2 === void 0 ? void 0 : options2.cacheSize
      };
      const response2 = yield (0, requestUtils_1.retryTypedResponse)("reserveCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.postJson(getCacheApiUrl("caches"), reserveCacheRequest);
      }));
      return response2;
    });
  }
  cacheHttpClient.reserveCache = reserveCache;
  function getContentRange(start, end) {
    return `bytes ${start}-${end}/*`;
  }
  function uploadChunk(httpClient, resourceUrl, openStream, start, end) {
    return __awaiter2(this, void 0, void 0, function* () {
      core2.debug(`Uploading chunk of size ${end - start + 1} bytes at offset ${start} with content range: ${getContentRange(start, end)}`);
      const additionalHeaders = {
        "Content-Type": "application/octet-stream",
        "Content-Range": getContentRange(start, end)
      };
      const uploadChunkResponse = yield (0, requestUtils_1.retryHttpClientResponse)(`uploadChunk (start: ${start}, end: ${end})`, () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.sendStream("PATCH", resourceUrl, openStream(), additionalHeaders);
      }));
      if (!(0, requestUtils_1.isSuccessStatusCode)(uploadChunkResponse.message.statusCode)) {
        throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
      }
    });
  }
  function uploadFile(httpClient, cacheId, archivePath, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const fileSize = utils2.getArchiveFileSizeInBytes(archivePath);
      const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`);
      const fd = fs.openSync(archivePath, "r");
      const uploadOptions = (0, options_1.getUploadOptions)(options2);
      const concurrency = utils2.assertDefined("uploadConcurrency", uploadOptions.uploadConcurrency);
      const maxChunkSize = utils2.assertDefined("uploadChunkSize", uploadOptions.uploadChunkSize);
      const parallelUploads = [...new Array(concurrency).keys()];
      core2.debug("Awaiting all uploads");
      let offset = 0;
      try {
        yield Promise.all(parallelUploads.map(() => __awaiter2(this, void 0, void 0, function* () {
          while (offset < fileSize) {
            const chunkSize = Math.min(fileSize - offset, maxChunkSize);
            const start = offset;
            const end = offset + chunkSize - 1;
            offset += maxChunkSize;
            yield uploadChunk(httpClient, resourceUrl, () => fs.createReadStream(archivePath, {
              fd,
              start,
              end,
              autoClose: false
            }).on("error", (error2) => {
              throw new Error(`Cache upload failed because file read failed with ${error2.message}`);
            }), start, end);
          }
        })));
      } finally {
        fs.closeSync(fd);
      }
      return;
    });
  }
  function commitCache(httpClient, cacheId, filesize) {
    return __awaiter2(this, void 0, void 0, function* () {
      const commitCacheRequest = { size: filesize };
      return yield (0, requestUtils_1.retryTypedResponse)("commitCache", () => __awaiter2(this, void 0, void 0, function* () {
        return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
      }));
    });
  }
  function saveCache(cacheId, archivePath, signedUploadURL, options2) {
    return __awaiter2(this, void 0, void 0, function* () {
      const uploadOptions = (0, options_1.getUploadOptions)(options2);
      if (uploadOptions.useAzureSdk) {
        if (!signedUploadURL) {
          throw new Error("Azure Storage SDK can only be used when a signed URL is provided.");
        }
        yield (0, uploadUtils_1.uploadCacheArchiveSDK)(signedUploadURL, archivePath, options2);
      } else {
        const httpClient = createHttpClient();
        core2.debug("Upload cache");
        yield uploadFile(httpClient, cacheId, archivePath, options2);
        core2.debug("Commiting cache");
        const cacheSize = utils2.getArchiveFileSizeInBytes(archivePath);
        core2.info(`Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`);
        const commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
        if (!(0, requestUtils_1.isSuccessStatusCode)(commitCacheResponse.statusCode)) {
          throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
        }
        core2.info("Cache saved successfully");
      }
    });
  }
  cacheHttpClient.saveCache = saveCache;
  return cacheHttpClient;
}
var cacheTwirpClient = {};
var cache_twirpClient = {};
var cache = {};
function typeofJsonValue(value) {
  let t = typeof value;
  if (t == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
let decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i = 0; i < base64Str.length; i++) {
    b = decTable[base64Str.charCodeAt(i)];
    if (b === void 0) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        // reset state when padding found
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base642 = "", groupPos = 0, b, p = 0;
  for (let i = 0; i < bytes.length; i++) {
    b = bytes[i];
    switch (groupPos) {
      case 0:
        base642 += encTable[b >> 2];
        p = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base642 += encTable[p | b >> 4];
        p = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base642 += encTable[p | b >> 6];
        base642 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base642 += encTable[p];
    base642 += "=";
    if (groupPos == 1)
      base642 += "=";
  }
  return base642;
}
const fromCharCodes = (chunk) => String.fromCharCode.apply(String, chunk);
function utf8read(bytes) {
  if (bytes.length < 1)
    return "";
  let pos = 0, parts = [], chunk = [], i = 0, t;
  let len = bytes.length;
  while (pos < len) {
    t = bytes[pos++];
    if (t < 128)
      chunk[i++] = t;
    else if (t > 191 && t < 224)
      chunk[i++] = (t & 31) << 6 | bytes[pos++] & 63;
    else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
      chunk[i++] = 55296 + (t >> 10);
      chunk[i++] = 56320 + (t & 1023);
    } else
      chunk[i++] = (t & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
    if (i > 8191) {
      parts.push(fromCharCodes(chunk));
      i = 0;
    }
  }
  if (parts.length) {
    if (i)
      parts.push(fromCharCodes(chunk.slice(0, i)));
    return parts.join("");
  }
  return fromCharCodes(chunk.slice(0, i));
}
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container2 = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container2.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
function mergeBinaryOptions(a, b) {
  return Object.assign(Object.assign({}, a), b);
}
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL$1) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL$1 | 0);
      lowBits = lowBits % TWO_PWR_32_DBL$1;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
let BI;
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
detectBi();
function assertBi(bi) {
  if (!bi)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
const RE_DECIMAL_STR = /^-?[0-9]+$/;
const TWO_PWR_32_DBL = 4294967296;
const HALF_2_PWR_32 = 2147483648;
class SharedPbLong {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
}
class PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value, true);
          return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new PbULong(lo, hi);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new PbULong(value, value / TWO_PWR_32_DBL);
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
}
PbULong.ZERO = new PbULong(0, 0);
class PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.MIN)
            throw new Error("signed long too small");
          if (value > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value, true);
          return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus) {
            if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new PbLong(lo, hi);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi += 1;
    return new PbLong(lo, hi);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n = this.negate();
      return "-" + int64toString(n.lo, n.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
}
PbLong.ZERO = new PbLong(0, 0);
const defaultsRead$1 = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options2) {
  return options2 ? Object.assign(Object.assign({}, defaultsRead$1), options2) : defaultsRead$1;
}
class BinaryReader {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t;
        while ((t = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return new PbLong(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function assertNever(value, msg) {
  throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value);
}
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}
const defaultsWrite$1 = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options2) {
  return options2 ? Object.assign(Object.assign({}, defaultsWrite$1), options2) : defaultsWrite$1;
}
class BinaryWriter {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
}
const defaultsWrite = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
}, defaultsRead = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options2) {
  return options2 ? Object.assign(Object.assign({}, defaultsRead), options2) : defaultsRead;
}
function jsonWriteOptions(options2) {
  return options2 ? Object.assign(Object.assign({}, defaultsWrite), options2) : defaultsWrite;
}
function mergeJsonOptions(a, b) {
  var _a, _b;
  let c = Object.assign(Object.assign({}, a), b);
  c.typeRegistry = [...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []];
  return c;
}
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let next = snakeCase.charAt(i);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb.push(next);
      capNext = true;
    } else if (capNext) {
      sb.push(next.toUpperCase());
      capNext = false;
    } else if (i == 0) {
      sb.push(next.toLowerCase());
    } else {
      sb.push(next);
    }
  }
  return sb.join("");
}
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a, _b, _c, _d;
  field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
  var _a;
  const options2 = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
  return options2 && options2[extensionName] ? extensionType.fromJson(options2[extensionName]) : void 0;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
  var _a;
  const options2 = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
  if (!options2) {
    return void 0;
  }
  const optionVal = options2[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
  const options2 = messageType.options;
  const optionVal = options2[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}
function getOneofValue(oneof, kind) {
  return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
  if (oneof.oneofKind !== void 0) {
    delete oneof[oneof.oneofKind];
  }
  oneof.oneofKind = kind;
  if (value !== void 0) {
    oneof[kind] = value;
  }
}
function clearOneofValue(oneof) {
  if (oneof.oneofKind !== void 0) {
    delete oneof[oneof.oneofKind];
  }
  oneof.oneofKind = void 0;
}
function getSelectedOneofValue(oneof) {
  if (oneof.oneofKind === void 0) {
    return void 0;
  }
  return oneof[oneof.oneofKind];
}
class ReflectionTypeCheck {
  constructor(info) {
    var _a;
    this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k) => !data.known.includes(k)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name of data.oneofs) {
      const group = message[name];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f) => f.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.isAssignable(arg[i], depth - 1))
          return false;
    } else {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.is(arg[i], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!this.scalar(arg[i], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map, type, depth) {
    let keys = Object.keys(map);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
}
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}
class ReflectionJsonReader {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options2) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options2.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options2);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options2.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options2);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options2.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options2, target[localName]);
            break;
          case "enum":
            if (jsonValue === null)
              continue;
            let val = this.enum(field.T(), jsonValue, field.name, options2.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            if (jsonValue === null)
              continue;
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e;
    try {
      switch (type) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        // bool:
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        // string:
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e = "extra whitespace";
            break;
          }
          return json;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error2) {
      e = error2.message;
    }
    this.assert(false, fieldName + (e ? " - " + e : ""), json);
  }
}
class ReflectionJsonWriter {
  constructor(info) {
    var _a;
    this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options2) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options2);
        if (jsonValue2 !== void 0)
          json[options2.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options2), { emitDefaultValues: true }) : options2;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options2.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options2) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options2);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options2.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options2.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            const val = this.scalar(field.T, value[i], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i = 0; i < value.length; i++) {
            assert(value[i] === void 0 || typeof value[i] == "number");
            const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options2.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i = 0; i < value.length; i++) {
            const val = this.message(messageType, value[i], field.name, options2);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options2.emitDefaultValues || jsonArr.length > 0 || options2.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options2.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options2.emitDefaultValues, options2.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options2);
          break;
      }
    }
    return jsonValue;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options2) {
    if (value === void 0)
      return options2.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options2);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed = emitDefaultValues || optional;
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertUInt32(value);
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        if (value === "")
          return ed ? "" : void 0;
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        if (value === false)
          return ed ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed)
          return void 0;
        return ulong.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed)
          return void 0;
        return long.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed ? "" : void 0;
        return base64encode(value);
    }
  }
}
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
class ReflectionBinaryReader {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options2, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u = options2.readUnknownField;
        if (u == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u !== false)
          (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
              let e = reader.uint32() + reader.pos;
              while (reader.pos < e)
                arr.push(this.scalar(reader, T, L));
            } else
              arr.push(this.scalar(reader, T, L));
          } else
            target[localName] = this.scalar(reader, T, L);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options2);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options2, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options2);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options2) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options2);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
}
class ReflectionBinaryWriter {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a, b) => a.no - b.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options2) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer, T, field.no, value);
            else
              for (const item of value)
                this.scalar(writer, T, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer, options2, field.T(), field.no, item);
          } else {
            this.message(writer, options2, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer, options2, field, key, val);
          break;
      }
    }
    let u = options2.writeUnknownFields;
    if (u !== false)
      (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options2, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer, options2, field.V.T(), 2, value);
        break;
    }
    writer.join();
  }
  message(writer, options2, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options2);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type);
    for (let i = 0; i < value.length; i++)
      writer[method](value[i]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type, value) {
    let t = WireType.Varint;
    let m;
    let i = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m = "int32";
        break;
      case ScalarType.STRING:
        d = i || !value.length;
        t = WireType.LengthDelimited;
        m = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m = "bool";
        break;
      case ScalarType.UINT32:
        m = "uint32";
        break;
      case ScalarType.DOUBLE:
        t = WireType.Bit64;
        m = "double";
        break;
      case ScalarType.FLOAT:
        t = WireType.Bit32;
        m = "float";
        break;
      case ScalarType.INT64:
        d = i || PbLong.from(value).isZero();
        m = "int64";
        break;
      case ScalarType.UINT64:
        d = i || PbULong.from(value).isZero();
        m = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i || PbULong.from(value).isZero();
        t = WireType.Bit64;
        m = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i || !value.byteLength;
        t = WireType.LengthDelimited;
        m = "bytes";
        break;
      case ScalarType.FIXED32:
        t = WireType.Bit32;
        m = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t = WireType.Bit32;
        m = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i || PbLong.from(value).isZero();
        t = WireType.Bit64;
        m = "sfixed64";
        break;
      case ScalarType.SINT32:
        m = "sint32";
        break;
      case ScalarType.SINT64:
        d = i || PbLong.from(value).isZero();
        m = "sint64";
        break;
    }
    return [t, m, i || d];
  }
}
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name] = 0;
          break;
        case "map":
          msg[name] = {};
          break;
      }
  }
  return msg;
}
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name];
        continue;
      }
    } else {
      fieldValue = input[name];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = fieldValue[i];
        else
          output[name] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = T.create(fieldValue[i]);
        else if (output[name] === void 0)
          output[name] = T.create(fieldValue);
        else
          T.mergePartial(output[name], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k of Object.keys(fieldValue))
              output[name][k] = T2.create(fieldValue[k]);
            break;
        }
        break;
    }
  }
}
function reflectionEquals(info, a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
  if (a === b)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba = a;
  let bb = b;
  if (ba.length !== bb.length)
    return false;
  for (let i = 0; i < ba.length; i++)
    if (ba[i] != bb[i])
      return false;
  return true;
}
function repeatedPrimitiveEq(type, a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!primitiveEq(type, a[i], b[i]))
      return false;
  return true;
}
function repeatedMsgEq(type, a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!type.equals(a[i], b[i]))
      return false;
  return true;
}
const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
const messageTypeDescriptor = baseDescriptors[MESSAGE_TYPE] = {};
class MessageType {
  constructor(name, fields, options2) {
    this.defaultCheckDepth = 16;
    this.typeName = name;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options2 !== null && options2 !== void 0 ? options2 : {};
    messageTypeDescriptor.value = this;
    this.messagePrototype = Object.create(null, baseDescriptors);
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy2 = this.create();
    reflectionMergePartial(this, copy2, message);
    return copy2;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a, b) {
    return reflectionEquals(this, a, b);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options2) {
    let opt = binaryReadOptions(options2);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json, options2) {
    return this.internalJsonRead(json, jsonReadOptions(options2));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json, options2) {
    let value = JSON.parse(json);
    return this.fromJson(value, options2);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options2) {
    return this.internalJsonWrite(message, jsonWriteOptions(options2));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options2) {
    var _a;
    let value = this.toJson(message, options2);
    return JSON.stringify(value, null, (_a = options2 === null || options2 === void 0 ? void 0 : options2.prettySpaces) !== null && _a !== void 0 ? _a : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options2) {
    let opt = binaryWriteOptions(options2);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json, options2, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options2);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options2) {
    return this.refJsonWriter.write(message, options2);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options2) {
    this.refBinWriter.write(message, writer, options2);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length, options2, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options2, length);
    return message;
  }
}
function containsMessageType(msg) {
  return msg[MESSAGE_TYPE] != null;
}
function isEnumObject(arg) {
  if (typeof arg != "object" || arg === null) {
    return false;
  }
  if (!arg.hasOwnProperty(0)) {
    return false;
  }
  for (let k of Object.keys(arg)) {
    let num = parseInt(k);
    if (!Number.isNaN(num)) {
      let nam = arg[num];
      if (nam === void 0)
        return false;
      if (arg[nam] !== num)
        return false;
    } else {
      let num2 = arg[k];
      if (num2 === void 0)
        return false;
      if (typeof num2 !== "number")
        return false;
      if (arg[num2] === void 0)
        return false;
    }
  }
  return true;
}
function listEnumValues(enumObject) {
  if (!isEnumObject(enumObject))
    throw new Error("not a typescript enum object");
  let values = [];
  for (let [name, number] of Object.entries(enumObject))
    if (typeof number == "number")
      values.push({ name, number });
  return values;
}
function listEnumNames(enumObject) {
  return listEnumValues(enumObject).map((val) => val.name);
}
function listEnumNumbers(enumObject) {
  return listEnumValues(enumObject).map((val) => val.number).filter((num, index, arr) => arr.indexOf(num) == index);
}
const es2015$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BinaryReader,
  BinaryWriter,
  get LongType() {
    return LongType;
  },
  MESSAGE_TYPE,
  MessageType,
  PbLong,
  PbULong,
  ReflectionBinaryReader,
  ReflectionBinaryWriter,
  ReflectionJsonReader,
  ReflectionJsonWriter,
  ReflectionTypeCheck,
  get RepeatType() {
    return RepeatType;
  },
  get ScalarType() {
    return ScalarType;
  },
  get UnknownFieldHandler() {
    return UnknownFieldHandler;
  },
  get WireType() {
    return WireType;
  },
  assert,
  assertFloat32,
  assertInt32,
  assertNever,
  assertUInt32,
  base64decode,
  base64encode,
  binaryReadOptions,
  binaryWriteOptions,
  clearOneofValue,
  containsMessageType,
  getOneofValue,
  getSelectedOneofValue,
  isEnumObject,
  isJsonObject,
  isOneofGroup,
  jsonReadOptions,
  jsonWriteOptions,
  listEnumNames,
  listEnumNumbers,
  listEnumValues,
  lowerCamelCase,
  mergeBinaryOptions,
  mergeJsonOptions,
  normalizeFieldInfo,
  readFieldOption,
  readFieldOptions,
  readMessageOption,
  reflectionCreate,
  reflectionEquals,
  reflectionMergePartial,
  reflectionScalarDefault,
  setOneofValue,
  typeofJsonValue,
  utf8read
}, Symbol.toStringTag, { value: "Module" }));
function normalizeMethodInfo(method, service2) {
  var _a, _b, _c;
  let m = method;
  m.service = service2;
  m.localName = (_a = m.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m.name);
  m.serverStreaming = !!m.serverStreaming;
  m.clientStreaming = !!m.clientStreaming;
  m.options = (_b = m.options) !== null && _b !== void 0 ? _b : {};
  m.idempotency = (_c = m.idempotency) !== null && _c !== void 0 ? _c : void 0;
  return m;
}
function readMethodOptions(service2, methodName, extensionName, extensionType) {
  var _a;
  const options2 = (_a = service2.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;
  return options2 && options2[extensionName] ? extensionType.fromJson(options2[extensionName]) : void 0;
}
function readMethodOption(service2, methodName, extensionName, extensionType) {
  var _a;
  const options2 = (_a = service2.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;
  if (!options2) {
    return void 0;
  }
  const optionVal = options2[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readServiceOption(service2, extensionName, extensionType) {
  const options2 = service2.options;
  if (!options2) {
    return void 0;
  }
  const optionVal = options2[extensionName];
  if (optionVal === void 0) {
    return optionVal;
  }
  return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
class ServiceType {
  constructor(typeName, methods, options2) {
    this.typeName = typeName;
    this.methods = methods.map((i) => normalizeMethodInfo(i, this));
    this.options = options2 !== null && options2 !== void 0 ? options2 : {};
  }
}
class RpcError extends Error {
  constructor(message, code = "UNKNOWN", meta) {
    super(message);
    this.name = "RpcError";
    Object.setPrototypeOf(this, new.target.prototype);
    this.code = code;
    this.meta = meta !== null && meta !== void 0 ? meta : {};
  }
  toString() {
    const l = [this.name + ": " + this.message];
    if (this.code) {
      l.push("");
      l.push("Code: " + this.code);
    }
    if (this.serviceName && this.methodName) {
      l.push("Method: " + this.serviceName + "/" + this.methodName);
    }
    let m = Object.entries(this.meta);
    if (m.length) {
      l.push("");
      l.push("Meta:");
      for (let [k, v] of m) {
        l.push(`  ${k}: ${v}`);
      }
    }
    return l.join("\n");
  }
}
function mergeRpcOptions(defaults, options2) {
  if (!options2)
    return defaults;
  let o = {};
  copy(defaults, o);
  copy(options2, o);
  for (let key of Object.keys(options2)) {
    let val = options2[key];
    switch (key) {
      case "jsonOptions":
        o.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);
        break;
      case "binaryOptions":
        o.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);
        break;
      case "meta":
        o.meta = {};
        copy(defaults.meta, o.meta);
        copy(options2.meta, o.meta);
        break;
      case "interceptors":
        o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
        break;
    }
  }
  return o;
}
function copy(a, into) {
  if (!a)
    return;
  let c = into;
  for (let [k, v] of Object.entries(a)) {
    if (v instanceof Date)
      c[k] = new Date(v.getTime());
    else if (Array.isArray(v))
      c[k] = v.concat();
    else
      c[k] = v;
  }
}
var DeferredState;
(function(DeferredState2) {
  DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
  DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
  DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
})(DeferredState || (DeferredState = {}));
class Deferred {
  /**
   * @param preventUnhandledRejectionWarning - prevents the warning
   * "Unhandled Promise rejection" by adding a noop rejection handler.
   * Working with calls returned from the runtime-rpc package in an
   * async function usually means awaiting one call property after
   * the other. This means that the "status" is not being awaited when
   * an earlier await for the "headers" is rejected. This causes the
   * "unhandled promise reject" warning. A more correct behaviour for
   * calls might be to become aware whether at least one of the
   * promises is handled and swallow the rejection warning for the
   * others.
   */
  constructor(preventUnhandledRejectionWarning = true) {
    this._state = DeferredState.PENDING;
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    if (preventUnhandledRejectionWarning) {
      this._promise.catch((_) => {
      });
    }
  }
  /**
   * Get the current state of the promise.
   */
  get state() {
    return this._state;
  }
  /**
   * Get the deferred promise.
   */
  get promise() {
    return this._promise;
  }
  /**
   * Resolve the promise. Throws if the promise is already resolved or rejected.
   */
  resolve(value) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
    this._resolve(value);
    this._state = DeferredState.RESOLVED;
  }
  /**
   * Reject the promise. Throws if the promise is already resolved or rejected.
   */
  reject(reason) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
    this._reject(reason);
    this._state = DeferredState.REJECTED;
  }
  /**
   * Resolve the promise. Ignore if not pending.
   */
  resolvePending(val) {
    if (this._state === DeferredState.PENDING)
      this.resolve(val);
  }
  /**
   * Reject the promise. Ignore if not pending.
   */
  rejectPending(reason) {
    if (this._state === DeferredState.PENDING)
      this.reject(reason);
  }
}
class RpcOutputStreamController {
  constructor() {
    this._lis = {
      nxt: [],
      msg: [],
      err: [],
      cmp: []
    };
    this._closed = false;
    this._itState = { q: [] };
  }
  // --- RpcOutputStream callback API
  onNext(callback) {
    return this.addLis(callback, this._lis.nxt);
  }
  onMessage(callback) {
    return this.addLis(callback, this._lis.msg);
  }
  onError(callback) {
    return this.addLis(callback, this._lis.err);
  }
  onComplete(callback) {
    return this.addLis(callback, this._lis.cmp);
  }
  addLis(callback, list) {
    list.push(callback);
    return () => {
      let i = list.indexOf(callback);
      if (i >= 0)
        list.splice(i, 1);
    };
  }
  // remove all listeners
  clearLis() {
    for (let l of Object.values(this._lis))
      l.splice(0, l.length);
  }
  // --- Controller API
  /**
   * Is this stream already closed by a completion or error?
   */
  get closed() {
    return this._closed !== false;
  }
  /**
   * Emit message, close with error, or close successfully, but only one
   * at a time.
   * Can be used to wrap a stream by using the other stream's `onNext`.
   */
  notifyNext(message, error2, complete) {
    assert((message ? 1 : 0) + (error2 ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
    if (message)
      this.notifyMessage(message);
    if (error2)
      this.notifyError(error2);
    if (complete)
      this.notifyComplete();
  }
  /**
   * Emits a new message. Throws if stream is closed.
   *
   * Triggers onNext and onMessage callbacks.
   */
  notifyMessage(message) {
    assert(!this.closed, "stream is closed");
    this.pushIt({ value: message, done: false });
    this._lis.msg.forEach((l) => l(message));
    this._lis.nxt.forEach((l) => l(message, void 0, false));
  }
  /**
   * Closes the stream with an error. Throws if stream is closed.
   *
   * Triggers onNext and onError callbacks.
   */
  notifyError(error2) {
    assert(!this.closed, "stream is closed");
    this._closed = error2;
    this.pushIt(error2);
    this._lis.err.forEach((l) => l(error2));
    this._lis.nxt.forEach((l) => l(void 0, error2, false));
    this.clearLis();
  }
  /**
   * Closes the stream successfully. Throws if stream is closed.
   *
   * Triggers onNext and onComplete callbacks.
   */
  notifyComplete() {
    assert(!this.closed, "stream is closed");
    this._closed = true;
    this.pushIt({ value: null, done: true });
    this._lis.cmp.forEach((l) => l());
    this._lis.nxt.forEach((l) => l(void 0, void 0, true));
    this.clearLis();
  }
  /**
   * Creates an async iterator (that can be used with `for await {...}`)
   * to consume the stream.
   *
   * Some things to note:
   * - If an error occurs, the `for await` will throw it.
   * - If an error occurred before the `for await` was started, `for await`
   *   will re-throw it.
   * - If the stream is already complete, the `for await` will be empty.
   * - If your `for await` consumes slower than the stream produces,
   *   for example because you are relaying messages in a slow operation,
   *   messages are queued.
   */
  [Symbol.asyncIterator]() {
    if (this._closed === true)
      this.pushIt({ value: null, done: true });
    else if (this._closed !== false)
      this.pushIt(this._closed);
    return {
      next: () => {
        let state2 = this._itState;
        assert(state2, "bad state");
        assert(!state2.p, "iterator contract broken");
        let first = state2.q.shift();
        if (first)
          return "value" in first ? Promise.resolve(first) : Promise.reject(first);
        state2.p = new Deferred();
        return state2.p.promise;
      }
    };
  }
  // "push" a new iterator result.
  // this either resolves a pending promise, or enqueues the result.
  pushIt(result) {
    let state2 = this._itState;
    if (state2.p) {
      const p = state2.p;
      assert(p.state == DeferredState.PENDING, "iterator contract broken");
      "value" in result ? p.resolve(result) : p.reject(result);
      delete state2.p;
    } else {
      state2.q.push(result);
    }
  }
}
var __awaiter$4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class UnaryCall {
  constructor(method, requestHeaders, request2, headers2, response2, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request2;
    this.headers = headers2;
    this.response = response2;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * If you are only interested in the final outcome of this call,
   * you can await it to receive a `FinishedUnaryCall`.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter$4(this, void 0, void 0, function* () {
      let [headers2, response2, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers: headers2,
        response: response2,
        status,
        trailers
      };
    });
  }
}
var __awaiter$3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ServerStreamingCall {
  constructor(method, requestHeaders, request2, headers2, response2, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request2;
    this.headers = headers2;
    this.responses = response2;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * You should first setup some listeners to the `request` to
   * see the actual messages the server replied with.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter$3(this, void 0, void 0, function* () {
      let [headers2, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers: headers2,
        status,
        trailers
      };
    });
  }
}
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class ClientStreamingCall {
  constructor(method, requestHeaders, request2, headers2, response2, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request2;
    this.headers = headers2;
    this.response = response2;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter$2(this, void 0, void 0, function* () {
      let [headers2, response2, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers: headers2,
        response: response2,
        status,
        trailers
      };
    });
  }
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DuplexStreamingCall {
  constructor(method, requestHeaders, request2, headers2, response2, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request2;
    this.headers = headers2;
    this.responses = response2;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter$1(this, void 0, void 0, function* () {
      let [headers2, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers: headers2,
        status,
        trailers
      };
    });
  }
}
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class TestTransport {
  /**
   * Initialize with mock data. Omitted fields have default value.
   */
  constructor(data) {
    this.suppressUncaughtRejections = true;
    this.headerDelay = 10;
    this.responseDelay = 50;
    this.betweenResponseDelay = 10;
    this.afterResponseDelay = 10;
    this.data = data !== null && data !== void 0 ? data : {};
  }
  /**
   * Sent message(s) during the last operation.
   */
  get sentMessages() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.sent;
    } else if (typeof this.lastInput == "object") {
      return [this.lastInput.single];
    }
    return [];
  }
  /**
   * Sending message(s) completed?
   */
  get sendComplete() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.completed;
    } else if (typeof this.lastInput == "object") {
      return true;
    }
    return false;
  }
  // Creates a promise for response headers from the mock data.
  promiseHeaders() {
    var _a;
    const headers2 = (_a = this.data.headers) !== null && _a !== void 0 ? _a : TestTransport.defaultHeaders;
    return headers2 instanceof RpcError ? Promise.reject(headers2) : Promise.resolve(headers2);
  }
  // Creates a promise for a single, valid, message from the mock data.
  promiseSingleResponse(method) {
    if (this.data.response instanceof RpcError) {
      return Promise.reject(this.data.response);
    }
    let r;
    if (Array.isArray(this.data.response)) {
      assert(this.data.response.length > 0);
      r = this.data.response[0];
    } else if (this.data.response !== void 0) {
      r = this.data.response;
    } else {
      r = method.O.create();
    }
    assert(method.O.is(r));
    return Promise.resolve(r);
  }
  /**
   * Pushes response messages from the mock data to the output stream.
   * If an error response, status or trailers are mocked, the stream is
   * closed with the respective error.
   * Otherwise, stream is completed successfully.
   *
   * The returned promise resolves when the stream is closed. It should
   * not reject. If it does, code is broken.
   */
  streamResponses(method, stream, abort) {
    return __awaiter(this, void 0, void 0, function* () {
      const messages = [];
      if (this.data.response === void 0) {
        messages.push(method.O.create());
      } else if (Array.isArray(this.data.response)) {
        for (let msg of this.data.response) {
          assert(method.O.is(msg));
          messages.push(msg);
        }
      } else if (!(this.data.response instanceof RpcError)) {
        assert(method.O.is(this.data.response));
        messages.push(this.data.response);
      }
      try {
        yield delay(this.responseDelay, abort)(void 0);
      } catch (error2) {
        stream.notifyError(error2);
        return;
      }
      if (this.data.response instanceof RpcError) {
        stream.notifyError(this.data.response);
        return;
      }
      for (let msg of messages) {
        stream.notifyMessage(msg);
        try {
          yield delay(this.betweenResponseDelay, abort)(void 0);
        } catch (error2) {
          stream.notifyError(error2);
          return;
        }
      }
      if (this.data.status instanceof RpcError) {
        stream.notifyError(this.data.status);
        return;
      }
      if (this.data.trailers instanceof RpcError) {
        stream.notifyError(this.data.trailers);
        return;
      }
      stream.notifyComplete();
    });
  }
  // Creates a promise for response status from the mock data.
  promiseStatus() {
    var _a;
    const status = (_a = this.data.status) !== null && _a !== void 0 ? _a : TestTransport.defaultStatus;
    return status instanceof RpcError ? Promise.reject(status) : Promise.resolve(status);
  }
  // Creates a promise for response trailers from the mock data.
  promiseTrailers() {
    var _a;
    const trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : TestTransport.defaultTrailers;
    return trailers instanceof RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
  }
  maybeSuppressUncaught(...promise) {
    if (this.suppressUncaughtRejections) {
      for (let p of promise) {
        p.catch(() => {
        });
      }
    }
  }
  mergeOptions(options2) {
    return mergeRpcOptions({}, options2);
  }
  unary(method, input, options2) {
    var _a;
    const requestHeaders = (_a = options2.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options2.abort)), responsePromise = headersPromise.catch((_) => {
    }).then(delay(this.responseDelay, options2.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options2.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options2.abort)).then((_) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  serverStreaming(method, input, options2) {
    var _a;
    const requestHeaders = (_a = options2.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options2.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options2.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options2.abort)).then(delay(this.afterResponseDelay, options2.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
  }
  clientStreaming(method, options2) {
    var _a;
    const requestHeaders = (_a = options2.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options2.abort)), responsePromise = headersPromise.catch((_) => {
    }).then(delay(this.responseDelay, options2.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options2.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
    }).then(delay(this.afterResponseDelay, options2.abort)).then((_) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options2.abort);
    return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  duplex(method, options2) {
    var _a;
    const requestHeaders = (_a = options2.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options2.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options2.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options2.abort)).then(delay(this.afterResponseDelay, options2.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options2.abort);
    return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
  }
}
TestTransport.defaultHeaders = {
  responseHeader: "test"
};
TestTransport.defaultStatus = {
  code: "OK",
  detail: "all good"
};
TestTransport.defaultTrailers = {
  responseTrailer: "test"
};
function delay(ms2, abort) {
  return (v) => new Promise((resolve, reject) => {
    if (abort === null || abort === void 0 ? void 0 : abort.aborted) {
      reject(new RpcError("user cancel", "CANCELLED"));
    } else {
      const id = setTimeout(() => resolve(v), ms2);
      if (abort) {
        abort.addEventListener("abort", (ev) => {
          clearTimeout(id);
          reject(new RpcError("user cancel", "CANCELLED"));
        });
      }
    }
  });
}
class TestInputStream {
  constructor(data, abort) {
    this._completed = false;
    this._sent = [];
    this.data = data;
    this.abort = abort;
  }
  get sent() {
    return this._sent;
  }
  get completed() {
    return this._completed;
  }
  send(message) {
    if (this.data.inputMessage instanceof RpcError) {
      return Promise.reject(this.data.inputMessage);
    }
    const delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
    return Promise.resolve(void 0).then(() => {
      this._sent.push(message);
    }).then(delay(delayMs, this.abort));
  }
  complete() {
    if (this.data.inputComplete instanceof RpcError) {
      return Promise.reject(this.data.inputComplete);
    }
    const delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
    return Promise.resolve(void 0).then(() => {
      this._completed = true;
    }).then(delay(delayMs, this.abort));
  }
}
function stackIntercept(kind, transport, method, options2, input) {
  var _a, _b, _c, _d;
  if (kind == "unary") {
    let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
    for (const curr of ((_a = options2.interceptors) !== null && _a !== void 0 ? _a : []).filter((i) => i.interceptUnary).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
    }
    return tail(method, input, options2);
  }
  if (kind == "serverStreaming") {
    let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
    for (const curr of ((_b = options2.interceptors) !== null && _b !== void 0 ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
    }
    return tail(method, input, options2);
  }
  if (kind == "clientStreaming") {
    let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
    for (const curr of ((_c = options2.interceptors) !== null && _c !== void 0 ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
    }
    return tail(method, options2);
  }
  if (kind == "duplex") {
    let tail = (mtd, opt) => transport.duplex(mtd, opt);
    for (const curr of ((_d = options2.interceptors) !== null && _d !== void 0 ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
    }
    return tail(method, options2);
  }
  assertNever(kind);
}
function stackUnaryInterceptors(transport, method, input, options2) {
  return stackIntercept("unary", transport, method, options2, input);
}
function stackServerStreamingInterceptors(transport, method, input, options2) {
  return stackIntercept("serverStreaming", transport, method, options2, input);
}
function stackClientStreamingInterceptors(transport, method, options2) {
  return stackIntercept("clientStreaming", transport, method, options2);
}
function stackDuplexStreamingInterceptors(transport, method, options2) {
  return stackIntercept("duplex", transport, method, options2);
}
class ServerCallContextController {
  constructor(method, headers2, deadline, sendResponseHeadersFn, defaultStatus = { code: "OK", detail: "" }) {
    this._cancelled = false;
    this._listeners = [];
    this.method = method;
    this.headers = headers2;
    this.deadline = deadline;
    this.trailers = {};
    this._sendRH = sendResponseHeadersFn;
    this.status = defaultStatus;
  }
  /**
   * Set the call cancelled.
   *
   * Invokes all callbacks registered with onCancel() and
   * sets `cancelled = true`.
   */
  notifyCancelled() {
    if (!this._cancelled) {
      this._cancelled = true;
      for (let l of this._listeners) {
        l();
      }
    }
  }
  /**
   * Send response headers.
   */
  sendResponseHeaders(data) {
    this._sendRH(data);
  }
  /**
   * Is the call cancelled?
   *
   * When the client closes the connection before the server
   * is done, the call is cancelled.
   *
   * If you want to cancel a request on the server, throw a
   * RpcError with the CANCELLED status code.
   */
  get cancelled() {
    return this._cancelled;
  }
  /**
   * Add a callback for cancellation.
   */
  onCancel(callback) {
    const l = this._listeners;
    l.push(callback);
    return () => {
      let i = l.indexOf(callback);
      if (i >= 0)
        l.splice(i, 1);
    };
  }
}
const es2015 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClientStreamingCall,
  Deferred,
  get DeferredState() {
    return DeferredState;
  },
  DuplexStreamingCall,
  RpcError,
  RpcOutputStreamController,
  ServerCallContextController,
  ServerStreamingCall,
  ServiceType,
  TestTransport,
  UnaryCall,
  mergeRpcOptions,
  readMethodOption,
  readMethodOptions,
  readServiceOption,
  stackClientStreamingInterceptors,
  stackDuplexStreamingInterceptors,
  stackIntercept,
  stackServerStreamingInterceptors,
  stackUnaryInterceptors
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(es2015);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(es2015$1);
var cachemetadata = {};
var cachescope = {};
var hasRequiredCachescope;
function requireCachescope() {
  if (hasRequiredCachescope) return cachescope;
  hasRequiredCachescope = 1;
  Object.defineProperty(cachescope, "__esModule", { value: true });
  cachescope.CacheScope = void 0;
  const runtime_1 = require$$1;
  const runtime_2 = require$$1;
  const runtime_3 = require$$1;
  const runtime_4 = require$$1;
  const runtime_5 = require$$1;
  class CacheScope$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheScope", [
        {
          no: 1,
          name: "scope",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "permission",
          kind: "scalar",
          T: 3
          /*ScalarType.INT64*/
        }
      ]);
    }
    create(value) {
      const message = { scope: "", permission: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options2, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case /* string scope */
          1:
            message.scope = reader.string();
            break;
          case /* int64 permission */
          2:
            message.permission = reader.int64().toString();
            break;
          default:
            let u = options2.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options2) {
      if (message.scope !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.scope);
      if (message.permission !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.permission);
      let u = options2.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  cachescope.CacheScope = new CacheScope$Type();
  return cachescope;
}
var hasRequiredCachemetadata;
function requireCachemetadata() {
  if (hasRequiredCachemetadata) return cachemetadata;
  hasRequiredCachemetadata = 1;
  Object.defineProperty(cachemetadata, "__esModule", { value: true });
  cachemetadata.CacheMetadata = void 0;
  const runtime_1 = require$$1;
  const runtime_2 = require$$1;
  const runtime_3 = require$$1;
  const runtime_4 = require$$1;
  const runtime_5 = require$$1;
  const cachescope_1 = /* @__PURE__ */ requireCachescope();
  class CacheMetadata$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheMetadata", [
        {
          no: 1,
          name: "repository_id",
          kind: "scalar",
          T: 3
          /*ScalarType.INT64*/
        },
        { no: 2, name: "scope", kind: "message", repeat: 1, T: () => cachescope_1.CacheScope }
      ]);
    }
    create(value) {
      const message = { repositoryId: "0", scope: [] };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options2, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case /* int64 repository_id */
          1:
            message.repositoryId = reader.int64().toString();
            break;
          case /* repeated github.actions.results.entities.v1.CacheScope scope */
          2:
            message.scope.push(cachescope_1.CacheScope.internalBinaryRead(reader, reader.uint32(), options2));
            break;
          default:
            let u = options2.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options2) {
      if (message.repositoryId !== "0")
        writer.tag(1, runtime_1.WireType.Varint).int64(message.repositoryId);
      for (let i = 0; i < message.scope.length; i++)
        cachescope_1.CacheScope.internalBinaryWrite(message.scope[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options2).join();
      let u = options2.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  cachemetadata.CacheMetadata = new CacheMetadata$Type();
  return cachemetadata;
}
var hasRequiredCache$1;
function requireCache$1() {
  if (hasRequiredCache$1) return cache;
  hasRequiredCache$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheService = exports.GetCacheEntryDownloadURLResponse = exports.GetCacheEntryDownloadURLRequest = exports.FinalizeCacheEntryUploadResponse = exports.FinalizeCacheEntryUploadRequest = exports.CreateCacheEntryResponse = exports.CreateCacheEntryRequest = void 0;
    const runtime_rpc_1 = require$$0;
    const runtime_1 = require$$1;
    const runtime_2 = require$$1;
    const runtime_3 = require$$1;
    const runtime_4 = require$$1;
    const runtime_5 = require$$1;
    const cachemetadata_1 = /* @__PURE__ */ requireCachemetadata();
    class CreateCacheEntryRequest$Type extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.CreateCacheEntryRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { key: "", version: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options2, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options2, message.metadata);
              break;
            case /* string key */
            2:
              message.key = reader.string();
              break;
            case /* string version */
            3:
              message.version = reader.string();
              break;
            default:
              let u = options2.readUnknownField;
              if (u === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u !== false)
                (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options2) {
        if (message.metadata)
          cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options2).join();
        if (message.key !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
        if (message.version !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.version);
        let u = options2.writeUnknownFields;
        if (u !== false)
          (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }
    exports.CreateCacheEntryRequest = new CreateCacheEntryRequest$Type();
    class CreateCacheEntryResponse$Type extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.CreateCacheEntryResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "signed_upload_url",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "message",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ok: false, signedUploadUrl: "", message: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options2, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool ok */
            1:
              message.ok = reader.bool();
              break;
            case /* string signed_upload_url */
            2:
              message.signedUploadUrl = reader.string();
              break;
            case /* string message */
            3:
              message.message = reader.string();
              break;
            default:
              let u = options2.readUnknownField;
              if (u === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u !== false)
                (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options2) {
        if (message.ok !== false)
          writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
        if (message.signedUploadUrl !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
        if (message.message !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.message);
        let u = options2.writeUnknownFields;
        if (u !== false)
          (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }
    exports.CreateCacheEntryResponse = new CreateCacheEntryResponse$Type();
    class FinalizeCacheEntryUploadRequest$Type extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.FinalizeCacheEntryUploadRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "size_bytes",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          },
          {
            no: 4,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { key: "", sizeBytes: "0", version: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options2, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options2, message.metadata);
              break;
            case /* string key */
            2:
              message.key = reader.string();
              break;
            case /* int64 size_bytes */
            3:
              message.sizeBytes = reader.int64().toString();
              break;
            case /* string version */
            4:
              message.version = reader.string();
              break;
            default:
              let u = options2.readUnknownField;
              if (u === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u !== false)
                (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options2) {
        if (message.metadata)
          cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options2).join();
        if (message.key !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
        if (message.sizeBytes !== "0")
          writer.tag(3, runtime_1.WireType.Varint).int64(message.sizeBytes);
        if (message.version !== "")
          writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
        let u = options2.writeUnknownFields;
        if (u !== false)
          (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }
    exports.FinalizeCacheEntryUploadRequest = new FinalizeCacheEntryUploadRequest$Type();
    class FinalizeCacheEntryUploadResponse$Type extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.FinalizeCacheEntryUploadResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "entry_id",
            kind: "scalar",
            T: 3
            /*ScalarType.INT64*/
          },
          {
            no: 3,
            name: "message",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ok: false, entryId: "0", message: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options2, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool ok */
            1:
              message.ok = reader.bool();
              break;
            case /* int64 entry_id */
            2:
              message.entryId = reader.int64().toString();
              break;
            case /* string message */
            3:
              message.message = reader.string();
              break;
            default:
              let u = options2.readUnknownField;
              if (u === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u !== false)
                (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options2) {
        if (message.ok !== false)
          writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
        if (message.entryId !== "0")
          writer.tag(2, runtime_1.WireType.Varint).int64(message.entryId);
        if (message.message !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.message);
        let u = options2.writeUnknownFields;
        if (u !== false)
          (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }
    exports.FinalizeCacheEntryUploadResponse = new FinalizeCacheEntryUploadResponse$Type();
    class GetCacheEntryDownloadURLRequest$Type extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.GetCacheEntryDownloadURLRequest", [
          { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
          {
            no: 2,
            name: "key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "restore_keys",
            kind: "scalar",
            repeat: 2,
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 4,
            name: "version",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { key: "", restoreKeys: [], version: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options2, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* github.actions.results.entities.v1.CacheMetadata metadata */
            1:
              message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options2, message.metadata);
              break;
            case /* string key */
            2:
              message.key = reader.string();
              break;
            case /* repeated string restore_keys */
            3:
              message.restoreKeys.push(reader.string());
              break;
            case /* string version */
            4:
              message.version = reader.string();
              break;
            default:
              let u = options2.readUnknownField;
              if (u === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u !== false)
                (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options2) {
        if (message.metadata)
          cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options2).join();
        if (message.key !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
        for (let i = 0; i < message.restoreKeys.length; i++)
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.restoreKeys[i]);
        if (message.version !== "")
          writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
        let u = options2.writeUnknownFields;
        if (u !== false)
          (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }
    exports.GetCacheEntryDownloadURLRequest = new GetCacheEntryDownloadURLRequest$Type();
    class GetCacheEntryDownloadURLResponse$Type extends runtime_5.MessageType {
      constructor() {
        super("github.actions.results.api.v1.GetCacheEntryDownloadURLResponse", [
          {
            no: 1,
            name: "ok",
            kind: "scalar",
            T: 8
            /*ScalarType.BOOL*/
          },
          {
            no: 2,
            name: "signed_download_url",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          },
          {
            no: 3,
            name: "matched_key",
            kind: "scalar",
            T: 9
            /*ScalarType.STRING*/
          }
        ]);
      }
      create(value) {
        const message = { ok: false, signedDownloadUrl: "", matchedKey: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== void 0)
          (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
      }
      internalBinaryRead(reader, length, options2, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
          let [fieldNo, wireType] = reader.tag();
          switch (fieldNo) {
            case /* bool ok */
            1:
              message.ok = reader.bool();
              break;
            case /* string signed_download_url */
            2:
              message.signedDownloadUrl = reader.string();
              break;
            case /* string matched_key */
            3:
              message.matchedKey = reader.string();
              break;
            default:
              let u = options2.readUnknownField;
              if (u === "throw")
                throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
              let d = reader.skip(wireType);
              if (u !== false)
                (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
          }
        }
        return message;
      }
      internalBinaryWrite(message, writer, options2) {
        if (message.ok !== false)
          writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
        if (message.signedDownloadUrl !== "")
          writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedDownloadUrl);
        if (message.matchedKey !== "")
          writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.matchedKey);
        let u = options2.writeUnknownFields;
        if (u !== false)
          (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
      }
    }
    exports.GetCacheEntryDownloadURLResponse = new GetCacheEntryDownloadURLResponse$Type();
    exports.CacheService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.CacheService", [
      { name: "CreateCacheEntry", options: {}, I: exports.CreateCacheEntryRequest, O: exports.CreateCacheEntryResponse },
      { name: "FinalizeCacheEntryUpload", options: {}, I: exports.FinalizeCacheEntryUploadRequest, O: exports.FinalizeCacheEntryUploadResponse },
      { name: "GetCacheEntryDownloadURL", options: {}, I: exports.GetCacheEntryDownloadURLRequest, O: exports.GetCacheEntryDownloadURLResponse }
    ]);
  })(cache);
  return cache;
}
var hasRequiredCache_twirpClient;
function requireCache_twirpClient() {
  if (hasRequiredCache_twirpClient) return cache_twirpClient;
  hasRequiredCache_twirpClient = 1;
  Object.defineProperty(cache_twirpClient, "__esModule", { value: true });
  cache_twirpClient.CacheServiceClientProtobuf = cache_twirpClient.CacheServiceClientJSON = void 0;
  const cache_1 = /* @__PURE__ */ requireCache$1();
  class CacheServiceClientJSON {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateCacheEntry.bind(this);
      this.FinalizeCacheEntryUpload.bind(this);
      this.GetCacheEntryDownloadURL.bind(this);
    }
    CreateCacheEntry(request2) {
      const data = cache_1.CreateCacheEntryRequest.toJson(request2, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/json", data);
      return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    FinalizeCacheEntryUpload(request2) {
      const data = cache_1.FinalizeCacheEntryUploadRequest.toJson(request2, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/json", data);
      return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    GetCacheEntryDownloadURL(request2) {
      const data = cache_1.GetCacheEntryDownloadURLRequest.toJson(request2, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/json", data);
      return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
  }
  cache_twirpClient.CacheServiceClientJSON = CacheServiceClientJSON;
  class CacheServiceClientProtobuf {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateCacheEntry.bind(this);
      this.FinalizeCacheEntryUpload.bind(this);
      this.GetCacheEntryDownloadURL.bind(this);
    }
    CreateCacheEntry(request2) {
      const data = cache_1.CreateCacheEntryRequest.toBinary(request2);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/protobuf", data);
      return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromBinary(data2));
    }
    FinalizeCacheEntryUpload(request2) {
      const data = cache_1.FinalizeCacheEntryUploadRequest.toBinary(request2);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/protobuf", data);
      return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromBinary(data2));
    }
    GetCacheEntryDownloadURL(request2) {
      const data = cache_1.GetCacheEntryDownloadURLRequest.toBinary(request2);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/protobuf", data);
      return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromBinary(data2));
    }
  }
  cache_twirpClient.CacheServiceClientProtobuf = CacheServiceClientProtobuf;
  return cache_twirpClient;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.maskSecretUrls = util.maskSigUrl = void 0;
  const core_1 = /* @__PURE__ */ requireCore();
  function maskSigUrl(url) {
    if (!url)
      return;
    try {
      const parsedUrl = new URL(url);
      const signature = parsedUrl.searchParams.get("sig");
      if (signature) {
        (0, core_1.setSecret)(signature);
        (0, core_1.setSecret)(encodeURIComponent(signature));
      }
    } catch (error2) {
      (0, core_1.debug)(`Failed to parse URL: ${url} ${error2 instanceof Error ? error2.message : String(error2)}`);
    }
  }
  util.maskSigUrl = maskSigUrl;
  function maskSecretUrls(body2) {
    if (typeof body2 !== "object" || body2 === null) {
      (0, core_1.debug)("body is not an object or is null");
      return;
    }
    if ("signed_upload_url" in body2 && typeof body2.signed_upload_url === "string") {
      maskSigUrl(body2.signed_upload_url);
    }
    if ("signed_download_url" in body2 && typeof body2.signed_download_url === "string") {
      maskSigUrl(body2.signed_download_url);
    }
  }
  util.maskSecretUrls = maskSecretUrls;
  return util;
}
var hasRequiredCacheTwirpClient;
function requireCacheTwirpClient() {
  if (hasRequiredCacheTwirpClient) return cacheTwirpClient;
  hasRequiredCacheTwirpClient = 1;
  var __awaiter2 = cacheTwirpClient && cacheTwirpClient.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(cacheTwirpClient, "__esModule", { value: true });
  cacheTwirpClient.internalCacheTwirpClient = void 0;
  const core_1 = /* @__PURE__ */ requireCore();
  const user_agent_1 = /* @__PURE__ */ requireUserAgent();
  const errors_1 = /* @__PURE__ */ requireErrors();
  const config_1 = /* @__PURE__ */ requireConfig();
  const cacheUtils_1 = /* @__PURE__ */ requireCacheUtils();
  const auth_1 = /* @__PURE__ */ requireAuth();
  const http_client_1 = /* @__PURE__ */ requireLib$1();
  const cache_twirp_client_1 = /* @__PURE__ */ requireCache_twirpClient();
  const util_1 = /* @__PURE__ */ requireUtil();
  class CacheServiceClient {
    constructor(userAgent2, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
      this.maxAttempts = 5;
      this.baseRetryIntervalMilliseconds = 3e3;
      this.retryMultiplier = 1.5;
      const token = (0, cacheUtils_1.getRuntimeToken)();
      this.baseUrl = (0, config_1.getCacheServiceURL)();
      if (maxAttempts) {
        this.maxAttempts = maxAttempts;
      }
      if (baseRetryIntervalMilliseconds) {
        this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
      }
      if (retryMultiplier) {
        this.retryMultiplier = retryMultiplier;
      }
      this.httpClient = new http_client_1.HttpClient(userAgent2, [
        new auth_1.BearerCredentialHandler(token)
      ]);
    }
    // This function satisfies the Rpc interface. It is compatible with the JSON
    // JSON generated client.
    request(service2, method, contentType, data) {
      return __awaiter2(this, void 0, void 0, function* () {
        const url = new URL(`/twirp/${service2}/${method}`, this.baseUrl).href;
        (0, core_1.debug)(`[Request] ${method} ${url}`);
        const headers2 = {
          "Content-Type": contentType
        };
        try {
          const { body: body2 } = yield this.retryableRequest(() => __awaiter2(this, void 0, void 0, function* () {
            return this.httpClient.post(url, JSON.stringify(data), headers2);
          }));
          return body2;
        } catch (error2) {
          throw new Error(`Failed to ${method}: ${error2.message}`);
        }
      });
    }
    retryableRequest(operation2) {
      return __awaiter2(this, void 0, void 0, function* () {
        let attempt = 0;
        let errorMessage = "";
        let rawBody = "";
        while (attempt < this.maxAttempts) {
          let isRetryable = false;
          try {
            const response2 = yield operation2();
            const statusCode = response2.message.statusCode;
            rawBody = yield response2.readBody();
            (0, core_1.debug)(`[Response] - ${response2.message.statusCode}`);
            (0, core_1.debug)(`Headers: ${JSON.stringify(response2.message.headers, null, 2)}`);
            const body2 = JSON.parse(rawBody);
            (0, util_1.maskSecretUrls)(body2);
            (0, core_1.debug)(`Body: ${JSON.stringify(body2, null, 2)}`);
            if (this.isSuccessStatusCode(statusCode)) {
              return { response: response2, body: body2 };
            }
            isRetryable = this.isRetryableHttpStatusCode(statusCode);
            errorMessage = `Failed request: (${statusCode}) ${response2.message.statusMessage}`;
            if (body2.msg) {
              if (errors_1.UsageError.isUsageErrorMessage(body2.msg)) {
                throw new errors_1.UsageError();
              }
              errorMessage = `${errorMessage}: ${body2.msg}`;
            }
          } catch (error2) {
            if (error2 instanceof SyntaxError) {
              (0, core_1.debug)(`Raw Body: ${rawBody}`);
            }
            if (error2 instanceof errors_1.UsageError) {
              throw error2;
            }
            if (errors_1.NetworkError.isNetworkErrorCode(error2 === null || error2 === void 0 ? void 0 : error2.code)) {
              throw new errors_1.NetworkError(error2 === null || error2 === void 0 ? void 0 : error2.code);
            }
            isRetryable = true;
            errorMessage = error2.message;
          }
          if (!isRetryable) {
            throw new Error(`Received non-retryable error: ${errorMessage}`);
          }
          if (attempt + 1 === this.maxAttempts) {
            throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
          }
          const retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
          (0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`);
          yield this.sleep(retryTimeMilliseconds);
          attempt++;
        }
        throw new Error(`Request failed`);
      });
    }
    isSuccessStatusCode(statusCode) {
      if (!statusCode)
        return false;
      return statusCode >= 200 && statusCode < 300;
    }
    isRetryableHttpStatusCode(statusCode) {
      if (!statusCode)
        return false;
      const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.InternalServerError,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.TooManyRequests
      ];
      return retryableStatusCodes.includes(statusCode);
    }
    sleep(milliseconds) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
      });
    }
    getExponentialRetryTimeMilliseconds(attempt) {
      if (attempt < 0) {
        throw new Error("attempt should be a positive integer");
      }
      if (attempt === 0) {
        return this.baseRetryIntervalMilliseconds;
      }
      const minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt);
      const maxTime = minTime * this.retryMultiplier;
      return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
    }
  }
  function internalCacheTwirpClient(options2) {
    const client2 = new CacheServiceClient((0, user_agent_1.getUserAgentString)(), options2 === null || options2 === void 0 ? void 0 : options2.maxAttempts, options2 === null || options2 === void 0 ? void 0 : options2.retryIntervalMs, options2 === null || options2 === void 0 ? void 0 : options2.retryMultiplier);
    return new cache_twirp_client_1.CacheServiceClientJSON(client2);
  }
  cacheTwirpClient.internalCacheTwirpClient = internalCacheTwirpClient;
  return cacheTwirpClient;
}
var tar = {};
var hasRequiredTar;
function requireTar() {
  if (hasRequiredTar) return tar;
  hasRequiredTar = 1;
  var __createBinding2 = tar && tar.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = tar && tar.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = tar && tar.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = tar && tar.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(tar, "__esModule", { value: true });
  tar.createTar = tar.extractTar = tar.listTar = void 0;
  const exec_1 = /* @__PURE__ */ requireExec();
  const io2 = __importStar2(/* @__PURE__ */ requireIo$1());
  const fs_1 = require$$1$2;
  const path2 = __importStar2(require$$1$7);
  const utils2 = __importStar2(/* @__PURE__ */ requireCacheUtils());
  const constants_1 = /* @__PURE__ */ requireConstants$5();
  const IS_WINDOWS = process.platform === "win32";
  function getTarPath() {
    return __awaiter2(this, void 0, void 0, function* () {
      switch (process.platform) {
        case "win32": {
          const gnuTar = yield utils2.getGnuTarPathOnWindows();
          const systemTar = constants_1.SystemTarPathOnWindows;
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else if ((0, fs_1.existsSync)(systemTar)) {
            return { path: systemTar, type: constants_1.ArchiveToolType.BSD };
          }
          break;
        }
        case "darwin": {
          const gnuTar = yield io2.which("gtar", false);
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else {
            return {
              path: yield io2.which("tar", true),
              type: constants_1.ArchiveToolType.BSD
            };
          }
        }
      }
      return {
        path: yield io2.which("tar", true),
        type: constants_1.ArchiveToolType.GNU
      };
    });
  }
  function getTarArgs(tarPath, compressionMethod, type, archivePath = "") {
    return __awaiter2(this, void 0, void 0, function* () {
      const args = [`"${tarPath.path}"`];
      const cacheFileName = utils2.getCacheFileName(compressionMethod);
      const tarFile = "cache.tar";
      const workingDirectory = getWorkingDirectory();
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (type) {
        case "create":
          args.push("--posix", "-cf", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "--exclude", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "--files-from", constants_1.ManifestFilename);
          break;
        case "extract":
          args.push("-xf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path2.sep}`, "g"), "/"));
          break;
        case "list":
          args.push("-tf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P");
          break;
      }
      if (tarPath.type === constants_1.ArchiveToolType.GNU) {
        switch (process.platform) {
          case "win32":
            args.push("--force-local");
            break;
          case "darwin":
            args.push("--delay-directory-restore");
            break;
        }
      }
      return args;
    });
  }
  function getCommands(compressionMethod, type, archivePath = "") {
    return __awaiter2(this, void 0, void 0, function* () {
      let args;
      const tarPath = yield getTarPath();
      const tarArgs = yield getTarArgs(tarPath, compressionMethod, type, archivePath);
      const compressionArgs = type !== "create" ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath) : yield getCompressionProgram(tarPath, compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      if (BSD_TAR_ZSTD && type !== "create") {
        args = [[...compressionArgs].join(" "), [...tarArgs].join(" ")];
      } else {
        args = [[...tarArgs].join(" "), [...compressionArgs].join(" ")];
      }
      if (BSD_TAR_ZSTD) {
        return args;
      }
      return [args.join(" ")];
    });
  }
  function getWorkingDirectory() {
    var _a;
    return (_a = process.env["GITHUB_WORKSPACE"]) !== null && _a !== void 0 ? _a : process.cwd();
  }
  function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
    return __awaiter2(this, void 0, void 0, function* () {
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -d --long=30 --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/")
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -d --long=30"' : "unzstd --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -d --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/")
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -d"' : "unzstd"];
        default:
          return ["-z"];
      }
    });
  }
  function getCompressionProgram(tarPath, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      const cacheFileName = utils2.getCacheFileName(compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --long=30 --force -o",
            cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --force -o",
            cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -T0"' : "zstdmt"];
        default:
          return ["-z"];
      }
    });
  }
  function execCommands(commands, cwd) {
    return __awaiter2(this, void 0, void 0, function* () {
      for (const command2 of commands) {
        try {
          yield (0, exec_1.exec)(command2, void 0, {
            cwd,
            env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
          });
        } catch (error2) {
          throw new Error(`${command2.split(" ")[0]} failed with error: ${error2 === null || error2 === void 0 ? void 0 : error2.message}`);
        }
      }
    });
  }
  function listTar(archivePath, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      const commands = yield getCommands(compressionMethod, "list", archivePath);
      yield execCommands(commands);
    });
  }
  tar.listTar = listTar;
  function extractTar(archivePath, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      const workingDirectory = getWorkingDirectory();
      yield io2.mkdirP(workingDirectory);
      const commands = yield getCommands(compressionMethod, "extract", archivePath);
      yield execCommands(commands);
    });
  }
  tar.extractTar = extractTar;
  function createTar(archiveFolder, sourceDirectories, compressionMethod) {
    return __awaiter2(this, void 0, void 0, function* () {
      (0, fs_1.writeFileSync)(path2.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join("\n"));
      const commands = yield getCommands(compressionMethod, "create");
      yield execCommands(commands, archiveFolder);
    });
  }
  tar.createTar = createTar;
  return tar;
}
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache$2;
  hasRequiredCache = 1;
  var __createBinding2 = cache$2 && cache$2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = cache$2 && cache$2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = cache$2 && cache$2.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __awaiter2 = cache$2 && cache$2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(cache$2, "__esModule", { value: true });
  cache$2.saveCache = cache$2.restoreCache = cache$2.isFeatureAvailable = cache$2.FinalizeCacheError = cache$2.ReserveCacheError = cache$2.ValidationError = void 0;
  const core2 = __importStar2(/* @__PURE__ */ requireCore());
  const path2 = __importStar2(require$$1$7);
  const utils2 = __importStar2(/* @__PURE__ */ requireCacheUtils());
  const cacheHttpClient2 = __importStar2(/* @__PURE__ */ requireCacheHttpClient());
  const cacheTwirpClient2 = __importStar2(/* @__PURE__ */ requireCacheTwirpClient());
  const config_1 = /* @__PURE__ */ requireConfig();
  const tar_1 = /* @__PURE__ */ requireTar();
  const http_client_1 = /* @__PURE__ */ requireLib$1();
  class ValidationError extends Error {
    constructor(message) {
      super(message);
      this.name = "ValidationError";
      Object.setPrototypeOf(this, ValidationError.prototype);
    }
  }
  cache$2.ValidationError = ValidationError;
  class ReserveCacheError extends Error {
    constructor(message) {
      super(message);
      this.name = "ReserveCacheError";
      Object.setPrototypeOf(this, ReserveCacheError.prototype);
    }
  }
  cache$2.ReserveCacheError = ReserveCacheError;
  class FinalizeCacheError extends Error {
    constructor(message) {
      super(message);
      this.name = "FinalizeCacheError";
      Object.setPrototypeOf(this, FinalizeCacheError.prototype);
    }
  }
  cache$2.FinalizeCacheError = FinalizeCacheError;
  function checkPaths(paths) {
    if (!paths || paths.length === 0) {
      throw new ValidationError(`Path Validation Error: At least one directory or file path is required`);
    }
  }
  function checkKey(key) {
    if (key.length > 512) {
      throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
    }
    const regex = /^[^,]*$/;
    if (!regex.test(key)) {
      throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
    }
  }
  function isFeatureAvailable() {
    const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
    switch (cacheServiceVersion) {
      case "v2":
        return !!process.env["ACTIONS_RESULTS_URL"];
      case "v1":
      default:
        return !!process.env["ACTIONS_CACHE_URL"];
    }
  }
  cache$2.isFeatureAvailable = isFeatureAvailable;
  function restoreCache(paths, primaryKey, restoreKeys, options2, enableCrossOsArchive = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      core2.debug(`Cache service version: ${cacheServiceVersion}`);
      checkPaths(paths);
      switch (cacheServiceVersion) {
        case "v2":
          return yield restoreCacheV2(paths, primaryKey, restoreKeys, options2, enableCrossOsArchive);
        case "v1":
        default:
          return yield restoreCacheV1(paths, primaryKey, restoreKeys, options2, enableCrossOsArchive);
      }
    });
  }
  cache$2.restoreCache = restoreCache;
  function restoreCacheV1(paths, primaryKey, restoreKeys, options2, enableCrossOsArchive = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core2.debug("Resolved Keys:");
      core2.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      const compressionMethod = yield utils2.getCompressionMethod();
      let archivePath = "";
      try {
        const cacheEntry = yield cacheHttpClient2.getCacheEntry(keys, paths, {
          compressionMethod,
          enableCrossOsArchive
        });
        if (!(cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.archiveLocation)) {
          return void 0;
        }
        if (options2 === null || options2 === void 0 ? void 0 : options2.lookupOnly) {
          core2.info("Lookup only - skipping download");
          return cacheEntry.cacheKey;
        }
        archivePath = path2.join(yield utils2.createTempDirectory(), utils2.getCacheFileName(compressionMethod));
        core2.debug(`Archive Path: ${archivePath}`);
        yield cacheHttpClient2.downloadCache(cacheEntry.archiveLocation, archivePath, options2);
        if (core2.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils2.getArchiveFileSizeInBytes(archivePath);
        core2.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core2.info("Cache restored successfully");
        return cacheEntry.cacheKey;
      } catch (error2) {
        const typedError = error2;
        if (typedError.name === ValidationError.name) {
          throw error2;
        } else {
          if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
            core2.error(`Failed to restore: ${error2.message}`);
          } else {
            core2.warning(`Failed to restore: ${error2.message}`);
          }
        }
      } finally {
        try {
          yield utils2.unlinkFile(archivePath);
        } catch (error2) {
          core2.debug(`Failed to delete archive: ${error2}`);
        }
      }
      return void 0;
    });
  }
  function restoreCacheV2(paths, primaryKey, restoreKeys, options2, enableCrossOsArchive = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      options2 = Object.assign(Object.assign({}, options2), { useAzureSdk: true });
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core2.debug("Resolved Keys:");
      core2.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      let archivePath = "";
      try {
        const twirpClient = cacheTwirpClient2.internalCacheTwirpClient();
        const compressionMethod = yield utils2.getCompressionMethod();
        const request2 = {
          key: primaryKey,
          restoreKeys,
          version: utils2.getCacheVersion(paths, compressionMethod, enableCrossOsArchive)
        };
        const response2 = yield twirpClient.GetCacheEntryDownloadURL(request2);
        if (!response2.ok) {
          core2.debug(`Cache not found for version ${request2.version} of keys: ${keys.join(", ")}`);
          return void 0;
        }
        const isRestoreKeyMatch = request2.key !== response2.matchedKey;
        if (isRestoreKeyMatch) {
          core2.info(`Cache hit for restore-key: ${response2.matchedKey}`);
        } else {
          core2.info(`Cache hit for: ${response2.matchedKey}`);
        }
        if (options2 === null || options2 === void 0 ? void 0 : options2.lookupOnly) {
          core2.info("Lookup only - skipping download");
          return response2.matchedKey;
        }
        archivePath = path2.join(yield utils2.createTempDirectory(), utils2.getCacheFileName(compressionMethod));
        core2.debug(`Archive path: ${archivePath}`);
        core2.debug(`Starting download of archive to: ${archivePath}`);
        yield cacheHttpClient2.downloadCache(response2.signedDownloadUrl, archivePath, options2);
        const archiveFileSize = utils2.getArchiveFileSizeInBytes(archivePath);
        core2.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        if (core2.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core2.info("Cache restored successfully");
        return response2.matchedKey;
      } catch (error2) {
        const typedError = error2;
        if (typedError.name === ValidationError.name) {
          throw error2;
        } else {
          if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
            core2.error(`Failed to restore: ${error2.message}`);
          } else {
            core2.warning(`Failed to restore: ${error2.message}`);
          }
        }
      } finally {
        try {
          if (archivePath) {
            yield utils2.unlinkFile(archivePath);
          }
        } catch (error2) {
          core2.debug(`Failed to delete archive: ${error2}`);
        }
      }
      return void 0;
    });
  }
  function saveCache(paths, key, options2, enableCrossOsArchive = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      core2.debug(`Cache service version: ${cacheServiceVersion}`);
      checkPaths(paths);
      checkKey(key);
      switch (cacheServiceVersion) {
        case "v2":
          return yield saveCacheV2(paths, key, options2, enableCrossOsArchive);
        case "v1":
        default:
          return yield saveCacheV1(paths, key, options2, enableCrossOsArchive);
      }
    });
  }
  cache$2.saveCache = saveCache;
  function saveCacheV1(paths, key, options2, enableCrossOsArchive = false) {
    var _a, _b, _c, _d, _e;
    return __awaiter2(this, void 0, void 0, function* () {
      const compressionMethod = yield utils2.getCompressionMethod();
      let cacheId = -1;
      const cachePaths = yield utils2.resolvePaths(paths);
      core2.debug("Cache Paths:");
      core2.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils2.createTempDirectory();
      const archivePath = path2.join(archiveFolder, utils2.getCacheFileName(compressionMethod));
      core2.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core2.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const fileSizeLimit = 10 * 1024 * 1024 * 1024;
        const archiveFileSize = utils2.getArchiveFileSizeInBytes(archivePath);
        core2.debug(`File Size: ${archiveFileSize}`);
        if (archiveFileSize > fileSizeLimit && !(0, config_1.isGhes)()) {
          throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
        }
        core2.debug("Reserving Cache");
        const reserveCacheResponse = yield cacheHttpClient2.reserveCache(key, paths, {
          compressionMethod,
          enableCrossOsArchive,
          cacheSize: archiveFileSize
        });
        if ((_a = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.result) === null || _a === void 0 ? void 0 : _a.cacheId) {
          cacheId = (_b = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.result) === null || _b === void 0 ? void 0 : _b.cacheId;
        } else if ((reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.statusCode) === 400) {
          throw new Error((_d = (_c = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.error) === null || _c === void 0 ? void 0 : _c.message) !== null && _d !== void 0 ? _d : `Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the data cap limit, not saving cache.`);
        } else {
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache. More details: ${(_e = reserveCacheResponse === null || reserveCacheResponse === void 0 ? void 0 : reserveCacheResponse.error) === null || _e === void 0 ? void 0 : _e.message}`);
        }
        core2.debug(`Saving Cache (ID: ${cacheId})`);
        yield cacheHttpClient2.saveCache(cacheId, archivePath, "", options2);
      } catch (error2) {
        const typedError = error2;
        if (typedError.name === ValidationError.name) {
          throw error2;
        } else if (typedError.name === ReserveCacheError.name) {
          core2.info(`Failed to save: ${typedError.message}`);
        } else {
          if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
            core2.error(`Failed to save: ${typedError.message}`);
          } else {
            core2.warning(`Failed to save: ${typedError.message}`);
          }
        }
      } finally {
        try {
          yield utils2.unlinkFile(archivePath);
        } catch (error2) {
          core2.debug(`Failed to delete archive: ${error2}`);
        }
      }
      return cacheId;
    });
  }
  function saveCacheV2(paths, key, options2, enableCrossOsArchive = false) {
    return __awaiter2(this, void 0, void 0, function* () {
      options2 = Object.assign(Object.assign({}, options2), { uploadChunkSize: 64 * 1024 * 1024, uploadConcurrency: 8, useAzureSdk: true });
      const compressionMethod = yield utils2.getCompressionMethod();
      const twirpClient = cacheTwirpClient2.internalCacheTwirpClient();
      let cacheId = -1;
      const cachePaths = yield utils2.resolvePaths(paths);
      core2.debug("Cache Paths:");
      core2.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils2.createTempDirectory();
      const archivePath = path2.join(archiveFolder, utils2.getCacheFileName(compressionMethod));
      core2.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core2.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils2.getArchiveFileSizeInBytes(archivePath);
        core2.debug(`File Size: ${archiveFileSize}`);
        options2.archiveSizeBytes = archiveFileSize;
        core2.debug("Reserving Cache");
        const version2 = utils2.getCacheVersion(paths, compressionMethod, enableCrossOsArchive);
        const request2 = {
          key,
          version: version2
        };
        let signedUploadUrl;
        try {
          const response2 = yield twirpClient.CreateCacheEntry(request2);
          if (!response2.ok) {
            if (response2.message) {
              core2.warning(`Cache reservation failed: ${response2.message}`);
            }
            throw new Error(response2.message || "Response was not ok");
          }
          signedUploadUrl = response2.signedUploadUrl;
        } catch (error2) {
          core2.debug(`Failed to reserve cache: ${error2}`);
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache.`);
        }
        core2.debug(`Attempting to upload cache located at: ${archivePath}`);
        yield cacheHttpClient2.saveCache(cacheId, archivePath, signedUploadUrl, options2);
        const finalizeRequest = {
          key,
          version: version2,
          sizeBytes: `${archiveFileSize}`
        };
        const finalizeResponse = yield twirpClient.FinalizeCacheEntryUpload(finalizeRequest);
        core2.debug(`FinalizeCacheEntryUploadResponse: ${finalizeResponse.ok}`);
        if (!finalizeResponse.ok) {
          if (finalizeResponse.message) {
            throw new FinalizeCacheError(finalizeResponse.message);
          }
          throw new Error(`Unable to finalize cache with key ${key}, another job may be finalizing this cache.`);
        }
        cacheId = parseInt(finalizeResponse.entryId);
      } catch (error2) {
        const typedError = error2;
        if (typedError.name === ValidationError.name) {
          throw error2;
        } else if (typedError.name === ReserveCacheError.name) {
          core2.info(`Failed to save: ${typedError.message}`);
        } else if (typedError.name === FinalizeCacheError.name) {
          core2.warning(typedError.message);
        } else {
          if (typedError instanceof http_client_1.HttpClientError && typeof typedError.statusCode === "number" && typedError.statusCode >= 500) {
            core2.error(`Failed to save: ${typedError.message}`);
          } else {
            core2.warning(`Failed to save: ${typedError.message}`);
          }
        }
      } finally {
        try {
          yield utils2.unlinkFile(archivePath);
        } catch (error2) {
          core2.debug(`Failed to delete archive: ${error2}`);
        }
      }
      return cacheId;
    });
  }
  return cache$2;
}
var cacheExports = /* @__PURE__ */ requireCache();
var io = {};
var ioUtil = {};
var hasRequiredIoUtil;
function requireIoUtil() {
  if (hasRequiredIoUtil) return ioUtil;
  hasRequiredIoUtil = 1;
  (function(exports) {
    var __createBinding2 = ioUtil && ioUtil.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault2 = ioUtil && ioUtil.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = ioUtil && ioUtil.__importStar || /* @__PURE__ */ (function() {
      var ownKeys2 = function(o) {
        ownKeys2 = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys2(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys2(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding2(result, mod, k[i]);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
    })();
    var __awaiter2 = ioUtil && ioUtil.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
    exports.readlink = readlink;
    exports.exists = exists;
    exports.isDirectory = isDirectory;
    exports.isRooted = isRooted;
    exports.tryGetExecutablePath = tryGetExecutablePath;
    exports.getCmdPath = getCmdPath;
    const fs = __importStar2(require$$1$2);
    const path2 = __importStar2(require$$1$7);
    _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
    exports.IS_WINDOWS = process.platform === "win32";
    function readlink(fsPath) {
      return __awaiter2(this, void 0, void 0, function* () {
        const result = yield fs.promises.readlink(fsPath);
        if (exports.IS_WINDOWS && !result.endsWith("\\")) {
          return `${result}\\`;
        }
        return result;
      });
    }
    exports.UV_FS_O_EXLOCK = 268435456;
    exports.READONLY = fs.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          yield (0, exports.stat)(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    function isDirectory(fsPath_1) {
      return __awaiter2(this, arguments, void 0, function* (fsPath, useStat = false) {
        const stats = useStat ? yield (0, exports.stat)(fsPath) : yield (0, exports.lstat)(fsPath);
        return stats.isDirectory();
      });
    }
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter2(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield (0, exports.stat)(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            const upperExt = path2.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield (0, exports.stat)(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              try {
                const directory = path2.dirname(filePath);
                const upperName = path2.basename(filePath).toUpperCase();
                for (const actualName of yield (0, exports.readdir)(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path2.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    function normalizeSeparators(p) {
      p = p || "";
      if (exports.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && process.getgid !== void 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && process.getuid !== void 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
  })(ioUtil);
  return ioUtil;
}
var hasRequiredIo;
function requireIo() {
  if (hasRequiredIo) return io;
  hasRequiredIo = 1;
  var __createBinding2 = io && io.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = io && io.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = io && io.__importStar || /* @__PURE__ */ (function() {
    var ownKeys2 = function(o) {
      ownKeys2 = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys2(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys2(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding2(result, mod, k[i]);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
  })();
  var __awaiter2 = io && io.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(io, "__esModule", { value: true });
  io.cp = cp;
  io.mv = mv;
  io.rmRF = rmRF;
  io.mkdirP = mkdirP;
  io.which = which;
  io.findInPath = findInPath;
  const assert_1 = require$$0$7;
  const path2 = __importStar2(require$$1$7);
  const ioUtil2 = __importStar2(/* @__PURE__ */ requireIoUtil());
  function cp(source_1, dest_1) {
    return __awaiter2(this, arguments, void 0, function* (source, dest, options2 = {}) {
      const { force, recursive, copySourceDirectory } = readCopyOptions(options2);
      const destStat = (yield ioUtil2.exists(dest)) ? yield ioUtil2.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path2.join(dest, path2.basename(source)) : dest;
      if (!(yield ioUtil2.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil2.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path2.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  function mv(source_1, dest_1) {
    return __awaiter2(this, arguments, void 0, function* (source, dest, options2 = {}) {
      if (yield ioUtil2.exists(dest)) {
        let destExists = true;
        if (yield ioUtil2.isDirectory(dest)) {
          dest = path2.join(dest, path2.basename(source));
          destExists = yield ioUtil2.exists(dest);
        }
        if (destExists) {
          if (options2.force == null || options2.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path2.dirname(dest));
      yield ioUtil2.rename(source, dest);
    });
  }
  function rmRF(inputPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (ioUtil2.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath)) {
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        }
      }
      try {
        yield ioUtil2.rm(inputPath, {
          force: true,
          maxRetries: 3,
          recursive: true,
          retryDelay: 300
        });
      } catch (err) {
        throw new Error(`File was unable to be removed ${err}`);
      }
    });
  }
  function mkdirP(fsPath) {
    return __awaiter2(this, void 0, void 0, function* () {
      (0, assert_1.ok)(fsPath, "a path argument must be provided");
      yield ioUtil2.mkdir(fsPath, { recursive: true });
    });
  }
  function which(tool, check) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result = yield which(tool, false);
        if (!result) {
          if (ioUtil2.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
        return result;
      }
      const matches = yield findInPath(tool);
      if (matches && matches.length > 0) {
        return matches[0];
      }
      return "";
    });
  }
  function findInPath(tool) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      const extensions = [];
      if (ioUtil2.IS_WINDOWS && process.env["PATHEXT"]) {
        for (const extension of process.env["PATHEXT"].split(path2.delimiter)) {
          if (extension) {
            extensions.push(extension);
          }
        }
      }
      if (ioUtil2.isRooted(tool)) {
        const filePath = yield ioUtil2.tryGetExecutablePath(tool, extensions);
        if (filePath) {
          return [filePath];
        }
        return [];
      }
      if (tool.includes(path2.sep)) {
        return [];
      }
      const directories = [];
      if (process.env.PATH) {
        for (const p of process.env.PATH.split(path2.delimiter)) {
          if (p) {
            directories.push(p);
          }
        }
      }
      const matches = [];
      for (const directory of directories) {
        const filePath = yield ioUtil2.tryGetExecutablePath(path2.join(directory, tool), extensions);
        if (filePath) {
          matches.push(filePath);
        }
      }
      return matches;
    });
  }
  function readCopyOptions(options2) {
    const force = options2.force == null ? true : options2.force;
    const recursive = Boolean(options2.recursive);
    const copySourceDirectory = options2.copySourceDirectory == null ? true : Boolean(options2.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil2.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil2.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil2.chmod(destDir, (yield ioUtil2.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter2(this, void 0, void 0, function* () {
      if ((yield ioUtil2.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil2.lstat(destFile);
          yield ioUtil2.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil2.chmod(destFile, "0666");
            yield ioUtil2.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil2.readlink(srcFile);
        yield ioUtil2.symlink(symlinkFull, destFile, ioUtil2.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil2.exists(destFile)) || force) {
        yield ioUtil2.copyFile(srcFile, destFile);
      }
    });
  }
  return io;
}
var ioExports = /* @__PURE__ */ requireIo();
var lib = {};
var proxy = {};
var hasRequiredProxy;
function requireProxy() {
  if (hasRequiredProxy) return proxy;
  hasRequiredProxy = 1;
  Object.defineProperty(proxy, "__esModule", { value: true });
  proxy.getProxyUrl = getProxyUrl;
  proxy.checkBypass = checkBypass;
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return void 0;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return void 0;
    }
  }
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }
  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
  return proxy;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var __createBinding2 = lib && lib.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault2 = lib && lib.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = lib && lib.__importStar || /* @__PURE__ */ (function() {
    var ownKeys2 = function(o) {
      ownKeys2 = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys2(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys2(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding2(result, mod, k[i]);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
  })();
  var __awaiter2 = lib && lib.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.HttpClient = lib.HttpClientResponse = lib.HttpClientError = lib.MediaTypes = lib.Headers = lib.HttpCodes = void 0;
  lib.getProxyUrl = getProxyUrl;
  lib.isHttps = isHttps;
  const http = __importStar2(require$$2);
  const https = __importStar2(require$$1$3);
  const pm = __importStar2(/* @__PURE__ */ requireProxy());
  const tunnel2 = __importStar2(/* @__PURE__ */ requireTunnel());
  const undici_1 = /* @__PURE__ */ requireUndici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (lib.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (lib.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (lib.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  const RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  const ExponentialBackoffCeiling = 10;
  const ExponentialBackoffTimeSlice = 5;
  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  lib.HttpClientError = HttpClientError;
  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter2(this, void 0, void 0, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  lib.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }
  class HttpClient {
    constructor(userAgent2, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = userAgent2;
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl_1) {
      return __awaiter2(this, arguments, void 0, function* (requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl_1, obj_1) {
      return __awaiter2(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl_1, obj_1) {
      return __awaiter2(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl_1, obj_1) {
      return __awaiter2(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers2) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers2);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response2;
        do {
          response2 = yield this.requestRaw(info, data);
          if (response2 && response2.message && response2.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response2)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response2;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response2.message.statusCode && HttpRedirectCodes.includes(response2.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response2.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response2.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers2) {
                if (header.toLowerCase() === "authorization") {
                  delete headers2[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers2);
            response2 = yield this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (!response2.message.statusCode || !HttpResponseRetryCodes.includes(response2.message.statusCode)) {
            return response2;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response2.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response2;
      });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err) {
              reject(err);
            } else if (!res) {
              reject(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers) {
          info.options.headers = {};
        }
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info.httpModule.request(info.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult(void 0, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error(`Request timeout: ${info.options.path}`));
      });
      req.on("error", function(err) {
        handleResult(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers2) {
      const info = {};
      info.parsedUrl = requestUrl;
      const usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info.options = {};
      info.options.host = info.parsedUrl.hostname;
      info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
      info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
      info.options.method = method;
      info.options.headers = this._mergeHeaders(headers2);
      if (this.userAgent != null) {
        info.options.headers["user-agent"] = this.userAgent;
      }
      info.options.agent = this._getAgent(info.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info.options);
        }
      }
      return info;
    }
    _mergeHeaders(headers2) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers2 || {}));
      }
      return lowercaseKeys(headers2 || {});
    }
    /**
     * Gets an existing header value or returns a default.
     * Handles converting number header values to strings since HTTP headers must be strings.
     * Note: This returns string | string[] since some headers can have multiple values.
     * For headers that must always be a single string (like Content-Type), use the
     * specialized _getExistingOrDefaultContentTypeHeader method instead.
     */
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        const headerValue = lowercaseKeys(this.requestOptions.headers)[header];
        if (headerValue) {
          clientHeader = typeof headerValue === "number" ? headerValue.toString() : headerValue;
        }
      }
      const additionalValue = additionalHeaders[header];
      if (additionalValue !== void 0) {
        return typeof additionalValue === "number" ? additionalValue.toString() : additionalValue;
      }
      if (clientHeader !== void 0) {
        return clientHeader;
      }
      return _default;
    }
    /**
     * Specialized version of _getExistingOrDefaultHeader for Content-Type header.
     * Always returns a single string (not an array) since Content-Type should be a single value.
     * Converts arrays to comma-separated strings and numbers to strings to ensure type safety.
     * This was split from _getExistingOrDefaultHeader to provide stricter typing for callers
     * that assign the result to places expecting a string (e.g., additionalHeaders[Headers.ContentType]).
     */
    _getExistingOrDefaultContentTypeHeader(additionalHeaders, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        const headerValue = lowercaseKeys(this.requestOptions.headers)[Headers.ContentType];
        if (headerValue) {
          if (typeof headerValue === "number") {
            clientHeader = String(headerValue);
          } else if (Array.isArray(headerValue)) {
            clientHeader = headerValue.join(", ");
          } else {
            clientHeader = headerValue;
          }
        }
      }
      const additionalValue = additionalHeaders[Headers.ContentType];
      if (additionalValue !== void 0) {
        if (typeof additionalValue === "number") {
          return String(additionalValue);
        } else if (Array.isArray(additionalValue)) {
          return additionalValue.join(", ");
        } else {
          return additionalValue;
        }
      }
      if (clientHeader !== void 0) {
        return clientHeader;
      }
      return _default;
    }
    _getAgent(parsedUrl) {
      let agent2;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent2 = this._proxyAgent;
      }
      if (!useProxy) {
        agent2 = this._agent;
      }
      if (agent2) {
        return agent2;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel2.httpsOverHttps : tunnel2.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel2.httpOverHttps : tunnel2.httpOverHttp;
        }
        agent2 = tunnelAgent(agentOptions);
        this._proxyAgent = agent2;
      }
      if (!agent2) {
        const options2 = { keepAlive: this._keepAlive, maxSockets };
        agent2 = usingSsl ? new https.Agent(options2) : new http.Agent(options2);
        this._agent = agent2;
      }
      if (usingSsl && this._ignoreSslError) {
        agent2.options = Object.assign(agent2.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent2;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent2;
      if (this._keepAlive) {
        proxyAgent2 = this._proxyAgentDispatcher;
      }
      if (proxyAgent2) {
        return proxyAgent2;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent2 = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent2;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent2.options = Object.assign(proxyAgent2.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent2;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter2(this, void 0, void 0, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms2 = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms2));
      });
    }
    _processResponse(res, options2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
          const statusCode = res.message.statusCode || 0;
          const response2 = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response2);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a = new Date(value);
              if (!isNaN(a.valueOf())) {
                return a;
              }
            }
            return value;
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options2 && options2.deserializeDates) {
                obj = JSON.parse(contents, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response2.result = obj;
            }
            response2.headers = res.message.headers;
          } catch (err) {
          }
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response2.result;
            reject(err);
          } else {
            resolve(response2);
          }
        }));
      });
    }
  }
  lib.HttpClient = HttpClient;
  const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  return lib;
}
var libExports = /* @__PURE__ */ requireLib();
async function resolveVersion(crate) {
  const url = `https://crates.io/api/v1/crates/${crate}`;
  const client2 = new libExports.HttpClient("@actions-rs-plus (https://github.com/actions-rs-plus/)");
  const response2 = await client2.getJson(url);
  if (response2.result === null) {
    throw new Error(`Unable to fetch latest crate version of "${crate}"`);
  }
  if ("errors" in response2.result) {
    throw new Error(
      `Unable to fetch latest crate version of "${crate}", server returned ${JSON.stringify(response2.result, null, 2)}`
    );
  }
  if (response2.result.crate?.newest_version === void 0) {
    throw new Error(`Unable to fetch latest crate version of "${crate}"`);
  }
  return response2.result.crate.newest_version;
}
class Cargo extends BaseProgram {
  constructor(pathToCargo) {
    super(pathToCargo);
  }
  static async get() {
    try {
      const pathToCargo = await ioExports.which("cargo", true);
      return new Cargo(pathToCargo);
    } catch (error2) {
      coreExports.error(
        "cargo is not installed by default for some virtual environments, see https://help.github.com/en/articles/software-in-virtual-environments-for-github-actions"
      );
      coreExports.error("To install it, use this action: https://github.com/actions-rs/toolchain");
      throw error2;
    }
  }
  /**
   * Executes `cargo install ${program}`.
   *
   * TODO: Caching ability implementation is blocked,
   * see https://github.com/actions-rs/core/issues/31
   * As for now it acts just like an stub and simply installs the program
   * on each call.
   *
   * `version` argument could be either actual program version or `"latest"` string,
   * which can be provided by user input.
   *
   * If `version` is `undefined` or `"latest"`, this method could call the Crates.io API,
   * fetch the latest version and search for it in cache.
   * TODO: Actually implement this.
   *
   * ## Returns
   *
   * Path to the installed program.
   * As the $PATH should be already tuned properly at this point,
   * returned value at the moment is simply equal to the `program` argument.
   */
  async installCached(program, version2, primaryKey, restoreKeys = []) {
    if (version2 === "latest") {
      version2 = await resolveVersion(program);
    }
    if (primaryKey === void 0) {
      return this.install(program, version2);
    }
    const paths = [path.join(path.dirname(this.path), program)];
    const versionForKey = version2 === void 0 ? "" : `-${version2}`;
    const programKey = `${program}${versionForKey}-${primaryKey}`;
    const programRestoreKeys = restoreKeys.map((key) => {
      return `${program}${versionForKey}-${key}`;
    });
    const cacheKey = await cacheExports.restoreCache(paths, programKey, programRestoreKeys);
    if (cacheKey !== void 0) {
      coreExports.info(`Using cached \`${program}\` with version ${version2 ?? "installed-version"} from ${cacheKey}`);
      return program;
    }
    const result = await this.install(program, version2);
    try {
      coreExports.info(`Caching \`${program}\` with key ${programKey}`);
      await cacheExports.saveCache(paths, programKey);
    } catch (error2) {
      if (error2 instanceof Error) {
        if (error2.name === cacheExports.ValidationError.name) {
          throw error2;
        } else if (error2.name === cacheExports.ReserveCacheError.name) {
          coreExports.warning(error2.message);
        }
      } else if (typeof error2 === "string") {
        coreExports.warning(error2);
      } else {
        throw error2;
      }
    }
    return result;
  }
  async install(program, version2) {
    const arguments_ = ["install"];
    if (version2 !== void 0 && version2 !== "latest") {
      arguments_.push("--version", version2);
    }
    arguments_.push(program);
    try {
      coreExports.startGroup(`Installing "${program} = ${version2 ?? "latest"}"`);
      await this.call(arguments_);
    } finally {
      coreExports.endGroup();
    }
    return program;
  }
  /**
   * Find the cargo sub-command or install it
   */
  async findOrInstall(program, version2) {
    try {
      void await ioExports.which(program, true);
      return program;
    } catch {
      coreExports.info(`${program} is not installed, installing it now`);
    }
    return this.installCached(program, version2);
  }
}
class Cross extends BaseProgram {
  constructor(path2) {
    super(path2);
  }
  static async getOrInstall() {
    try {
      return await Cross.get();
    } catch (error2) {
      coreExports.debug(String(error2));
      return Cross.install();
    }
  }
  static async get() {
    const path2 = await ioExports.which("cross", true);
    return new Cross(path2);
  }
  static async install(version2) {
    const cargo = await Cargo.get();
    const cwd = process.cwd();
    process.chdir(require$$1$1.tmpdir());
    try {
      const crossPath = await cargo.installCached("cross", version2);
      return new Cross(crossPath);
    } finally {
      process.chdir(cwd);
    }
  }
}
function getInput(name, options2) {
  const inputFullName = name.replaceAll("-", "_");
  const value = coreExports.getInput(inputFullName, options2);
  if (value.length > 0) {
    return value;
  }
  return coreExports.getInput(name, options2);
}
function getInputBool(name, options2) {
  const value = getInput(name, options2);
  if (value === "true" || value === "1") {
    return true;
  } else {
    return false;
  }
}
var AnnotationLevel = /* @__PURE__ */ ((AnnotationLevel2) => {
  AnnotationLevel2[AnnotationLevel2["Error"] = 0] = "Error";
  AnnotationLevel2[AnnotationLevel2["Warning"] = 1] = "Warning";
  AnnotationLevel2[AnnotationLevel2["Notice"] = 2] = "Notice";
  return AnnotationLevel2;
})(AnnotationLevel || {});
class OutputParser {
  _workingDirectory;
  _uniqueAnnotations;
  _stats;
  constructor(workingDirectory) {
    this._workingDirectory = workingDirectory ?? null;
    this._uniqueAnnotations = /* @__PURE__ */ new Map();
    this._stats = {
      ice: 0,
      error: 0,
      warning: 0,
      note: 0,
      help: 0
    };
  }
  get stats() {
    return this._stats;
  }
  get annotations() {
    return [...this._uniqueAnnotations.values()];
  }
  static parseCargoJson(line) {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }
  static validateMessageIsCargoMessage(contents) {
    if (contents.reason !== "compiler-message") {
      coreExports.debug(`Unexpected reason field, ignoring it: ${contents.reason}`);
      return false;
    }
    if (contents.message?.code === void 0 || contents.message.code === null) {
      coreExports.debug("Message code is missing, ignoring it");
      return false;
    }
    return true;
  }
  static parseLevel(level) {
    switch (level) {
      case "help":
      case "note": {
        return AnnotationLevel.Notice;
      }
      case "warning": {
        return AnnotationLevel.Warning;
      }
      default: {
        return AnnotationLevel.Error;
      }
    }
  }
  tryParseClippyLine(line) {
    const message = OutputParser.parseCargoJson(line);
    if (message === null) {
      coreExports.debug("Not valid JSON or null, ignoring it");
      return;
    }
    if (!OutputParser.validateMessageIsCargoMessage(message)) {
      return;
    }
    const parsedAnnotation = this.makeAnnotation(message);
    const key = JSON.stringify(parsedAnnotation);
    if (this._uniqueAnnotations.has(key)) {
      return;
    }
    switch (message.message.level) {
      case "help": {
        this._stats.help += 1;
        break;
      }
      case "note": {
        this._stats.note += 1;
        break;
      }
      case "warning": {
        this._stats.warning += 1;
        break;
      }
      case "error": {
        this._stats.error += 1;
        break;
      }
      case "error: internal compiler error": {
        this._stats.ice += 1;
        break;
      }
    }
    this._uniqueAnnotations.set(key, parsedAnnotation);
  }
  /// Convert parsed JSON line into the GH annotation object
  ///
  /// https://developer.github.com/v3/checks/runs/#annotations-object
  makeAnnotation(contents) {
    const primarySpan = contents.message.spans.find((span) => {
      return span.is_primary;
    });
    if (primarySpan === void 0) {
      throw new Error("Unable to find primary span for message");
    }
    let pathToFile = primarySpan.file_name;
    if (this._workingDirectory !== null) {
      pathToFile = path.join(this._workingDirectory, pathToFile);
    }
    if (require$$1__default.platform() === "win32") {
      pathToFile = pathToFile.split(path.win32.sep).join(path.posix.sep);
    }
    const annotation = {
      level: OutputParser.parseLevel(contents.message.level),
      message: contents.message.rendered,
      properties: {
        file: pathToFile,
        startLine: primarySpan.line_start,
        endLine: primarySpan.line_end,
        title: contents.message.message
      }
    };
    if (primarySpan.line_start === primarySpan.line_end) {
      annotation.properties.startColumn = primarySpan.column_start;
      annotation.properties.endColumn = primarySpan.column_end;
    }
    return annotation;
  }
}
async function report(stats, annotations, context) {
  for (const annotation of annotations) {
    switch (annotation.level) {
      case AnnotationLevel.Error: {
        coreExports.error(annotation.message, annotation.properties);
        break;
      }
      case AnnotationLevel.Notice: {
        coreExports.notice(annotation.message, annotation.properties);
        break;
      }
      case AnnotationLevel.Warning: {
        coreExports.warning(annotation.message, annotation.properties);
        break;
      }
    }
  }
  coreExports.summary.addHeading("Clippy summary", 2);
  coreExports.summary.addTable([
    [
      {
        header: true,
        data: "Message level"
      },
      {
        header: true,
        data: "Amount"
      }
    ],
    [
      {
        data: "Internal compiler error"
      },
      {
        data: stats.ice.toString()
      }
    ],
    [
      {
        data: "Error"
      },
      {
        data: stats.error.toString()
      }
    ],
    [
      {
        data: "Warning"
      },
      {
        data: stats.warning.toString()
      }
    ],
    [
      {
        data: "Note"
      },
      {
        data: stats.note.toString()
      }
    ],
    [
      {
        data: "Help"
      },
      {
        data: stats.help.toString()
      }
    ]
  ]);
  coreExports.summary.addHeading("Versions", 2);
  coreExports.summary.addList([context.rustc, context.cargo, context.clippy]);
  await coreExports.summary.write();
}
async function buildContext(program, toolchain) {
  const context = {
    cargo: "",
    clippy: "",
    rustc: ""
  };
  await Promise.all([
    execExports.exec("rustc", buildToolchainArguments(toolchain, ["-V"]), {
      listeners: {
        stdout: (buffer) => {
          return context.rustc = buffer.toString().trim();
        }
      },
      silent: false
    }),
    program.call(buildToolchainArguments(toolchain, ["-V"]), {
      listeners: {
        stdout: (buffer) => {
          return context.cargo = buffer.toString().trim();
        }
      },
      silent: false
    }),
    program.call(buildToolchainArguments(toolchain, ["clippy", "-V"]), {
      listeners: {
        stdout: (buffer) => {
          return context.clippy = buffer.toString().trim();
        }
      },
      silent: false
    })
  ]);
  return context;
}
function _processLineBuffer(data, stringBuffer, onLine) {
  const POSIX_EOL = "\n";
  let s = stringBuffer + data.toString();
  let n = s.indexOf(POSIX_EOL);
  while (n > -1) {
    const line = s.slice(0, Math.max(0, n));
    onLine(line);
    s = s.slice(Math.max(0, n + POSIX_EOL.length));
    n = s.indexOf(POSIX_EOL);
  }
  return s;
}
async function runClippy(actionInput, program) {
  const arguments_ = buildClippyArguments(actionInput);
  const outputParser = new OutputParser();
  let stdbuffer = "";
  const options2 = {
    failOnStdErr: false,
    ignoreReturnCode: true,
    listeners: {
      stdout: (data) => {
        stdbuffer = _processLineBuffer(data, stdbuffer, (line) => {
          outputParser.tryParseClippyLine(line);
        });
      }
    }
  };
  if (actionInput.workingDirectory !== void 0 && actionInput.workingDirectory !== "") {
    options2.cwd = path.join(process.cwd(), actionInput.workingDirectory);
  }
  let exitCode = 0;
  try {
    coreExports.startGroup("Executing cargo clippy (JSON output)");
    exitCode = await program.call(arguments_, options2);
  } finally {
    coreExports.endGroup();
  }
  return {
    stats: outputParser.stats,
    annotations: outputParser.annotations,
    exitCode
  };
}
function getProgram(useCross) {
  if (useCross) {
    return Cross.getOrInstall();
  } else {
    return Cargo.get();
  }
}
async function run(actionInput) {
  const program = await getProgram(actionInput.useCross);
  const context = await buildContext(program, actionInput.toolchain);
  const { stats, annotations, exitCode } = await runClippy(actionInput, program);
  await report(stats, annotations, context);
  if (exitCode !== 0) {
    throw new Error(`Clippy had exited with the ${exitCode} exit code`);
  }
}
function buildToolchainArguments(toolchain, after) {
  const arguments_ = [];
  if (toolchain !== void 0 && toolchain !== "") {
    arguments_.push(`+${toolchain}`);
  }
  arguments_.push(...after);
  return arguments_;
}
function buildClippyArguments(actionInput) {
  return buildToolchainArguments(actionInput.toolchain, [
    "clippy",
    // `--message-format=json` should just right after the `cargo clippy`
    // because usually people are adding the `-- -D warnings` at the end
    // of arguments and it will mess up the output.
    "--message-format=json",
    // and the rest
    ...actionInput.args
  ]);
}
function parseArgsStringToArgv(value, env, file2) {
  var myRegexp = /([^\s'"]([^\s'"]*(['"])([^\3]*?)\3)+[^\s'"]*)|[^\s'"]+|(['"])([^\5]*?)\5/gi;
  var myString = value;
  var myArray = [];
  var match;
  do {
    match = myRegexp.exec(myString);
    if (match !== null) {
      myArray.push(firstString(match[1], match[6], match[0]));
    }
  } while (match !== null);
  return myArray;
}
function firstString() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    if (typeof arg === "string") {
      return arg;
    }
  }
}
function get() {
  let toolchain = getInput("toolchain");
  if (toolchain.startsWith("+")) {
    toolchain = toolchain.slice(1);
  }
  const workingDirectory = getInput("working-directory");
  return {
    args: parseArgsStringToArgv(getInput("args")),
    useCross: getInputBool("use-cross"),
    workingDirectory: workingDirectory === "" ? void 0 : workingDirectory,
    toolchain: toolchain === "" ? void 0 : toolchain
  };
}
async function main() {
  try {
    const actionInput = get();
    await run(actionInput);
  } catch (error2) {
    if (error2 instanceof Error) {
      coreExports.setFailed(error2.message);
    } else {
      coreExports.setFailed(String(error2));
    }
  }
}
await main();
//# sourceMappingURL=index.js.map
